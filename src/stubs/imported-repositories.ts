export const importedRepository = [
  {
    name: "refactoring-crawler",
    currentBranch: "master",
    ownerId: "PatrickLai7528",
    commits: [
      {
        sha: "27447784904e85b61609a78983e4ecbecaf37c4f",
        message:
          "Merge pull request #4 from PatrickLai7528/develop\n\ntest(PushDownMethod): test push down method detection",
        stats: {
          total: 221,
          additions: 216,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "6b11e9932c8355342ef55dc552b6774ed4725edd"
          },
          {
            sha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c"
          }
        ],
        committedAt: 1585577675000,
        changedFiles: [
          {
            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 50,
            deletions: 5,
            patch:
              '@@ -20,12 +20,12 @@\n   static void setUp() {\n     settings = new Hashtable<>();\n \n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n   }\n \n   @Test\n@@ -297,4 +297,49 @@ void testPullUpMethod() throws IOException {\n         "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n         nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPushDownMethod() throws IOException {\n+    String originalFolder = "testPushDownMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPushDownMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler =\n+        new RefactoringCrawler("test pull down method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PushedDownMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2dc66023a72d428c6c21fd74e2234072326a49e2",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "701f29bc236e688897a8a591086c04fde5b966e9",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "986e673462260d92feac4b036a4d2b48af19cb71",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          },
          {
            sha: "3663e804b7832ea04bf4a3ff8eafea32070498dd",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c",
        message: "test(PushDownMethod): test push down method detection",
        stats: {
          total: 221,
          additions: 216,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f"
          }
        ],
        committedAt: 1585577616000,
        changedFiles: [
          {
            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 50,
            deletions: 5,
            patch:
              '@@ -20,12 +20,12 @@\n   static void setUp() {\n     settings = new Hashtable<>();\n \n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n   }\n \n   @Test\n@@ -297,4 +297,49 @@ void testPullUpMethod() throws IOException {\n         "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n         nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPushDownMethod() throws IOException {\n+    String originalFolder = "testPushDownMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPushDownMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler =\n+        new RefactoringCrawler("test pull down method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PushedDownMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2dc66023a72d428c6c21fd74e2234072326a49e2",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "701f29bc236e688897a8a591086c04fde5b966e9",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "986e673462260d92feac4b036a4d2b48af19cb71",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          },
          {
            sha: "3663e804b7832ea04bf4a3ff8eafea32070498dd",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "6b11e9932c8355342ef55dc552b6774ed4725edd",
        message:
          "Merge pull request #3 from PatrickLai7528/develop\n\ntest pull up method",
        stats: {
          total: 245,
          additions: 232,
          deletions: 13
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "35d82874cab17a326c6a72ca59ee3867d3160d20"
          },
          {
            sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f"
          }
        ],
        committedAt: 1585556937000,
        changedFiles: [
          {
            sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              '@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-//        updateFeedbackLoop(pair);\n+        //        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -119,7 +119,7 @@ private void updateFeedbackLoop(Node[] pair) {\n         for (Node node : verCallers) {\n           if (origInV2Callers.contains(node))\n             if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n               nodesToRemove.add(pair);\n             }\n         }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ca0cc03d4aaf1bdba7e7155a01518bc000a5b3cd",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 61,
            deletions: 6,
            patch:
              '@@ -208,17 +208,28 @@ void testRenameClass() {\n \n   @Test\n   void testMoveMethod() throws IOException {\n-    String originalArray = TestUtils.readFile("original", "Array.java", null);\n-    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n-    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n \n     String newVersionArray =\n-        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Array.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionArrayStack =\n         TestUtils.readFile(\n-            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+            "testMoveMethod",\n+            "ArrayStack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionStack =\n-        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Stack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n \n     List<String> originalList = new ArrayList<>();\n     List<String> newVersionList = new ArrayList<>();\n@@ -242,4 +253,48 @@ void testMoveMethod() throws IOException {\n     assertEquals(\n         "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPullUpMethod() throws IOException {\n+    String originalFolder = "testPullUpMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPullUpMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PulledUpMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "modified",
            additions: 3,
            deletions: 5,
            patch:
              '@@ -10,7 +10,8 @@\n  * @create: 2020-03-29 13:55\n  */\n public class TestUtils {\n-  public static String readFile(String folder, String filename, String packageName)\n+  public static String readFile(\n+      String folder, String filename, String replacePackage, String packageName)\n       throws IOException {\n     String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n     BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n@@ -22,10 +23,7 @@ public static String readFile(String folder, String filename, String packageName\n     }\n     String fileContent = sb.toString();\n     if (packageName != null) {\n-      fileContent =\n-          fileContent.replace(\n-              "package refactoring.crawler.testMoveMethod;",\n-              "package refactoring.crawler.original;");\n+      fileContent = fileContent.replace(replacePackage, packageName);\n     }\n     return fileContent;\n   }',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n'
          },
          {
            sha: "dd83f48f6ade0ae1135e1142522e3d14895cb000",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "e4e3a2ff422284c53ab262608b26088f45ae47e1",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          },
          {
            sha: "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f",
        message: "test(PullUpMethodDetection): add test for pull up method",
        stats: {
          total: 79,
          additions: 66,
          deletions: 13
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "70cd2cbd746583044f719566a0354aa4b2beb5ea"
          }
        ],
        committedAt: 1585556845000,
        changedFiles: [
          {
            sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              '@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-//        updateFeedbackLoop(pair);\n+        //        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -119,7 +119,7 @@ private void updateFeedbackLoop(Node[] pair) {\n         for (Node node : verCallers) {\n           if (origInV2Callers.contains(node))\n             if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n               nodesToRemove.add(pair);\n             }\n         }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ca0cc03d4aaf1bdba7e7155a01518bc000a5b3cd",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 61,
            deletions: 6,
            patch:
              '@@ -208,17 +208,28 @@ void testRenameClass() {\n \n   @Test\n   void testMoveMethod() throws IOException {\n-    String originalArray = TestUtils.readFile("original", "Array.java", null);\n-    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n-    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n \n     String newVersionArray =\n-        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Array.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionArrayStack =\n         TestUtils.readFile(\n-            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+            "testMoveMethod",\n+            "ArrayStack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionStack =\n-        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Stack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n \n     List<String> originalList = new ArrayList<>();\n     List<String> newVersionList = new ArrayList<>();\n@@ -242,4 +253,48 @@ void testMoveMethod() throws IOException {\n     assertEquals(\n         "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPullUpMethod() throws IOException {\n+    String originalFolder = "testPullUpMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPullUpMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PulledUpMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "modified",
            additions: 3,
            deletions: 5,
            patch:
              '@@ -10,7 +10,8 @@\n  * @create: 2020-03-29 13:55\n  */\n public class TestUtils {\n-  public static String readFile(String folder, String filename, String packageName)\n+  public static String readFile(\n+      String folder, String filename, String replacePackage, String packageName)\n       throws IOException {\n     String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n     BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n@@ -22,10 +23,7 @@ public static String readFile(String folder, String filename, String packageName\n     }\n     String fileContent = sb.toString();\n     if (packageName != null) {\n-      fileContent =\n-          fileContent.replace(\n-              "package refactoring.crawler.testMoveMethod;",\n-              "package refactoring.crawler.original;");\n+      fileContent = fileContent.replace(replacePackage, packageName);\n     }\n     return fileContent;\n   }',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n'
          }
        ]
      },
      {
        sha: "70cd2cbd746583044f719566a0354aa4b2beb5ea",
        message: "test(*): add test classes for pull up method",
        stats: {
          total: 166,
          additions: 166,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "dd0b341819343cb1eededc8901d8252d943f4e71"
          }
        ],
        committedAt: 1585556822000,
        changedFiles: [
          {
            sha: "dd83f48f6ade0ae1135e1142522e3d14895cb000",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "e4e3a2ff422284c53ab262608b26088f45ae47e1",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          },
          {
            sha: "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "35d82874cab17a326c6a72ca59ee3867d3160d20",
        message:
          "Merge pull request #2 from PatrickLai7528/develop\n\nAdd tests for move method and rename class detection",
        stats: {
          total: 725,
          additions: 706,
          deletions: 19
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a"
          },
          {
            sha: "dd0b341819343cb1eededc8901d8252d943f4e71"
          }
        ],
        committedAt: 1585495169000,
        changedFiles: [
          {
            sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
            filename: "build.gradle",
            status: "modified",
            additions: 36,
            deletions: 2,
            patch:
              "@@ -5,11 +5,46 @@\n  * For more details take a look at the Java Libraries chapter in the Gradle\n  * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n  */\n-\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n     id 'com.github.sherter.google-java-format' version '0.8'\n+    id 'jacoco'\n+}\n+\n+jacoco {\n+    toolVersion = \"0.8.5\"\n+    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n+}\n+\n+jacocoTestReport {\n+    reports {\n+        xml.enabled false\n+        csv.enabled false\n+        html.destination file(\"${buildDir}/jacocoHtml\")\n+    }\n+}\n+\n+jacocoTestCoverageVerification {\n+    violationRules {\n+        rule {\n+            limit {\n+                minimum = 0.5\n+            }\n+        }\n+\n+        rule {\n+            enabled = false\n+            element = 'CLASS'\n+            includes = ['org.gradle.*']\n+\n+            limit {\n+                counter = 'LINE'\n+                value = 'TOTALCOUNT'\n+                maximum = 0.3\n+            }\n+        }\n+    }\n }\n \n repositories {\n@@ -47,7 +82,6 @@ dependencies {\n     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n     implementation 'org.jetbrains:annotations:15.0'\n }\n-\n test {\n     // Use junit platform for unit tests\n     useJUnitPlatform()",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -2,8 +2,14 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import java.util.*;\n import lombok.Getter;\n@@ -37,10 +43,35 @@ public RefactoringCrawler(String projectName, Dictionary<Settings, Double> setti\n   }\n \n   private static List<CompilationUnit> parse(List<String> files) {\n+\n     TypeSolver typeSolver = new ReflectionTypeSolver();\n     JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n     StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n \n+    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n+      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n+      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n+        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n+          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n+        }\n+      }\n+      if (null != classOrInterfaceDeclaration) {\n+        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n+        if (fullyQualifiedName.isPresent()) {\n+          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n+              classOrInterfaceDeclaration.resolve();\n+          memoryTypeSolver.addDeclaration(\n+              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n+        }\n+      }\n+    }\n+\n+    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n+\n     List<CompilationUnit> resList = new LinkedList<>();\n     for (String source : files) {\n       CompilationUnit cu = StaticJavaParser.parse(source);",
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          },
          {
            sha: "da52b72d6129eeaaecc0171a5c6ec463564026b1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 13,
            deletions: 2,
            patch:
              "@@ -50,7 +50,7 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n    */\n   public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> refactoredNodes = new ArrayList<>();\n     List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n     return pruneFalsePositives(listWithFP);\n   }\n@@ -76,6 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n+//        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -84,6 +85,16 @@ protected String extractPotentialRename(String parentClassOriginal) {\n     return refactoredNodes;\n   }\n \n+  /** @param pair */\n+  private void updateFeedbackLoop(Node[] pair) {\n+    if (isRename()) {\n+      Node original = pair[0];\n+      Node renamed = pair[1];\n+      Dictionary<String, String> dict = getRenamingDictionary();\n+      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n+    }\n+  }\n+\n   public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n     List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n     for (Node[] pair : listWithFP) {\n@@ -365,7 +376,7 @@ protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigr\n         result -> {\n           if (graph.hasNamedNode(result))\n             graph.addEdge(\n-                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n         });\n     // Possible change to methods that instantiate classes\n     // from class -> class edges.",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n//        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 15,
            deletions: 6,
            patch:
              "@@ -2,10 +2,7 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-import refactoring.crawler.graph.ClassNode;\n-import refactoring.crawler.graph.FieldNode;\n-import refactoring.crawler.graph.MethodNode;\n-import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n   public static List<String> findFieldReferences(FieldNode node) {\n@@ -16,8 +13,20 @@\n     return node.getSuperClasses();\n   }\n \n-  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-    return node.getClassesImported();\n+  public static List<String> findClassReferences(\n+      NamedDirectedMultigraph graph, ClassNode classNode) {\n+    //    return node.getClassesImported();\n+    List<String> res = new LinkedList<>();\n+    for (Node n : graph.vertexSet()) {\n+      if (n.getType() == Node.Type.CLASS) {\n+        for (String imported : ((ClassNode) n).getClassesImported()) {\n+          if (imported.equals(classNode.getFullyQualifiedName())) {\n+            res.add(n.getFullyQualifiedName());\n+          }\n+        }\n+      }\n+    }\n+    return res;\n   }\n \n   public static List<String> findMethodCallers(",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 5,
            deletions: 4,
            patch:
              "@@ -19,15 +19,16 @@ public RenameMethodDetection(\n    */\n   public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n     List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n     for (Node[] pair : prePrunedMethods) {\n       Node original = pair[0];\n       Node version = pair[1];\n       String parentClassOriginal = extractFullyQualifiedParentName(original);\n       String parentClassVersion = extractFullyQualifiedParentName(version);\n-      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-        candidatesWithSameParentClass.add(pair);\n+      boolean isTheSameModuloRename =\n+          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n+      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n     }\n \n     return candidatesWithSameParentClass;",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -277,7 +277,7 @@ private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph gr\n       for (Node c : this.oldVersionClassList) {\n         if (!c.isAPI()) continue;\n \n-        for (Node c2 : this.oldVersionClassList) {\n+        for (Node c2 : this.newVersionClassList) {\n           if (!c2.isAPI()) continue;\n \n           if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {",
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "d417febc4d7566232396eca5c9745c45efdea9d9",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 117,
            deletions: 4,
            patch:
              '@@ -5,9 +5,8 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import java.util.Dictionary;\n-import java.util.Hashtable;\n-import java.util.List;\n+import java.io.IOException;\n+import java.util.*;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n@@ -23,7 +22,7 @@ static void setUp() {\n \n     settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n@@ -129,4 +128,118 @@ void testChangeMethodSignature() {\n     assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n     assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testRenameClass() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String source2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library123 {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(1);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String newVersion2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library123;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library123();\\n"\n+            + "}\\n";\n+\n+    List<String> originals = new LinkedList<>();\n+    List<String> newVersions = new LinkedList<>();\n+\n+    originals.add(source);\n+    originals.add(source2);\n+\n+    newVersions.add(newVersion);\n+    newVersions.add(newVersion2);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(originals, newVersions);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedClasses", refactoringCategory.getName());\n+    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+  }\n+\n+  @Test\n+  void testMoveMethod() throws IOException {\n+    String originalArray = TestUtils.readFile("original", "Array.java", null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+\n+    String newVersionArray =\n+        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+    String newVersionArrayStack =\n+        TestUtils.readFile(\n+            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+    String newVersionStack =\n+        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalArray);\n+    originalList.add(originalStack);\n+    originalList.add(originalArrayStack);\n+\n+    newVersionList.add(newVersionArray);\n+    newVersionList.add(newVersionStack);\n+    newVersionList.add(newVersionArrayStack);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("MovedMethods", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n\n    String newVersionArray =\n        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "d18a5d147ebcf0a40f031c5cf65e1b6fb0ac8c20",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "added",
            additions: 32,
            deletions: 0,
            patch:
              '@@ -0,0 +1,32 @@\n+package refactoring.crawler;\n+\n+import java.io.*;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Utils Class For Testing\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-29 13:55\n+ */\n+public class TestUtils {\n+  public static String readFile(String folder, String filename, String packageName)\n+      throws IOException {\n+    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n+    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n+    String st;\n+    StringBuilder sb = new StringBuilder();\n+    while ((st = bufferedReader.readLine()) != null) {\n+      sb.append(st);\n+      sb.append(System.getProperty("line.separator"));\n+    }\n+    String fileContent = sb.toString();\n+    if (packageName != null) {\n+      fileContent =\n+          fileContent.replace(\n+              "package refactoring.crawler.testMoveMethod;",\n+              "package refactoring.crawler.original;");\n+    }\n+    return fileContent;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(String folder, String filename, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent =\n          fileContent.replace(\n              "package refactoring.crawler.testMoveMethod;",\n              "package refactoring.crawler.original;");\n    }\n    return fileContent;\n  }\n}\n'
          },
          {
            sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
            filename: "src/test/java/refactoring/crawler/original/Array.java",
            status: "added",
            additions: 152,
            deletions: 0,
            patch:
              '@@ -0,0 +1,152 @@\n+package refactoring.crawler.original;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // capacityArray\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.getLast());\n+  }\n+\n+  // capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // \n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // \n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // \n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // indexe\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // \n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // \n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // index\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // indexe\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // ee-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // index, \n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // , \n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // , \n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // newCapacity\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
            filename:
              "src/test/java/refactoring/crawler/original/ArrayStack.java",
            status: "added",
            additions: 62,
            deletions: 0,
            patch:
              '@@ -0,0 +1,62 @@\n+package refactoring.crawler.original;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.array.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
            filename: "src/test/java/refactoring/crawler/original/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.original;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          },
          {
            sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Array.java",
            status: "added",
            additions: 148,
            deletions: 0,
            patch:
              '@@ -0,0 +1,148 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // capacityArray\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  // capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // \n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // \n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // \n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // indexe\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // \n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // \n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // index\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // indexe\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // ee-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // index, \n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // , \n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // , \n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // newCapacity\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/ArrayStack.java",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.peek());\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          }
        ]
      },
      {
        sha: "dd0b341819343cb1eededc8901d8252d943f4e71",
        message: "fix(test): fix change method signature detection failed",
        stats: {
          total: 2,
          additions: 1,
          deletions: 1
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "7c561f5ca55b8f558802d42395673ab9d92a5fa9"
          }
        ],
        committedAt: 1585495096000,
        changedFiles: [
          {
            sha: "da52b72d6129eeaaecc0171a5c6ec463564026b1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-        updateFeedbackLoop(pair);\n+//        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n//        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          }
        ]
      },
      {
        sha: "7c561f5ca55b8f558802d42395673ab9d92a5fa9",
        message: "test(MovedMethodsDetection): test and fix",
        stats: {
          total: 101,
          additions: 90,
          deletions: 11
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ecedbb481795ccea9f78c784c875d04dbf7e2cf5"
          }
        ],
        committedAt: 1585494132000,
        changedFiles: [
          {
            sha: "d55b1786c1cbd3593a570a6f84796eac01d18305",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 12,
            deletions: 1,
            patch:
              "@@ -50,7 +50,7 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n    */\n   public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> refactoredNodes = new ArrayList<>();\n     List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n     return pruneFalsePositives(listWithFP);\n   }\n@@ -76,6 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n+        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -84,6 +85,16 @@ protected String extractPotentialRename(String parentClassOriginal) {\n     return refactoredNodes;\n   }\n \n+  /** @param pair */\n+  private void updateFeedbackLoop(Node[] pair) {\n+    if (isRename()) {\n+      Node original = pair[0];\n+      Node renamed = pair[1];\n+      Dictionary<String, String> dict = getRenamingDictionary();\n+      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n+    }\n+  }\n+\n   public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n     List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n     for (Node[] pair : listWithFP) {",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 5,
            deletions: 4,
            patch:
              "@@ -19,15 +19,16 @@ public RenameMethodDetection(\n    */\n   public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n     List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n     for (Node[] pair : prePrunedMethods) {\n       Node original = pair[0];\n       Node version = pair[1];\n       String parentClassOriginal = extractFullyQualifiedParentName(original);\n       String parentClassVersion = extractFullyQualifiedParentName(version);\n-      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-        candidatesWithSameParentClass.add(pair);\n+      boolean isTheSameModuloRename =\n+          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n+      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n     }\n \n     return candidatesWithSameParentClass;",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "d417febc4d7566232396eca5c9745c45efdea9d9",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 41,
            deletions: 6,
            patch:
              '@@ -5,10 +5,8 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import java.util.Dictionary;\n-import java.util.Hashtable;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.io.IOException;\n+import java.util.*;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n@@ -24,7 +22,7 @@ static void setUp() {\n \n     settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n@@ -185,7 +183,7 @@ void testRenameClass() {\n             + "package refactoring.a;\\n"\n             + "import refactoring.crawler.Library123;\\n"\n             + "public class A {\\n"\n-            + "private Library library = new Library();\\n"\n+            + "private Library library = new Library123();\\n"\n             + "}\\n";\n \n     List<String> originals = new LinkedList<>();\n@@ -207,4 +205,41 @@ void testRenameClass() {\n     assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n     assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testMoveMethod() throws IOException {\n+    String originalArray = TestUtils.readFile("original", "Array.java", null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+\n+    String newVersionArray =\n+        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+    String newVersionArrayStack =\n+        TestUtils.readFile(\n+            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+    String newVersionStack =\n+        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalArray);\n+    originalList.add(originalStack);\n+    originalList.add(originalArrayStack);\n+\n+    newVersionList.add(newVersionArray);\n+    newVersionList.add(newVersionStack);\n+    newVersionList.add(newVersionArrayStack);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("MovedMethods", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n\n    String newVersionArray =\n        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "d18a5d147ebcf0a40f031c5cf65e1b6fb0ac8c20",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "added",
            additions: 32,
            deletions: 0,
            patch:
              '@@ -0,0 +1,32 @@\n+package refactoring.crawler;\n+\n+import java.io.*;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Utils Class For Testing\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-29 13:55\n+ */\n+public class TestUtils {\n+  public static String readFile(String folder, String filename, String packageName)\n+      throws IOException {\n+    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n+    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n+    String st;\n+    StringBuilder sb = new StringBuilder();\n+    while ((st = bufferedReader.readLine()) != null) {\n+      sb.append(st);\n+      sb.append(System.getProperty("line.separator"));\n+    }\n+    String fileContent = sb.toString();\n+    if (packageName != null) {\n+      fileContent =\n+          fileContent.replace(\n+              "package refactoring.crawler.testMoveMethod;",\n+              "package refactoring.crawler.original;");\n+    }\n+    return fileContent;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(String folder, String filename, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent =\n          fileContent.replace(\n              "package refactoring.crawler.testMoveMethod;",\n              "package refactoring.crawler.original;");\n    }\n    return fileContent;\n  }\n}\n'
          }
        ]
      },
      {
        sha: "ecedbb481795ccea9f78c784c875d04dbf7e2cf5",
        message:
          "feat(UseMemoryTypeSolver): parse to cu and added to memory type solver first",
        stats: {
          total: 31,
          additions: 31,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "d06c38c0ad3c96244a0f1ac69bf8ddfad2c85eaf"
          }
        ],
        committedAt: 1585494105000,
        changedFiles: [
          {
            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -2,8 +2,14 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import java.util.*;\n import lombok.Getter;\n@@ -37,10 +43,35 @@ public RefactoringCrawler(String projectName, Dictionary<Settings, Double> setti\n   }\n \n   private static List<CompilationUnit> parse(List<String> files) {\n+\n     TypeSolver typeSolver = new ReflectionTypeSolver();\n     JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n     StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n \n+    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n+      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n+      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n+        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n+          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n+        }\n+      }\n+      if (null != classOrInterfaceDeclaration) {\n+        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n+        if (fullyQualifiedName.isPresent()) {\n+          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n+              classOrInterfaceDeclaration.resolve();\n+          memoryTypeSolver.addDeclaration(\n+              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n+        }\n+      }\n+    }\n+\n+    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n+\n     List<CompilationUnit> resList = new LinkedList<>();\n     for (String source : files) {\n       CompilationUnit cu = StaticJavaParser.parse(source);",
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          }
        ]
      },
      {
        sha: "d06c38c0ad3c96244a0f1ac69bf8ddfad2c85eaf",
        message: "test(MovedMethodsDetection): add java file for testing",
        stats: {
          total: 456,
          additions: 456,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "51c79a1d70c10f3b81a73b9f67fef233e22f9b19"
          }
        ],
        committedAt: 1585494005000,
        changedFiles: [
          {
            sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
            filename: "src/test/java/refactoring/crawler/original/Array.java",
            status: "added",
            additions: 152,
            deletions: 0,
            patch:
              '@@ -0,0 +1,152 @@\n+package refactoring.crawler.original;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // capacityArray\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.getLast());\n+  }\n+\n+  // capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // \n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // \n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // \n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // indexe\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // \n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // \n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // index\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // indexe\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // ee-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // index, \n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // , \n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // , \n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // newCapacity\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
            filename:
              "src/test/java/refactoring/crawler/original/ArrayStack.java",
            status: "added",
            additions: 62,
            deletions: 0,
            patch:
              '@@ -0,0 +1,62 @@\n+package refactoring.crawler.original;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.array.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
            filename: "src/test/java/refactoring/crawler/original/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.original;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          },
          {
            sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Array.java",
            status: "added",
            additions: 148,
            deletions: 0,
            patch:
              '@@ -0,0 +1,148 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // capacityArray\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  // capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // \n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // \n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // \n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // indexe\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // \n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // \n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // index\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // indexe\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // ee-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // index, \n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // , \n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // , \n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // newCapacity\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/ArrayStack.java",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.peek());\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          }
        ]
      },
      {
        sha: "51c79a1d70c10f3b81a73b9f67fef233e22f9b19",
        message: "style(*): format code",
        stats: {
          total: 1413,
          additions: 704,
          deletions: 709
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "5547ee77aae8348fb47173c17db3bbe8bef88da0"
          }
        ],
        committedAt: 1585458717000,
        changedFiles: [
          {
            sha: "87155fad22f81e508316285eaa34f383811496b3",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 412,
            deletions: 417,
            patch:
              '@@ -1,7 +1,6 @@\n package refactoring.crawler.detection;\n \n import java.util.*;\n-\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n@@ -12,420 +11,416 @@\n \n public abstract class RefactoringDetection {\n \n-\t@Getter\n-\t@Setter\n-\tprivate double threshold;\n-\n-\tprotected NamedDirectedMultigraph graph1;\n-\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\tprivate double lowerThreshold;\n-\n-\t/**\n-\t * Dictionary contains <Original, Version> pairs for the renaming.\n-\t */\n-\tprivate static Dictionary<String, String> renamingDictionary;\n-\n-\tpublic static Dictionary<String, String> getRenamingDictionary() {\n-\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-\t\treturn renamingDictionary;\n-\t}\n-\n-\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tthis.graph1 = graph;\n-\t\tthis.graph2 = graph2;\n-\t}\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n-\n-\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-\tpublic abstract boolean isRename();\n-\n-\t/**\n-\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-\t * computeLikeliness and pruneOriginalCandidates.\n-\t */\n-\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-\t\treturn pruneFalsePositives(listWithFP);\n-\t}\n-\n-\tprotected String extractPotentialRename(String parentClassOriginal) {\n-\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n-\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n-\t}\n-\n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Node[] pair : prunedCandidates) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n-\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n-\t\t\t\t// detect those cases when two\n-\t\t\t\t// types of refactorings happened to the same node\n-\t\t\t}\n-\t\t}\n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n-\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n-\t\t\tif (originalInV2 != null) {\n-\t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-\t\t\t\tList<Edge> verIncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n-\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n-\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n-\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Node node : verCallers) {\n-\t\t\t\t\tif (origInV2Callers.contains(node))\n-\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-\t\t\t\t// pair\n-\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n-\t\t\t\t// call sites\n-\t\t\t\t// should be different\n-\t\t\t\tfor (Node node : origInV1Callers) {\n-\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n-\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tlistWithFP.remove(pair);\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\n-\t\tpruneOverloadedMethodFP(listWithFP);\n-\n-\t\treturn listWithFP;\n-\t}\n-\n-\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<>();\n-\t\tfor (Edge edge : incomingEdges) {\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n-\n-\t/**\n-\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-\t *\n-\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-\t * because of a method overload.\n-\t *\n-\t * <p>This method is never called in the ChangeMethodSignature detection.\n-\t */\n-\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n-\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n-\t\t\tboolean hasSameNameAndSignature = false;\n-\t\t\tNode[] pair = listWithFP.get(i);\n-\t\t\tNode source = pair[0];\n-\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (hasSameNameAndSignature) {\n-\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-\t\t\tlistWithFP.remove(pair);\n-\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This takes into account the possible renaming in the parent of the node\n-\t *\n-\t * @param g        is the Version2 graph\n-\t * @param original is a node from Version1\n-\t * @return\n-\t */\n-\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tString fqnParent = extractFullyQualifiedParentName(original);\n-\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n-\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-\t\tNode parentNode = g.findNamedNode(fqnParent);\n-\n-\t\tif (parentNode != null) {\n-\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-\t\t\t\tEdge edge = (Edge) iter.next();\n-\t\t\t\tNode child = (Node) edge.getTarget();\n-\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n-\t\t\t\t\tif (original.getSignature() != null) {\n-\t\t\t\t\t\t// This handles the method nodes\n-\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n-\t\t\t\t\t} else\n-\t\t\t\t\t\t// Classes and packages\n-\t\t\t\t\t\treturn child;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (label.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\tprotected String extractFullyQualifiedParentName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\treturn extractFullyQualifiedParentName(originalName);\n-\t}\n-\n-\tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fq_parentName = "";\n-\t\tint lastIndex = originalName.lastIndexOf(".");\n-\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-\t\treturn fq_parentName;\n-\t}\n-\n-\t/**\n-\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-\t * IDE.openEditor(IWorkbenchPage, IFile)\n-\t */\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null) return false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/**\n-\t * This helper method takes a string containing the dot separated name of a node and it returns\n-\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-\t * class1)\n-\t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n-\t}\n-\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original))) return true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original\n-\t\t\t.substring(original.lastIndexOf("."))\n-\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-\t\telse return false;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t// TODO this is bug pruned\n-\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-\t\t//\t\ttry {\n-\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-\t\tresults.forEach(\n-\t\t\tresult -> {\n-\t\t\t\tif (graph.hasNamedNode(result))\n-\t\t\t\t\tgraph.addEdge(\n-\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n-\t\t\t});\n-\t\t// Possible change to methods that instantiate classes\n-\t\t// from class -> class edges.\n-\t\t//\t\t\tfor (String result : results) {\n-\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-\t\t//\t\t\t\tString callingNode = null;\n-\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n-\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n-\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n-\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n-\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-\t\t//\t\t\t\t\t// Workaround\n-\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += ".";\n-\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n-\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-\t\t// ASTNodes\n-\t\t//\t\t\t\t\t\t.getParent(initializer,\n-\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-\t\t//\t\t\t\t\t\tIType.class);\n-\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-\t\t//\t\t\t\t}\n-\t\t//\n-\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n-\t\t//\t\t\t\t// ImportDeclaration\n-\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n-\t\t//\t\t\t\t// Initializer\n-\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-\t\t//\t\t\t\t// Level\n-\t\t//\t\t\t\tif (callingNode == null) {\n-\t\t//\t\t\t\t\tSystem.out.print("");\n-\t\t//\t\t\t\t}\n-\t\t//\t\t\t\tif (callingNode != null) {\n-\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-\t\t//\t\t\t\t\tif (callerNode != null)\n-\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-\t\t//\t\t\t\t}\n-\t\t//\n-\t\t//\t\t\t}\n-\t\t//\n-\t\t//\t\t} catch (CoreException e) {\n-\t\t//\t\t\tJavaPlugin.log(e);\n-\t\t//\t\t}\n-\t}\n+  @Getter @Setter private double threshold;\n+\n+  protected NamedDirectedMultigraph graph1;\n+\n+  protected NamedDirectedMultigraph graph2;\n+\n+  private double lowerThreshold;\n+\n+  /** Dictionary contains <Original, Version> pairs for the renaming. */\n+  private static Dictionary<String, String> renamingDictionary;\n+\n+  public static Dictionary<String, String> getRenamingDictionary() {\n+    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+    return renamingDictionary;\n+  }\n+\n+  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    this.graph1 = graph;\n+    this.graph2 = graph2;\n+  }\n+\n+  public abstract double computeLikeliness(Node node1, Node node12);\n+\n+  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+  public abstract boolean isRename();\n+\n+  /**\n+   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+   * computeLikeliness and pruneOriginalCandidates.\n+   */\n+  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+    return pruneFalsePositives(listWithFP);\n+  }\n+\n+  protected String extractPotentialRename(String parentClassOriginal) {\n+    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+    return renamedName == null ? parentClassOriginal : renamedName;\n+  }\n+\n+  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+    boolean foundNewRefactoring = false;\n+    for (Node[] pair : prunedCandidates) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      double likeliness = computeLikeliness(original, version);\n+      if (likeliness >= threshold) {\n+        if (!refactoredNodes.contains(pair)) {\n+          refactoredNodes.add(pair);\n+          foundNewRefactoring = true;\n+        }\n+        // candidates.remove(pair); acivating this line would fail to\n+        // detect those cases when two\n+        // types of refactorings happened to the same node\n+      }\n+    }\n+    if (foundNewRefactoring) {\n+      doDetectRefactorings(candidates, refactoredNodes);\n+    }\n+    return refactoredNodes;\n+  }\n+\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+    for (Node[] pair : listWithFP) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+      if (originalInV2 != null) {\n+        createCallGraph(originalInV2, graph2);\n+        List<Edge> origIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+        List<Edge> verIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        List<Edge> origInVer1IncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+        List<Node> verCallers = getCallers(verIncomingEdges);\n+        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+        // since a call site cannot be calling both the old and the new entity at the same time\n+        for (Node node : verCallers) {\n+          if (origInV2Callers.contains(node))\n+            if (!nodesToRemove.contains(pair)) {\n+              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              nodesToRemove.add(pair);\n+            }\n+        }\n+\n+        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+        // pair\n+        // is a false positive (since there should be either no more callers for N1inV2 or their\n+        // call sites\n+        // should be different\n+        for (Node node : origInV1Callers) {\n+          for (Node callingNode : origInV2Callers) {\n+            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+              if (!nodesToRemove.contains(pair)) {\n+                nodesToRemove.add(pair);\n+              }\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    for (Node[] pair : nodesToRemove) {\n+      listWithFP.remove(pair);\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n+    }\n+\n+    pruneOverloadedMethodFP(listWithFP);\n+\n+    return listWithFP;\n+  }\n+\n+  private List<Node> getCallers(List<Edge> incomingEdges) {\n+    List<Node> callers = new ArrayList<>();\n+    for (Edge edge : incomingEdges) {\n+      callers.add(edge.getSource());\n+    }\n+    return callers;\n+  }\n+\n+  /**\n+   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+   *\n+   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+   * because of a method overload.\n+   *\n+   * <p>This method is never called in the ChangeMethodSignature detection.\n+   */\n+  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<>();\n+    for (int i = 0; i < listWithFP.size(); i++) {\n+      boolean hasSameNameAndSignature = false;\n+      Node[] pair = listWithFP.get(i);\n+      Node source = pair[0];\n+      for (int j = i; j < listWithFP.size(); j++) {\n+        Node[] pair2 = listWithFP.get(j);\n+        Node source2 = pair2[0];\n+        if (source.equals(source2)) {\n+          Node target2 = pair2[1];\n+          if (source.getSimpleName().equals(target2.getSimpleName()))\n+            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+        }\n+      }\n+      if (hasSameNameAndSignature) {\n+        for (int j = i; j < listWithFP.size(); j++) {\n+          Node[] pair2 = listWithFP.get(j);\n+          Node source2 = pair2[0];\n+          if (source.equals(source2)) {\n+            Node target2 = pair2[1];\n+            if (source.getSimpleName().equals(target2.getSimpleName()))\n+              if (!signatureEqualsModuloMoveMethod(source, target2))\n+                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+          }\n+        }\n+      }\n+    }\n+    for (Node[] pair : nodesToRemove) {\n+      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+      listWithFP.remove(pair);\n+\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n+    }\n+  }\n+\n+  /**\n+   * This takes into account the possible renaming in the parent of the node\n+   *\n+   * @param g is the Version2 graph\n+   * @param original is a node from Version1\n+   * @return\n+   */\n+  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    String fqnParent = extractFullyQualifiedParentName(original);\n+    String possiblyRenamedFQN = dictionary.get(fqnParent);\n+    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+    Node parentNode = g.findNamedNode(fqnParent);\n+\n+    if (parentNode != null) {\n+      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+        Edge edge = (Edge) iter.next();\n+        Node child = (Node) edge.getTarget();\n+        if (original.getSimpleName().equals(child.getSimpleName()))\n+          if (original.getSignature() != null) {\n+            // This handles the method nodes\n+            if (original.getSignature().equals(child.getSignature())) return child;\n+          } else\n+            // Classes and packages\n+            return child;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge edge : list) {\n+      if (label.equals(edge.getLabel())) {\n+        results.add(edge);\n+      }\n+    }\n+    return results;\n+  }\n+\n+  protected String extractFullyQualifiedParentName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    return extractFullyQualifiedParentName(originalName);\n+  }\n+\n+  public String extractFullyQualifiedParentName(String originalName) {\n+    String fq_parentName = "";\n+    int lastIndex = originalName.lastIndexOf(".");\n+    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+    return fq_parentName;\n+  }\n+\n+  /**\n+   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+   * IDE.openEditor(IWorkbenchPage, IFile)\n+   */\n+  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+    boolean retval = false;\n+\n+    if (source.getSignature() == null) return false;\n+\n+    retval = source.getSignature().equals(target.getSignature());\n+\n+    if (!retval && (this instanceof MoveMethodDetection)) {\n+      String sourceParent = extractParentSimpleName(source);\n+      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+      String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+      for (int i = 0; i < sourceTokens.length; i++) {\n+        sourceTokens[i] = sourceTokenizer.nextToken();\n+      }\n+\n+      for (int i = 0; i < targetTokens.length; i++) {\n+        targetTokens[i] = targetTokenizer.nextToken();\n+      }\n+\n+      if (targetTokens.length == sourceTokens.length + 1) {\n+        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+        else {\n+          for (int i = 0; i < sourceTokens.length; i++) {\n+            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+          }\n+          retval = true;\n+        }\n+      }\n+    }\n+    return retval;\n+  }\n+\n+  /**\n+   * This helper method takes a string containing the dot separated name of a node and it returns\n+   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+   * class1)\n+   */\n+  protected String extractParentSimpleName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+    return parentName;\n+  }\n+\n+  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+    double count = 0;\n+\n+    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+    for (Edge edge1 : edges1) {\n+      Node node1 = edge1.getSource();\n+      for (int i = 0; i < arrEdge2.length; i++) {\n+        Edge edge2 = arrEdge2[i];\n+        if (edge2 != null) {\n+          Node node2 = (Node) edge2.getSource();\n+          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+            count++;\n+            // we mark this edge as already counted so that we don\'t\n+            // count it\n+            // twice when there are multiple edges between two nodes\n+            arrEdge2[i] = null;\n+          }\n+        }\n+      }\n+    }\n+\n+    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+    return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  protected boolean isTheSameModuloRename(String original, String version) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    if (version.equals(dictionary.get(original))) return true;\n+    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+      return original.equals(version);\n+    else if (original\n+        .substring(original.lastIndexOf("."))\n+        .equals(version.substring(version.lastIndexOf("."))))\n+      return isTheSameModuloRename(\n+          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+    else return false;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+        if (pair[0].isAPI() && pair[1].isAPI()) {\n+          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+          if ((n2inV1 == null)) {\n+            prunedCandidates.add(pair);\n+          }\n+        }\n+      }\n+    }\n+    return prunedCandidates;\n+  }\n+\n+  // TODO this is bug pruned\n+  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    //\t\ttry {\n+    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+    results.forEach(\n+        result -> {\n+          if (graph.hasNamedNode(result))\n+            graph.addEdge(\n+                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n+        });\n+    // Possible change to methods that instantiate classes\n+    // from class -> class edges.\n+    //\t\t\tfor (String result : results) {\n+    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+    //\t\t\t\tString callingNode = null;\n+    //\t\t\t\tif (resultNode instanceof IMethod) {\n+    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof IType) {\n+    //\t\t\t\t\tIType rst = (IType) resultNode;\n+    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t} else if (resultNode instanceof IField) {\n+    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+    //\t\t\t\t\t// Workaround\n+    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += ".";\n+    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+    // ASTNodes\n+    //\t\t\t\t\t\t.getParent(initializer,\n+    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+    //\t\t\t\t\t\tIType.class);\n+    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// ImportDeclaration\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// Initializer\n+    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+    //\t\t\t\t// Level\n+    //\t\t\t\tif (callingNode == null) {\n+    //\t\t\t\t\tSystem.out.print("");\n+    //\t\t\t\t}\n+    //\t\t\t\tif (callingNode != null) {\n+    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+    //\t\t\t\t\tif (callerNode != null)\n+    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t}\n+    //\n+    //\t\t} catch (CoreException e) {\n+    //\t\t\tJavaPlugin.log(e);\n+    //\t\t}\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 53,
            deletions: 53,
            patch:
              "@@ -2,63 +2,63 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-\n import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n-\tpublic static List<String> findFieldReferences(FieldNode node) {\n-\t\treturn node.getFieldReferenceToMethod();\n-\t}\n+  public static List<String> findFieldReferences(FieldNode node) {\n+    return node.getFieldReferenceToMethod();\n+  }\n \n-\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n-\t\treturn node.getSuperClasses();\n-\t}\n+  public static List<String> findSuperClassesOf(ClassNode node) {\n+    return node.getSuperClasses();\n+  }\n \n-\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n-//    return node.getClassesImported();\n-\t\tList<String> res = new LinkedList<>();\n-\t\tfor (Node n : graph.vertexSet()) {\n-\t\t\tif (n.getType() == Node.Type.CLASS) {\n-\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n-\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn res;\n-\t}\n+  public static List<String> findClassReferences(\n+      NamedDirectedMultigraph graph, ClassNode classNode) {\n+    //    return node.getClassesImported();\n+    List<String> res = new LinkedList<>();\n+    for (Node n : graph.vertexSet()) {\n+      if (n.getType() == Node.Type.CLASS) {\n+        for (String imported : ((ClassNode) n).getClassesImported()) {\n+          if (imported.equals(classNode.getFullyQualifiedName())) {\n+            res.add(n.getFullyQualifiedName());\n+          }\n+        }\n+      }\n+    }\n+    return res;\n+  }\n \n-\tpublic static List<String> findMethodCallers(\n-\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-\t\treturn graph\n-\t\t\t.vertexSet()\n-\t\t\t.stream()\n-\t\t\t.filter(n -> (n instanceof MethodNode))\n-\t\t\t.map(methodNode -> (MethodNode) methodNode)\n-\t\t\t.filter(\n-\t\t\t\tmethodNode ->\n-\t\t\t\t\tmethodNode\n-\t\t\t\t\t\t.getCalledInside()\n-\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t.anyMatch(\n-\t\t\t\t\t\t\tcalledMethod -> {\n-\t\t\t\t\t\t\t\tString expect =\n-\t\t\t\t\t\t\t\t\twithSignature\n-\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n-\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n-\t\t\t\t\t\t\t\tString actual =\n-\t\t\t\t\t\t\t\t\twithSignature\n-\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n-\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n-\t\t\t\t\t\t\t\treturn expect.equals(actual);\n-\t\t\t\t\t\t\t}))\n-\t\t\t.map(\n-\t\t\t\tmethodNode -> {\n-\t\t\t\t\treturn withSignature\n-\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n-\t\t\t\t})\n-\t\t\t.collect(Collectors.toList());\n-\t}\n+  public static List<String> findMethodCallers(\n+      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+    return graph\n+        .vertexSet()\n+        .stream()\n+        .filter(n -> (n instanceof MethodNode))\n+        .map(methodNode -> (MethodNode) methodNode)\n+        .filter(\n+            methodNode ->\n+                methodNode\n+                    .getCalledInside()\n+                    .stream()\n+                    .anyMatch(\n+                        calledMethod -> {\n+                          String expect =\n+                              withSignature\n+                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                          String actual =\n+                              withSignature\n+                                  ? node.getFullyQualifiedName() + node.getSignature()\n+                                  : node.getFullyQualifiedName();\n+                          return expect.equals(actual);\n+                        }))\n+        .map(\n+            methodNode -> {\n+              return withSignature\n+                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                  : methodNode.getFullyQualifiedName();\n+            })\n+        .collect(Collectors.toList());\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "f069e44153341cbf9da6818393293f5e7e9ac108",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 48,
            deletions: 49,
            patch:
              "@@ -2,59 +2,58 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import refactoring.crawler.graph.Edge;\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n-\t}\n-\n-\t/**\n-\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-\t * computeLikelinessIncomingEdges in RefactoringDetection\n-\t *\n-\t * @param nodeOriginal\n-\t * @param nodeVersion\n-\t * @return\n-\t */\n-\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal =\n-\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion =\n-\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-\t\tfor (Node[] pair : prePruned) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n-\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n-\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentPackage;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+  }\n+\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+  }\n+\n+  /**\n+   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+   * computeLikelinessIncomingEdges in RefactoringDetection\n+   *\n+   * @param nodeOriginal\n+   * @param nodeVersion\n+   * @return\n+   */\n+  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+    for (Node[] pair : prePruned) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractParentSimpleName(original);\n+      String parentPackageVersion = extractParentSimpleName(version);\n+      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithSameParentPackage.add(pair);\n+      }\n+    }\n+\n+    return candidatesWithSameParentPackage;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n"
          },
          {
            sha: "d3e68342476ab78bcaf0e3af02c379adf650eb64",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 191,
            deletions: 190,
            patch:
              '@@ -9,201 +9,202 @@\n import java.util.Hashtable;\n import java.util.LinkedList;\n import java.util.List;\n-\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n-\n-\t@BeforeAll\n-\tstatic void setUp() {\n-\t\tsettings = new Hashtable<>();\n-\n-\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-\t}\n-\n-\t@Test\n-\tvoid testRenameMethod() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo12() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(source, newVersion);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n-\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n-\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n-\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n-\t}\n-\n-\t@Test\n-\tvoid testChangeMethodSignature() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(source, newVersion);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tRefactoringCategory refactoringCategory = categories.get(0);\n-\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n-\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n-\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n-\t}\n-\n-\t@Test\n-\tvoid testRenameClass() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\t\tString source2 = "/*\\n"\n-\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t+ " */\\n"\n-\t\t\t+ "package refactoring.a;\\n"\n-\t\t\t+ "import refactoring.crawler.Library;\\n"\n-\t\t\t+ "public class A {\\n"\n-\t\t\t+ "private Library library = new Library();\\n"\n-\t\t\t+ "}\\n";\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library123 {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\t\tString newVersion2 = "/*\\n"\n-\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t+ " */\\n"\n-\t\t\t+ "package refactoring.a;\\n"\n-\t\t\t+ "import refactoring.crawler.Library123;\\n"\n-\t\t\t+ "public class A {\\n"\n-\t\t\t+ "private Library library = new Library();\\n"\n-\t\t\t+ "}\\n";\n-\n-\t\tList<String> originals = new LinkedList<>();\n-\t\tList<String> newVersions = new LinkedList<>();\n-\n-\t\toriginals.add(source);\n-\t\toriginals.add(source2);\n-\n-\t\tnewVersions.add(newVersion);\n-\t\tnewVersions.add(newVersion2);\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(originals, newVersions);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tRefactoringCategory refactoringCategory = categories.get(0);\n-\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n-\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n-\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n-\t}\n+  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    settings = new Hashtable<>();\n+\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+  }\n+\n+  @Test\n+  void testRenameMethod() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo12() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo12();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedMethods", categories.get(0).getName());\n+    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+  }\n+\n+  @Test\n+  void testChangeMethodSignature() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo(int i) {\\n"\n+            + "\\t\\tSystem.out.println(i);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo(1);\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n+  }\n+\n+  @Test\n+  void testRenameClass() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String source2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library123 {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(1);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String newVersion2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library123;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+\n+    List<String> originals = new LinkedList<>();\n+    List<String> newVersions = new LinkedList<>();\n+\n+    originals.add(source);\n+    originals.add(source2);\n+\n+    newVersions.add(newVersion);\n+    newVersions.add(newVersion2);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(originals, newVersions);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedClasses", refactoringCategory.getName());\n+    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n}\n'
          }
        ]
      },
      {
        sha: "5547ee77aae8348fb47173c17db3bbe8bef88da0",
        message: "test(RenameClasses): test rename classes",
        stats: {
          total: 1332,
          additions: 712,
          deletions: 620
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "fed214ccff862674ed63f5dd5f017cda31b6ef80"
          }
        ],
        committedAt: 1585458618000,
        changedFiles: [
          {
            sha: "10e10408f92f26211f650f1c23409f3eee6b05b5",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 417,
            deletions: 412,
            patch:
              '@@ -1,6 +1,7 @@\n package refactoring.crawler.detection;\n \n import java.util.*;\n+\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n@@ -11,416 +12,420 @@\n \n public abstract class RefactoringDetection {\n \n-  @Getter @Setter private double threshold;\n-\n-  protected NamedDirectedMultigraph graph1;\n-\n-  protected NamedDirectedMultigraph graph2;\n-\n-  private double lowerThreshold;\n-\n-  /** Dictionary contains <Original, Version> pairs for the renaming. */\n-  private static Dictionary<String, String> renamingDictionary;\n-\n-  public static Dictionary<String, String> getRenamingDictionary() {\n-    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-    return renamingDictionary;\n-  }\n-\n-  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-    this.graph1 = graph;\n-    this.graph2 = graph2;\n-  }\n-\n-  public abstract double computeLikeliness(Node node1, Node node12);\n-\n-  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-  public abstract boolean isRename();\n-\n-  /**\n-   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-   * computeLikeliness and pruneOriginalCandidates.\n-   */\n-  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-    return pruneFalsePositives(listWithFP);\n-  }\n-\n-  protected String extractPotentialRename(String parentClassOriginal) {\n-    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n-    return renamedName == null ? parentClassOriginal : renamedName;\n-  }\n-\n-  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-    boolean foundNewRefactoring = false;\n-    for (Node[] pair : prunedCandidates) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      double likeliness = computeLikeliness(original, version);\n-      if (likeliness >= threshold) {\n-        if (!refactoredNodes.contains(pair)) {\n-          refactoredNodes.add(pair);\n-          foundNewRefactoring = true;\n-        }\n-        // candidates.remove(pair); acivating this line would fail to\n-        // detect those cases when two\n-        // types of refactorings happened to the same node\n-      }\n-    }\n-    if (foundNewRefactoring) {\n-      doDetectRefactorings(candidates, refactoredNodes);\n-    }\n-    return refactoredNodes;\n-  }\n-\n-  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-    for (Node[] pair : listWithFP) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-      if (originalInV2 != null) {\n-        createCallGraph(originalInV2, graph2);\n-        List<Edge> origIncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-        List<Edge> verIncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-        List<Edge> origInVer1IncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-        List<Node> verCallers = getCallers(verIncomingEdges);\n-        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-        // since a call site cannot be calling both the old and the new entity at the same time\n-        for (Node node : verCallers) {\n-          if (origInV2Callers.contains(node))\n-            if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-              nodesToRemove.add(pair);\n-            }\n-        }\n-\n-        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-        // pair\n-        // is a false positive (since there should be either no more callers for N1inV2 or their\n-        // call sites\n-        // should be different\n-        for (Node node : origInV1Callers) {\n-          for (Node callingNode : origInV2Callers) {\n-            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-              if (!nodesToRemove.contains(pair)) {\n-                nodesToRemove.add(pair);\n-              }\n-              break;\n-            }\n-          }\n-        }\n-      }\n-    }\n-    for (Node[] pair : nodesToRemove) {\n-      listWithFP.remove(pair);\n-      Dictionary<String, String> dictionary = getRenamingDictionary();\n-      dictionary.remove(pair[0].getFullyQualifiedName());\n-    }\n-\n-    pruneOverloadedMethodFP(listWithFP);\n-\n-    return listWithFP;\n-  }\n-\n-  private List<Node> getCallers(List<Edge> incomingEdges) {\n-    List<Node> callers = new ArrayList<>();\n-    for (Edge edge : incomingEdges) {\n-      callers.add(edge.getSource());\n-    }\n-    return callers;\n-  }\n-\n-  /**\n-   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-   *\n-   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-   * because of a method overload.\n-   *\n-   * <p>This method is never called in the ChangeMethodSignature detection.\n-   */\n-  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-    List<Node[]> nodesToRemove = new ArrayList<>();\n-    for (int i = 0; i < listWithFP.size(); i++) {\n-      boolean hasSameNameAndSignature = false;\n-      Node[] pair = listWithFP.get(i);\n-      Node source = pair[0];\n-      for (int j = i; j < listWithFP.size(); j++) {\n-        Node[] pair2 = listWithFP.get(j);\n-        Node source2 = pair2[0];\n-        if (source.equals(source2)) {\n-          Node target2 = pair2[1];\n-          if (source.getSimpleName().equals(target2.getSimpleName()))\n-            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-        }\n-      }\n-      if (hasSameNameAndSignature) {\n-        for (int j = i; j < listWithFP.size(); j++) {\n-          Node[] pair2 = listWithFP.get(j);\n-          Node source2 = pair2[0];\n-          if (source.equals(source2)) {\n-            Node target2 = pair2[1];\n-            if (source.getSimpleName().equals(target2.getSimpleName()))\n-              if (!signatureEqualsModuloMoveMethod(source, target2))\n-                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-          }\n-        }\n-      }\n-    }\n-    for (Node[] pair : nodesToRemove) {\n-      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-      listWithFP.remove(pair);\n-\n-      Dictionary<String, String> dictionary = getRenamingDictionary();\n-      dictionary.remove(pair[0].getFullyQualifiedName());\n-    }\n-  }\n-\n-  /**\n-   * This takes into account the possible renaming in the parent of the node\n-   *\n-   * @param g is the Version2 graph\n-   * @param original is a node from Version1\n-   * @return\n-   */\n-  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-    Dictionary<String, String> dictionary = getRenamingDictionary();\n-    String fqnParent = extractFullyQualifiedParentName(original);\n-    String possiblyRenamedFQN = dictionary.get(fqnParent);\n-    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-    Node parentNode = g.findNamedNode(fqnParent);\n-\n-    if (parentNode != null) {\n-      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-        Edge edge = (Edge) iter.next();\n-        Node child = (Node) edge.getTarget();\n-        if (original.getSimpleName().equals(child.getSimpleName()))\n-          if (original.getSignature() != null) {\n-            // This handles the method nodes\n-            if (original.getSignature().equals(child.getSignature())) return child;\n-          } else\n-            // Classes and packages\n-            return child;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-    List<Edge> results = new ArrayList<>();\n-    for (Edge edge : list) {\n-      if (label.equals(edge.getLabel())) {\n-        results.add(edge);\n-      }\n-    }\n-    return results;\n-  }\n-\n-  protected String extractFullyQualifiedParentName(Node original) {\n-    String originalName = original.getFullyQualifiedName();\n-    return extractFullyQualifiedParentName(originalName);\n-  }\n-\n-  public String extractFullyQualifiedParentName(String originalName) {\n-    String fq_parentName = "";\n-    int lastIndex = originalName.lastIndexOf(".");\n-    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-    return fq_parentName;\n-  }\n-\n-  /**\n-   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-   * IDE.openEditor(IWorkbenchPage, IFile)\n-   */\n-  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-    boolean retval = false;\n-\n-    if (source.getSignature() == null) return false;\n-\n-    retval = source.getSignature().equals(target.getSignature());\n-\n-    if (!retval && (this instanceof MoveMethodDetection)) {\n-      String sourceParent = extractParentSimpleName(source);\n-      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-      String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-      for (int i = 0; i < sourceTokens.length; i++) {\n-        sourceTokens[i] = sourceTokenizer.nextToken();\n-      }\n-\n-      for (int i = 0; i < targetTokens.length; i++) {\n-        targetTokens[i] = targetTokenizer.nextToken();\n-      }\n-\n-      if (targetTokens.length == sourceTokens.length + 1) {\n-        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n-        else {\n-          for (int i = 0; i < sourceTokens.length; i++) {\n-            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-          }\n-          retval = true;\n-        }\n-      }\n-    }\n-    return retval;\n-  }\n-\n-  /**\n-   * This helper method takes a string containing the dot separated name of a node and it returns\n-   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-   * class1)\n-   */\n-  protected String extractParentSimpleName(Node original) {\n-    String originalName = original.getFullyQualifiedName();\n-    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-    return parentName;\n-  }\n-\n-  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-    double count = 0;\n-\n-    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-    for (Edge edge1 : edges1) {\n-      Node node1 = edge1.getSource();\n-      for (int i = 0; i < arrEdge2.length; i++) {\n-        Edge edge2 = arrEdge2[i];\n-        if (edge2 != null) {\n-          Node node2 = (Node) edge2.getSource();\n-          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-            count++;\n-            // we mark this edge as already counted so that we don\'t\n-            // count it\n-            // twice when there are multiple edges between two nodes\n-            arrEdge2[i] = null;\n-          }\n-        }\n-      }\n-    }\n-\n-    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-    return (fraction1 + fraction2) / 2.0;\n-  }\n-\n-  protected boolean isTheSameModuloRename(String original, String version) {\n-    Dictionary<String, String> dictionary = getRenamingDictionary();\n-    if (version.equals(dictionary.get(original))) return true;\n-    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-      return original.equals(version);\n-    else if (original\n-        .substring(original.lastIndexOf("."))\n-        .equals(version.substring(version.lastIndexOf("."))))\n-      return isTheSameModuloRename(\n-          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-    else return false;\n-  }\n-\n-  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-    List<Node[]> prunedCandidates = new ArrayList<>();\n-    for (Node[] pair : candidates) {\n-      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-        if (pair[0].isAPI() && pair[1].isAPI()) {\n-          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-          if ((n2inV1 == null)) {\n-            prunedCandidates.add(pair);\n-          }\n-        }\n-      }\n-    }\n-    return prunedCandidates;\n-  }\n-\n-  // TODO this is bug pruned\n-  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-    //\t\ttry {\n-    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-    results.forEach(\n-        result -> {\n-          if (graph.hasNamedNode(result))\n-            graph.addEdge(\n-                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-        });\n-    // Possible change to methods that instantiate classes\n-    // from class -> class edges.\n-    //\t\t\tfor (String result : results) {\n-    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-    //\t\t\t\tString callingNode = null;\n-    //\t\t\t\tif (resultNode instanceof IMethod) {\n-    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-    //\t\t\t\t} else if (resultNode instanceof IType) {\n-    //\t\t\t\t\tIType rst = (IType) resultNode;\n-    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t} else if (resultNode instanceof IField) {\n-    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-    //\t\t\t\t\t// Workaround\n-    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += ".";\n-    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n-    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-    // ASTNodes\n-    //\t\t\t\t\t\t.getParent(initializer,\n-    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-    //\t\t\t\t\t\tIType.class);\n-    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-    //\t\t\t\t}\n-    //\n-    //\t\t\t\t// TODO treat the case when resultNode is instance of\n-    //\t\t\t\t// ImportDeclaration\n-    //\t\t\t\t// TODO treat the case when resultNode is instance of\n-    //\t\t\t\t// Initializer\n-    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-    //\t\t\t\t// Level\n-    //\t\t\t\tif (callingNode == null) {\n-    //\t\t\t\t\tSystem.out.print("");\n-    //\t\t\t\t}\n-    //\t\t\t\tif (callingNode != null) {\n-    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-    //\t\t\t\t\tif (callerNode != null)\n-    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-    //\t\t\t\t}\n-    //\n-    //\t\t\t}\n-    //\n-    //\t\t} catch (CoreException e) {\n-    //\t\t\tJavaPlugin.log(e);\n-    //\t\t}\n-  }\n+\t@Getter\n+\t@Setter\n+\tprivate double threshold;\n+\n+\tprotected NamedDirectedMultigraph graph1;\n+\n+\tprotected NamedDirectedMultigraph graph2;\n+\n+\tprivate double lowerThreshold;\n+\n+\t/**\n+\t * Dictionary contains <Original, Version> pairs for the renaming.\n+\t */\n+\tprivate static Dictionary<String, String> renamingDictionary;\n+\n+\tpublic static Dictionary<String, String> getRenamingDictionary() {\n+\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+\t\treturn renamingDictionary;\n+\t}\n+\n+\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tthis.graph1 = graph;\n+\t\tthis.graph2 = graph2;\n+\t}\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tpublic abstract boolean isRename();\n+\n+\t/**\n+\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+\t * computeLikeliness and pruneOriginalCandidates.\n+\t */\n+\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+\t\treturn pruneFalsePositives(listWithFP);\n+\t}\n+\n+\tprotected String extractPotentialRename(String parentClassOriginal) {\n+\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n+\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n+\t}\n+\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Node[] pair : prunedCandidates) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n+\t\t\t\t}\n+\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n+\t\t\t\t// detect those cases when two\n+\t\t\t\t// types of refactorings happened to the same node\n+\t\t\t}\n+\t\t}\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n+\t}\n+\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n+\t\t\tif (originalInV2 != null) {\n+\t\t\t\tcreateCallGraph(originalInV2, graph2);\n+\t\t\t\tList<Edge> origIncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+\t\t\t\tList<Edge> verIncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n+\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n+\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n+\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n+\t\t\t\tfor (Node node : verCallers) {\n+\t\t\t\t\tif (origInV2Callers.contains(node))\n+\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+\t\t\t\t// pair\n+\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n+\t\t\t\t// call sites\n+\t\t\t\t// should be different\n+\t\t\t\tfor (Node node : origInV1Callers) {\n+\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n+\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tlistWithFP.remove(pair);\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\n+\t\tpruneOverloadedMethodFP(listWithFP);\n+\n+\t\treturn listWithFP;\n+\t}\n+\n+\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<>();\n+\t\tfor (Edge edge : incomingEdges) {\n+\t\t\tcallers.add(edge.getSource());\n+\t\t}\n+\t\treturn callers;\n+\t}\n+\n+\t/**\n+\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+\t *\n+\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+\t * because of a method overload.\n+\t *\n+\t * <p>This method is never called in the ChangeMethodSignature detection.\n+\t */\n+\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n+\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n+\t\t\tboolean hasSameNameAndSignature = false;\n+\t\t\tNode[] pair = listWithFP.get(i);\n+\t\t\tNode source = pair[0];\n+\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (hasSameNameAndSignature) {\n+\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+\t\t\tlistWithFP.remove(pair);\n+\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This takes into account the possible renaming in the parent of the node\n+\t *\n+\t * @param g        is the Version2 graph\n+\t * @param original is a node from Version1\n+\t * @return\n+\t */\n+\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tString fqnParent = extractFullyQualifiedParentName(original);\n+\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n+\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+\t\tNode parentNode = g.findNamedNode(fqnParent);\n+\n+\t\tif (parentNode != null) {\n+\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+\t\t\t\tEdge edge = (Edge) iter.next();\n+\t\t\t\tNode child = (Node) edge.getTarget();\n+\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n+\t\t\t\t\tif (original.getSignature() != null) {\n+\t\t\t\t\t\t// This handles the method nodes\n+\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n+\t\t\t\t\t} else\n+\t\t\t\t\t\t// Classes and packages\n+\t\t\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (label.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tprotected String extractFullyQualifiedParentName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\treturn extractFullyQualifiedParentName(originalName);\n+\t}\n+\n+\tpublic String extractFullyQualifiedParentName(String originalName) {\n+\t\tString fq_parentName = "";\n+\t\tint lastIndex = originalName.lastIndexOf(".");\n+\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+\t\treturn fq_parentName;\n+\t}\n+\n+\t/**\n+\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+\t * IDE.openEditor(IWorkbenchPage, IFile)\n+\t */\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n+\n+\t\tif (source.getSignature() == null) return false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+\t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a node and it returns\n+\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+\t * class1)\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n+\t}\n+\n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n+\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original))) return true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original\n+\t\t\t.substring(original.lastIndexOf("."))\n+\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+\t\telse return false;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\t// TODO this is bug pruned\n+\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+\t\t//\t\ttry {\n+\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+\t\tresults.forEach(\n+\t\t\tresult -> {\n+\t\t\t\tif (graph.hasNamedNode(result))\n+\t\t\t\t\tgraph.addEdge(\n+\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n+\t\t\t});\n+\t\t// Possible change to methods that instantiate classes\n+\t\t// from class -> class edges.\n+\t\t//\t\t\tfor (String result : results) {\n+\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+\t\t//\t\t\t\tString callingNode = null;\n+\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n+\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n+\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n+\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n+\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+\t\t//\t\t\t\t\t// Workaround\n+\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += ".";\n+\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n+\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+\t\t// ASTNodes\n+\t\t//\t\t\t\t\t\t.getParent(initializer,\n+\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+\t\t//\t\t\t\t\t\tIType.class);\n+\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+\t\t//\t\t\t\t}\n+\t\t//\n+\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n+\t\t//\t\t\t\t// ImportDeclaration\n+\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n+\t\t//\t\t\t\t// Initializer\n+\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+\t\t//\t\t\t\t// Level\n+\t\t//\t\t\t\tif (callingNode == null) {\n+\t\t//\t\t\t\t\tSystem.out.print("");\n+\t\t//\t\t\t\t}\n+\t\t//\t\t\t\tif (callingNode != null) {\n+\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+\t\t//\t\t\t\t\tif (callerNode != null)\n+\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+\t\t//\t\t\t\t}\n+\t\t//\n+\t\t//\t\t\t}\n+\t\t//\n+\t\t//\t\t} catch (CoreException e) {\n+\t\t//\t\t\tJavaPlugin.log(e);\n+\t\t//\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n\t\t\t\t// pair\n\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n\t\t\t\t// call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n\t *\n\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n\t * because of a method overload.\n\t *\n\t * <p>This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null) return false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a node and it returns\n\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n\t * class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original))) return true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original\n\t\t\t.substring(original.lastIndexOf("."))\n\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n\t\telse return false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t// TODO this is bug pruned\n\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n\t\t//\t\ttry {\n\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n\t\tresults.forEach(\n\t\t\tresult -> {\n\t\t\t\tif (graph.hasNamedNode(result))\n\t\t\t\t\tgraph.addEdge(\n\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n\t\t\t});\n\t\t// Possible change to methods that instantiate classes\n\t\t// from class -> class edges.\n\t\t//\t\t\tfor (String result : results) {\n\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n\t\t//\t\t\t\tString callingNode = null;\n\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n\t\t//\t\t\t\t\t// Workaround\n\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += ".";\n\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n\t\t// ASTNodes\n\t\t//\t\t\t\t\t\t.getParent(initializer,\n\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n\t\t//\t\t\t\t\t\tIType.class);\n\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n\t\t//\t\t\t\t}\n\t\t//\n\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n\t\t//\t\t\t\t// ImportDeclaration\n\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n\t\t//\t\t\t\t// Initializer\n\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n\t\t//\t\t\t\t// Level\n\t\t//\t\t\t\tif (callingNode == null) {\n\t\t//\t\t\t\t\tSystem.out.print("");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tif (callingNode != null) {\n\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n\t\t//\t\t\t\t\tif (callerNode != null)\n\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n\t\t//\t\t\t\t}\n\t\t//\n\t\t//\t\t\t}\n\t\t//\n\t\t//\t\t} catch (CoreException e) {\n\t\t//\t\t\tJavaPlugin.log(e);\n\t\t//\t\t}\n\t}\n}\n'
          },
          {
            sha: "f09ca701b33f45cc7fde18db284114c3d50a6da8",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 54,
            deletions: 45,
            patch:
              "@@ -2,54 +2,63 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-import refactoring.crawler.graph.ClassNode;\n-import refactoring.crawler.graph.FieldNode;\n-import refactoring.crawler.graph.MethodNode;\n-import refactoring.crawler.graph.NamedDirectedMultigraph;\n+\n+import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n-  public static List<String> findFieldReferences(FieldNode node) {\n-    return node.getFieldReferenceToMethod();\n-  }\n+\tpublic static List<String> findFieldReferences(FieldNode node) {\n+\t\treturn node.getFieldReferenceToMethod();\n+\t}\n \n-  public static List<String> findSuperClassesOf(ClassNode node) {\n-    return node.getSuperClasses();\n-  }\n+\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n+\t\treturn node.getSuperClasses();\n+\t}\n \n-  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-    return node.getClassesImported();\n-  }\n+\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n+//    return node.getClassesImported();\n+\t\tList<String> res = new LinkedList<>();\n+\t\tfor (Node n : graph.vertexSet()) {\n+\t\t\tif (n.getType() == Node.Type.CLASS) {\n+\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n+\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn res;\n+\t}\n \n-  public static List<String> findMethodCallers(\n-      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-    return graph\n-        .vertexSet()\n-        .stream()\n-        .filter(n -> (n instanceof MethodNode))\n-        .map(methodNode -> (MethodNode) methodNode)\n-        .filter(\n-            methodNode ->\n-                methodNode\n-                    .getCalledInside()\n-                    .stream()\n-                    .anyMatch(\n-                        calledMethod -> {\n-                          String expect =\n-                              withSignature\n-                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n-                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n-                          String actual =\n-                              withSignature\n-                                  ? node.getFullyQualifiedName() + node.getSignature()\n-                                  : node.getFullyQualifiedName();\n-                          return expect.equals(actual);\n-                        }))\n-        .map(\n-            methodNode -> {\n-              return withSignature\n-                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-                  : methodNode.getFullyQualifiedName();\n-            })\n-        .collect(Collectors.toList());\n-  }\n+\tpublic static List<String> findMethodCallers(\n+\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+\t\treturn graph\n+\t\t\t.vertexSet()\n+\t\t\t.stream()\n+\t\t\t.filter(n -> (n instanceof MethodNode))\n+\t\t\t.map(methodNode -> (MethodNode) methodNode)\n+\t\t\t.filter(\n+\t\t\t\tmethodNode ->\n+\t\t\t\t\tmethodNode\n+\t\t\t\t\t\t.getCalledInside()\n+\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t.anyMatch(\n+\t\t\t\t\t\t\tcalledMethod -> {\n+\t\t\t\t\t\t\t\tString expect =\n+\t\t\t\t\t\t\t\t\twithSignature\n+\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n+\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n+\t\t\t\t\t\t\t\tString actual =\n+\t\t\t\t\t\t\t\t\twithSignature\n+\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n+\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n+\t\t\t\t\t\t\t\treturn expect.equals(actual);\n+\t\t\t\t\t\t\t}))\n+\t\t\t.map(\n+\t\t\t\tmethodNode -> {\n+\t\t\t\t\treturn withSignature\n+\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n+\t\t\t\t})\n+\t\t\t.collect(Collectors.toList());\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n\tpublic static List<String> findFieldReferences(FieldNode node) {\n\t\treturn node.getFieldReferenceToMethod();\n\t}\n\n\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n\t\treturn node.getSuperClasses();\n\t}\n\n\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n//    return node.getClassesImported();\n\t\tList<String> res = new LinkedList<>();\n\t\tfor (Node n : graph.vertexSet()) {\n\t\t\tif (n.getType() == Node.Type.CLASS) {\n\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static List<String> findMethodCallers(\n\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph\n\t\t\t.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(\n\t\t\t\tmethodNode ->\n\t\t\t\t\tmethodNode\n\t\t\t\t\t\t.getCalledInside()\n\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t.anyMatch(\n\t\t\t\t\t\t\tcalledMethod -> {\n\t\t\t\t\t\t\t\tString expect =\n\t\t\t\t\t\t\t\t\twithSignature\n\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\t\t\tString actual =\n\t\t\t\t\t\t\t\t\twithSignature\n\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n\t\t\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t\t\t}))\n\t\t\t.map(\n\t\t\t\tmethodNode -> {\n\t\t\t\t\treturn withSignature\n\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n\t\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n}\n"
          },
          {
            sha: "5526c7aeb020c013e422550ea546e1cc94a686f6",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 49,
            deletions: 48,
            patch:
              "@@ -2,58 +2,59 @@\n \n import java.util.ArrayList;\n import java.util.List;\n+\n import refactoring.crawler.graph.Edge;\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-    super(graph1, graph2);\n-  }\n-\n-  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n-  }\n-\n-  /**\n-   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-   * computeLikelinessIncomingEdges in RefactoringDetection\n-   *\n-   * @param nodeOriginal\n-   * @param nodeVersion\n-   * @return\n-   */\n-  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-    double edgeGrade;\n-    createCallGraph(nodeOriginal, nodeVersion);\n-    List<Edge> incomingEdgesOriginal =\n-        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-    List<Edge> incomingEdgesVersion =\n-        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-    return edgeGrade;\n-  }\n-\n-  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-    for (Node[] pair : prePruned) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      String parentPackageOriginal = extractParentSimpleName(original);\n-      String parentPackageVersion = extractParentSimpleName(version);\n-      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-        candidatesWithSameParentPackage.add(pair);\n-      }\n-    }\n-\n-    return candidatesWithSameParentPackage;\n-  }\n-\n-  @Override\n-  public boolean isRename() {\n-    return true;\n-  }\n+\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n+\t}\n+\n+\t/**\n+\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+\t * computeLikelinessIncomingEdges in RefactoringDetection\n+\t *\n+\t * @param nodeOriginal\n+\t * @param nodeVersion\n+\t * @return\n+\t */\n+\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal =\n+\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion =\n+\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+\t\tfor (Node[] pair : prePruned) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n+\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n+\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentPackage;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n\t}\n\n\t/**\n\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n\t * computeLikelinessIncomingEdges in RefactoringDetection\n\t *\n\t * @param nodeOriginal\n\t * @param nodeVersion\n\t * @return\n\t */\n\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal =\n\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion =\n\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n\t\tfor (Node[] pair : prePruned) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithSameParentPackage;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n}\n"
          },
          {
            sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -277,7 +277,7 @@ private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph gr\n       for (Node c : this.oldVersionClassList) {\n         if (!c.isAPI()) continue;\n \n-        for (Node c2 : this.oldVersionClassList) {\n+        for (Node c2 : this.newVersionClassList) {\n           if (!c2.isAPI()) continue;\n \n           if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {",
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "553efb98631d251ca093e8374d61cb29a646e846",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 191,
            deletions: 114,
            patch:
              '@@ -7,126 +7,203 @@\n \n import java.util.Dictionary;\n import java.util.Hashtable;\n+import java.util.LinkedList;\n import java.util.List;\n+\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n-\n-  @BeforeAll\n-  static void setUp() {\n-    settings = new Hashtable<>();\n-\n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-  }\n-\n-  @Test\n-  void testRenameMethod() {\n-    String source =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    String newVersion =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo12() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo12();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-    refactoringCrawler.detect(source, newVersion);\n-    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    assertEquals(1, categories.size());\n-    assertEquals("RenamedMethods", categories.get(0).getName());\n-    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n-    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n-    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n-  }\n-\n-  @Test\n-  void testChangeMethodSignature() {\n-    String source =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    String newVersion =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo(int i) {\\n"\n-            + "\\t\\tSystem.out.println(i);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo(1);\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-    refactoringCrawler.detect(source, newVersion);\n-    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    RefactoringCategory refactoringCategory = categories.get(0);\n-    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-    assertEquals(1, categories.size());\n-    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n-    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n-    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n-  }\n+\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+\t@BeforeAll\n+\tstatic void setUp() {\n+\t\tsettings = new Hashtable<>();\n+\n+\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+\t}\n+\n+\t@Test\n+\tvoid testRenameMethod() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo12() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(source, newVersion);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n+\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+\t}\n+\n+\t@Test\n+\tvoid testChangeMethodSignature() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(source, newVersion);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tRefactoringCategory refactoringCategory = categories.get(0);\n+\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n+\t}\n+\n+\t@Test\n+\tvoid testRenameClass() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\t\tString source2 = "/*\\n"\n+\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t+ " */\\n"\n+\t\t\t+ "package refactoring.a;\\n"\n+\t\t\t+ "import refactoring.crawler.Library;\\n"\n+\t\t\t+ "public class A {\\n"\n+\t\t\t+ "private Library library = new Library();\\n"\n+\t\t\t+ "}\\n";\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library123 {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\t\tString newVersion2 = "/*\\n"\n+\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t+ " */\\n"\n+\t\t\t+ "package refactoring.a;\\n"\n+\t\t\t+ "import refactoring.crawler.Library123;\\n"\n+\t\t\t+ "public class A {\\n"\n+\t\t\t+ "private Library library = new Library();\\n"\n+\t\t\t+ "}\\n";\n+\n+\t\tList<String> originals = new LinkedList<>();\n+\t\tList<String> newVersions = new LinkedList<>();\n+\n+\t\toriginals.add(source);\n+\t\toriginals.add(source2);\n+\n+\t\tnewVersions.add(newVersion);\n+\t\tnewVersions.add(newVersion2);\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(originals, newVersions);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tRefactoringCategory refactoringCategory = categories.get(0);\n+\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n+\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+\t}\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n\t@BeforeAll\n\tstatic void setUp() {\n\t\tsettings = new Hashtable<>();\n\n\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\t}\n\n\t@Test\n\tvoid testRenameMethod() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo12() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(source, newVersion);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n\t}\n\n\t@Test\n\tvoid testChangeMethodSignature() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(source, newVersion);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tRefactoringCategory refactoringCategory = categories.get(0);\n\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n\t}\n\n\t@Test\n\tvoid testRenameClass() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\t\tString source2 = "/*\\n"\n\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t+ " */\\n"\n\t\t\t+ "package refactoring.a;\\n"\n\t\t\t+ "import refactoring.crawler.Library;\\n"\n\t\t\t+ "public class A {\\n"\n\t\t\t+ "private Library library = new Library();\\n"\n\t\t\t+ "}\\n";\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library123 {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\t\tString newVersion2 = "/*\\n"\n\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t+ " */\\n"\n\t\t\t+ "package refactoring.a;\\n"\n\t\t\t+ "import refactoring.crawler.Library123;\\n"\n\t\t\t+ "public class A {\\n"\n\t\t\t+ "private Library library = new Library();\\n"\n\t\t\t+ "}\\n";\n\n\t\tList<String> originals = new LinkedList<>();\n\t\tList<String> newVersions = new LinkedList<>();\n\n\t\toriginals.add(source);\n\t\toriginals.add(source2);\n\n\t\tnewVersions.add(newVersion);\n\t\tnewVersions.add(newVersion2);\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(originals, newVersions);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tRefactoringCategory refactoringCategory = categories.get(0);\n\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "fed214ccff862674ed63f5dd5f017cda31b6ef80",
        message: "chore(*): add jacoco for coverage",
        stats: {
          total: 38,
          additions: 36,
          deletions: 2
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a"
          }
        ],
        committedAt: 1585458591000,
        changedFiles: [
          {
            sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
            filename: "build.gradle",
            status: "modified",
            additions: 36,
            deletions: 2,
            patch:
              "@@ -5,11 +5,46 @@\n  * For more details take a look at the Java Libraries chapter in the Gradle\n  * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n  */\n-\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n     id 'com.github.sherter.google-java-format' version '0.8'\n+    id 'jacoco'\n+}\n+\n+jacoco {\n+    toolVersion = \"0.8.5\"\n+    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n+}\n+\n+jacocoTestReport {\n+    reports {\n+        xml.enabled false\n+        csv.enabled false\n+        html.destination file(\"${buildDir}/jacocoHtml\")\n+    }\n+}\n+\n+jacocoTestCoverageVerification {\n+    violationRules {\n+        rule {\n+            limit {\n+                minimum = 0.5\n+            }\n+        }\n+\n+        rule {\n+            enabled = false\n+            element = 'CLASS'\n+            includes = ['org.gradle.*']\n+\n+            limit {\n+                counter = 'LINE'\n+                value = 'TOTALCOUNT'\n+                maximum = 0.3\n+            }\n+        }\n+    }\n }\n \n repositories {\n@@ -47,7 +82,6 @@ dependencies {\n     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n     implementation 'org.jetbrains:annotations:15.0'\n }\n-\n test {\n     // Use junit platform for unit tests\n     useJUnitPlatform()",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          }
        ]
      },
      {
        sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a",
        message:
          "Merge pull request #1 from PatrickLai7528/circleci-project-setup\n\nAdd .circleci/config.yml",
        stats: {
          total: 42,
          additions: 42,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4"
          },
          {
            sha: "2a8ff280c4626e929dec89adc0992be9af6c2c55"
          }
        ],
        committedAt: 1585234852000,
        changedFiles: [
          {
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            filename: ".circleci/config.yml",
            status: "added",
            additions: 42,
            deletions: 0,
            patch:
              '@@ -0,0 +1,42 @@\n+# Java Gradle CircleCI 2.0 configuration file\n+#\n+# Check https://circleci.com/docs/2.0/language-java/ for more details\n+#\n+version: 2\n+jobs:\n+  build:\n+    docker:\n+      # specify the version you desire here\n+      - image: circleci/openjdk:8-jdk\n+\n+      # Specify service dependencies here if necessary\n+      # CircleCI maintains a library of pre-built images\n+      # documented at https://circleci.com/docs/2.0/circleci-images/\n+      # - image: circleci/postgres:9.4\n+\n+    working_directory: ~/repo\n+\n+    environment:\n+      # Customize the JVM maximum heap limit\n+      JVM_OPTS: -Xmx3200m\n+      TERM: dumb\n+\n+    steps:\n+      - checkout\n+\n+      # Download and cache dependencies\n+      - restore_cache:\n+          keys:\n+            - v1-dependencies-{{ checksum "build.gradle" }}\n+            # fallback to using the latest cache if no exact match is found\n+            - v1-dependencies-\n+\n+      - run: gradle dependencies\n+\n+      - save_cache:\n+          paths:\n+            - ~/.gradle\n+          key: v1-dependencies-{{ checksum "build.gradle" }}\n+\n+      # run tests!\n+      - run: gradle test\n\\ No newline at end of file',
            rawContent:
              '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test'
          }
        ]
      },
      {
        sha: "2a8ff280c4626e929dec89adc0992be9af6c2c55",
        message: "Add .circleci/config.yml",
        stats: {
          total: 42,
          additions: 42,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4"
          }
        ],
        committedAt: 1585234706000,
        changedFiles: [
          {
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            filename: ".circleci/config.yml",
            status: "added",
            additions: 42,
            deletions: 0,
            patch:
              '@@ -0,0 +1,42 @@\n+# Java Gradle CircleCI 2.0 configuration file\n+#\n+# Check https://circleci.com/docs/2.0/language-java/ for more details\n+#\n+version: 2\n+jobs:\n+  build:\n+    docker:\n+      # specify the version you desire here\n+      - image: circleci/openjdk:8-jdk\n+\n+      # Specify service dependencies here if necessary\n+      # CircleCI maintains a library of pre-built images\n+      # documented at https://circleci.com/docs/2.0/circleci-images/\n+      # - image: circleci/postgres:9.4\n+\n+    working_directory: ~/repo\n+\n+    environment:\n+      # Customize the JVM maximum heap limit\n+      JVM_OPTS: -Xmx3200m\n+      TERM: dumb\n+\n+    steps:\n+      - checkout\n+\n+      # Download and cache dependencies\n+      - restore_cache:\n+          keys:\n+            - v1-dependencies-{{ checksum "build.gradle" }}\n+            # fallback to using the latest cache if no exact match is found\n+            - v1-dependencies-\n+\n+      - run: gradle dependencies\n+\n+      - save_cache:\n+          paths:\n+            - ~/.gradle\n+          key: v1-dependencies-{{ checksum "build.gradle" }}\n+\n+      # run tests!\n+      - run: gradle test\n\\ No newline at end of file',
            rawContent:
              '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test'
          }
        ]
      },
      {
        sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4",
        message: "Create README.md",
        stats: {
          total: 2,
          additions: 2,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "60611e9d306af2245db7837ec774c40ad294bb7b"
          }
        ],
        committedAt: 1585224669000,
        changedFiles: [
          {
            sha: "b34fbf6028059b5e0f654d1d1645aef6f2400c75",
            filename: "README.md",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# refactoring-crawler\n+Java tool for detecting refactor",
            rawContent:
              "# refactoring-crawler\nJava tool for detecting refactor\n"
          }
        ]
      },
      {
        sha: "60611e9d306af2245db7837ec774c40ad294bb7b",
        message: "test(*): test rename method, change method signature",
        stats: {
          total: 65,
          additions: 60,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ae654f2173cfa166b3d03a9663357095ad227969"
          }
        ],
        committedAt: 1585224530000,
        changedFiles: [
          {
            sha: "f01bbc1df8c35dbe9a882751728487b090a1ad25",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 60,
            deletions: 5,
            patch:
              '@@ -3,19 +3,20 @@\n  */\n package refactoring.crawler;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n import java.util.Dictionary;\n import java.util.Hashtable;\n import java.util.List;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n+import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n   private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n \n-  private static RefactoringCrawler refactoringCrawler;\n-\n   @BeforeAll\n   static void setUp() {\n     settings = new Hashtable<>();\n@@ -26,8 +27,6 @@ static void setUp() {\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-\n-    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n   }\n \n   @Test\n@@ -70,8 +69,64 @@ void testRenameMethod() {\n             + "\\t}\\n"\n             + "}\\n";\n \n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedMethods", categories.get(0).getName());\n+    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+  }\n+\n+  @Test\n+  void testChangeMethodSignature() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo(int i) {\\n"\n+            + "\\t\\tSystem.out.println(i);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo(1);\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n     refactoringCrawler.detect(source, newVersion);\n     List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    System.out.println(categories);\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n   }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n}\n'
          }
        ]
      },
      {
        sha: "ae654f2173cfa166b3d03a9663357095ad227969",
        message: "format(*): format all code",
        stats: {
          total: 5208,
          additions: 2596,
          deletions: 2612
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "f38d6d29251fbdacab8f8a7a8390339bd60e65f2"
          }
        ],
        committedAt: 1585222642000,
        changedFiles: [
          {
            sha: "c344d7ed7a76b5681a9bfc5ca07fe5e1940bf67e",
            filename: "build.gradle",
            status: "modified",
            additions: 1,
            deletions: 17,
            patch:
              '@@ -9,25 +9,9 @@\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id \'java-library\'\n-    id "com.diffplug.gradle.spotless" version "3.16.0"\n+    id \'com.github.sherter.google-java-format\' version \'0.8\'\n }\n \n-sourceCompatibility = 1.8\n-\n-spotless {\n-    java {\n-        googleJavaFormat()\n-        indentWithTabs(2)\n-        indentWithSpaces(4)\n-    }\n-}\n-\n-def hook = new File("$rootProject.projectDir/.git/hooks/pre-commit")\n-hook.text = """#!/bin/bash\n-echo "will run nova code format"\n-./gradlew spotlessApply\n-"""\n-\n repositories {\n     // Use jcenter for resolving dependencies.\n     // You can declare any Maven/Ivy/file repository here.',
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "b2f029504a118dbd1bc75b63bec2d151004ae6ee",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 177,
            deletions: 177,
            patch:
              '@@ -17,188 +17,188 @@\n \n public class RefactoringCrawler {\n \n-    public static enum Settings {\n-        T_RENAME_METHOD,\n-        T_RENAME_CLASS,\n-        T_MOVE_METHOD,\n-        T_PULL_UP_METHOD,\n-        T_PUSH_DOWN_METHOD,\n-        T_CHANGE_METHOD_SIGNATURE\n+  public static enum Settings {\n+    T_RENAME_METHOD,\n+    T_RENAME_CLASS,\n+    T_MOVE_METHOD,\n+    T_PULL_UP_METHOD,\n+    T_PUSH_DOWN_METHOD,\n+    T_CHANGE_METHOD_SIGNATURE\n+  }\n+\n+  private String projectName;\n+  private Dictionary<Settings, Double> settings;\n+\n+  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n+\n+  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n+    this.projectName = projectName;\n+    this.settings = settings;\n+  }\n+\n+  private static List<CompilationUnit> parse(List<String> files) {\n+    TypeSolver typeSolver = new ReflectionTypeSolver();\n+    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n+    List<CompilationUnit> resList = new LinkedList<>();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      resList.add(cu);\n     }\n-\n-    private String projectName;\n-    private Dictionary<Settings, Double> settings;\n-\n-    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n-\n-    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n-        this.projectName = projectName;\n-        this.settings = settings;\n-    }\n-\n-    private static List<CompilationUnit> parse(List<String> files) {\n-        TypeSolver typeSolver = new ReflectionTypeSolver();\n-        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n-        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n-\n-        List<CompilationUnit> resList = new LinkedList<>();\n-        for (String source : files) {\n-            CompilationUnit cu = StaticJavaParser.parse(source);\n-            resList.add(cu);\n-        }\n-        return resList;\n-    }\n-\n-    public void detect(String oldVersion, String newVersion) {\n-        List<String> oldVersionList = new LinkedList<>();\n-        List<String> newVersionList = new LinkedList<>();\n-\n-        oldVersionList.add(oldVersion);\n-        newVersionList.add(newVersion);\n-\n-        this.detect(oldVersionList, newVersionList);\n-    }\n-\n-    public void detect(List<String> oldVersion, List<String> newVersion) {\n-        ShinglesUtil shinglesUtil = new ShinglesUtil();\n-\n-        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n-        List<CompilationUnit> newVersionCU = parse(newVersion);\n-        SourceNavigator navigator = new SourceNavigator();\n-        navigator.setShinglesUtil(shinglesUtil);\n-        navigator.browseProject(projectName, oldVersionCU);\n-        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n-\n-        SourceNavigator navigatorForVersion = new SourceNavigator();\n-        navigatorForVersion.setShinglesUtil(shinglesUtil);\n-        navigatorForVersion.browseProject(projectName, newVersionCU);\n-        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n-\n-        shinglesUtil.initialize(originalGraph, versionGraph);\n-\n-        // must in this order\n-\n-        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n-        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n-        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n-        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n-        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n-        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n-        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+    return resList;\n+  }\n+\n+  public void detect(String oldVersion, String newVersion) {\n+    List<String> oldVersionList = new LinkedList<>();\n+    List<String> newVersionList = new LinkedList<>();\n+\n+    oldVersionList.add(oldVersion);\n+    newVersionList.add(newVersion);\n+\n+    this.detect(oldVersionList, newVersionList);\n+  }\n+\n+  public void detect(List<String> oldVersion, List<String> newVersion) {\n+    ShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n+    List<CompilationUnit> newVersionCU = parse(newVersion);\n+    SourceNavigator navigator = new SourceNavigator();\n+    navigator.setShinglesUtil(shinglesUtil);\n+    navigator.browseProject(projectName, oldVersionCU);\n+    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+    SourceNavigator navigatorForVersion = new SourceNavigator();\n+    navigatorForVersion.setShinglesUtil(shinglesUtil);\n+    navigatorForVersion.browseProject(projectName, newVersionCU);\n+    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+    shinglesUtil.initialize(originalGraph, versionGraph);\n+\n+    // must in this order\n+\n+    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+  }\n+\n+  private void detectChangeMethodSignature(\n+      double tChangeMethodSignature,\n+      ShinglesUtil shinglesUtil,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tChangeMethodSignature);\n+    List<Node[]> changedMethodSignatures =\n+        detector.detectRefactorings(candidateChangedMethodSignatures);\n+    if (changedMethodSignatures.size() > 0) {\n+      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+      changeSignatureCategory.setName("ChangedMethodSignatures");\n+      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+      this.refactoringCategories.add(changeSignatureCategory);\n     }\n-\n-    private void detectChangeMethodSignature(\n-            double tChangeMethodSignature,\n-            ShinglesUtil shinglesUtil,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tChangeMethodSignature);\n-        List<Node[]> changedMethodSignatures =\n-                detector.detectRefactorings(candidateChangedMethodSignatures);\n-        if (changedMethodSignatures.size() > 0) {\n-            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-            changeSignatureCategory.setName("ChangedMethodSignatures");\n-            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n-            this.refactoringCategories.add(changeSignatureCategory);\n-        }\n+  }\n+\n+  private void detectRenameMethod(\n+      double tMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph oldVersionGraph,\n+      NamedDirectedMultigraph newVersionGraph) {\n+    List<Node[]> candidateMethods = se.findSimilarMethods();\n+    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+    detector.setThreshold(tMethod);\n+\n+    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+    if (renamedMethods.size() > 0) {\n+      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+      renameMethodCategory.setName("RenamedMethods");\n+      renameMethodCategory.setRefactoringPairs(renamedMethods);\n+      this.refactoringCategories.add(renameMethodCategory);\n     }\n-\n-    private void detectRenameMethod(\n-            double tMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph oldVersionGraph,\n-            NamedDirectedMultigraph newVersionGraph) {\n-        List<Node[]> candidateMethods = se.findSimilarMethods();\n-        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-        detector.setThreshold(tMethod);\n-\n-        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n-        if (renamedMethods.size() > 0) {\n-            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n-            renameMethodCategory.setName("RenamedMethods");\n-            renameMethodCategory.setRefactoringPairs(renamedMethods);\n-            this.refactoringCategories.add(renameMethodCategory);\n-        }\n+  }\n+\n+  public void detectRenameClass(\n+      double tClass,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidateClasses = se.findSimilarClasses();\n+    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tClass);\n+    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+    if (renamedClasses.size() > 0) {\n+      RefactoringCategory renameClassCategory = new RefactoringCategory();\n+      renameClassCategory.setName("RenamedClasses");\n+      renameClassCategory.setRefactoringPairs(renamedClasses);\n+      this.refactoringCategories.add(renameClassCategory);\n     }\n-\n-    public void detectRenameClass(\n-            double tClass,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidateClasses = se.findSimilarClasses();\n-        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tClass);\n-        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n-        if (renamedClasses.size() > 0) {\n-            RefactoringCategory renameClassCategory = new RefactoringCategory();\n-            renameClassCategory.setName("RenamedClasses");\n-            renameClassCategory.setRefactoringPairs(renamedClasses);\n-            this.refactoringCategories.add(renameClassCategory);\n-        }\n+  }\n+\n+  public void detectMoveMethod(\n+      double tMoveMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> methodCandidates = se.findSimilarMethods();\n+    se.findSimilarClasses();\n+    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+    detector.setThreshold(tMoveMethod);\n+    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+    if (movedMethods.size() > 0) {\n+      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n+      moveMethodCategory.setName("MovedMethods");\n+      moveMethodCategory.setRefactoringPairs(movedMethods);\n+      this.refactoringCategories.add(moveMethodCategory);\n     }\n-\n-    public void detectMoveMethod(\n-            double tMoveMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> methodCandidates = se.findSimilarMethods();\n-        se.findSimilarClasses();\n-        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n-        detector.setThreshold(tMoveMethod);\n-        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n-        if (movedMethods.size() > 0) {\n-            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n-            moveMethodCategory.setName("MovedMethods");\n-            moveMethodCategory.setRefactoringPairs(movedMethods);\n-            this.refactoringCategories.add(moveMethodCategory);\n-        }\n+  }\n+\n+  public void detectPullUpMethod(\n+      double tPullUpMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tPullUpMethod);\n+    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+    if (pullUpMethodResults.size() > 0) {\n+      RefactoringCategory pullUpCategory = new RefactoringCategory();\n+      pullUpCategory.setName("PulledUpMethods");\n+      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+      this.refactoringCategories.add(pullUpCategory);\n     }\n-\n-    public void detectPullUpMethod(\n-            double tPullUpMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n-        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tPullUpMethod);\n-        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n-        if (pullUpMethodResults.size() > 0) {\n-            RefactoringCategory pullUpCategory = new RefactoringCategory();\n-            pullUpCategory.setName("PulledUpMethods");\n-            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n-            this.refactoringCategories.add(pullUpCategory);\n-        }\n-    }\n-\n-    public void detectPushDownMethod(\n-            double tPushDownMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n-        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tPushDownMethod);\n-        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n-        if (pushDownMethodResults.size() > 0) {\n-            RefactoringCategory pushDownCategory = new RefactoringCategory();\n-            pushDownCategory.setName("PushedDownMethods");\n-            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n-            this.refactoringCategories.add(pushDownCategory);\n-        }\n+  }\n+\n+  public void detectPushDownMethod(\n+      double tPushDownMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tPushDownMethod);\n+    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+    if (pushDownMethodResults.size() > 0) {\n+      RefactoringCategory pushDownCategory = new RefactoringCategory();\n+      pushDownCategory.setName("PushedDownMethods");\n+      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+      this.refactoringCategories.add(pushDownCategory);\n     }\n+  }\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          },
          {
            sha: "5218fee4bcbf9d8299259e5f503c3c584b100aae",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 374,
            deletions: 374,
            patch:
              '@@ -11,416 +11,416 @@\n \n public abstract class RefactoringDetection {\n \n-    @Getter @Setter private double threshold;\n+  @Getter @Setter private double threshold;\n \n-    protected NamedDirectedMultigraph graph1;\n+  protected NamedDirectedMultigraph graph1;\n \n-    protected NamedDirectedMultigraph graph2;\n+  protected NamedDirectedMultigraph graph2;\n \n-    private double lowerThreshold;\n+  private double lowerThreshold;\n \n-    /** Dictionary contains <Original, Version> pairs for the renaming. */\n-    private static Dictionary<String, String> renamingDictionary;\n+  /** Dictionary contains <Original, Version> pairs for the renaming. */\n+  private static Dictionary<String, String> renamingDictionary;\n \n-    public static Dictionary<String, String> getRenamingDictionary() {\n-        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-        return renamingDictionary;\n-    }\n+  public static Dictionary<String, String> getRenamingDictionary() {\n+    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+    return renamingDictionary;\n+  }\n \n-    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        this.graph1 = graph;\n-        this.graph2 = graph2;\n-    }\n+  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    this.graph1 = graph;\n+    this.graph2 = graph2;\n+  }\n \n-    public abstract double computeLikeliness(Node node1, Node node12);\n+  public abstract double computeLikeliness(Node node1, Node node12);\n \n-    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n \n-    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n \n-    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n \n-    public abstract boolean isRename();\n+  public abstract boolean isRename();\n \n-    /**\n-    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-    * computeLikeliness and pruneOriginalCandidates.\n-    */\n-    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+  /**\n+   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+   * computeLikeliness and pruneOriginalCandidates.\n+   */\n+  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-        return pruneFalsePositives(listWithFP);\n-    }\n+    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+    return pruneFalsePositives(listWithFP);\n+  }\n \n-    protected String extractPotentialRename(String parentClassOriginal) {\n-        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n-        return renamedName == null ? parentClassOriginal : renamedName;\n-    }\n+  protected String extractPotentialRename(String parentClassOriginal) {\n+    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+    return renamedName == null ? parentClassOriginal : renamedName;\n+  }\n \n-    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-        boolean foundNewRefactoring = false;\n-        for (Node[] pair : prunedCandidates) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            double likeliness = computeLikeliness(original, version);\n-            if (likeliness >= threshold) {\n-                if (!refactoredNodes.contains(pair)) {\n-                    refactoredNodes.add(pair);\n-                    foundNewRefactoring = true;\n-                }\n-                // candidates.remove(pair); acivating this line would fail to\n-                // detect those cases when two\n-                // types of refactorings happened to the same node\n-            }\n-        }\n-        if (foundNewRefactoring) {\n-            doDetectRefactorings(candidates, refactoredNodes);\n+  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+    boolean foundNewRefactoring = false;\n+    for (Node[] pair : prunedCandidates) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      double likeliness = computeLikeliness(original, version);\n+      if (likeliness >= threshold) {\n+        if (!refactoredNodes.contains(pair)) {\n+          refactoredNodes.add(pair);\n+          foundNewRefactoring = true;\n         }\n-        return refactoredNodes;\n+        // candidates.remove(pair); acivating this line would fail to\n+        // detect those cases when two\n+        // types of refactorings happened to the same node\n+      }\n     }\n-\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-        for (Node[] pair : listWithFP) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-            if (originalInV2 != null) {\n-                createCallGraph(originalInV2, graph2);\n-                List<Edge> origIncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-                List<Edge> verIncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-                List<Edge> origInVer1IncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-                List<Node> verCallers = getCallers(verIncomingEdges);\n-                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-                // since a call site cannot be calling both the old and the new entity at the same time\n-                for (Node node : verCallers) {\n-                    if (origInV2Callers.contains(node))\n-                        if (!nodesToRemove.contains(pair)) {\n-                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-                            nodesToRemove.add(pair);\n-                        }\n-                }\n-\n-                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-                // pair\n-                // is a false positive (since there should be either no more callers for N1inV2 or their\n-                // call sites\n-                // should be different\n-                for (Node node : origInV1Callers) {\n-                    for (Node callingNode : origInV2Callers) {\n-                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-                            if (!nodesToRemove.contains(pair)) {\n-                                nodesToRemove.add(pair);\n-                            }\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            listWithFP.remove(pair);\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-\n-        pruneOverloadedMethodFP(listWithFP);\n-\n-        return listWithFP;\n+    if (foundNewRefactoring) {\n+      doDetectRefactorings(candidates, refactoredNodes);\n     }\n-\n-    private List<Node> getCallers(List<Edge> incomingEdges) {\n-        List<Node> callers = new ArrayList<>();\n-        for (Edge edge : incomingEdges) {\n-            callers.add(edge.getSource());\n-        }\n-        return callers;\n-    }\n-\n-    /**\n-    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-    *\n-    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-    * because of a method overload.\n-    *\n-    * <p>This method is never called in the ChangeMethodSignature detection.\n-    */\n-    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<>();\n-        for (int i = 0; i < listWithFP.size(); i++) {\n-            boolean hasSameNameAndSignature = false;\n-            Node[] pair = listWithFP.get(i);\n-            Node source = pair[0];\n-            for (int j = i; j < listWithFP.size(); j++) {\n-                Node[] pair2 = listWithFP.get(j);\n-                Node source2 = pair2[0];\n-                if (source.equals(source2)) {\n-                    Node target2 = pair2[1];\n-                    if (source.getSimpleName().equals(target2.getSimpleName()))\n-                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-                }\n+    return refactoredNodes;\n+  }\n+\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+    for (Node[] pair : listWithFP) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+      if (originalInV2 != null) {\n+        createCallGraph(originalInV2, graph2);\n+        List<Edge> origIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+        List<Edge> verIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        List<Edge> origInVer1IncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+        List<Node> verCallers = getCallers(verIncomingEdges);\n+        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+        // since a call site cannot be calling both the old and the new entity at the same time\n+        for (Node node : verCallers) {\n+          if (origInV2Callers.contains(node))\n+            if (!nodesToRemove.contains(pair)) {\n+              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              nodesToRemove.add(pair);\n             }\n-            if (hasSameNameAndSignature) {\n-                for (int j = i; j < listWithFP.size(); j++) {\n-                    Node[] pair2 = listWithFP.get(j);\n-                    Node source2 = pair2[0];\n-                    if (source.equals(source2)) {\n-                        Node target2 = pair2[1];\n-                        if (source.getSimpleName().equals(target2.getSimpleName()))\n-                            if (!signatureEqualsModuloMoveMethod(source, target2))\n-                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-            listWithFP.remove(pair);\n-\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n         }\n-    }\n \n-    /**\n-    * This takes into account the possible renaming in the parent of the node\n-    *\n-    * @param g is the Version2 graph\n-    * @param original is a node from Version1\n-    * @return\n-    */\n-    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        String fqnParent = extractFullyQualifiedParentName(original);\n-        String possiblyRenamedFQN = dictionary.get(fqnParent);\n-        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-        Node parentNode = g.findNamedNode(fqnParent);\n-\n-        if (parentNode != null) {\n-            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-                Edge edge = (Edge) iter.next();\n-                Node child = (Node) edge.getTarget();\n-                if (original.getSimpleName().equals(child.getSimpleName()))\n-                    if (original.getSignature() != null) {\n-                        // This handles the method nodes\n-                        if (original.getSignature().equals(child.getSignature())) return child;\n-                    } else\n-                        // Classes and packages\n-                        return child;\n+        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+        // pair\n+        // is a false positive (since there should be either no more callers for N1inV2 or their\n+        // call sites\n+        // should be different\n+        for (Node node : origInV1Callers) {\n+          for (Node callingNode : origInV2Callers) {\n+            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+              if (!nodesToRemove.contains(pair)) {\n+                nodesToRemove.add(pair);\n+              }\n+              break;\n             }\n+          }\n         }\n-        return null;\n+      }\n     }\n-\n-    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge edge : list) {\n-            if (label.equals(edge.getLabel())) {\n-                results.add(edge);\n-            }\n-        }\n-        return results;\n+    for (Node[] pair : nodesToRemove) {\n+      listWithFP.remove(pair);\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n     }\n \n-    protected String extractFullyQualifiedParentName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        return extractFullyQualifiedParentName(originalName);\n-    }\n+    pruneOverloadedMethodFP(listWithFP);\n \n-    public String extractFullyQualifiedParentName(String originalName) {\n-        String fq_parentName = "";\n-        int lastIndex = originalName.lastIndexOf(".");\n-        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-        return fq_parentName;\n-    }\n+    return listWithFP;\n+  }\n \n-    /**\n-    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-    * IDE.openEditor(IWorkbenchPage, IFile)\n-    */\n-    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-        boolean retval = false;\n-\n-        if (source.getSignature() == null) return false;\n-\n-        retval = source.getSignature().equals(target.getSignature());\n-\n-        if (!retval && (this instanceof MoveMethodDetection)) {\n-            String sourceParent = extractParentSimpleName(source);\n-            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-            String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-            for (int i = 0; i < sourceTokens.length; i++) {\n-                sourceTokens[i] = sourceTokenizer.nextToken();\n-            }\n-\n-            for (int i = 0; i < targetTokens.length; i++) {\n-                targetTokens[i] = targetTokenizer.nextToken();\n-            }\n-\n-            if (targetTokens.length == sourceTokens.length + 1) {\n-                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n-                else {\n-                    for (int i = 0; i < sourceTokens.length; i++) {\n-                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-                    }\n-                    retval = true;\n-                }\n-            }\n+  private List<Node> getCallers(List<Edge> incomingEdges) {\n+    List<Node> callers = new ArrayList<>();\n+    for (Edge edge : incomingEdges) {\n+      callers.add(edge.getSource());\n+    }\n+    return callers;\n+  }\n+\n+  /**\n+   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+   *\n+   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+   * because of a method overload.\n+   *\n+   * <p>This method is never called in the ChangeMethodSignature detection.\n+   */\n+  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<>();\n+    for (int i = 0; i < listWithFP.size(); i++) {\n+      boolean hasSameNameAndSignature = false;\n+      Node[] pair = listWithFP.get(i);\n+      Node source = pair[0];\n+      for (int j = i; j < listWithFP.size(); j++) {\n+        Node[] pair2 = listWithFP.get(j);\n+        Node source2 = pair2[0];\n+        if (source.equals(source2)) {\n+          Node target2 = pair2[1];\n+          if (source.getSimpleName().equals(target2.getSimpleName()))\n+            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+        }\n+      }\n+      if (hasSameNameAndSignature) {\n+        for (int j = i; j < listWithFP.size(); j++) {\n+          Node[] pair2 = listWithFP.get(j);\n+          Node source2 = pair2[0];\n+          if (source.equals(source2)) {\n+            Node target2 = pair2[1];\n+            if (source.getSimpleName().equals(target2.getSimpleName()))\n+              if (!signatureEqualsModuloMoveMethod(source, target2))\n+                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+          }\n         }\n-        return retval;\n+      }\n     }\n+    for (Node[] pair : nodesToRemove) {\n+      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+      listWithFP.remove(pair);\n \n-    /**\n-    * This helper method takes a string containing the dot separated name of a node and it returns\n-    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-    * class1)\n-    */\n-    protected String extractParentSimpleName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-        return parentName;\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n     }\n-\n-    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-        double count = 0;\n-\n-        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-        for (Edge edge1 : edges1) {\n-            Node node1 = edge1.getSource();\n-            for (int i = 0; i < arrEdge2.length; i++) {\n-                Edge edge2 = arrEdge2[i];\n-                if (edge2 != null) {\n-                    Node node2 = (Node) edge2.getSource();\n-                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-                        count++;\n-                        // we mark this edge as already counted so that we don\'t\n-                        // count it\n-                        // twice when there are multiple edges between two nodes\n-                        arrEdge2[i] = null;\n-                    }\n-                }\n-            }\n-        }\n-\n-        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-        return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  /**\n+   * This takes into account the possible renaming in the parent of the node\n+   *\n+   * @param g is the Version2 graph\n+   * @param original is a node from Version1\n+   * @return\n+   */\n+  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    String fqnParent = extractFullyQualifiedParentName(original);\n+    String possiblyRenamedFQN = dictionary.get(fqnParent);\n+    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+    Node parentNode = g.findNamedNode(fqnParent);\n+\n+    if (parentNode != null) {\n+      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+        Edge edge = (Edge) iter.next();\n+        Node child = (Node) edge.getTarget();\n+        if (original.getSimpleName().equals(child.getSimpleName()))\n+          if (original.getSignature() != null) {\n+            // This handles the method nodes\n+            if (original.getSignature().equals(child.getSignature())) return child;\n+          } else\n+            // Classes and packages\n+            return child;\n+      }\n     }\n-\n-    protected boolean isTheSameModuloRename(String original, String version) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        if (version.equals(dictionary.get(original))) return true;\n-        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-            return original.equals(version);\n-        else if (original\n-                .substring(original.lastIndexOf("."))\n-                .equals(version.substring(version.lastIndexOf("."))))\n-            return isTheSameModuloRename(\n-                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-        else return false;\n+    return null;\n+  }\n+\n+  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge edge : list) {\n+      if (label.equals(edge.getLabel())) {\n+        results.add(edge);\n+      }\n     }\n-\n-    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-                if (pair[0].isAPI() && pair[1].isAPI()) {\n-                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-                    if ((n2inV1 == null)) {\n-                        prunedCandidates.add(pair);\n-                    }\n-                }\n-            }\n+    return results;\n+  }\n+\n+  protected String extractFullyQualifiedParentName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    return extractFullyQualifiedParentName(originalName);\n+  }\n+\n+  public String extractFullyQualifiedParentName(String originalName) {\n+    String fq_parentName = "";\n+    int lastIndex = originalName.lastIndexOf(".");\n+    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+    return fq_parentName;\n+  }\n+\n+  /**\n+   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+   * IDE.openEditor(IWorkbenchPage, IFile)\n+   */\n+  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+    boolean retval = false;\n+\n+    if (source.getSignature() == null) return false;\n+\n+    retval = source.getSignature().equals(target.getSignature());\n+\n+    if (!retval && (this instanceof MoveMethodDetection)) {\n+      String sourceParent = extractParentSimpleName(source);\n+      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+      String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+      for (int i = 0; i < sourceTokens.length; i++) {\n+        sourceTokens[i] = sourceTokenizer.nextToken();\n+      }\n+\n+      for (int i = 0; i < targetTokens.length; i++) {\n+        targetTokens[i] = targetTokenizer.nextToken();\n+      }\n+\n+      if (targetTokens.length == sourceTokens.length + 1) {\n+        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+        else {\n+          for (int i = 0; i < sourceTokens.length; i++) {\n+            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+          }\n+          retval = true;\n         }\n-        return prunedCandidates;\n+      }\n+    }\n+    return retval;\n+  }\n+\n+  /**\n+   * This helper method takes a string containing the dot separated name of a node and it returns\n+   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+   * class1)\n+   */\n+  protected String extractParentSimpleName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+    return parentName;\n+  }\n+\n+  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+    double count = 0;\n+\n+    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+    for (Edge edge1 : edges1) {\n+      Node node1 = edge1.getSource();\n+      for (int i = 0; i < arrEdge2.length; i++) {\n+        Edge edge2 = arrEdge2[i];\n+        if (edge2 != null) {\n+          Node node2 = (Node) edge2.getSource();\n+          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+            count++;\n+            // we mark this edge as already counted so that we don\'t\n+            // count it\n+            // twice when there are multiple edges between two nodes\n+            arrEdge2[i] = null;\n+          }\n+        }\n+      }\n     }\n \n-    // TODO this is bug pruned\n-    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-        //\t\ttry {\n-        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-        results.forEach(\n-                result -> {\n-                    if (graph.hasNamedNode(result))\n-                        graph.addEdge(\n-                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-                });\n-        // Possible change to methods that instantiate classes\n-        // from class -> class edges.\n-        //\t\t\tfor (String result : results) {\n-        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-        //\t\t\t\tString callingNode = null;\n-        //\t\t\t\tif (resultNode instanceof IMethod) {\n-        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-        //\t\t\t\t} else if (resultNode instanceof IType) {\n-        //\t\t\t\t\tIType rst = (IType) resultNode;\n-        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t} else if (resultNode instanceof IField) {\n-        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-        //\t\t\t\t\t// Workaround\n-        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += ".";\n-        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n-        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-        // ASTNodes\n-        //\t\t\t\t\t\t.getParent(initializer,\n-        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-        //\t\t\t\t\t\tIType.class);\n-        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-        //\t\t\t\t}\n-        //\n-        //\t\t\t\t// TODO treat the case when resultNode is instance of\n-        //\t\t\t\t// ImportDeclaration\n-        //\t\t\t\t// TODO treat the case when resultNode is instance of\n-        //\t\t\t\t// Initializer\n-        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-        //\t\t\t\t// Level\n-        //\t\t\t\tif (callingNode == null) {\n-        //\t\t\t\t\tSystem.out.print("");\n-        //\t\t\t\t}\n-        //\t\t\t\tif (callingNode != null) {\n-        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-        //\t\t\t\t\tif (callerNode != null)\n-        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-        //\t\t\t\t}\n-        //\n-        //\t\t\t}\n-        //\n-        //\t\t} catch (CoreException e) {\n-        //\t\t\tJavaPlugin.log(e);\n-        //\t\t}\n+    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+    return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  protected boolean isTheSameModuloRename(String original, String version) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    if (version.equals(dictionary.get(original))) return true;\n+    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+      return original.equals(version);\n+    else if (original\n+        .substring(original.lastIndexOf("."))\n+        .equals(version.substring(version.lastIndexOf("."))))\n+      return isTheSameModuloRename(\n+          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+    else return false;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+        if (pair[0].isAPI() && pair[1].isAPI()) {\n+          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+          if ((n2inV1 == null)) {\n+            prunedCandidates.add(pair);\n+          }\n+        }\n+      }\n     }\n+    return prunedCandidates;\n+  }\n+\n+  // TODO this is bug pruned\n+  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    //\t\ttry {\n+    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+    results.forEach(\n+        result -> {\n+          if (graph.hasNamedNode(result))\n+            graph.addEdge(\n+                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+        });\n+    // Possible change to methods that instantiate classes\n+    // from class -> class edges.\n+    //\t\t\tfor (String result : results) {\n+    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+    //\t\t\t\tString callingNode = null;\n+    //\t\t\t\tif (resultNode instanceof IMethod) {\n+    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof IType) {\n+    //\t\t\t\t\tIType rst = (IType) resultNode;\n+    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t} else if (resultNode instanceof IField) {\n+    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+    //\t\t\t\t\t// Workaround\n+    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += ".";\n+    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+    // ASTNodes\n+    //\t\t\t\t\t\t.getParent(initializer,\n+    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+    //\t\t\t\t\t\tIType.class);\n+    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// ImportDeclaration\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// Initializer\n+    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+    //\t\t\t\t// Level\n+    //\t\t\t\tif (callingNode == null) {\n+    //\t\t\t\t\tSystem.out.print("");\n+    //\t\t\t\t}\n+    //\t\t\t\tif (callingNode != null) {\n+    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+    //\t\t\t\t\tif (callerNode != null)\n+    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t}\n+    //\n+    //\t\t} catch (CoreException e) {\n+    //\t\t\tJavaPlugin.log(e);\n+    //\t\t}\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "61e3c86c3f1a509ae8b075433384dfcb2ef2bb22",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 41,
            deletions: 41,
            patch:
              "@@ -8,48 +8,48 @@\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n \n public class SearchHelper {\n-    public static List<String> findFieldReferences(FieldNode node) {\n-        return node.getFieldReferenceToMethod();\n-    }\n+  public static List<String> findFieldReferences(FieldNode node) {\n+    return node.getFieldReferenceToMethod();\n+  }\n \n-    public static List<String> findSuperClassesOf(ClassNode node) {\n-        return node.getSuperClasses();\n-    }\n+  public static List<String> findSuperClassesOf(ClassNode node) {\n+    return node.getSuperClasses();\n+  }\n \n-    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-        return node.getClassesImported();\n-    }\n+  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+    return node.getClassesImported();\n+  }\n \n-    public static List<String> findMethodCallers(\n-            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-        return graph\n-                .vertexSet()\n-                .stream()\n-                .filter(n -> (n instanceof MethodNode))\n-                .map(methodNode -> (MethodNode) methodNode)\n-                .filter(\n-                        methodNode ->\n-                                methodNode\n-                                        .getCalledInside()\n-                                        .stream()\n-                                        .anyMatch(\n-                                                calledMethod -> {\n-                                                    String expect =\n-                                                            withSignature\n-                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n-                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n-                                                    String actual =\n-                                                            withSignature\n-                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n-                                                                    : node.getFullyQualifiedName();\n-                                                    return expect.equals(actual);\n-                                                }))\n-                .map(\n-                        methodNode -> {\n-                            return withSignature\n-                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-                                    : methodNode.getFullyQualifiedName();\n-                        })\n-                .collect(Collectors.toList());\n-    }\n+  public static List<String> findMethodCallers(\n+      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+    return graph\n+        .vertexSet()\n+        .stream()\n+        .filter(n -> (n instanceof MethodNode))\n+        .map(methodNode -> (MethodNode) methodNode)\n+        .filter(\n+            methodNode ->\n+                methodNode\n+                    .getCalledInside()\n+                    .stream()\n+                    .anyMatch(\n+                        calledMethod -> {\n+                          String expect =\n+                              withSignature\n+                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                          String actual =\n+                              withSignature\n+                                  ? node.getFullyQualifiedName() + node.getSignature()\n+                                  : node.getFullyQualifiedName();\n+                          return expect.equals(actual);\n+                        }))\n+        .map(\n+            methodNode -> {\n+              return withSignature\n+                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                  : methodNode.getFullyQualifiedName();\n+            })\n+        .collect(Collectors.toList());\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n    return node.getClassesImported();\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "072aa07a114622cd395391b740b9a1e46b64fb70",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "modified",
            additions: 53,
            deletions: 53,
            patch:
              "@@ -11,67 +11,67 @@\n \n public class ClassDetection extends RefactoringDetection {\n \n-    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        // TODO Auto-generated method stub\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    // TODO Auto-generated method stub\n+    return false;\n+  }\n \n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    /**\n-    * We need to find all the places that the original and version classes are instantiated. We will\n-    * incorporate this into the likeliness grade.\n-    */\n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  /**\n+   * We need to find all the places that the original and version classes are instantiated. We will\n+   * incorporate this into the likeliness grade.\n+   */\n+  protected void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createCallGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        createClassReferenceGraph(node, graph);\n-        node.setCreatedCallGraph();\n+    if (!version.hasCallGraph()) {\n+      createCallGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+    createClassReferenceGraph(node, graph);\n+    node.setCreatedCallGraph();\n+  }\n \n-    /**\n-    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n-    * parameter.\n-    */\n-    public static boolean isSuperClassOf(Node node1, Node node2) {\n-        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n-        for (String superClass : superClasses) {\n-            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n-        }\n-        return false;\n+  /**\n+   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n+   * parameter.\n+   */\n+  public static boolean isSuperClassOf(Node node1, Node node2) {\n+    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+    for (String superClass : superClasses) {\n+      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n     }\n+    return false;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * We need to find all the places that the original and version classes are instantiated. We will\n   * incorporate this into the likeliness grade.\n   */\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    createClassReferenceGraph(node, graph);\n    node.setCreatedCallGraph();\n  }\n\n  /**\n   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n   * parameter.\n   */\n  public static boolean isSuperClassOf(Node node1, Node node2) {\n    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n    for (String superClass : superClasses) {\n      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n    }\n    return false;\n  }\n}\n"
          },
          {
            sha: "e753da375cfabc5fb57d8d5440f95671d7bf42f9",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "modified",
            additions: 30,
            deletions: 30,
            patch:
              "@@ -9,38 +9,38 @@\n \n public class MoveClassDetection extends ClassDetection {\n \n-    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-        double edgeGrade;\n-        createCallGraph(nodeOriginal, nodeVersion);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n-        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return edgeGrade;\n-    }\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n-        for (Node[] pair : prePrunedClasses) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n-            String parentPackageVersion = extractFullyQualifiedParentName(version);\n-            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesInDifferentPackages.add(pair);\n-            }\n-        }\n-        return candidatesInDifferentPackages;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+    for (Node[] pair : prePrunedClasses) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n+      String parentPackageVersion = extractFullyQualifiedParentName(version);\n+      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesInDifferentPackages.add(pair);\n+      }\n     }\n+    return candidatesInDifferentPackages;\n+  }\n \n-    public boolean isRename() {\n-        return false;\n-    }\n+  public boolean isRename() {\n+    return false;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n    for (Node[] pair : prePrunedClasses) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n      String parentPackageVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesInDifferentPackages.add(pair);\n      }\n    }\n    return candidatesInDifferentPackages;\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n"
          },
          {
            sha: "f069e44153341cbf9da6818393293f5e7e9ac108",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 45,
            deletions: 45,
            patch:
              "@@ -8,52 +8,52 @@\n \n public class RenameClassDetection extends ClassDetection {\n \n-    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-        super(graph1, graph2);\n+  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+  }\n+\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+  }\n+\n+  /**\n+   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+   * computeLikelinessIncomingEdges in RefactoringDetection\n+   *\n+   * @param nodeOriginal\n+   * @param nodeVersion\n+   * @return\n+   */\n+  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+    for (Node[] pair : prePruned) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractParentSimpleName(original);\n+      String parentPackageVersion = extractParentSimpleName(version);\n+      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithSameParentPackage.add(pair);\n+      }\n     }\n \n-    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n-    }\n-\n-    /**\n-    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-    * computeLikelinessIncomingEdges in RefactoringDetection\n-    *\n-    * @param nodeOriginal\n-    * @param nodeVersion\n-    * @return\n-    */\n-    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-        double edgeGrade;\n-        createCallGraph(nodeOriginal, nodeVersion);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return edgeGrade;\n-    }\n+    return candidatesWithSameParentPackage;\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-        for (Node[] pair : prePruned) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentPackageOriginal = extractParentSimpleName(original);\n-            String parentPackageVersion = extractParentSimpleName(version);\n-            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithSameParentPackage.add(pair);\n-            }\n-        }\n-\n-        return candidatesWithSameParentPackage;\n-    }\n-\n-    @Override\n-    public boolean isRename() {\n-        return true;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n"
          },
          {
            sha: "67bf6cf86456904a46c7d568fe0527ed920c971f",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "modified",
            additions: 73,
            deletions: 73,
            patch:
              "@@ -11,90 +11,90 @@\n \n public class FieldDetection extends RefactoringDetection {\n \n-    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n+  @Override\n+  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n \n-    @Override\n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  @Override\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n \n-    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n \n-        for (String result : results) {\n-            //\t\t\t\tIMember resultNode = (IMember) result;\n-            //\t\t\t\tString callingNode = null;\n-            //\t\t\t\tif (resultNode instanceof IMethod) {\n-            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n-            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n-            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-            // ASTNodes\n-            //\t\t\t\t\t\t.getParent(initializer,\n-            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n-            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n-            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n-            //\t\t\t\t}\n+    for (String result : results) {\n+      //\t\t\t\tIMember resultNode = (IMember) result;\n+      //\t\t\t\tString callingNode = null;\n+      //\t\t\t\tif (resultNode instanceof IMethod) {\n+      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+      // ASTNodes\n+      //\t\t\t\t\t\t.getParent(initializer,\n+      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+      //\t\t\t\t}\n \n-            Node callerNode = graph.findNamedNode(result);\n-            if (callerNode != null)\n-                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n-        }\n+      Node callerNode = graph.findNamedNode(result);\n+      if (callerNode != null)\n+        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n     }\n+  }\n \n-    public void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createFieldReferenceGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createFieldReferenceGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  public void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createFieldReferenceGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-        incomingEdgesGrade =\n-                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n+    if (!version.hasCallGraph()) {\n+      createFieldReferenceGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public double analyzeIncomingEdges(Node original, Node version) {\n+    double incomingEdgesGrade;\n+    createCallGraph(original, version);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+    incomingEdgesGrade =\n+        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return incomingEdgesGrade;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n  @Override\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n    for (String result : results) {\n      //\t\t\t\tIMember resultNode = (IMember) result;\n      //\t\t\t\tString callingNode = null;\n      //\t\t\t\tif (resultNode instanceof IMethod) {\n      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n      // ASTNodes\n      //\t\t\t\t\t\t.getParent(initializer,\n      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n      //\t\t\t\t}\n\n      Node callerNode = graph.findNamedNode(result);\n      if (callerNode != null)\n        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n    }\n  }\n\n  public void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createFieldReferenceGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createFieldReferenceGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n"
          },
          {
            sha: "184ff327f5f763cae4d3307e3cf0ae9b0391eb70",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "modified",
            additions: 25,
            deletions: 25,
            patch:
              "@@ -7,34 +7,34 @@\n \n public class MoveFieldDetection extends FieldDetection {\n \n-    /*\n-    * We already have Class - Field edges. So we need to make sure that they\n-    * are different parents, and also make sure that their call graph is still\n-    * the same.\n-    */\n+  /*\n+   * We already have Class - Field edges. So we need to make sure that they\n+   * are different parents, and also make sure that their call graph is still\n+   * the same.\n+   */\n \n-    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public double computeLikeliness(Node original, Node version) {\n-        return analyzeIncomingEdges(original, version);\n-    }\n+  public double computeLikeliness(Node original, Node version) {\n+    return analyzeIncomingEdges(original, version);\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedFields) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedFields) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n \n-            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n-        return candidatesWithDifferentParentClass;\n+      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n+    return candidatesWithDifferentParentClass;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n  /*\n   * We already have Class - Field edges. So we need to make sure that they\n   * are different parents, and also make sure that their call graph is still\n   * the same.\n   */\n\n  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    return analyzeIncomingEdges(original, version);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedFields) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n}\n"
          },
          {
            sha: "6f93400dab485c9315236a4fe01494f3d3b2aef8",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 105,
            deletions: 105,
            patch:
              '@@ -7,123 +7,123 @@\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n \n-    /**\n-    * @param graph\n-    * @param graph2\n-    */\n-    public ChangeMethodSignatureDetection(\n-            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n+  /**\n+   * @param graph\n+   * @param graph2\n+   */\n+  public ChangeMethodSignatureDetection(\n+      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n+\n+  /**\n+   * We need to go from the node to the AST and get the actual method. Then we will call\n+   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n+   * checked, since we do not want to detect polymorphism as change method signature.\n+   */\n+  public double computeLikeliness(Node original, Node version) {\n+    // Need to find out if in V2 there is a node with the same signature\n+    // as the original\n+    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n+    else {\n+      // This is when we have a method overload or deprecated. So when\n+      // we can check deprecated methods we need to add it here\n+      return analyzeIncomingEdges(original, version);\n     }\n+  }\n \n-    /**\n-    * We need to go from the node to the AST and get the actual method. Then we will call\n-    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n-    * checked, since we do not want to detect polymorphism as change method signature.\n-    */\n-    public double computeLikeliness(Node original, Node version) {\n-        // Need to find out if in V2 there is a node with the same signature\n-        // as the original\n-        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n-        else {\n-            // This is when we have a method overload or deprecated. So when\n-            // we can check deprecated methods we need to add it here\n-            return analyzeIncomingEdges(original, version);\n-        }\n-    }\n+  /** This will handle the same name condition, explained above. */\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n \n-    /** This will handle the same name condition, explained above. */\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n+      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n \n-            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n+      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n \n-            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+      if (hasSameNameAndSignature) continue;\n \n-            if (hasSameNameAndSignature) continue;\n-\n-            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n-                prunedCandidates.add(pair);\n-        }\n-        return prunedCandidates;\n-    }\n-\n-    private boolean hasTheSameSignatureAndName(Node[] pair) {\n-        // TODO here we have to take into account the RenamigsDictionary\n-        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n-        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n-\n-        boolean hasSameNameAndSignature = false;\n-\n-        if (n2ParentInV1 != null) {\n-            // Calling the overloaded method\n-            List<Edge> allMethodEdges =\n-                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n-            for (Edge methodEdge : allMethodEdges) {\n-                Node targetMethod = methodEdge.getTarget();\n-                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n-                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n-                    hasSameNameAndSignature = true;\n-            }\n-        }\n-        return hasSameNameAndSignature;\n+      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n+        prunedCandidates.add(pair);\n     }\n-\n-    private boolean isDeprecatedOrRemoved(Node[] pair) {\n-        Node source = pair[0];\n-        String parentOfOriginal = extractFullyQualifiedParentName(source);\n-        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n-        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n-        boolean isDeprecated = false;\n-        boolean isRemoved = true;\n-        if (parentOfOriginalInV2 != null) {\n-            List<Edge> methodEdges =\n-                    filterNamedEdges(\n-                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n-            for (Edge edge : methodEdges) {\n-                Node methodNode = edge.getTarget();\n-                if (methodNode.getSimpleName().equals(source.getSimpleName())\n-                        && methodNode.getSignature().equals(source.getSignature())) {\n-                    isRemoved = false;\n-                    isDeprecated = methodNode.isDeprecated();\n-                }\n-            }\n-        }\n-\n-        return isDeprecated || isRemoved;\n+    return prunedCandidates;\n+  }\n+\n+  private boolean hasTheSameSignatureAndName(Node[] pair) {\n+    // TODO here we have to take into account the RenamigsDictionary\n+    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+    boolean hasSameNameAndSignature = false;\n+\n+    if (n2ParentInV1 != null) {\n+      // Calling the overloaded method\n+      List<Edge> allMethodEdges =\n+          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+      for (Edge methodEdge : allMethodEdges) {\n+        Node targetMethod = methodEdge.getTarget();\n+        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n+            && targetMethod.getSignature().equals(pair[1].getSignature()))\n+          hasSameNameAndSignature = true;\n+      }\n     }\n-\n-    @Override\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n-        List<Node[]> goodResults = new ArrayList<Node[]>();\n-\n-        for (Node[] pair : listWithFP) {\n-            String signatureN1 = pair[0].getSignature();\n-            String signatureN2 = pair[1].getSignature();\n-            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n+    return hasSameNameAndSignature;\n+  }\n+\n+  private boolean isDeprecatedOrRemoved(Node[] pair) {\n+    Node source = pair[0];\n+    String parentOfOriginal = extractFullyQualifiedParentName(source);\n+    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n+    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+    boolean isDeprecated = false;\n+    boolean isRemoved = true;\n+    if (parentOfOriginalInV2 != null) {\n+      List<Edge> methodEdges =\n+          filterNamedEdges(\n+              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+      for (Edge edge : methodEdges) {\n+        Node methodNode = edge.getTarget();\n+        if (methodNode.getSimpleName().equals(source.getSimpleName())\n+            && methodNode.getSignature().equals(source.getSignature())) {\n+          isRemoved = false;\n+          isDeprecated = methodNode.isDeprecated();\n         }\n-        return goodResults;\n+      }\n     }\n \n-    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n-        // TODO filters out (IPluginDescriptor) with\n-        // (org.eclipse.core.runtime.IPluginDescriptor)\n-        // right now this is checked only for case when there is a one argument\n-        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n-        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n-        return simpleName1.equals(simpleName2);\n-    }\n+    return isDeprecated || isRemoved;\n+  }\n \n-    private String extractSimpleName(String fqn) {\n-        int lastIndex = fqn.lastIndexOf(".");\n-        if (lastIndex < 0) return fqn;\n-        else return fqn.substring(lastIndex + 1);\n-    }\n+  @Override\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+    List<Node[]> goodResults = new ArrayList<Node[]>();\n \n-    public boolean isRename() {\n-        return false;\n+    for (Node[] pair : listWithFP) {\n+      String signatureN1 = pair[0].getSignature();\n+      String signatureN2 = pair[1].getSignature();\n+      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n     }\n+    return goodResults;\n+  }\n+\n+  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+    // TODO filters out (IPluginDescriptor) with\n+    // (org.eclipse.core.runtime.IPluginDescriptor)\n+    // right now this is checked only for case when there is a one argument\n+    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n+    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n+    return simpleName1.equals(simpleName2);\n+  }\n+\n+  private String extractSimpleName(String fqn) {\n+    int lastIndex = fqn.lastIndexOf(".");\n+    if (lastIndex < 0) return fqn;\n+    else return fqn.substring(lastIndex + 1);\n+  }\n+\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n  /**\n   * @param graph\n   * @param graph2\n   */\n  public ChangeMethodSignatureDetection(\n      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We need to go from the node to the AST and get the actual method. Then we will call\n   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n   * checked, since we do not want to detect polymorphism as change method signature.\n   */\n  public double computeLikeliness(Node original, Node version) {\n    // Need to find out if in V2 there is a node with the same signature\n    // as the original\n    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n    else {\n      // This is when we have a method overload or deprecated. So when\n      // we can check deprecated methods we need to add it here\n      return analyzeIncomingEdges(original, version);\n    }\n  }\n\n  /** This will handle the same name condition, explained above. */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n      if (hasSameNameAndSignature) continue;\n\n      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n        prunedCandidates.add(pair);\n    }\n    return prunedCandidates;\n  }\n\n  private boolean hasTheSameSignatureAndName(Node[] pair) {\n    // TODO here we have to take into account the RenamigsDictionary\n    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n    boolean hasSameNameAndSignature = false;\n\n    if (n2ParentInV1 != null) {\n      // Calling the overloaded method\n      List<Edge> allMethodEdges =\n          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n      for (Edge methodEdge : allMethodEdges) {\n        Node targetMethod = methodEdge.getTarget();\n        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n            && targetMethod.getSignature().equals(pair[1].getSignature()))\n          hasSameNameAndSignature = true;\n      }\n    }\n    return hasSameNameAndSignature;\n  }\n\n  private boolean isDeprecatedOrRemoved(Node[] pair) {\n    Node source = pair[0];\n    String parentOfOriginal = extractFullyQualifiedParentName(source);\n    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n    boolean isDeprecated = false;\n    boolean isRemoved = true;\n    if (parentOfOriginalInV2 != null) {\n      List<Edge> methodEdges =\n          filterNamedEdges(\n              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n      for (Edge edge : methodEdges) {\n        Node methodNode = edge.getTarget();\n        if (methodNode.getSimpleName().equals(source.getSimpleName())\n            && methodNode.getSignature().equals(source.getSignature())) {\n          isRemoved = false;\n          isDeprecated = methodNode.isDeprecated();\n        }\n      }\n    }\n\n    return isDeprecated || isRemoved;\n  }\n\n  @Override\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n    List<Node[]> goodResults = new ArrayList<Node[]>();\n\n    for (Node[] pair : listWithFP) {\n      String signatureN1 = pair[0].getSignature();\n      String signatureN2 = pair[1].getSignature();\n      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n    }\n    return goodResults;\n  }\n\n  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n    // TODO filters out (IPluginDescriptor) with\n    // (org.eclipse.core.runtime.IPluginDescriptor)\n    // right now this is checked only for case when there is a one argument\n    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n    return simpleName1.equals(simpleName2);\n  }\n\n  private String extractSimpleName(String fqn) {\n    int lastIndex = fqn.lastIndexOf(".");\n    if (lastIndex < 0) return fqn;\n    else return fqn.substring(lastIndex + 1);\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "9e492fa56e3b1f654735d03da1b18778ea4a3c5e",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "modified",
            additions: 58,
            deletions: 58,
            patch:
              "@@ -11,72 +11,72 @@\n import refactoring.crawler.graph.Node;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        // TODO Auto-generated method stub\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    // TODO Auto-generated method stub\n+    return false;\n+  }\n \n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        List<String> callers;\n-        if (this instanceof ChangeMethodSignatureDetection)\n-            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n-        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n-        for (String s : callers) {\n-            Node callerNode = graph.findNamedNode(s);\n-            if (callerNode != null) {\n-                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n-            }\n-        }\n-        node.setCreatedCallGraph();\n+  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+    List<String> callers;\n+    if (this instanceof ChangeMethodSignatureDetection)\n+      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+    for (String s : callers) {\n+      Node callerNode = graph.findNamedNode(s);\n+      if (callerNode != null) {\n+        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+      }\n     }\n+    node.setCreatedCallGraph();\n+  }\n \n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  protected void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createCallGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n-        incomingEdgesGrade =\n-                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n+    if (!version.hasCallGraph()) {\n+      createCallGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public double analyzeIncomingEdges(Node original, Node version) {\n+    double incomingEdgesGrade;\n+    createCallGraph(original, version);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+    incomingEdgesGrade =\n+        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return incomingEdgesGrade;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    List<String> callers;\n    if (this instanceof ChangeMethodSignatureDetection)\n      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n    for (String s : callers) {\n      Node callerNode = graph.findNamedNode(s);\n      if (callerNode != null) {\n        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n      }\n    }\n    node.setCreatedCallGraph();\n  }\n\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n"
          },
          {
            sha: "76a947129555279bb0423f831c949f1899b2074a",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "modified",
            additions: 186,
            deletions: 186,
            patch:
              '@@ -10,207 +10,207 @@\n \n public class MoveMethodDetection extends MethodDetection {\n \n-    private Node targetClassInVerGraph;\n-\n-    private Node targetClassInOrigGraph;\n-\n-    private RefactoringCrawler crawler;\n-\n-    /**\n-    * Checks for MoveMethod\n-    *\n-    * <p>1. Check that from the old method, all the references to objects having the same type as the\n-    * destination class were removed\n-    *\n-    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n-    */\n-    public MoveMethodDetection(\n-            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-        super(graph1, graph2);\n-        this.crawler = crawler;\n-    }\n-\n-    public double computeLikeliness(Node original, Node version) {\n-        double edgeGrade = 0.0;\n-\n-        double referenceGrade = 0.0;\n-\n-        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+  private Node targetClassInVerGraph;\n+\n+  private Node targetClassInOrigGraph;\n+\n+  private RefactoringCrawler crawler;\n+\n+  /**\n+   * Checks for MoveMethod\n+   *\n+   * <p>1. Check that from the old method, all the references to objects having the same type as the\n+   * destination class were removed\n+   *\n+   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n+   */\n+  public MoveMethodDetection(\n+      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+    this.crawler = crawler;\n+  }\n+\n+  public double computeLikeliness(Node original, Node version) {\n+    double edgeGrade = 0.0;\n+\n+    double referenceGrade = 0.0;\n+\n+    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+\n+    // FIXME: Potential problem when we subtract 0.01 from reference grade\n+    referenceGrade = referencesRemoved(original, version);\n+    edgeGrade = analyzeIncomingEdges(original, version);\n+    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+  }\n+\n+  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+    String sourceInOriginal = extractFullyQualifiedParentName(original);\n+    String targetInVersion = extractFullyQualifiedParentName(version);\n+    // treat case 1\n+    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+  }\n+\n+  /**\n+   * 1. Check that from the old method, all the references to objects having the same type as the\n+   * destination class were removed\n+   */\n+  private double referencesRemoved(Node original, Node version) {\n+    String targetInVersion = extractFullyQualifiedParentName(version);\n+\n+    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+    // treat case 2\n+    if (targetClassInOrigGraph == null) {\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      Enumeration<String> keys = dictionary.keys();\n+      for (; keys.hasMoreElements(); ) {\n+        String aKey = keys.nextElement();\n+        String aValue = dictionary.get(aKey);\n+        if (targetInVersion.equals(aValue)) {\n+          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n+        }\n+      }\n \n-        // FIXME: Potential problem when we subtract 0.01 from reference grade\n-        referenceGrade = referencesRemoved(original, version);\n-        edgeGrade = analyzeIncomingEdges(original, version);\n-        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+      // treat case 3\n+      if (targetClassInOrigGraph == null) return 1.0;\n     }\n \n-    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n-        String sourceInOriginal = extractFullyQualifiedParentName(original);\n-        String targetInVersion = extractFullyQualifiedParentName(version);\n-        // treat case 1\n-        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+    // treat case 2 and 4\n+    if (!targetClassInVerGraph.hasCallGraph()) {\n+      createClassReferenceGraph(targetClassInVerGraph, graph2);\n+      targetClassInVerGraph.setCreatedCallGraph();\n     }\n-\n-    /**\n-    * 1. Check that from the old method, all the references to objects having the same type as the\n-    * destination class were removed\n-    */\n-    private double referencesRemoved(Node original, Node version) {\n-        String targetInVersion = extractFullyQualifiedParentName(version);\n-\n-        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n-        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n-        // treat case 2\n-        if (targetClassInOrigGraph == null) {\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            Enumeration<String> keys = dictionary.keys();\n-            for (; keys.hasMoreElements(); ) {\n-                String aKey = keys.nextElement();\n-                String aValue = dictionary.get(aKey);\n-                if (targetInVersion.equals(aValue)) {\n-                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n-                }\n-            }\n-\n-            // treat case 3\n-            if (targetClassInOrigGraph == null) return 1.0;\n-        }\n-\n-        // treat case 2 and 4\n-        if (!targetClassInVerGraph.hasCallGraph()) {\n-            createClassReferenceGraph(targetClassInVerGraph, graph2);\n-            targetClassInVerGraph.setCreatedCallGraph();\n-        }\n-        if (!targetClassInOrigGraph.hasCallGraph()) {\n-            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n-            targetClassInOrigGraph.setCreatedCallGraph();\n-        }\n-\n-        List<Edge> originalClassReferences =\n-                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n-        List<Edge> versionClassReferences =\n-                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n-        if (originalClassReferences.size() == 0) {\n-            if (original.isStatic()) return 1.0;\n-            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n-            if (versionClassReferences.size() == 0) return 1.0;\n-            return 0.0;\n-        } else\n-            return Math.abs(\n-                    ((originalClassReferences.size() - versionClassReferences.size())\n-                            / originalClassReferences.size()));\n+    if (!targetClassInOrigGraph.hasCallGraph()) {\n+      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n+      targetClassInOrigGraph.setCreatedCallGraph();\n     }\n \n-    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n-        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n-        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n-        List<Node> fields = new ArrayList<Node>();\n-        for (Edge value : edges) {\n-            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-                fields.add((Node) value.getTarget());\n-            }\n-        }\n-\n-        return fields.contains(theTargetClassInOrigGraph);\n+    List<Edge> originalClassReferences =\n+        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+    List<Edge> versionClassReferences =\n+        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n+    if (originalClassReferences.size() == 0) {\n+      if (original.isStatic()) return 1.0;\n+      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n+      if (versionClassReferences.size() == 0) return 1.0;\n+      return 0.0;\n+    } else\n+      return Math.abs(\n+          ((originalClassReferences.size() - versionClassReferences.size())\n+              / originalClassReferences.size()));\n+  }\n+\n+  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n+    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+    List<Node> fields = new ArrayList<Node>();\n+    for (Edge value : edges) {\n+      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+        fields.add((Node) value.getTarget());\n+      }\n     }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-\n-            // Prune toString since the SearchEngine finds all the toString()\n-            // methods, even those that are called from different classes\n-            if ("toString".equals(original.getSimpleName())) continue;\n-\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n-        return candidatesWithDifferentParentClass;\n+    return fields.contains(theTargetClassInOrigGraph);\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+\n+      // Prune toString since the SearchEngine finds all the toString()\n+      // methods, even those that are called from different classes\n+      if ("toString".equals(original.getSimpleName())) continue;\n+\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n-\n-    @Override\n-    public boolean isRename() {\n-        return false;\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n+\n+  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+    return withoutFP;\n+  }\n+\n+  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+    boolean needsOneMorePass = false;\n+    List<Node[]> addToPUM = new ArrayList<>();\n+    List<Node[]> addToPDM = new ArrayList<>();\n+    for (Node[] pair : withoutFP) {\n+      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n+      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n+      if (sourceClass != null && destinationClass != null) {\n+        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n+        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n+      }\n     }\n \n-    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n-        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n-        return withoutFP;\n+    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+    RefactoringCategory pulledUpCategory = null;\n+    RefactoringCategory pushedDownCategory = null;\n+    // TODO this only checks whether we already have such a category\n+    // created. It might be\n+    // that such a category has not been created previously (because no\n+    // results were found\n+    // for that category. In this case, will need to create a brand new\n+    // Category object.\n+    for (RefactoringCategory category : refactoringsList) {\n+      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n+      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n     }\n \n-    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n-        boolean needsOneMorePass = false;\n-        List<Node[]> addToPUM = new ArrayList<>();\n-        List<Node[]> addToPDM = new ArrayList<>();\n-        for (Node[] pair : withoutFP) {\n-            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n-            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n-            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n-            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n-            if (sourceClass != null && destinationClass != null) {\n-                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n-                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n-            }\n-        }\n-\n-        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\n-        RefactoringCategory pulledUpCategory = null;\n-        RefactoringCategory pushedDownCategory = null;\n-        // TODO this only checks whether we already have such a category\n-        // created. It might be\n-        // that such a category has not been created previously (because no\n-        // results were found\n-        // for that category. In this case, will need to create a brand new\n-        // Category object.\n-        for (RefactoringCategory category : refactoringsList) {\n-            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n-            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n-        }\n-\n-        for (Node[] pair : addToPDM) {\n-            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n-            withoutFP.remove(pair);\n-            needsOneMorePass = true;\n-        }\n-\n-        for (Node[] pair : addToPUM) {\n-            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n-            withoutFP.remove(pair);\n-            needsOneMorePass = true;\n-        }\n-        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n-        else return withoutFP;\n+    for (Node[] pair : addToPDM) {\n+      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n+      withoutFP.remove(pair);\n+      needsOneMorePass = true;\n     }\n \n-    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n-        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-        List<Node[]> pairsToRemove = new ArrayList<>();\n-        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-        for (RefactoringCategory category : refactoringsList) {\n-            if (category.getName().equals("PulledUpMethods")\n-                    || category.getName().equals("PushedDownMethods")) {\n-                for (Node[] pair : category.getRefactoringPairs()) {\n-                    for (Node[] prunedPair : prunedList) {\n-                        // The OR below takes care about n->1 and 1->n\n-                        // overlappings\n-                        // between PullUp/PushDown and MoveMethod\n-                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : pairsToRemove) {\n-            prunedList.remove(pair);\n+    for (Node[] pair : addToPUM) {\n+      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n+      withoutFP.remove(pair);\n+      needsOneMorePass = true;\n+    }\n+    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n+    else return withoutFP;\n+  }\n+\n+  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+    List<Node[]> pairsToRemove = new ArrayList<>();\n+    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+    for (RefactoringCategory category : refactoringsList) {\n+      if (category.getName().equals("PulledUpMethods")\n+          || category.getName().equals("PushedDownMethods")) {\n+        for (Node[] pair : category.getRefactoringPairs()) {\n+          for (Node[] prunedPair : prunedList) {\n+            // The OR below takes care about n->1 and 1->n\n+            // overlappings\n+            // between PullUp/PushDown and MoveMethod\n+            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n+          }\n         }\n-        return prunedList;\n+      }\n+    }\n+    for (Node[] pair : pairsToRemove) {\n+      prunedList.remove(pair);\n     }\n+    return prunedList;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n  private Node targetClassInVerGraph;\n\n  private Node targetClassInOrigGraph;\n\n  private RefactoringCrawler crawler;\n\n  /**\n   * Checks for MoveMethod\n   *\n   * <p>1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   *\n   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n   */\n  public MoveMethodDetection(\n      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n    this.crawler = crawler;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    double edgeGrade = 0.0;\n\n    double referenceGrade = 0.0;\n\n    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n    // FIXME: Potential problem when we subtract 0.01 from reference grade\n    referenceGrade = referencesRemoved(original, version);\n    edgeGrade = analyzeIncomingEdges(original, version);\n    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n  }\n\n  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n    String sourceInOriginal = extractFullyQualifiedParentName(original);\n    String targetInVersion = extractFullyQualifiedParentName(version);\n    // treat case 1\n    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n  }\n\n  /**\n   * 1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   */\n  private double referencesRemoved(Node original, Node version) {\n    String targetInVersion = extractFullyQualifiedParentName(version);\n\n    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n    // treat case 2\n    if (targetClassInOrigGraph == null) {\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      Enumeration<String> keys = dictionary.keys();\n      for (; keys.hasMoreElements(); ) {\n        String aKey = keys.nextElement();\n        String aValue = dictionary.get(aKey);\n        if (targetInVersion.equals(aValue)) {\n          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n        }\n      }\n\n      // treat case 3\n      if (targetClassInOrigGraph == null) return 1.0;\n    }\n\n    // treat case 2 and 4\n    if (!targetClassInVerGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInVerGraph, graph2);\n      targetClassInVerGraph.setCreatedCallGraph();\n    }\n    if (!targetClassInOrigGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n      targetClassInOrigGraph.setCreatedCallGraph();\n    }\n\n    List<Edge> originalClassReferences =\n        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n    List<Edge> versionClassReferences =\n        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n    if (originalClassReferences.size() == 0) {\n      if (original.isStatic()) return 1.0;\n      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n      if (versionClassReferences.size() == 0) return 1.0;\n      return 0.0;\n    } else\n      return Math.abs(\n          ((originalClassReferences.size() - versionClassReferences.size())\n              / originalClassReferences.size()));\n  }\n\n  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n    List<Node> fields = new ArrayList<Node>();\n    for (Edge value : edges) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        fields.add((Node) value.getTarget());\n      }\n    }\n\n    return fields.contains(theTargetClassInOrigGraph);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n\n      // Prune toString since the SearchEngine finds all the toString()\n      // methods, even those that are called from different classes\n      if ("toString".equals(original.getSimpleName())) continue;\n\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n    return withoutFP;\n  }\n\n  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n    boolean needsOneMorePass = false;\n    List<Node[]> addToPUM = new ArrayList<>();\n    List<Node[]> addToPDM = new ArrayList<>();\n    for (Node[] pair : withoutFP) {\n      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n      if (sourceClass != null && destinationClass != null) {\n        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n      }\n    }\n\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n    RefactoringCategory pulledUpCategory = null;\n    RefactoringCategory pushedDownCategory = null;\n    // TODO this only checks whether we already have such a category\n    // created. It might be\n    // that such a category has not been created previously (because no\n    // results were found\n    // for that category. In this case, will need to create a brand new\n    // Category object.\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n    }\n\n    for (Node[] pair : addToPDM) {\n      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n\n    for (Node[] pair : addToPUM) {\n      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n    else return withoutFP;\n  }\n\n  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    List<Node[]> pairsToRemove = new ArrayList<>();\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")\n          || category.getName().equals("PushedDownMethods")) {\n        for (Node[] pair : category.getRefactoringPairs()) {\n          for (Node[] prunedPair : prunedList) {\n            // The OR below takes care about n->1 and 1->n\n            // overlappings\n            // between PullUp/PushDown and MoveMethod\n            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n          }\n        }\n      }\n    }\n    for (Node[] pair : pairsToRemove) {\n      prunedList.remove(pair);\n    }\n    return prunedList;\n  }\n}\n'
          },
          {
            sha: "2c24f295bf40887025a35ce694a69c056b81a7a3",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "modified",
            additions: 50,
            deletions: 50,
            patch:
              '@@ -8,59 +8,59 @@\n \n public class PullUpMethodDetection extends MethodDetection {\n \n-    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    /**\n-    * We should now check for the same method being in the parent class, thus for the two nodes,\n-    * check if the version now resides in the superclass of the original method\'s parent class.\n-    */\n-    // TODO: Check why we get a null pointer exception with parentclassver and\n-    // parent class orig)\n-    public double computeLikeliness(Node original, Node version) {\n-        double incomingEdgesGrade = 0.0;\n-        boolean isSuperclass = false;\n-        // TODO: Think about possible different cases that this might be\n-        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n-        // find it.\n-        // TODO: Think about the NULL case. Return 0.0 if you find null,\n-        // since clearly they are not "like" each other.\n-        String parentClassOriginal = extractFullyQualifiedParentName(original);\n-        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n-        String parentClassVersion = extractFullyQualifiedParentName(version);\n-        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-        if (parentClassOrig == null) return 0.0;\n-        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n-        // Now we should check if parentClassOrig is a subclass of\n-        // parentClassVer\n-        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n+  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-        if (isSuperclass) {\n-            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n-            return incomingEdgesGrade;\n-        } else return 0.0;\n-    }\n+  /**\n+   * We should now check for the same method being in the parent class, thus for the two nodes,\n+   * check if the version now resides in the superclass of the original method\'s parent class.\n+   */\n+  // TODO: Check why we get a null pointer exception with parentclassver and\n+  // parent class orig)\n+  public double computeLikeliness(Node original, Node version) {\n+    double incomingEdgesGrade = 0.0;\n+    boolean isSuperclass = false;\n+    // TODO: Think about possible different cases that this might be\n+    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+    // find it.\n+    // TODO: Think about the NULL case. Return 0.0 if you find null,\n+    // since clearly they are not "like" each other.\n+    String parentClassOriginal = extractFullyQualifiedParentName(original);\n+    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+    String parentClassVersion = extractFullyQualifiedParentName(version);\n+    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+    if (parentClassOrig == null) return 0.0;\n+    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+    // Now we should check if parentClassOrig is a subclass of\n+    // parentClassVer\n+    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractParentSimpleName(original);\n-            String parentClassVersion = extractParentSimpleName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n+    if (isSuperclass) {\n+      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n+      return incomingEdgesGrade;\n+    } else return 0.0;\n+  }\n \n-        return candidatesWithDifferentParentClass;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractParentSimpleName(original);\n+      String parentClassVersion = extractParentSimpleName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We should now check for the same method being in the parent class, thus for the two nodes,\n   * check if the version now resides in the superclass of the original method\'s parent class.\n   */\n  // TODO: Check why we get a null pointer exception with parentclassver and\n  // parent class orig)\n  public double computeLikeliness(Node original, Node version) {\n    double incomingEdgesGrade = 0.0;\n    boolean isSuperclass = false;\n    // TODO: Think about possible different cases that this might be\n    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n    // find it.\n    // TODO: Think about the NULL case. Return 0.0 if you find null,\n    // since clearly they are not "like" each other.\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassOrig is a subclass of\n    // parentClassVer\n    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n    if (isSuperclass) {\n      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n      return incomingEdgesGrade;\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "296bce275d7968716d7f0bed80da373e18210114",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "modified",
            additions: 39,
            deletions: 39,
            patch:
              '@@ -8,47 +8,47 @@\n \n public class PushDownMethodDetection extends MethodDetection {\n \n-    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    public double computeLikeliness(Node original, Node version) {\n-        boolean superClassGrade = false;\n-        String parentClassOriginal = extractFullyQualifiedParentName(original);\n-        String parentClassVersion = extractFullyQualifiedParentName(version);\n-        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n-        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-        if (parentClassOrig == null) return 0.0;\n-        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n-        // Now we should check if parentClassVer is a subclass of\n-        // parentClassOrig\n-        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n-            System.out.println("stop");\n-        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n-        if (superClassGrade) {\n-            return (analyzeIncomingEdges(original, version));\n-        } else return 0.0;\n-    }\n+  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractParentSimpleName(original);\n-            String parentClassVersion = extractParentSimpleName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n+  public double computeLikeliness(Node original, Node version) {\n+    boolean superClassGrade = false;\n+    String parentClassOriginal = extractFullyQualifiedParentName(original);\n+    String parentClassVersion = extractFullyQualifiedParentName(version);\n+    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+    if (parentClassOrig == null) return 0.0;\n+    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+    // Now we should check if parentClassVer is a subclass of\n+    // parentClassOrig\n+    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+      System.out.println("stop");\n+    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n+    if (superClassGrade) {\n+      return (analyzeIncomingEdges(original, version));\n+    } else return 0.0;\n+  }\n \n-        return candidatesWithDifferentParentClass;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractParentSimpleName(original);\n+      String parentClassVersion = extractParentSimpleName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    boolean superClassGrade = false;\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassVer is a subclass of\n    // parentClassOrig\n    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n      System.out.println("stop");\n    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n    if (superClassGrade) {\n      return (analyzeIncomingEdges(original, version));\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "8cb105ce7458d9c39635ff368d652f3cd45ba1ef",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 60,
            deletions: 60,
            patch:
              "@@ -8,71 +8,71 @@\n \n public class RenameMethodDetection extends MethodDetection {\n \n-    public RenameMethodDetection(\n-            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-        super(oldVersion, newVersion);\n-    }\n-\n-    /**\n-    * @param candidates List containing clone methods\n-    * @return A List containing only the candidate methods that are in the same class\n-    */\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-                candidatesWithSameParentClass.add(pair);\n-        }\n+  public RenameMethodDetection(\n+      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+    super(oldVersion, newVersion);\n+  }\n \n-        return candidatesWithSameParentClass;\n+  /**\n+   * @param candidates List containing clone methods\n+   * @return A List containing only the candidate methods that are in the same class\n+   */\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n+        candidatesWithSameParentClass.add(pair);\n     }\n \n-    public double computeLikeliness(Node original, Node version) {\n-        // createCallGraph(original, version);\n-        // return computeLikelinessConsideringEdges(original, version);\n-        return analyzeIncomingEdges(original, version);\n-    }\n+    return candidatesWithSameParentClass;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        return true;\n-    }\n+  public double computeLikeliness(Node original, Node version) {\n+    // createCallGraph(original, version);\n+    // return computeLikelinessConsideringEdges(original, version);\n+    return analyzeIncomingEdges(original, version);\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n \n-    /**\n-    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n-    * getStartConnector) in JHD5.3 )\n-    */\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-        for (int i = 0; i < prunedList.size(); i++) {\n-            Node[] pair = prunedList.get(i);\n-            Node target = pair[1];\n-            String targetName = target.getSimpleName().toLowerCase().trim();\n-            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n-            for (Node[] nodes : prunedList) {\n-                Node potentialTarget = (nodes)[1];\n-                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n-            }\n-            if (allPairsWithSameTarget.size() > 1) {\n-                for (Object o : allPairsWithSameTarget) {\n-                    Node[] sameTargetPair = (Node[]) o;\n-                    Node sourceNode = sameTargetPair[0];\n-                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n-                    // Changed from || to && and changed the !='s to =='s\n-                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n-                        prunedList.remove(sameTargetPair);\n-                        Dictionary<String, String> dictionary = getRenamingDictionary();\n-                        dictionary.remove(sourceNode.getFullyQualifiedName());\n-                    }\n-                }\n-            }\n+  /**\n+   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n+   * getStartConnector) in JHD5.3 )\n+   */\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+    for (int i = 0; i < prunedList.size(); i++) {\n+      Node[] pair = prunedList.get(i);\n+      Node target = pair[1];\n+      String targetName = target.getSimpleName().toLowerCase().trim();\n+      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+      for (Node[] nodes : prunedList) {\n+        Node potentialTarget = (nodes)[1];\n+        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n+      }\n+      if (allPairsWithSameTarget.size() > 1) {\n+        for (Object o : allPairsWithSameTarget) {\n+          Node[] sameTargetPair = (Node[]) o;\n+          Node sourceNode = sameTargetPair[0];\n+          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n+          // Changed from || to && and changed the !='s to =='s\n+          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n+            prunedList.remove(sameTargetPair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(sourceNode.getFullyQualifiedName());\n+          }\n         }\n-        return prunedList;\n+      }\n     }\n+    return prunedList;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n        candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "66cc05cc40337a87d4835854e19c62d19d2c4067",
            filename: "src/main/java/refactoring/crawler/graph/ClassNode.java",
            status: "modified",
            additions: 6,
            deletions: 6,
            patch:
              "@@ -7,12 +7,12 @@\n \n public class ClassNode extends Node {\n \n-    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n+  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n \n-    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n+  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public ClassNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.CLASS);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public ClassNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.CLASS);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public ClassNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.CLASS);\n  }\n}\n"
          },
          {
            sha: "7774ec8b37feef6882a868e2660021a320eeaa54",
            filename: "src/main/java/refactoring/crawler/graph/Edge.java",
            status: "modified",
            additions: 26,
            deletions: 26,
            patch:
              '@@ -6,30 +6,30 @@\n \n public class Edge extends DefaultEdge {\n \n-    @Getter @Setter private Node.Type label;\n-\n-    public Edge(Node.Type label) {\n-        this.label = label;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-    }\n-\n-    @Override\n-    public Node getSource() {\n-        return (Node) super.getSource();\n-    }\n-\n-    @Override\n-    public Node getTarget() {\n-        return (Node) super.getTarget();\n-    }\n-\n-    public Node oppositeVertex(Node n) {\n-        Node source = this.getSource();\n-        Node target = this.getTarget();\n-        return n.equals(source) ? target : source;\n-    }\n+  @Getter @Setter private Node.Type label;\n+\n+  public Edge(Node.Type label) {\n+    this.label = label;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+  }\n+\n+  @Override\n+  public Node getSource() {\n+    return (Node) super.getSource();\n+  }\n+\n+  @Override\n+  public Node getTarget() {\n+    return (Node) super.getTarget();\n+  }\n+\n+  public Node oppositeVertex(Node n) {\n+    Node source = this.getSource();\n+    Node target = this.getTarget();\n+    return n.equals(source) ? target : source;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n  @Getter @Setter private Node.Type label;\n\n  public Edge(Node.Type label) {\n    this.label = label;\n  }\n\n  @Override\n  public String toString() {\n    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n  }\n\n  @Override\n  public Node getSource() {\n    return (Node) super.getSource();\n  }\n\n  @Override\n  public Node getTarget() {\n    return (Node) super.getTarget();\n  }\n\n  public Node oppositeVertex(Node n) {\n    Node source = this.getSource();\n    Node target = this.getTarget();\n    return n.equals(source) ? target : source;\n  }\n}\n'
          },
          {
            sha: "51d845ea135825c28660aac7c258adde05243914",
            filename: "src/main/java/refactoring/crawler/graph/FieldNode.java",
            status: "modified",
            additions: 5,
            deletions: 5,
            patch:
              "@@ -6,10 +6,10 @@\n \n public class FieldNode extends Node {\n \n-    @Getter @Setter private List<String> fieldReferenceToMethod;\n+  @Getter @Setter private List<String> fieldReferenceToMethod;\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public FieldNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.FIELD);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public FieldNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.FIELD);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n  @Getter @Setter private List<String> fieldReferenceToMethod;\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public FieldNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.FIELD);\n  }\n}\n"
          },
          {
            sha: "e2919264f5aa7154db6f0c0501950564a730a1e3",
            filename: "src/main/java/refactoring/crawler/graph/MethodNode.java",
            status: "modified",
            additions: 10,
            deletions: 10,
            patch:
              "@@ -8,17 +8,17 @@\n \n public class MethodNode extends Node {\n \n-    @AllArgsConstructor\n-    public static class CalledMethod {\n-        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n+  @AllArgsConstructor\n+  public static class CalledMethod {\n+    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n \n-        @Getter @Setter private String fullyQualifiedNameWithSignature;\n-    }\n+    @Getter @Setter private String fullyQualifiedNameWithSignature;\n+  }\n \n-    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n+  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public MethodNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.METHOD);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public MethodNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.METHOD);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n  @AllArgsConstructor\n  public static class CalledMethod {\n    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n    @Getter @Setter private String fullyQualifiedNameWithSignature;\n  }\n\n  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public MethodNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.METHOD);\n  }\n}\n"
          },
          {
            sha: "5c0ac895baf10b75181e22675a8b7840b08fb90d",
            filename:
              "src/main/java/refactoring/crawler/graph/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 24,
            deletions: 24,
            patch:
              "@@ -8,28 +8,28 @@\n \n public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n \n-    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n-\n-    public NamedDirectedMultigraph() {\n-        super(Edge.class);\n-    }\n-\n-    public NamedDirectedMultigraph(\n-            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-        super(vertexSupplier, edgeSupplier, weighted);\n-    }\n-\n-    public boolean addNamedVertex(Node v) {\n-        if (!addVertex(v)) return false;\n-        namedVertexMap.put(v.getFullyQualifiedName(), v);\n-        return true;\n-    }\n-\n-    public Node findNamedNode(String name) {\n-        return namedVertexMap.get(name);\n-    }\n-\n-    public boolean hasNamedNode(String name) {\n-        return namedVertexMap.containsKey(name);\n-    }\n+  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+  public NamedDirectedMultigraph() {\n+    super(Edge.class);\n+  }\n+\n+  public NamedDirectedMultigraph(\n+      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+    super(vertexSupplier, edgeSupplier, weighted);\n+  }\n+\n+  public boolean addNamedVertex(Node v) {\n+    if (!addVertex(v)) return false;\n+    namedVertexMap.put(v.getFullyQualifiedName(), v);\n+    return true;\n+  }\n+\n+  public Node findNamedNode(String name) {\n+    return namedVertexMap.get(name);\n+  }\n+\n+  public boolean hasNamedNode(String name) {\n+    return namedVertexMap.containsKey(name);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n  public NamedDirectedMultigraph() {\n    super(Edge.class);\n  }\n\n  public NamedDirectedMultigraph(\n      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n    super(vertexSupplier, edgeSupplier, weighted);\n  }\n\n  public boolean addNamedVertex(Node v) {\n    if (!addVertex(v)) return false;\n    namedVertexMap.put(v.getFullyQualifiedName(), v);\n    return true;\n  }\n\n  public Node findNamedNode(String name) {\n    return namedVertexMap.get(name);\n  }\n\n  public boolean hasNamedNode(String name) {\n    return namedVertexMap.containsKey(name);\n  }\n}\n"
          },
          {
            sha: "4397227e131372600696f0c613eaab9d7bf41229",
            filename: "src/main/java/refactoring/crawler/graph/Node.java",
            status: "modified",
            additions: 50,
            deletions: 50,
            patch:
              '@@ -5,70 +5,70 @@\n \n public class Node {\n \n-    public boolean hasCallGraph() {\n-        return false;\n-    }\n+  public boolean hasCallGraph() {\n+    return false;\n+  }\n \n-    public void setCreatedCallGraph() {}\n-\n-    public static enum Type {\n-        PROJECT,\n-        PACKAGE,\n-        CLASS,\n-        METHOD,\n-        FIELD,\n-        METHOD_CALL,\n-        IMPORT,\n-        CLASS_REFERENCE,\n-        FIELD_REFERENCE\n-    }\n+  public void setCreatedCallGraph() {}\n \n-    @Getter @Setter private String fullyQualifiedName;\n+  public static enum Type {\n+    PROJECT,\n+    PACKAGE,\n+    CLASS,\n+    METHOD,\n+    FIELD,\n+    METHOD_CALL,\n+    IMPORT,\n+    CLASS_REFERENCE,\n+    FIELD_REFERENCE\n+  }\n \n-    @Setter @Getter private Node.Type type;\n+  @Getter @Setter private String fullyQualifiedName;\n \n-    @Setter @Getter private int[] shingles;\n+  @Setter @Getter private Node.Type type;\n \n-    @Setter @Getter private boolean hasCallGraph;\n+  @Setter @Getter private int[] shingles;\n \n-    @Setter @Getter private String projectName;\n+  @Setter @Getter private boolean hasCallGraph;\n \n-    @Setter @Getter private boolean isAPI = false;\n+  @Setter @Getter private String projectName;\n \n-    @Setter @Getter private String signature;\n+  @Setter @Getter private boolean isAPI = false;\n \n-    @Setter @Getter private int flags;\n+  @Setter @Getter private String signature;\n \n-    @Setter @Getter private boolean deprecated = false;\n+  @Setter @Getter private int flags;\n \n-    @Setter @Getter private boolean isInterface = false;\n+  @Setter @Getter private boolean deprecated = false;\n \n-    @Getter @Setter private boolean isStatic = false;\n+  @Setter @Getter private boolean isInterface = false;\n \n-    /**\n-    * @param fullyQualifiedName fullyQualifiedName\n-    * @param type type\n-    */\n-    public Node(String fullyQualifiedName, Node.Type type) {\n-        this.fullyQualifiedName = fullyQualifiedName;\n-        this.type = type;\n-    }\n+  @Getter @Setter private boolean isStatic = false;\n \n-    public String getSimpleName() {\n-        int pos = fullyQualifiedName.lastIndexOf(".");\n-        if (pos != -1) {\n-            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n-        }\n-        return fullyQualifiedName;\n-    }\n+  /**\n+   * @param fullyQualifiedName fullyQualifiedName\n+   * @param type type\n+   */\n+  public Node(String fullyQualifiedName, Node.Type type) {\n+    this.fullyQualifiedName = fullyQualifiedName;\n+    this.type = type;\n+  }\n \n-    @Override\n-    public String toString() {\n-        if (getSignature() != null)\n-            return getType()\n-                    + "= "\n-                    + getFullyQualifiedName()\n-                    + getSignature().substring(getSignature().indexOf("("));\n-        else return getType() + "= " + getFullyQualifiedName();\n+  public String getSimpleName() {\n+    int pos = fullyQualifiedName.lastIndexOf(".");\n+    if (pos != -1) {\n+      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n     }\n+    return fullyQualifiedName;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    if (getSignature() != null)\n+      return getType()\n+          + "= "\n+          + getFullyQualifiedName()\n+          + getSignature().substring(getSignature().indexOf("("));\n+    else return getType() + "= " + getFullyQualifiedName();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n  public boolean hasCallGraph() {\n    return false;\n  }\n\n  public void setCreatedCallGraph() {}\n\n  public static enum Type {\n    PROJECT,\n    PACKAGE,\n    CLASS,\n    METHOD,\n    FIELD,\n    METHOD_CALL,\n    IMPORT,\n    CLASS_REFERENCE,\n    FIELD_REFERENCE\n  }\n\n  @Getter @Setter private String fullyQualifiedName;\n\n  @Setter @Getter private Node.Type type;\n\n  @Setter @Getter private int[] shingles;\n\n  @Setter @Getter private boolean hasCallGraph;\n\n  @Setter @Getter private String projectName;\n\n  @Setter @Getter private boolean isAPI = false;\n\n  @Setter @Getter private String signature;\n\n  @Setter @Getter private int flags;\n\n  @Setter @Getter private boolean deprecated = false;\n\n  @Setter @Getter private boolean isInterface = false;\n\n  @Getter @Setter private boolean isStatic = false;\n\n  /**\n   * @param fullyQualifiedName fullyQualifiedName\n   * @param type type\n   */\n  public Node(String fullyQualifiedName, Node.Type type) {\n    this.fullyQualifiedName = fullyQualifiedName;\n    this.type = type;\n  }\n\n  public String getSimpleName() {\n    int pos = fullyQualifiedName.lastIndexOf(".");\n    if (pos != -1) {\n      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n    }\n    return fullyQualifiedName;\n  }\n\n  @Override\n  public String toString() {\n    if (getSignature() != null)\n      return getType()\n          + "= "\n          + getFullyQualifiedName()\n          + getSignature().substring(getSignature().indexOf("("));\n    else return getType() + "= " + getFullyQualifiedName();\n  }\n}\n'
          },
          {
            sha: "98bf2210121031f53e8caf7f8f89645f6b1dcc86",
            filename:
              "src/main/java/refactoring/crawler/shingles/BloomFilter.java",
            status: "modified",
            additions: 464,
            deletions: 464,
            patch:
              '@@ -11,512 +11,512 @@\n import java.net.URL;\n \n /**\n-* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n-*\n-* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n-* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n-* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n-* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n-* can make a useful tool.\n-*\n-* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n-* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n-* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n-* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n-* checkers.\n-*\n-* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n-* vector of a given length. We choose the length of the bit vector and the number of hash functions\n-* depending on how many keys we want to add to the set and how high an error rate we are willing to\n-* put up with.\n-*\n-* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n-* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n-* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n-* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n-* function would increase our false-positive rate.\n-*\n-* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n-* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n-* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n-* a Bloom filter.\n-*\n-* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n-* key. We run the key through our set of hash functions, and then check to see whether the bits at\n-* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n-* the filter. If all of the bits are on, we know the key is probably there.\n-*\n-* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n-* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n-* bits we check will be on, unless the key actually exists in the filter. The relationship between\n-* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n-* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n-* will be very dense, increasing the probability of collisions. You can calculate the\n-* false-positive rate for any filter using the formula:\n-*\n-* <p><code>c = ( 1 - e(-kn/m) )k</code>\n-*\n-* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n-* in the filter, and m is the length of the filter in bits.\n-*\n-* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n-* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n-* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n-* our limit. The following equation will give us vector length from the error rate and number of\n-* keys:\n-*\n-* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n-*\n-* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n-* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n-* combinations of error rate, filter size, and number of hash functions at <a\n-* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n-* -- the math</a>.\n-*\n-* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n-* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n-* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n-* the case of JDK 1.4).\n-*\n-* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n-* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n-* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n-* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n-* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n-* even in this Java implementation the speed is reasonable.\n-*\n-* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n-* method" by Andrei Broder. See <a\n-* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n-* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n-* paper in PDF format.\n-*\n-* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n-* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n-* <code>URL</code>.\n-*\n-* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n-* initial value multiplied by a list of distinct values.\n-*\n-* @see java.lang.Object#hashCode()\n-* @see java.util.Map\n-* @author Bruno Martins\n-*/\n+ * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n+ *\n+ * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n+ * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n+ * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n+ * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n+ * can make a useful tool.\n+ *\n+ * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+ * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n+ * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n+ * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n+ * checkers.\n+ *\n+ * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n+ * vector of a given length. We choose the length of the bit vector and the number of hash functions\n+ * depending on how many keys we want to add to the set and how high an error rate we are willing to\n+ * put up with.\n+ *\n+ * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n+ * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n+ * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+ * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+ * function would increase our false-positive rate.\n+ *\n+ * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n+ * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+ * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n+ * a Bloom filter.\n+ *\n+ * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n+ * key. We run the key through our set of hash functions, and then check to see whether the bits at\n+ * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n+ * the filter. If all of the bits are on, we know the key is probably there.\n+ *\n+ * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n+ * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n+ * bits we check will be on, unless the key actually exists in the filter. The relationship between\n+ * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+ * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n+ * will be very dense, increasing the probability of collisions. You can calculate the\n+ * false-positive rate for any filter using the formula:\n+ *\n+ * <p><code>c = ( 1 - e(-kn/m) )k</code>\n+ *\n+ * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n+ * in the filter, and m is the length of the filter in bits.\n+ *\n+ * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n+ * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n+ * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n+ * our limit. The following equation will give us vector length from the error rate and number of\n+ * keys:\n+ *\n+ * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n+ *\n+ * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+ * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n+ * combinations of error rate, filter size, and number of hash functions at <a\n+ * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n+ * -- the math</a>.\n+ *\n+ * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n+ * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n+ * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n+ * the case of JDK 1.4).\n+ *\n+ * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n+ * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n+ * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n+ * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n+ * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n+ * even in this Java implementation the speed is reasonable.\n+ *\n+ * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+ * method" by Andrei Broder. See <a\n+ * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+ * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+ * paper in PDF format.\n+ *\n+ * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n+ * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n+ * <code>URL</code>.\n+ *\n+ * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+ * initial value multiplied by a list of distinct values.\n+ *\n+ * @see java.lang.Object#hashCode()\n+ * @see java.util.Map\n+ * @author Bruno Martins\n+ */\n public class BloomFilter implements Cloneable {\n \n-    /** A buffer for the Rabin fingerprinting algorithm. */\n-    private byte[] buffer;\n+  /** A buffer for the Rabin fingerprinting algorithm. */\n+  private byte[] buffer;\n \n-    /**\n-    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n-    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n-    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n-    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n-    * bit is the constant coefficient.\n-    *\n-    * <p>For example the integer 0x00000803, in binary, is:\n-    *\n-    * <p><code>00000000 00000000 00001000 00000011</code>\n-    *\n-    * <p>Therefore it correponds to the polynomial:\n-    *\n-    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n-    */\n-    private static int POLYNOMIAL = 0x000001C7;\n+  /**\n+   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n+   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n+   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n+   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+   * bit is the constant coefficient.\n+   *\n+   * <p>For example the integer 0x00000803, in binary, is:\n+   *\n+   * <p><code>00000000 00000000 00001000 00000011</code>\n+   *\n+   * <p>Therefore it correponds to the polynomial:\n+   *\n+   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+   */\n+  private static int POLYNOMIAL = 0x000001C7;\n \n-    /** Internal values for the Rabin fingerprinting algorithm. */\n-    private static int[] table32, table40, table48, table54;\n+  /** Internal values for the Rabin fingerprinting algorithm. */\n+  private static int[] table32, table40, table48, table54;\n \n-    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-    private static int P_DEGREE = 32;\n+  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+  private static int P_DEGREE = 32;\n \n-    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n-    private static int READ_BUFFER_SIZE = 2048;\n+  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n+  private static int READ_BUFFER_SIZE = 2048;\n \n-    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n \n-    /** The bit vector for the Bloom Filter. */\n-    private boolean keys[];\n+  /** The bit vector for the Bloom Filter. */\n+  private boolean keys[];\n \n-    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n-    private boolean useRabin = true;\n+  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+  private boolean useRabin = true;\n \n-    /** The number of hash functions. */\n-    private int numFunctions;\n+  /** The number of hash functions. */\n+  private int numFunctions;\n \n-    /**\n-    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n-    * length for the bit vector (1000).\n-    */\n-    public BloomFilter() {\n-        table32 = new int[256];\n-        table40 = new int[256];\n-        table48 = new int[256];\n-        table54 = new int[256];\n-        buffer = new byte[READ_BUFFER_SIZE];\n-        // We want to have mods[i] == x^(P_DEGREE+i)\n-        int[] mods = new int[P_DEGREE];\n-        mods[0] = POLYNOMIAL;\n-        for (int i = 1; i < P_DEGREE; i++) {\n-            // x^i == x(x^(i-1)) (mod P)\n-            mods[i] = mods[i - 1] << 1;\n-            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n-            // x^P_DEGREE term that \'fell off\' the top end.\n-            // Since x^P_DEGREE == P (mod P), we should add P\n-            // to account for this:\n-            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n-                mods[i] ^= POLYNOMIAL;\n-            }\n-        }\n-        for (int i = 0; i < 256; i++) {\n-            int c = i;\n-            for (int j = 0; j < 8 && c != 0; j++) {\n-                if ((c & 1) != 0) {\n-                    table32[i] ^= mods[j];\n-                    table40[i] ^= mods[j + 8];\n-                    table48[i] ^= mods[j + 16];\n-                    table54[i] ^= mods[j + 24];\n-                }\n-                c >>>= 1;\n-            }\n-        }\n-        mods = null;\n-        this.keys = new boolean[1000];\n-        this.numFunctions = 10;\n-        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+  /**\n+   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n+   * length for the bit vector (1000).\n+   */\n+  public BloomFilter() {\n+    table32 = new int[256];\n+    table40 = new int[256];\n+    table48 = new int[256];\n+    table54 = new int[256];\n+    buffer = new byte[READ_BUFFER_SIZE];\n+    // We want to have mods[i] == x^(P_DEGREE+i)\n+    int[] mods = new int[P_DEGREE];\n+    mods[0] = POLYNOMIAL;\n+    for (int i = 1; i < P_DEGREE; i++) {\n+      // x^i == x(x^(i-1)) (mod P)\n+      mods[i] = mods[i - 1] << 1;\n+      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+      // x^P_DEGREE term that \'fell off\' the top end.\n+      // Since x^P_DEGREE == P (mod P), we should add P\n+      // to account for this:\n+      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n+        mods[i] ^= POLYNOMIAL;\n+      }\n     }\n-\n-    /**\n-    * Constructs a Bloom Filter from a string representation.\n-    *\n-    * @see #toString()\n-    */\n-    public BloomFilter(String filter) {\n-        this();\n-        int index1 = filter.indexOf(":");\n-        int index2 = filter.lastIndexOf(":");\n-        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n-        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n-        for (int i = index2 + 1; i < filter.length(); i++) {\n-            if (filter.charAt(i) == \'1\') keys[i] = true;\n-            else keys[i] = false;\n+    for (int i = 0; i < 256; i++) {\n+      int c = i;\n+      for (int j = 0; j < 8 && c != 0; j++) {\n+        if ((c & 1) != 0) {\n+          table32[i] ^= mods[j];\n+          table40[i] ^= mods[j + 8];\n+          table48[i] ^= mods[j + 16];\n+          table54[i] ^= mods[j + 24];\n         }\n+        c >>>= 1;\n+      }\n     }\n+    mods = null;\n+    this.keys = new boolean[1000];\n+    this.numFunctions = 10;\n+    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n-    * error rate.\n-    *\n-    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n-    */\n-    public BloomFilter(int numKeys, double errorRate) {\n-        this();\n-        double lowest_m = Double.MAX_VALUE;\n-        int best_k = 1;\n-        for (int k = 1; k <= 100; k++) {\n-            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n-            if (m < lowest_m) {\n-                lowest_m = m;\n-                best_k = k;\n-            }\n-        }\n-        this.keys = new boolean[numKeys];\n-        this.numFunctions = best_k;\n-        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  /**\n+   * Constructs a Bloom Filter from a string representation.\n+   *\n+   * @see #toString()\n+   */\n+  public BloomFilter(String filter) {\n+    this();\n+    int index1 = filter.indexOf(":");\n+    int index2 = filter.lastIndexOf(":");\n+    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n+    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n+    for (int i = index2 + 1; i < filter.length(); i++) {\n+      if (filter.charAt(i) == \'1\') keys[i] = true;\n+      else keys[i] = false;\n     }\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n-    * length for the bit vector.\n-    *\n-    * @param numKeys The length of the bit vector.\n-    */\n-    public BloomFilter(int numKeys) {\n-        this(numKeys, 10);\n+  /**\n+   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n+   * error rate.\n+   *\n+   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n+   */\n+  public BloomFilter(int numKeys, double errorRate) {\n+    this();\n+    double lowest_m = Double.MAX_VALUE;\n+    int best_k = 1;\n+    for (int k = 1; k <= 100; k++) {\n+      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+      if (m < lowest_m) {\n+        lowest_m = m;\n+        best_k = k;\n+      }\n     }\n+    this.keys = new boolean[numKeys];\n+    this.numFunctions = best_k;\n+    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n-    * the bit vector.\n-    *\n-    * @param numKeys The length of the bit vector.\n-    * @param numHashFunctions The number of hash functions.\n-    */\n-    public BloomFilter(int numKeys, int numHashFunctions) {\n-        this();\n-        this.keys = new boolean[numKeys];\n-        this.numFunctions = numHashFunctions;\n-        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n-    }\n+  /**\n+   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n+   * length for the bit vector.\n+   *\n+   * @param numKeys The length of the bit vector.\n+   */\n+  public BloomFilter(int numKeys) {\n+    this(numKeys, 10);\n+  }\n \n-    /**\n-    * Internal method for producing the hash value for a given function number.\n-    *\n-    * @param fnum The number of the hash function.\n-    * @param original The original value for the hash of the object.\n-    * @see java.lang.Object#hashCode()\n-    * @return Returns the hash code value for the given function number.\n-    */\n-    private int getHash(int fnum, int original) {\n-        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n-        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n-        int hash[] = {original};\n-        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n-        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n-        hash[0] = hash[0] % keys.length;\n-        if (hash[0] < 0) hash[0] = -hash[0];\n-        return hash[0];\n-    }\n+  /**\n+   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n+   * the bit vector.\n+   *\n+   * @param numKeys The length of the bit vector.\n+   * @param numHashFunctions The number of hash functions.\n+   */\n+  public BloomFilter(int numKeys, int numHashFunctions) {\n+    this();\n+    this.keys = new boolean[numKeys];\n+    this.numFunctions = numHashFunctions;\n+    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Returns true if this Bloom Filter contains the specified key.\n-    *\n-    * @param obj The key whose presence in this Bloom Filter is to be tested.\n-    * @return true if this Bloom Filter contains a mapping for the specified key.\n-    */\n-    public boolean hasKey(Object obj) {\n-        boolean result = true;\n-        int hashCodeObject;\n-        if (!useRabin) hashCodeObject = obj.hashCode();\n-        else\n-            try {\n-                hashCodeObject = hashRabin(obj);\n-            } catch (Exception e) {\n-                useRabin = false;\n-                hashCodeObject = obj.hashCode();\n-            }\n-        for (int i = 0; i < numFunctions && result; i++) {\n-            result &= keys[getHash(i, hashCodeObject)];\n-        }\n-        return result;\n-    }\n+  /**\n+   * Internal method for producing the hash value for a given function number.\n+   *\n+   * @param fnum The number of the hash function.\n+   * @param original The original value for the hash of the object.\n+   * @see java.lang.Object#hashCode()\n+   * @return Returns the hash code value for the given function number.\n+   */\n+  private int getHash(int fnum, int original) {\n+    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n+    int hash[] = {original};\n+    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n+    hash[0] = hash[0] % keys.length;\n+    if (hash[0] < 0) hash[0] = -hash[0];\n+    return hash[0];\n+  }\n \n-    /**\n-    * Adds the specified key in this Bloom Filter.\n-    *\n-    * @param obj The key to be added to this Bloom Filter.\n-    */\n-    public void put(Object obj) {\n-        int hashCodeObject;\n-        if (!useRabin) hashCodeObject = obj.hashCode();\n-        else\n-            try {\n-                hashCodeObject = hashRabin(obj);\n-            } catch (Exception e) {\n-                useRabin = false;\n-                hashCodeObject = obj.hashCode();\n-            }\n-        for (int i = 0; i < numFunctions; i++) {\n-            keys[getHash(i, hashCodeObject)] = true;\n-        }\n+  /**\n+   * Returns true if this Bloom Filter contains the specified key.\n+   *\n+   * @param obj The key whose presence in this Bloom Filter is to be tested.\n+   * @return true if this Bloom Filter contains a mapping for the specified key.\n+   */\n+  public boolean hasKey(Object obj) {\n+    boolean result = true;\n+    int hashCodeObject;\n+    if (!useRabin) hashCodeObject = obj.hashCode();\n+    else\n+      try {\n+        hashCodeObject = hashRabin(obj);\n+      } catch (Exception e) {\n+        useRabin = false;\n+        hashCodeObject = obj.hashCode();\n+      }\n+    for (int i = 0; i < numFunctions && result; i++) {\n+      result &= keys[getHash(i, hashCodeObject)];\n     }\n+    return result;\n+  }\n \n-    /**\n-    * Returns a string representation of this Bloom Filter. The string representation consists of an\n-    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n-    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n-    * the character ":".\n-    *\n-    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n-    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n-    * returned.\n-    *\n-    * @return A string representation of this Bloom Filter.\n-    */\n-    public String toString() {\n-        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n-        for (int i = 0; i < keys.length; i++) {\n-            if (keys[i]) aux.append("1");\n-            else aux.append("0");\n-        }\n-        return aux.toString();\n+  /**\n+   * Adds the specified key in this Bloom Filter.\n+   *\n+   * @param obj The key to be added to this Bloom Filter.\n+   */\n+  public void put(Object obj) {\n+    int hashCodeObject;\n+    if (!useRabin) hashCodeObject = obj.hashCode();\n+    else\n+      try {\n+        hashCodeObject = hashRabin(obj);\n+      } catch (Exception e) {\n+        useRabin = false;\n+        hashCodeObject = obj.hashCode();\n+      }\n+    for (int i = 0; i < numFunctions; i++) {\n+      keys[getHash(i, hashCodeObject)] = true;\n     }\n+  }\n \n-    /**\n-    * Returns a copy of this Bloom Filter instance.\n-    *\n-    * @see java.lang.Object#clone()\n-    */\n-    public Object clone() {\n-        return new BloomFilter(this.toString());\n+  /**\n+   * Returns a string representation of this Bloom Filter. The string representation consists of an\n+   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n+   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n+   * the character ":".\n+   *\n+   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n+   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n+   * returned.\n+   *\n+   * @return A string representation of this Bloom Filter.\n+   */\n+  public String toString() {\n+    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n+    for (int i = 0; i < keys.length; i++) {\n+      if (keys[i]) aux.append("1");\n+      else aux.append("0");\n     }\n+    return aux.toString();\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of bytes.\n-    *\n-    * @param arr An array of bytes.\n-    * @return The Rabin hash value for the array of bytes.\n-    */\n-    public int hashRabin(byte[] arr) {\n-        return hashRabin(arr, 0, arr.length, 0);\n-    }\n+  /**\n+   * Returns a copy of this Bloom Filter instance.\n+   *\n+   * @see java.lang.Object#clone()\n+   */\n+  public Object clone() {\n+    return new BloomFilter(this.toString());\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of bytes.\n-    *\n-    * @param arr An array of bytes.\n-    * @param offset Index of the first byte of the array to hash.\n-    * @param length Number of bytes to hash.\n-    * @param ws ??\n-    * @return The Rabin hash value for the array of bytes.\n-    */\n-    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n-        int w = ws;\n-        int start = length % 4;\n-        for (int s = offset; s < offset + start; s++) {\n-            w = (w << 8) ^ (arr[s] & 0xFF);\n-        }\n-        for (int s = start + offset; s < length + offset; s += 4) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ (arr[s] << 24)\n-                            ^ ((arr[s + 1] & 0xFF) << 16)\n-                            ^ ((arr[s + 2] & 0xFF) << 8)\n-                            ^ (arr[s + 3] & 0xFF);\n-        }\n-        return w;\n-    }\n+  /**\n+   * Return the Rabin hash value of an array of bytes.\n+   *\n+   * @param arr An array of bytes.\n+   * @return The Rabin hash value for the array of bytes.\n+   */\n+  public int hashRabin(byte[] arr) {\n+    return hashRabin(arr, 0, arr.length, 0);\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of chars.\n-    *\n-    * @param arr An array of chars.\n-    * @return The Rabin hash value for the array of chars.\n-    */\n-    public int hashRabin(char[] arr) {\n-        int w = 0;\n-        int start = 0;\n-        if (arr.length % 2 == 1) {\n-            w = arr[0] & 0xFFFF;\n-            start = 1;\n-        }\n-        for (int s = start; s < arr.length; s += 2) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ ((arr[s] & 0xFFFF) << 16)\n-                            ^ (arr[s + 1] & 0xFFFF);\n-        }\n-        return w;\n+  /**\n+   * Return the Rabin hash value of an array of bytes.\n+   *\n+   * @param arr An array of bytes.\n+   * @param offset Index of the first byte of the array to hash.\n+   * @param length Number of bytes to hash.\n+   * @param ws ??\n+   * @return The Rabin hash value for the array of bytes.\n+   */\n+  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n+    int w = ws;\n+    int start = length % 4;\n+    for (int s = offset; s < offset + start; s++) {\n+      w = (w << 8) ^ (arr[s] & 0xFF);\n     }\n-\n-    /**\n-    * Computes the Rabin hash value of the contents of a <code>File</code>.\n-    *\n-    * @param f A <code>File</code>.\n-    * @return The Rabin hash value for the contents of the File.\n-    * @throws FileNotFoundException If the file cannot be found.\n-    * @throws IOException If an error occurs while reading the file.\n-    */\n-    public int hashRabin(File f) throws FileNotFoundException, IOException {\n-        FileInputStream fis = new FileInputStream(f);\n-        try {\n-            return hashRabin(fis);\n-        } finally {\n-            fis.close();\n-        }\n+    for (int s = start + offset; s < length + offset; s += 4) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ (arr[s] << 24)\n+              ^ ((arr[s + 1] & 0xFF) << 16)\n+              ^ ((arr[s + 2] & 0xFF) << 8)\n+              ^ (arr[s + 3] & 0xFF);\n     }\n+    return w;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n-    *\n-    * @param is An InputStream.\n-    * @return The Rabin hash value for the contents read from the InputStream.\n-    * @throws IOException if an error occurs while reading from the InputStream.\n-    */\n-    public int hashRabin(InputStream is) throws IOException {\n-        int hashValue = 0;\n-        int bytesRead;\n-        synchronized (buffer) {\n-            while ((bytesRead = is.read(buffer)) > 0) {\n-                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n-            }\n-        }\n-        return hashValue;\n+  /**\n+   * Return the Rabin hash value of an array of chars.\n+   *\n+   * @param arr An array of chars.\n+   * @return The Rabin hash value for the array of chars.\n+   */\n+  public int hashRabin(char[] arr) {\n+    int w = 0;\n+    int start = 0;\n+    if (arr.length % 2 == 1) {\n+      w = arr[0] & 0xFFFF;\n+      start = 1;\n     }\n+    for (int s = start; s < arr.length; s += 2) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ ((arr[s] & 0xFFFF) << 16)\n+              ^ (arr[s + 1] & 0xFFFF);\n+    }\n+    return w;\n+  }\n \n-    /**\n-    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n-    * the hash methods, so it should be used when possible.\n-    *\n-    * @param arr An array of integers.\n-    * @return int The Rabin hash value for the array of integers.\n-    */\n-    public int hashRabin(int[] arr) {\n-        int w = 0;\n-        for (int s = 0; s < arr.length; s++) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ arr[s];\n-        }\n-        return w;\n+  /**\n+   * Computes the Rabin hash value of the contents of a <code>File</code>.\n+   *\n+   * @param f A <code>File</code>.\n+   * @return The Rabin hash value for the contents of the File.\n+   * @throws FileNotFoundException If the file cannot be found.\n+   * @throws IOException If an error occurs while reading the file.\n+   */\n+  public int hashRabin(File f) throws FileNotFoundException, IOException {\n+    FileInputStream fis = new FileInputStream(f);\n+    try {\n+      return hashRabin(fis);\n+    } finally {\n+      fis.close();\n     }\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a given Object.\n-    *\n-    * @param obj An Object.\n-    * @return The Rabin hash value for the Object.\n-    * @throws IOException If Object serialization fails.\n-    */\n-    public int hashRabin(Object obj) throws IOException {\n-        return hashRabin((Serializable) obj);\n+  /**\n+   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+   *\n+   * @param is An InputStream.\n+   * @return The Rabin hash value for the contents read from the InputStream.\n+   * @throws IOException if an error occurs while reading from the InputStream.\n+   */\n+  public int hashRabin(InputStream is) throws IOException {\n+    int hashValue = 0;\n+    int bytesRead;\n+    synchronized (buffer) {\n+      while ((bytesRead = is.read(buffer)) > 0) {\n+        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+      }\n     }\n+    return hashValue;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a given serializable Object.\n-    *\n-    * @param obj An Object.\n-    * @return The Rabin hash value for the Object.\n-    * @throws IOException If serialization fails.\n-    */\n-    public int hashRabin(Serializable obj) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = null;\n-        try {\n-            oos = new ObjectOutputStream(baos);\n-            oos.writeObject(obj);\n-            return hashRabin(baos.toByteArray());\n-        } finally {\n-            oos.close();\n-            baos.close();\n-            oos = null;\n-            baos = null;\n-        }\n+  /**\n+   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n+   * the hash methods, so it should be used when possible.\n+   *\n+   * @param arr An array of integers.\n+   * @return int The Rabin hash value for the array of integers.\n+   */\n+  public int hashRabin(int[] arr) {\n+    int w = 0;\n+    for (int s = 0; s < arr.length; s++) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ arr[s];\n     }\n+    return w;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a String.\n-    *\n-    * @param s A <code>String</code>.\n-    * @return The Rabin hash value for the String.\n-    */\n-    public int hashRabin(String s) {\n-        return hashRabin(s.toCharArray());\n+  /**\n+   * Computes the Rabin hash value of a given Object.\n+   *\n+   * @param obj An Object.\n+   * @return The Rabin hash value for the Object.\n+   * @throws IOException If Object serialization fails.\n+   */\n+  public int hashRabin(Object obj) throws IOException {\n+    return hashRabin((Serializable) obj);\n+  }\n+\n+  /**\n+   * Computes the Rabin hash value of a given serializable Object.\n+   *\n+   * @param obj An Object.\n+   * @return The Rabin hash value for the Object.\n+   * @throws IOException If serialization fails.\n+   */\n+  public int hashRabin(Serializable obj) throws IOException {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    ObjectOutputStream oos = null;\n+    try {\n+      oos = new ObjectOutputStream(baos);\n+      oos.writeObject(obj);\n+      return hashRabin(baos.toByteArray());\n+    } finally {\n+      oos.close();\n+      baos.close();\n+      oos = null;\n+      baos = null;\n     }\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n-    *\n-    * @param url The URL of the document to be hashed.\n-    * @return The Rabin hash value for the document.\n-    * @throws IOException If an error occurs while reading the document.\n-    */\n-    public int hashRabin(URL url) throws IOException {\n-        InputStream is = url.openStream();\n-        try {\n-            return hashRabin(is);\n-        } finally {\n-            is.close();\n-        }\n+  /**\n+   * Computes the Rabin hash value of a String.\n+   *\n+   * @param s A <code>String</code>.\n+   * @return The Rabin hash value for the String.\n+   */\n+  public int hashRabin(String s) {\n+    return hashRabin(s.toCharArray());\n+  }\n+\n+  /**\n+   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n+   *\n+   * @param url The URL of the document to be hashed.\n+   * @return The Rabin hash value for the document.\n+   * @throws IOException If an error occurs while reading the document.\n+   */\n+  public int hashRabin(URL url) throws IOException {\n+    InputStream is = url.openStream();\n+    try {\n+      return hashRabin(is);\n+    } finally {\n+      is.close();\n     }\n+  }\n }',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n *\n * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n * can make a useful tool.\n *\n * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n * checkers.\n *\n * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n * vector of a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are willing to\n * put up with.\n *\n * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.\n *\n * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n * a Bloom filter.\n *\n * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n * key. We run the key through our set of hash functions, and then check to see whether the bits at\n * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n * the filter. If all of the bits are on, we know the key is probably there.\n *\n * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n * bits we check will be on, unless the key actually exists in the filter. The relationship between\n * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n * will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:\n *\n * <p><code>c = ( 1 - e(-kn/m) )k</code>\n *\n * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n * in the filter, and m is the length of the filter in bits.\n *\n * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n * our limit. The following equation will give us vector length from the error rate and number of\n * keys:\n *\n * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n *\n * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n * combinations of error rate, filter size, and number of hash functions at <a\n * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n * -- the math</a>.\n *\n * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n * the case of JDK 1.4).\n *\n * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n * even in this Java implementation the speed is reasonable.\n *\n * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a\n * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.\n *\n * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n * <code>URL</code>.\n *\n * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n *\n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n * @author Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n  /** A buffer for the Rabin fingerprinting algorithm. */\n  private byte[] buffer;\n\n  /**\n   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n   * bit is the constant coefficient.\n   *\n   * <p>For example the integer 0x00000803, in binary, is:\n   *\n   * <p><code>00000000 00000000 00001000 00000011</code>\n   *\n   * <p>Therefore it correponds to the polynomial:\n   *\n   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n   */\n  private static int POLYNOMIAL = 0x000001C7;\n\n  /** Internal values for the Rabin fingerprinting algorithm. */\n  private static int[] table32, table40, table48, table54;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int P_DEGREE = 32;\n\n  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n  private static int READ_BUFFER_SIZE = 2048;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n  /** The bit vector for the Bloom Filter. */\n  private boolean keys[];\n\n  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n  private boolean useRabin = true;\n\n  /** The number of hash functions. */\n  private int numFunctions;\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n   * length for the bit vector (1000).\n   */\n  public BloomFilter() {\n    table32 = new int[256];\n    table40 = new int[256];\n    table48 = new int[256];\n    table54 = new int[256];\n    buffer = new byte[READ_BUFFER_SIZE];\n    // We want to have mods[i] == x^(P_DEGREE+i)\n    int[] mods = new int[P_DEGREE];\n    mods[0] = POLYNOMIAL;\n    for (int i = 1; i < P_DEGREE; i++) {\n      // x^i == x(x^(i-1)) (mod P)\n      mods[i] = mods[i - 1] << 1;\n      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n      // x^P_DEGREE term that \'fell off\' the top end.\n      // Since x^P_DEGREE == P (mod P), we should add P\n      // to account for this:\n      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n        mods[i] ^= POLYNOMIAL;\n      }\n    }\n    for (int i = 0; i < 256; i++) {\n      int c = i;\n      for (int j = 0; j < 8 && c != 0; j++) {\n        if ((c & 1) != 0) {\n          table32[i] ^= mods[j];\n          table40[i] ^= mods[j + 8];\n          table48[i] ^= mods[j + 16];\n          table54[i] ^= mods[j + 24];\n        }\n        c >>>= 1;\n      }\n    }\n    mods = null;\n    this.keys = new boolean[1000];\n    this.numFunctions = 10;\n    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs a Bloom Filter from a string representation.\n   *\n   * @see #toString()\n   */\n  public BloomFilter(String filter) {\n    this();\n    int index1 = filter.indexOf(":");\n    int index2 = filter.lastIndexOf(":");\n    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n    for (int i = index2 + 1; i < filter.length(); i++) {\n      if (filter.charAt(i) == \'1\') keys[i] = true;\n      else keys[i] = false;\n    }\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n   * error rate.\n   *\n   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n   */\n  public BloomFilter(int numKeys, double errorRate) {\n    this();\n    double lowest_m = Double.MAX_VALUE;\n    int best_k = 1;\n    for (int k = 1; k <= 100; k++) {\n      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n      if (m < lowest_m) {\n        lowest_m = m;\n        best_k = k;\n      }\n    }\n    this.keys = new boolean[numKeys];\n    this.numFunctions = best_k;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n   * length for the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   */\n  public BloomFilter(int numKeys) {\n    this(numKeys, 10);\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n   * the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   * @param numHashFunctions The number of hash functions.\n   */\n  public BloomFilter(int numKeys, int numHashFunctions) {\n    this();\n    this.keys = new boolean[numKeys];\n    this.numFunctions = numHashFunctions;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Internal method for producing the hash value for a given function number.\n   *\n   * @param fnum The number of the hash function.\n   * @param original The original value for the hash of the object.\n   * @see java.lang.Object#hashCode()\n   * @return Returns the hash code value for the given function number.\n   */\n  private int getHash(int fnum, int original) {\n    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n    int hash[] = {original};\n    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n    hash[0] = hash[0] % keys.length;\n    if (hash[0] < 0) hash[0] = -hash[0];\n    return hash[0];\n  }\n\n  /**\n   * Returns true if this Bloom Filter contains the specified key.\n   *\n   * @param obj The key whose presence in this Bloom Filter is to be tested.\n   * @return true if this Bloom Filter contains a mapping for the specified key.\n   */\n  public boolean hasKey(Object obj) {\n    boolean result = true;\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions && result; i++) {\n      result &= keys[getHash(i, hashCodeObject)];\n    }\n    return result;\n  }\n\n  /**\n   * Adds the specified key in this Bloom Filter.\n   *\n   * @param obj The key to be added to this Bloom Filter.\n   */\n  public void put(Object obj) {\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions; i++) {\n      keys[getHash(i, hashCodeObject)] = true;\n    }\n  }\n\n  /**\n   * Returns a string representation of this Bloom Filter. The string representation consists of an\n   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n   * the character ":".\n   *\n   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n   * returned.\n   *\n   * @return A string representation of this Bloom Filter.\n   */\n  public String toString() {\n    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n    for (int i = 0; i < keys.length; i++) {\n      if (keys[i]) aux.append("1");\n      else aux.append("0");\n    }\n    return aux.toString();\n  }\n\n  /**\n   * Returns a copy of this Bloom Filter instance.\n   *\n   * @see java.lang.Object#clone()\n   */\n  public Object clone() {\n    return new BloomFilter(this.toString());\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @return The Rabin hash value for the array of bytes.\n   */\n  public int hashRabin(byte[] arr) {\n    return hashRabin(arr, 0, arr.length, 0);\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @param offset Index of the first byte of the array to hash.\n   * @param length Number of bytes to hash.\n   * @param ws ??\n   * @return The Rabin hash value for the array of bytes.\n   */\n  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n    int w = ws;\n    int start = length % 4;\n    for (int s = offset; s < offset + start; s++) {\n      w = (w << 8) ^ (arr[s] & 0xFF);\n    }\n    for (int s = start + offset; s < length + offset; s += 4) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ (arr[s] << 24)\n              ^ ((arr[s + 1] & 0xFF) << 16)\n              ^ ((arr[s + 2] & 0xFF) << 8)\n              ^ (arr[s + 3] & 0xFF);\n    }\n    return w;\n  }\n\n  /**\n   * Return the Rabin hash value of an array of chars.\n   *\n   * @param arr An array of chars.\n   * @return The Rabin hash value for the array of chars.\n   */\n  public int hashRabin(char[] arr) {\n    int w = 0;\n    int start = 0;\n    if (arr.length % 2 == 1) {\n      w = arr[0] & 0xFFFF;\n      start = 1;\n    }\n    for (int s = start; s < arr.length; s += 2) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ ((arr[s] & 0xFFFF) << 16)\n              ^ (arr[s + 1] & 0xFFFF);\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a <code>File</code>.\n   *\n   * @param f A <code>File</code>.\n   * @return The Rabin hash value for the contents of the File.\n   * @throws FileNotFoundException If the file cannot be found.\n   * @throws IOException If an error occurs while reading the file.\n   */\n  public int hashRabin(File f) throws FileNotFoundException, IOException {\n    FileInputStream fis = new FileInputStream(f);\n    try {\n      return hashRabin(fis);\n    } finally {\n      fis.close();\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n   *\n   * @param is An InputStream.\n   * @return The Rabin hash value for the contents read from the InputStream.\n   * @throws IOException if an error occurs while reading from the InputStream.\n   */\n  public int hashRabin(InputStream is) throws IOException {\n    int hashValue = 0;\n    int bytesRead;\n    synchronized (buffer) {\n      while ((bytesRead = is.read(buffer)) > 0) {\n        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n      }\n    }\n    return hashValue;\n  }\n\n  /**\n   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n   * the hash methods, so it should be used when possible.\n   *\n   * @param arr An array of integers.\n   * @return int The Rabin hash value for the array of integers.\n   */\n  public int hashRabin(int[] arr) {\n    int w = 0;\n    for (int s = 0; s < arr.length; s++) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ arr[s];\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of a given Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If Object serialization fails.\n   */\n  public int hashRabin(Object obj) throws IOException {\n    return hashRabin((Serializable) obj);\n  }\n\n  /**\n   * Computes the Rabin hash value of a given serializable Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If serialization fails.\n   */\n  public int hashRabin(Serializable obj) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = null;\n    try {\n      oos = new ObjectOutputStream(baos);\n      oos.writeObject(obj);\n      return hashRabin(baos.toByteArray());\n    } finally {\n      oos.close();\n      baos.close();\n      oos = null;\n      baos = null;\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of a String.\n   *\n   * @param s A <code>String</code>.\n   * @return The Rabin hash value for the String.\n   */\n  public int hashRabin(String s) {\n    return hashRabin(s.toCharArray());\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n   *\n   * @param url The URL of the document to be hashed.\n   * @return The Rabin hash value for the document.\n   * @throws IOException If an error occurs while reading the document.\n   */\n  public int hashRabin(URL url) throws IOException {\n    InputStream is = url.openStream();\n    try {\n      return hashRabin(is);\n    } finally {\n      is.close();\n    }\n  }\n}\n'
          },
          {
            sha: "3be706f1ea9ded9a332de32c31f99eedf4652de0",
            filename:
              "src/main/java/refactoring/crawler/shingles/DefaultStrategy.java",
            status: "modified",
            additions: 16,
            deletions: 16,
            patch:
              "@@ -3,23 +3,23 @@\n /** @author Can Comertoglu */\n public class DefaultStrategy implements ShinglesStrategy {\n \n-    /** */\n-    public DefaultStrategy() {\n-        super();\n-    }\n+  /** */\n+  public DefaultStrategy() {\n+    super();\n+  }\n \n-    /* (non-Javadoc)\n-    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-    */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base;\n-    }\n+  /* (non-Javadoc)\n+   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+   */\n+  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+    return s_base;\n+  }\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base;\n-    }\n+  public int upperBoundForClassShingles(int numMethods, int s_base) {\n+    return s_base;\n+  }\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base;\n-    }\n+  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+    return s_base;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n  /** */\n  public DefaultStrategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base;\n  }\n}\n"
          },
          {
            sha: "55e796c451fb63675bae1000f41dd15b720bbb42",
            filename:
              "src/main/java/refactoring/crawler/shingles/FactorOf2Strategy.java",
            status: "modified",
            additions: 17,
            deletions: 17,
            patch:
              "@@ -2,24 +2,24 @@\n \n public class FactorOf2Strategy implements ShinglesStrategy {\n \n-    /** */\n-    public FactorOf2Strategy() {\n-        super();\n-    }\n+  /** */\n+  public FactorOf2Strategy() {\n+    super();\n+  }\n \n-    /* (non-Javadoc)\n-    * @Override\n-    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-    */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base + (2 * loc);\n-    }\n+  /* (non-Javadoc)\n+   * @Override\n+   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+   */\n+  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+    return s_base + (2 * loc);\n+  }\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base + (2 * numMethods);\n-    }\n+  public int upperBoundForClassShingles(int numMethods, int s_base) {\n+    return s_base + (2 * numMethods);\n+  }\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base + (2 * numClasses);\n-    }\n+  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+    return s_base + (2 * numClasses);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n  /** */\n  public FactorOf2Strategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @Override\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base + (2 * loc);\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base + (2 * numMethods);\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base + (2 * numClasses);\n  }\n}\n"
          },
          {
            sha: "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesStrategy.java",
            status: "modified",
            additions: 3,
            deletions: 3,
            patch:
              "@@ -1,9 +1,9 @@\n package refactoring.crawler.shingles;\n \n public interface ShinglesStrategy {\n-    int upperBoundLimitForShinglesBag(int loc, int s_base);\n+  int upperBoundLimitForShinglesBag(int loc, int s_base);\n \n-    int upperBoundForClassShingles(int numMethods, int s_base);\n+  int upperBoundForClassShingles(int numMethods, int s_base);\n \n-    int upperBoundForPackageShingles(int numClasses, int s_base);\n+  int upperBoundForPackageShingles(int numClasses, int s_base);\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n  int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n  int upperBoundForClassShingles(int numMethods, int s_base);\n\n  int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "0418f0db4600a32e90aa4732194cd3215844cb06",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 260,
            deletions: 260,
            patch:
              '@@ -11,291 +11,291 @@\n \n public class ShinglesUtil {\n \n-    private int w = 2;\n-    private int sClass = 10;\n-    private int sMethod = 8;\n-    private double classThreshold = 0.0;\n+  private int w = 2;\n+  private int sClass = 10;\n+  private int sMethod = 8;\n+  private double classThreshold = 0.0;\n \n-    @Getter @Setter private double methodThreshold = 0.0;\n+  @Getter @Setter private double methodThreshold = 0.0;\n \n-    private ShinglesStrategy shinglesStrategy;\n+  private ShinglesStrategy shinglesStrategy;\n \n-    private NamedDirectedMultigraph oldVersionGraph;\n+  private NamedDirectedMultigraph oldVersionGraph;\n \n-    private NamedDirectedMultigraph newVersionGraph;\n+  private NamedDirectedMultigraph newVersionGraph;\n \n-    private List<Node[]> similarMethods = new LinkedList<>();\n-    private List<Node[]> similarClasses = new LinkedList<>();\n+  private List<Node[]> similarMethods = new LinkedList<>();\n+  private List<Node[]> similarClasses = new LinkedList<>();\n \n-    private List<Node> oldVersionPackageList;\n-    private List<Node> oldVersionClassList;\n-    private List<Node> oldVersionMethodList;\n-    private List<Node> oldVersionFieldList;\n+  private List<Node> oldVersionPackageList;\n+  private List<Node> oldVersionClassList;\n+  private List<Node> oldVersionMethodList;\n+  private List<Node> oldVersionFieldList;\n \n-    private List<Node> newVersionPackageList;\n-    private List<Node> newVersionClassList;\n-    private List<Node> newVersionMethodList;\n-    private List<Node> newVersionFieldList;\n+  private List<Node> newVersionPackageList;\n+  private List<Node> newVersionClassList;\n+  private List<Node> newVersionMethodList;\n+  private List<Node> newVersionFieldList;\n \n-    public ShinglesUtil() {\n-        this.shinglesStrategy = new DefaultStrategy();\n-        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n-    }\n-\n-    public List<String> tokenizer(String s) {\n-        List<String> list = new ArrayList<>();\n-        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n-        while (st.hasMoreElements()) {\n-            list.add(st.nextToken());\n-        }\n-        return list;\n-    }\n+  public ShinglesUtil() {\n+    this.shinglesStrategy = new DefaultStrategy();\n+    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+  }\n \n-    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n-\n-        List<List<String>> bagOfTokensList = new ArrayList<>();\n-        ListIterator<String> iter = tokenList.listIterator();\n-        while (iter.nextIndex() <= (tokenList.size() - w))\n-        // W=2, iterIndex = size - W identifies the last window\n-        {\n-            List<String> tempList = new ArrayList<>();\n-            for (int i = 1; i <= w; i++) // W=3\n-            {\n-                tempList.add(iter.next());\n-            }\n-            bagOfTokensList.add(tempList);\n-            for (int i = 1; i <= w - 1; i++)\n-                // i<= W-1\n-                iter.previous();\n-        }\n-        return bagOfTokensList;\n+  public List<String> tokenizer(String s) {\n+    List<String> list = new ArrayList<>();\n+    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+    while (st.hasMoreElements()) {\n+      list.add(st.nextToken());\n     }\n-\n-    private int findNumberOfLines(String str) {\n-        int retval = 0;\n-        char[] c = str.toCharArray();\n-        for (char value : c) {\n-            if (value == \'\\n\') retval++;\n-        }\n-        return retval;\n+    return list;\n+  }\n+\n+  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+    List<List<String>> bagOfTokensList = new ArrayList<>();\n+    ListIterator<String> iter = tokenList.listIterator();\n+    while (iter.nextIndex() <= (tokenList.size() - w))\n+    // W=2, iterIndex = size - W identifies the last window\n+    {\n+      List<String> tempList = new ArrayList<>();\n+      for (int i = 1; i <= w; i++) // W=3\n+      {\n+        tempList.add(iter.next());\n+      }\n+      bagOfTokensList.add(tempList);\n+      for (int i = 1; i <= w - 1; i++)\n+        // i<= W-1\n+        iter.previous();\n     }\n-\n-    public int[] computeMethodShingles(String str) {\n-        return computeMethodShingles(\n-                str,\n-                w,\n-                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+    return bagOfTokensList;\n+  }\n+\n+  private int findNumberOfLines(String str) {\n+    int retval = 0;\n+    char[] c = str.toCharArray();\n+    for (char value : c) {\n+      if (value == \'\\n\') retval++;\n     }\n-\n-    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n-        /*\n-        * We are now introducing the idea of finding the number of lines in the\n-        * method, and incorporate that into the calculation of shingles, so\n-        * that, if there are more lines, then there are going to be more\n-        * shingles associated with the method. However, a 1-1 correspondance\n-        * will be misleading, thus another method is required.\n-        */\n-        BloomFilter bloomFilter = new BloomFilter();\n-        List<String> tokenList = tokenizer(str);\n-        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n-\n-        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n-        int numberOfWindowedTokens = 0;\n-\n-        for (List<String> tempList : bagOfWindowedTokens) {\n-            StringBuilder tokensInOneWindow = new StringBuilder();\n-            for (int i = 0; i < window; i++) {\n-                tokensInOneWindow.append(tempList.get(i));\n-                if (i != window - 1) tokensInOneWindow.append(" ");\n-            }\n-            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n-            shinglesValues[numberOfWindowedTokens] = shingle;\n-            numberOfWindowedTokens++;\n-        }\n-\n-        Arrays.sort(shinglesValues);\n-\n-        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n-\n-        int[] retVal = new int[correctNumberOfShingles];\n-        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n-        return retVal;\n+    return retval;\n+  }\n+\n+  public int[] computeMethodShingles(String str) {\n+    return computeMethodShingles(\n+        str,\n+        w,\n+        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+  }\n+\n+  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+    /*\n+     * We are now introducing the idea of finding the number of lines in the\n+     * method, and incorporate that into the calculation of shingles, so\n+     * that, if there are more lines, then there are going to be more\n+     * shingles associated with the method. However, a 1-1 correspondance\n+     * will be misleading, thus another method is required.\n+     */\n+    BloomFilter bloomFilter = new BloomFilter();\n+    List<String> tokenList = tokenizer(str);\n+    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+    int numberOfWindowedTokens = 0;\n+\n+    for (List<String> tempList : bagOfWindowedTokens) {\n+      StringBuilder tokensInOneWindow = new StringBuilder();\n+      for (int i = 0; i < window; i++) {\n+        tokensInOneWindow.append(tempList.get(i));\n+        if (i != window - 1) tokensInOneWindow.append(" ");\n+      }\n+      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+      shinglesValues[numberOfWindowedTokens] = shingle;\n+      numberOfWindowedTokens++;\n     }\n \n-    public void initialize(\n-            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n-        this.oldVersionGraph = oldVersionGraph;\n-        this.newVersionGraph = newVersionGraph;\n-\n-        this.oldVersionPackageList = new ArrayList<>();\n-        this.oldVersionClassList = new ArrayList<>();\n-        this.oldVersionMethodList = new ArrayList<>();\n-        this.oldVersionFieldList = new ArrayList<>();\n-\n-        this.newVersionPackageList = new ArrayList<>();\n-        this.newVersionClassList = new ArrayList<>();\n-        this.newVersionMethodList = new ArrayList<>();\n-        this.newVersionFieldList = new ArrayList<>();\n-\n-        initializeElementsLists(\n-                oldVersionGraph,\n-                oldVersionMethodList,\n-                oldVersionClassList,\n-                oldVersionPackageList,\n-                oldVersionFieldList);\n-\n-        initializeElementsLists(\n-                newVersionGraph,\n-                newVersionMethodList,\n-                newVersionClassList,\n-                newVersionPackageList,\n-                newVersionFieldList);\n+    Arrays.sort(shinglesValues);\n+\n+    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n+\n+    int[] retVal = new int[correctNumberOfShingles];\n+    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+    return retVal;\n+  }\n+\n+  public void initialize(\n+      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+    this.oldVersionGraph = oldVersionGraph;\n+    this.newVersionGraph = newVersionGraph;\n+\n+    this.oldVersionPackageList = new ArrayList<>();\n+    this.oldVersionClassList = new ArrayList<>();\n+    this.oldVersionMethodList = new ArrayList<>();\n+    this.oldVersionFieldList = new ArrayList<>();\n+\n+    this.newVersionPackageList = new ArrayList<>();\n+    this.newVersionClassList = new ArrayList<>();\n+    this.newVersionMethodList = new ArrayList<>();\n+    this.newVersionFieldList = new ArrayList<>();\n+\n+    initializeElementsLists(\n+        oldVersionGraph,\n+        oldVersionMethodList,\n+        oldVersionClassList,\n+        oldVersionPackageList,\n+        oldVersionFieldList);\n+\n+    initializeElementsLists(\n+        newVersionGraph,\n+        newVersionMethodList,\n+        newVersionClassList,\n+        newVersionPackageList,\n+        newVersionFieldList);\n+  }\n+\n+  private void initializeElementsLists(\n+      DirectedMultigraph<Node, Edge> graph,\n+      List<Node> methods,\n+      List<Node> classes,\n+      List<Node> packages,\n+      List<Node> fields) {\n+    // Create a BreadthFirstIterator for the graph\n+    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+    while (bfi.hasNext()) {\n+      Node n = bfi.next();\n+      if (n.getType().equals(Node.Type.CLASS)) {\n+        classes.add(n);\n+      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+        packages.add(n);\n+      } else if (n.getType().equals(Node.Type.METHOD)) {\n+        methods.add(n);\n+      } else if (n.getType().equals(Node.Type.FIELD)) {\n+        fields.add(n);\n+      }\n     }\n-\n-    private void initializeElementsLists(\n-            DirectedMultigraph<Node, Edge> graph,\n-            List<Node> methods,\n-            List<Node> classes,\n-            List<Node> packages,\n-            List<Node> fields) {\n-        // Create a BreadthFirstIterator for the graph\n-        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-        while (bfi.hasNext()) {\n-            Node n = bfi.next();\n-            if (n.getType().equals(Node.Type.CLASS)) {\n-                classes.add(n);\n-            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n-                packages.add(n);\n-            } else if (n.getType().equals(Node.Type.METHOD)) {\n-                methods.add(n);\n-            } else if (n.getType().equals(Node.Type.FIELD)) {\n-                fields.add(n);\n-            }\n+  }\n+\n+  public List<Node[]> findSimilarMethods() {\n+    if (this.similarMethods.isEmpty()) {\n+      List<Node[]> similarMethods = new ArrayList<>();\n+      for (Node m : this.oldVersionMethodList) {\n+        if (!m.isAPI()) continue;\n+\n+        for (Node m2 : this.newVersionMethodList) {\n+          if (!m2.isAPI()) continue;\n+\n+          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+            Node[] arr = {m, m2};\n+            // if (!isThisArrayInTheList(simMet, arr))\n+            similarMethods.add(arr);\n+          }\n         }\n+      }\n+      this.similarMethods = similarMethods;\n     }\n-\n-    public List<Node[]> findSimilarMethods() {\n-        if (this.similarMethods.isEmpty()) {\n-            List<Node[]> similarMethods = new ArrayList<>();\n-            for (Node m : this.oldVersionMethodList) {\n-                if (!m.isAPI()) continue;\n-\n-                for (Node m2 : this.newVersionMethodList) {\n-                    if (!m2.isAPI()) continue;\n-\n-                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-                        Node[] arr = {m, m2};\n-                        // if (!isThisArrayInTheList(simMet, arr))\n-                        similarMethods.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarMethods = similarMethods;\n+    return this.similarMethods;\n+  }\n+\n+  public double howMuchAlike(int[] arr1, int[] arr2) {\n+    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+    return finalGrade;\n+  }\n+\n+  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+    int[] tempArr = arr2.clone();\n+    double grade = 0.0;\n+    for (int value : arr1) {\n+      for (int j = 0; j < tempArr.length; j++) {\n+        if (value == tempArr[j]) {\n+          grade += 1.0 / arr1.length;\n+          tempArr[j] = Integer.MIN_VALUE;\n+          break;\n         }\n-        return this.similarMethods;\n+      }\n     }\n+    return grade;\n+  }\n+\n+  /**\n+   * @param classes\n+   * @param graph <br>\n+   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n+   *     its subtree. The parameter s_class will determine the maximum size of shingles\n+   */\n+  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+    for (Node clasz : classes) {\n+      // We will keep the number of methods for the class with the\n+      // numberOfMethods variable.\n+      int numberOfMethods = 0;\n+      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+      int methodsTotalShingleSize = 0;\n+      for (Edge e : outEdges) {\n+        Node neighbor = e.oppositeVertex(clasz);\n+        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+          methodsTotalShingleSize += neighbor.getShingles().length;\n+          // Here we update the method count.\n+          numberOfMethods++;\n+        }\n+      }\n+\n+      // fill allShinglesFromMethods with shingles from all the methods in\n+      // the class\n+      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+      int index = 0;\n+      for (Edge e : outEdges) {\n+        Node neighbor = e.oppositeVertex(clasz);\n+        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+          for (int j = 0; j < neighbor.getShingles().length; j++) {\n+            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n+            index++;\n+          }\n+        }\n+      }\n \n-    public double howMuchAlike(int[] arr1, int[] arr2) {\n-        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-        return finalGrade;\n-    }\n+      int upperBoundForClassShingles =\n+          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n+      Arrays.sort(allShinglesFromMethods);\n \n-    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-        int[] tempArr = arr2.clone();\n-        double grade = 0.0;\n-        for (int value : arr1) {\n-            for (int j = 0; j < tempArr.length; j++) {\n-                if (value == tempArr[j]) {\n-                    grade += 1.0 / arr1.length;\n-                    tempArr[j] = Integer.MIN_VALUE;\n-                    break;\n-                }\n-            }\n-        }\n-        return grade;\n-    }\n+      upperBoundForClassShingles =\n+          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n \n-    /**\n-    * @param classes\n-    * @param graph <br>\n-    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n-    *     its subtree. The parameter s_class will determine the maximum size of shingles\n-    */\n-    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n-        for (Node clasz : classes) {\n-            // We will keep the number of methods for the class with the\n-            // numberOfMethods variable.\n-            int numberOfMethods = 0;\n-            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n-            int methodsTotalShingleSize = 0;\n-            for (Edge e : outEdges) {\n-                Node neighbor = e.oppositeVertex(clasz);\n-                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-                    methodsTotalShingleSize += neighbor.getShingles().length;\n-                    // Here we update the method count.\n-                    numberOfMethods++;\n-                }\n-            }\n-\n-            // fill allShinglesFromMethods with shingles from all the methods in\n-            // the class\n-            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n-            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n-            int index = 0;\n-            for (Edge e : outEdges) {\n-                Node neighbor = e.oppositeVertex(clasz);\n-                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n-                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n-                        index++;\n-                    }\n-                }\n-            }\n-\n-            int upperBoundForClassShingles =\n-                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n-            Arrays.sort(allShinglesFromMethods);\n-\n-            upperBoundForClassShingles =\n-                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n-\n-            int[] retVal = new int[upperBoundForClassShingles];\n-            if (upperBoundForClassShingles >= 0)\n-                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n-            clasz.setShingles(retVal);\n-        }\n+      int[] retVal = new int[upperBoundForClassShingles];\n+      if (upperBoundForClassShingles >= 0)\n+        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+      clasz.setShingles(retVal);\n     }\n-\n-    public List<Node[]> findSimilarClasses() {\n-        if (this.similarClasses.isEmpty()) {\n-            computeClassShingles(oldVersionClassList, oldVersionGraph);\n-            computeClassShingles(newVersionClassList, newVersionGraph);\n-            List<Node[]> simClass = new ArrayList<>();\n-            for (Node c : this.oldVersionClassList) {\n-                if (!c.isAPI()) continue;\n-\n-                for (Node c2 : this.oldVersionClassList) {\n-                    if (!c2.isAPI()) continue;\n-\n-                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n-                        Node[] arr = {c, c2};\n-                        simClass.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarClasses = simClass;\n+  }\n+\n+  public List<Node[]> findSimilarClasses() {\n+    if (this.similarClasses.isEmpty()) {\n+      computeClassShingles(oldVersionClassList, oldVersionGraph);\n+      computeClassShingles(newVersionClassList, newVersionGraph);\n+      List<Node[]> simClass = new ArrayList<>();\n+      for (Node c : this.oldVersionClassList) {\n+        if (!c.isAPI()) continue;\n+\n+        for (Node c2 : this.oldVersionClassList) {\n+          if (!c2.isAPI()) continue;\n+\n+          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+            Node[] arr = {c, c2};\n+            simClass.add(arr);\n+          }\n         }\n-        return this.similarClasses;\n+      }\n+      this.similarClasses = simClass;\n     }\n+    return this.similarClasses;\n+  }\n \n-    public List<Node[]> findPullUpMethodCandidates() {\n-        return findSimilarMethods();\n-    }\n+  public List<Node[]> findPullUpMethodCandidates() {\n+    return findSimilarMethods();\n+  }\n \n-    public List<Node[]> findPushDownMethodCandidates() {\n-        return findSimilarMethods();\n-    }\n+  public List<Node[]> findPushDownMethodCandidates() {\n+    return findSimilarMethods();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.oldVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "modified",
            additions: 18,
            deletions: 18,
            patch:
              '@@ -7,28 +7,28 @@\n \n public class RefactoringCategory {\n \n-    @Getter @Setter private String name;\n+  @Getter @Setter private String name;\n \n-    @Getter @Setter private List<Node[]> refactoringPairs;\n+  @Getter @Setter private List<Node[]> refactoringPairs;\n \n-    public Node[][] getElements() {\n-        Node[][] elements = new Node[refactoringPairs.size()][];\n-        int i = 0;\n-        for (Node[] pair : refactoringPairs) {\n-            elements[i++] = pair;\n-        }\n-        return elements;\n+  public Node[][] getElements() {\n+    Node[][] elements = new Node[refactoringPairs.size()][];\n+    int i = 0;\n+    for (Node[] pair : refactoringPairs) {\n+      elements[i++] = pair;\n     }\n+    return elements;\n+  }\n \n-    public String toString() {\n-        return name + printElements(getElements());\n-    }\n+  public String toString() {\n+    return name + printElements(getElements());\n+  }\n \n-    private String printElements(Node[][] array) {\n-        StringBuilder res = new StringBuilder();\n-        for (Node[] nodes : array) {\n-            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n-        }\n-        return res.toString();\n+  private String printElements(Node[][] array) {\n+    StringBuilder res = new StringBuilder();\n+    for (Node[] nodes : array) {\n+      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n     }\n+    return res.toString();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n  @Getter @Setter private String name;\n\n  @Getter @Setter private List<Node[]> refactoringPairs;\n\n  public Node[][] getElements() {\n    Node[][] elements = new Node[refactoringPairs.size()][];\n    int i = 0;\n    for (Node[] pair : refactoringPairs) {\n      elements[i++] = pair;\n    }\n    return elements;\n  }\n\n  public String toString() {\n    return name + printElements(getElements());\n  }\n\n  private String printElements(Node[][] array) {\n    StringBuilder res = new StringBuilder();\n    for (Node[] nodes : array) {\n      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n    }\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "15111aaeb3dee736e91cde79219e6eafa796ca62",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 323,
            deletions: 323,
            patch:
              '@@ -15,327 +15,327 @@\n \n public class SourceNavigator {\n \n-    @Getter private NamedDirectedMultigraph graph;\n-\n-    private ShinglesUtil shinglesUtil;\n-\n-    private String projectName;\n-\n-    private int packageCounter = 0;\n-\n-    private int allMethodsCounter = 0;\n-\n-    private int allClassCounter = 0;\n-\n-    private int apiClassCounter = 0;\n-\n-    private int apiMethodCounter = 0;\n-\n-    public static boolean useJavadocComments = false;\n-\n-    public SourceNavigator() {\n-        graph = new NamedDirectedMultigraph();\n-    }\n-\n-    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n-        this.shinglesUtil = shinglesUtil;\n-    }\n-\n-    public void browseProject(\n-            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n-        this.projectName = projectName;\n-        val projectNode = new Node(projectName, Node.Type.PROJECT);\n-        this.graph.addNamedVertex(projectNode);\n-        compilationUnits.forEach(\n-                cu -> {\n-                    val packageDeclaration = cu.getPackageDeclaration();\n-                    val importDeclarations = cu.getImports();\n-\n-                    val classesImported = new LinkedList<String>();\n-\n-                    importDeclarations.forEach(\n-                            importDeclaration -> {\n-                                classesImported.add(importDeclaration.getName().asString());\n-                            });\n-\n-                    if (packageDeclaration.isPresent()) {\n-                        val packageName = packageDeclaration.get().getNameAsString();\n-                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n-                        packageNode.setProjectName(projectName);\n-                        this.graph.addNamedVertex(packageNode);\n-                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-                        cu.getTypes()\n-                                .forEach(\n-                                        type -> {\n-                                            if (type.isClassOrInterfaceDeclaration()) {\n-                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n-                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n-                                                if (className.isPresent()) {\n-                                                    val classNode = new ClassNode(className.get());\n-                                                    classNode.setProjectName(projectName);\n-\n-                                                    List<String> extendedClasses =\n-                                                            classOrInterfaceDeclaration\n-                                                                    .getExtendedTypes()\n-                                                                    .stream()\n-                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n-                                                                    .collect(Collectors.toList());\n-\n-                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n-                                                    classNode.setSuperClasses(extendedClasses);\n-                                                    classNode.setClassesImported(classesImported);\n-                                                    classNode.setDeprecated(\n-                                                            classOrInterfaceDeclaration\n-                                                                    .getAnnotationByClass(Deprecated.class)\n-                                                                    .isPresent());\n-                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n-\n-                                                    this.allClassCounter += 1;\n-                                                    if (classOrInterfaceDeclaration.isProtected()\n-                                                            || classOrInterfaceDeclaration.isPublic()) {\n-                                                        classNode.setAPI(true);\n-                                                        this.apiClassCounter += 1;\n-                                                    }\n-                                                    graph.addNamedVertex(classNode);\n-                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\n-                                                    // methods\n-                                                    List<MethodDeclaration> methodDeclarations =\n-                                                            classOrInterfaceDeclaration.getMethods();\n-\n-                                                    // filed fqn -> methods fqn\n-                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n-\n-                                                    methodDeclarations.forEach(\n-                                                            method -> {\n-                                                                String statementBody = "";\n-                                                                val methodBody = method.getBody();\n-\n-                                                                if (methodBody.isPresent()) {\n-                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n-                                                                        statementBody = methodBody.get().toString().trim();\n-                                                                    } else\n-                                                                        statementBody =\n-                                                                                statementBody(methodBody.get().toString()).trim();\n-                                                                    int[] shingles =\n-                                                                            shinglesUtil.computeMethodShingles(statementBody);\n-                                                                    String qualifiedName =\n-                                                                            classNode.getFullyQualifiedName()\n-                                                                                    + "."\n-                                                                                    + method.getNameAsString();\n-                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n-\n-                                                                    List<String> methodReferencedFields =\n-                                                                            method\n-                                                                                    .findAll(FieldAccessExpr.class)\n-                                                                                    .stream()\n-                                                                                    .map(\n-                                                                                            fieldAccessExpr ->\n-                                                                                                    classNode.getFullyQualifiedName()\n-                                                                                                            + "."\n-                                                                                                            + fieldAccessExpr.resolve().getName())\n-                                                                                    .collect(Collectors.toList());\n-\n-                                                                    methodReferencedFields.forEach(\n-                                                                            field -> {\n-                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n-                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n-                                                                                    methods.add(qualifiedName);\n-                                                                                    fieldReferenceToMethods.put(field, methods);\n-                                                                                }\n-                                                                            });\n-\n-                                                                    List<MethodNode.CalledMethod> calledMethodList =\n-                                                                            method\n-                                                                                    .findAll(MethodCallExpr.class)\n-                                                                                    .stream()\n-                                                                                    .map(MethodCallExpr::resolve)\n-                                                                                    .map(\n-                                                                                            resolved ->\n-                                                                                                    new MethodNode.CalledMethod(\n-                                                                                                            resolved.getQualifiedName(),\n-                                                                                                            resolved.getQualifiedSignature()))\n-                                                                                    .collect(Collectors.toList());\n-\n-                                                                    methodNode.setCalledInside(calledMethodList);\n-\n-                                                                    allMethodsCounter += 1;\n-                                                                    if (method.isPublic() || method.isProtected()) {\n-                                                                        methodNode.setAPI(true);\n-                                                                        this.apiMethodCounter += 1;\n-                                                                    }\n-                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n-                                                                        methodNode.setDeprecated(true);\n-                                                                    methodNode.setStatic(method.isStatic());\n-                                                                    methodNode.setProjectName(projectName);\n-                                                                    methodNode.setShingles(shingles);\n-                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n-                                                                    methodNode.setSignature(method.getSignature().toString());\n-                                                                    graph.addNamedVertex(methodNode);\n-                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-                                                                }\n-                                                            });\n-\n-                                                    // fields\n-                                                    List<FieldDeclaration> fieldDeclarations =\n-                                                            classOrInterfaceDeclaration.getFields();\n-                                                    fieldDeclarations.forEach(\n-                                                            field -> {\n-                                                                int[] shingles =\n-                                                                        this.shinglesUtil.computeMethodShingles(\n-                                                                                field.getVariables().toString());\n-                                                                String fullyQualifiedName =\n-                                                                        classNode.getFullyQualifiedName()\n-                                                                                + "."\n-                                                                                + field.getVariables().toString();\n-                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n-                                                                fieldNode.setFieldReferenceToMethod(\n-                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n-                                                                fieldNode.setProjectName(this.projectName);\n-                                                                fieldNode.setShingles(shingles);\n-                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-                                                                fieldNode.setStatic(field.isStatic());\n-                                                                fieldNode.setSignature(field.getCommonType().asString());\n-                                                                fieldNode.setDeprecated(\n-                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n-                                                                graph.addNamedVertex(fieldNode);\n-                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-                                                            });\n-                                                }\n-                                            }\n-                                        });\n-                    }\n-                });\n-\n-        //\t\tval packages = compilationUnits.stream()\n-        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-        //\t\t\t.filter(Optional::isPresent)\n-        //\t\t\t.collect(Collectors.toList());\n-        ////        this.graph.addVertex(projectNode);\n-        //\t\tthis.graph.addNamedVertex(projectNode);\n-        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n-    }\n-\n-    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n-    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n-    //\t\tchildrenPackages.forEach(childrenPackage -> {\n-    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n-    //\t\t\tpackageNode.setProjectName(this.projectName);\n-    ////            graph.addVertex(packageNode);\n-    //\t\t\tgraph.addNamedVertex(packageNode);\n-    ////            graph.addEdge(projectNode, packageNode);\n-    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-    //\t\t\tthis.packageCounter += 1;\n-    //\t\t});\n-    //\t}\n-\n-    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-    //\t\tval classes = pckg.getClasses();\n-    //\t\tclasses.forEach(clz -> {\n-    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-    //\t\t\tclassNode.setProjectName(this.projectName);\n-    //\t\t\tclassNode.setFlags(clz.getFlags());\n-    ////            graph.addVertex(classNode);\n-    ////            graph.addEdge(packageNode, classNode);\n-    //\t\t\tgraph.addNamedVertex(classNode);\n-    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-    //\t\t\tthis.browseClass(clz, classNode);\n-    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n-    //\t\t\tthis.allClassCounter += 1;\n-    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-    //\t\t\t\tclassNode.setAPI(true);\n-    //\t\t\t\tthis.apiClassCounter += 1;\n-    //\t\t\t}\n-    //\t\t});\n-    //\t}\n-\n-    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-    //\t\tval methods = clz.getMethods();\n-    //\t\tbrowseMethods(methods, classNode);\n-    //\t\tval fields = clz.getFields();\n-    //\t\tbrowseFields(fields, classNode);\n-    //\t}\n-    //\n-    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-    //\t\tmethods.forEach(method -> {\n-    //\t\t\tString statementBody = "";\n-    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-    //\t\t\t\tstatementBody = method.getSource().trim();\n-    //\t\t\t} else\n-    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-    //\t\t\t\t+ method.getElementName();\n-    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-    //\n-    //\t\t\tallMethodsCounter += 1;\n-    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-    //\t\t\t\tmethodNode.setAPI(true);\n-    //\t\t\t\tthis.apiMethodCounter += 1;\n-    //\t\t\t}\n-    //\t\t\tif (method.getIsDeprecated())\n-    //\t\t\t\tmethodNode.setDeprecated(true);\n-    //\t\t\tmethodNode.setProjectName(projectName);\n-    //\t\t\tmethodNode.setShingles(shingles);\n-    //\t\t\tmethodNode.setFlags(method.getFlags());\n-    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-    ////            graph.addVertex(methodNode);\n-    ////            graph.addEdge(classNode, methodNode);\n-    //\t\t\tgraph.addNamedVertex(methodNode);\n-    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-    //\t\t});\n-    //\t}\n-    //\n-    //\n-    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-    //\t\tStringBuilder buffer = new StringBuilder();\n-    //\n-    //\t\tbuffer.append(\'(\');\n-    //\n-    //\t\tString[] types = method.getParameterTypes();\n-    //\t\tfor (int i = 0; i < types.length; i++) {\n-    //\t\t\tif (i > 0)\n-    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-    //\t\t\tString typeSig = Signature.toString(types[i]);\n-    //\t\t\tbuffer.append(typeSig);\n-    //\t\t}\n-    //\t\tbuffer.append(\')\');\n-    //\n-    //\t\treturn buffer.toString();\n-    //\t}\n-    //\n-    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-    //\t\tfields.forEach(field -> {\n-    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-    //\t\t\tfieldNode.setProjectName(this.projectName);\n-    //\t\t\tfieldNode.setShingles(shingles);\n-    //\t\t\tfieldNode.setFlags(field.getFlags());\n-    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-    ////            graph.addVertex(fieldNode);\n-    ////            graph.addEdge(classNode, fieldNode);\n-    //\t\t\tgraph.addNamedVertex(fieldNode);\n-    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-    //\t\t});\n-    //\t}\n-    //\n-\n-    /**\n-    * This prunes away the javadoc comments\n-    *\n-    * @param source\n-    * @return\n-    */\n-    private String statementBody(String source) {\n-        int lastAtChar = source.lastIndexOf("@");\n-        if (lastAtChar == -1) lastAtChar = 0;\n-        int openingBracket = source.indexOf("{", lastAtChar);\n-        int closingBracket = source.lastIndexOf("}");\n-        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n-        return source;\n-    }\n+  @Getter private NamedDirectedMultigraph graph;\n+\n+  private ShinglesUtil shinglesUtil;\n+\n+  private String projectName;\n+\n+  private int packageCounter = 0;\n+\n+  private int allMethodsCounter = 0;\n+\n+  private int allClassCounter = 0;\n+\n+  private int apiClassCounter = 0;\n+\n+  private int apiMethodCounter = 0;\n+\n+  public static boolean useJavadocComments = false;\n+\n+  public SourceNavigator() {\n+    graph = new NamedDirectedMultigraph();\n+  }\n+\n+  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+    this.shinglesUtil = shinglesUtil;\n+  }\n+\n+  public void browseProject(\n+      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+    this.projectName = projectName;\n+    val projectNode = new Node(projectName, Node.Type.PROJECT);\n+    this.graph.addNamedVertex(projectNode);\n+    compilationUnits.forEach(\n+        cu -> {\n+          val packageDeclaration = cu.getPackageDeclaration();\n+          val importDeclarations = cu.getImports();\n+\n+          val classesImported = new LinkedList<String>();\n+\n+          importDeclarations.forEach(\n+              importDeclaration -> {\n+                classesImported.add(importDeclaration.getName().asString());\n+              });\n+\n+          if (packageDeclaration.isPresent()) {\n+            val packageName = packageDeclaration.get().getNameAsString();\n+            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n+            packageNode.setProjectName(projectName);\n+            this.graph.addNamedVertex(packageNode);\n+            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+            cu.getTypes()\n+                .forEach(\n+                    type -> {\n+                      if (type.isClassOrInterfaceDeclaration()) {\n+                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+                        if (className.isPresent()) {\n+                          val classNode = new ClassNode(className.get());\n+                          classNode.setProjectName(projectName);\n+\n+                          List<String> extendedClasses =\n+                              classOrInterfaceDeclaration\n+                                  .getExtendedTypes()\n+                                  .stream()\n+                                  .map(extendType -> extendType.resolve().getQualifiedName())\n+                                  .collect(Collectors.toList());\n+\n+                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+                          classNode.setSuperClasses(extendedClasses);\n+                          classNode.setClassesImported(classesImported);\n+                          classNode.setDeprecated(\n+                              classOrInterfaceDeclaration\n+                                  .getAnnotationByClass(Deprecated.class)\n+                                  .isPresent());\n+                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n+                          this.allClassCounter += 1;\n+                          if (classOrInterfaceDeclaration.isProtected()\n+                              || classOrInterfaceDeclaration.isPublic()) {\n+                            classNode.setAPI(true);\n+                            this.apiClassCounter += 1;\n+                          }\n+                          graph.addNamedVertex(classNode);\n+                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\n+                          // methods\n+                          List<MethodDeclaration> methodDeclarations =\n+                              classOrInterfaceDeclaration.getMethods();\n+\n+                          // filed fqn -> methods fqn\n+                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n+                          methodDeclarations.forEach(\n+                              method -> {\n+                                String statementBody = "";\n+                                val methodBody = method.getBody();\n+\n+                                if (methodBody.isPresent()) {\n+                                  if (classNode.isInterface() || (useJavadocComments)) {\n+                                    statementBody = methodBody.get().toString().trim();\n+                                  } else\n+                                    statementBody =\n+                                        statementBody(methodBody.get().toString()).trim();\n+                                  int[] shingles =\n+                                      shinglesUtil.computeMethodShingles(statementBody);\n+                                  String qualifiedName =\n+                                      classNode.getFullyQualifiedName()\n+                                          + "."\n+                                          + method.getNameAsString();\n+                                  MethodNode methodNode = new MethodNode(qualifiedName);\n+\n+                                  List<String> methodReferencedFields =\n+                                      method\n+                                          .findAll(FieldAccessExpr.class)\n+                                          .stream()\n+                                          .map(\n+                                              fieldAccessExpr ->\n+                                                  classNode.getFullyQualifiedName()\n+                                                      + "."\n+                                                      + fieldAccessExpr.resolve().getName())\n+                                          .collect(Collectors.toList());\n+\n+                                  methodReferencedFields.forEach(\n+                                      field -> {\n+                                        if (fieldReferenceToMethods.containsKey(field)) {\n+                                          List<String> methods = fieldReferenceToMethods.get(field);\n+                                          methods.add(qualifiedName);\n+                                          fieldReferenceToMethods.put(field, methods);\n+                                        }\n+                                      });\n+\n+                                  List<MethodNode.CalledMethod> calledMethodList =\n+                                      method\n+                                          .findAll(MethodCallExpr.class)\n+                                          .stream()\n+                                          .map(MethodCallExpr::resolve)\n+                                          .map(\n+                                              resolved ->\n+                                                  new MethodNode.CalledMethod(\n+                                                      resolved.getQualifiedName(),\n+                                                      resolved.getQualifiedSignature()))\n+                                          .collect(Collectors.toList());\n+\n+                                  methodNode.setCalledInside(calledMethodList);\n+\n+                                  allMethodsCounter += 1;\n+                                  if (method.isPublic() || method.isProtected()) {\n+                                    methodNode.setAPI(true);\n+                                    this.apiMethodCounter += 1;\n+                                  }\n+                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n+                                    methodNode.setDeprecated(true);\n+                                  methodNode.setStatic(method.isStatic());\n+                                  methodNode.setProjectName(projectName);\n+                                  methodNode.setShingles(shingles);\n+                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+                                  methodNode.setSignature(method.getSignature().toString());\n+                                  graph.addNamedVertex(methodNode);\n+                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+                                }\n+                              });\n+\n+                          // fields\n+                          List<FieldDeclaration> fieldDeclarations =\n+                              classOrInterfaceDeclaration.getFields();\n+                          fieldDeclarations.forEach(\n+                              field -> {\n+                                int[] shingles =\n+                                    this.shinglesUtil.computeMethodShingles(\n+                                        field.getVariables().toString());\n+                                String fullyQualifiedName =\n+                                    classNode.getFullyQualifiedName()\n+                                        + "."\n+                                        + field.getVariables().toString();\n+                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+                                fieldNode.setFieldReferenceToMethod(\n+                                    fieldReferenceToMethods.get(fullyQualifiedName));\n+                                fieldNode.setProjectName(this.projectName);\n+                                fieldNode.setShingles(shingles);\n+                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+                                fieldNode.setStatic(field.isStatic());\n+                                fieldNode.setSignature(field.getCommonType().asString());\n+                                fieldNode.setDeprecated(\n+                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n+                                graph.addNamedVertex(fieldNode);\n+                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+                              });\n+                        }\n+                      }\n+                    });\n+          }\n+        });\n+\n+    //\t\tval packages = compilationUnits.stream()\n+    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+    //\t\t\t.filter(Optional::isPresent)\n+    //\t\t\t.collect(Collectors.toList());\n+    ////        this.graph.addVertex(projectNode);\n+    //\t\tthis.graph.addNamedVertex(projectNode);\n+    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+  }\n+\n+  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n+  //\t\tchildrenPackages.forEach(childrenPackage -> {\n+  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+  //\t\t\tpackageNode.setProjectName(this.projectName);\n+  ////            graph.addVertex(packageNode);\n+  //\t\t\tgraph.addNamedVertex(packageNode);\n+  ////            graph.addEdge(projectNode, packageNode);\n+  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+  //\t\t\tthis.packageCounter += 1;\n+  //\t\t});\n+  //\t}\n+\n+  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+  //\t\tval classes = pckg.getClasses();\n+  //\t\tclasses.forEach(clz -> {\n+  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+  //\t\t\tclassNode.setProjectName(this.projectName);\n+  //\t\t\tclassNode.setFlags(clz.getFlags());\n+  ////            graph.addVertex(classNode);\n+  ////            graph.addEdge(packageNode, classNode);\n+  //\t\t\tgraph.addNamedVertex(classNode);\n+  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+  //\t\t\tthis.browseClass(clz, classNode);\n+  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n+  //\t\t\tthis.allClassCounter += 1;\n+  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+  //\t\t\t\tclassNode.setAPI(true);\n+  //\t\t\t\tthis.apiClassCounter += 1;\n+  //\t\t\t}\n+  //\t\t});\n+  //\t}\n+\n+  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+  //\t\tval methods = clz.getMethods();\n+  //\t\tbrowseMethods(methods, classNode);\n+  //\t\tval fields = clz.getFields();\n+  //\t\tbrowseFields(fields, classNode);\n+  //\t}\n+  //\n+  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+  //\t\tmethods.forEach(method -> {\n+  //\t\t\tString statementBody = "";\n+  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+  //\t\t\t\tstatementBody = method.getSource().trim();\n+  //\t\t\t} else\n+  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+  //\t\t\t\t+ method.getElementName();\n+  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+  //\n+  //\t\t\tallMethodsCounter += 1;\n+  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+  //\t\t\t\tmethodNode.setAPI(true);\n+  //\t\t\t\tthis.apiMethodCounter += 1;\n+  //\t\t\t}\n+  //\t\t\tif (method.getIsDeprecated())\n+  //\t\t\t\tmethodNode.setDeprecated(true);\n+  //\t\t\tmethodNode.setProjectName(projectName);\n+  //\t\t\tmethodNode.setShingles(shingles);\n+  //\t\t\tmethodNode.setFlags(method.getFlags());\n+  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+  ////            graph.addVertex(methodNode);\n+  ////            graph.addEdge(classNode, methodNode);\n+  //\t\t\tgraph.addNamedVertex(methodNode);\n+  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+  //\t\t});\n+  //\t}\n+  //\n+  //\n+  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+  //\t\tStringBuilder buffer = new StringBuilder();\n+  //\n+  //\t\tbuffer.append(\'(\');\n+  //\n+  //\t\tString[] types = method.getParameterTypes();\n+  //\t\tfor (int i = 0; i < types.length; i++) {\n+  //\t\t\tif (i > 0)\n+  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+  //\t\t\tString typeSig = Signature.toString(types[i]);\n+  //\t\t\tbuffer.append(typeSig);\n+  //\t\t}\n+  //\t\tbuffer.append(\')\');\n+  //\n+  //\t\treturn buffer.toString();\n+  //\t}\n+  //\n+  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+  //\t\tfields.forEach(field -> {\n+  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+  //\t\t\tfieldNode.setProjectName(this.projectName);\n+  //\t\t\tfieldNode.setShingles(shingles);\n+  //\t\t\tfieldNode.setFlags(field.getFlags());\n+  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+  ////            graph.addVertex(fieldNode);\n+  ////            graph.addEdge(classNode, fieldNode);\n+  //\t\t\tgraph.addNamedVertex(fieldNode);\n+  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+  //\t\t});\n+  //\t}\n+  //\n+\n+  /**\n+   * This prunes away the javadoc comments\n+   *\n+   * @param source\n+   * @return\n+   */\n+  private String statementBody(String source) {\n+    int lastAtChar = source.lastIndexOf("@");\n+    if (lastAtChar == -1) lastAtChar = 0;\n+    int openingBracket = source.indexOf("{", lastAtChar);\n+    int closingBracket = source.lastIndexOf("}");\n+    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n+    return source;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n  @Getter private NamedDirectedMultigraph graph;\n\n  private ShinglesUtil shinglesUtil;\n\n  private String projectName;\n\n  private int packageCounter = 0;\n\n  private int allMethodsCounter = 0;\n\n  private int allClassCounter = 0;\n\n  private int apiClassCounter = 0;\n\n  private int apiMethodCounter = 0;\n\n  public static boolean useJavadocComments = false;\n\n  public SourceNavigator() {\n    graph = new NamedDirectedMultigraph();\n  }\n\n  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n    this.shinglesUtil = shinglesUtil;\n  }\n\n  public void browseProject(\n      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n    this.projectName = projectName;\n    val projectNode = new Node(projectName, Node.Type.PROJECT);\n    this.graph.addNamedVertex(projectNode);\n    compilationUnits.forEach(\n        cu -> {\n          val packageDeclaration = cu.getPackageDeclaration();\n          val importDeclarations = cu.getImports();\n\n          val classesImported = new LinkedList<String>();\n\n          importDeclarations.forEach(\n              importDeclaration -> {\n                classesImported.add(importDeclaration.getName().asString());\n              });\n\n          if (packageDeclaration.isPresent()) {\n            val packageName = packageDeclaration.get().getNameAsString();\n            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n            packageNode.setProjectName(projectName);\n            this.graph.addNamedVertex(packageNode);\n            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n            cu.getTypes()\n                .forEach(\n                    type -> {\n                      if (type.isClassOrInterfaceDeclaration()) {\n                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                        if (className.isPresent()) {\n                          val classNode = new ClassNode(className.get());\n                          classNode.setProjectName(projectName);\n\n                          List<String> extendedClasses =\n                              classOrInterfaceDeclaration\n                                  .getExtendedTypes()\n                                  .stream()\n                                  .map(extendType -> extendType.resolve().getQualifiedName())\n                                  .collect(Collectors.toList());\n\n                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                          classNode.setSuperClasses(extendedClasses);\n                          classNode.setClassesImported(classesImported);\n                          classNode.setDeprecated(\n                              classOrInterfaceDeclaration\n                                  .getAnnotationByClass(Deprecated.class)\n                                  .isPresent());\n                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                          this.allClassCounter += 1;\n                          if (classOrInterfaceDeclaration.isProtected()\n                              || classOrInterfaceDeclaration.isPublic()) {\n                            classNode.setAPI(true);\n                            this.apiClassCounter += 1;\n                          }\n                          graph.addNamedVertex(classNode);\n                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                          // methods\n                          List<MethodDeclaration> methodDeclarations =\n                              classOrInterfaceDeclaration.getMethods();\n\n                          // filed fqn -> methods fqn\n                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                          methodDeclarations.forEach(\n                              method -> {\n                                String statementBody = "";\n                                val methodBody = method.getBody();\n\n                                if (methodBody.isPresent()) {\n                                  if (classNode.isInterface() || (useJavadocComments)) {\n                                    statementBody = methodBody.get().toString().trim();\n                                  } else\n                                    statementBody =\n                                        statementBody(methodBody.get().toString()).trim();\n                                  int[] shingles =\n                                      shinglesUtil.computeMethodShingles(statementBody);\n                                  String qualifiedName =\n                                      classNode.getFullyQualifiedName()\n                                          + "."\n                                          + method.getNameAsString();\n                                  MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                  List<String> methodReferencedFields =\n                                      method\n                                          .findAll(FieldAccessExpr.class)\n                                          .stream()\n                                          .map(\n                                              fieldAccessExpr ->\n                                                  classNode.getFullyQualifiedName()\n                                                      + "."\n                                                      + fieldAccessExpr.resolve().getName())\n                                          .collect(Collectors.toList());\n\n                                  methodReferencedFields.forEach(\n                                      field -> {\n                                        if (fieldReferenceToMethods.containsKey(field)) {\n                                          List<String> methods = fieldReferenceToMethods.get(field);\n                                          methods.add(qualifiedName);\n                                          fieldReferenceToMethods.put(field, methods);\n                                        }\n                                      });\n\n                                  List<MethodNode.CalledMethod> calledMethodList =\n                                      method\n                                          .findAll(MethodCallExpr.class)\n                                          .stream()\n                                          .map(MethodCallExpr::resolve)\n                                          .map(\n                                              resolved ->\n                                                  new MethodNode.CalledMethod(\n                                                      resolved.getQualifiedName(),\n                                                      resolved.getQualifiedSignature()))\n                                          .collect(Collectors.toList());\n\n                                  methodNode.setCalledInside(calledMethodList);\n\n                                  allMethodsCounter += 1;\n                                  if (method.isPublic() || method.isProtected()) {\n                                    methodNode.setAPI(true);\n                                    this.apiMethodCounter += 1;\n                                  }\n                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                    methodNode.setDeprecated(true);\n                                  methodNode.setStatic(method.isStatic());\n                                  methodNode.setProjectName(projectName);\n                                  methodNode.setShingles(shingles);\n                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                  methodNode.setSignature(method.getSignature().toString());\n                                  graph.addNamedVertex(methodNode);\n                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                }\n                              });\n\n                          // fields\n                          List<FieldDeclaration> fieldDeclarations =\n                              classOrInterfaceDeclaration.getFields();\n                          fieldDeclarations.forEach(\n                              field -> {\n                                int[] shingles =\n                                    this.shinglesUtil.computeMethodShingles(\n                                        field.getVariables().toString());\n                                String fullyQualifiedName =\n                                    classNode.getFullyQualifiedName()\n                                        + "."\n                                        + field.getVariables().toString();\n                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                fieldNode.setFieldReferenceToMethod(\n                                    fieldReferenceToMethods.get(fullyQualifiedName));\n                                fieldNode.setProjectName(this.projectName);\n                                fieldNode.setShingles(shingles);\n                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                fieldNode.setStatic(field.isStatic());\n                                fieldNode.setSignature(field.getCommonType().asString());\n                                fieldNode.setDeprecated(\n                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n                                graph.addNamedVertex(fieldNode);\n                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                              });\n                        }\n                      }\n                    });\n          }\n        });\n\n    //\t\tval packages = compilationUnits.stream()\n    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n    //\t\t\t.filter(Optional::isPresent)\n    //\t\t\t.collect(Collectors.toList());\n    ////        this.graph.addVertex(projectNode);\n    //\t\tthis.graph.addNamedVertex(projectNode);\n    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n  }\n\n  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n  //\t\tchildrenPackages.forEach(childrenPackage -> {\n  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n  //\t\t\tpackageNode.setProjectName(this.projectName);\n  ////            graph.addVertex(packageNode);\n  //\t\t\tgraph.addNamedVertex(packageNode);\n  ////            graph.addEdge(projectNode, packageNode);\n  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n  //\t\t\tthis.packageCounter += 1;\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n  //\t\tval classes = pckg.getClasses();\n  //\t\tclasses.forEach(clz -> {\n  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n  //\t\t\tclassNode.setProjectName(this.projectName);\n  //\t\t\tclassNode.setFlags(clz.getFlags());\n  ////            graph.addVertex(classNode);\n  ////            graph.addEdge(packageNode, classNode);\n  //\t\t\tgraph.addNamedVertex(classNode);\n  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n  //\t\t\tthis.browseClass(clz, classNode);\n  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n  //\t\t\tthis.allClassCounter += 1;\n  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n  //\t\t\t\tclassNode.setAPI(true);\n  //\t\t\t\tthis.apiClassCounter += 1;\n  //\t\t\t}\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n  //\t\tval methods = clz.getMethods();\n  //\t\tbrowseMethods(methods, classNode);\n  //\t\tval fields = clz.getFields();\n  //\t\tbrowseFields(fields, classNode);\n  //\t}\n  //\n  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n  //\t\tmethods.forEach(method -> {\n  //\t\t\tString statementBody = "";\n  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n  //\t\t\t\tstatementBody = method.getSource().trim();\n  //\t\t\t} else\n  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n  //\t\t\t\t+ method.getElementName();\n  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n  //\n  //\t\t\tallMethodsCounter += 1;\n  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n  //\t\t\t\tmethodNode.setAPI(true);\n  //\t\t\t\tthis.apiMethodCounter += 1;\n  //\t\t\t}\n  //\t\t\tif (method.getIsDeprecated())\n  //\t\t\t\tmethodNode.setDeprecated(true);\n  //\t\t\tmethodNode.setProjectName(projectName);\n  //\t\t\tmethodNode.setShingles(shingles);\n  //\t\t\tmethodNode.setFlags(method.getFlags());\n  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n  ////            graph.addVertex(methodNode);\n  ////            graph.addEdge(classNode, methodNode);\n  //\t\t\tgraph.addNamedVertex(methodNode);\n  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n  //\t\t});\n  //\t}\n  //\n  //\n  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n  //\t\tStringBuilder buffer = new StringBuilder();\n  //\n  //\t\tbuffer.append(\'(\');\n  //\n  //\t\tString[] types = method.getParameterTypes();\n  //\t\tfor (int i = 0; i < types.length; i++) {\n  //\t\t\tif (i > 0)\n  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n  //\t\t\tString typeSig = Signature.toString(types[i]);\n  //\t\t\tbuffer.append(typeSig);\n  //\t\t}\n  //\t\tbuffer.append(\')\');\n  //\n  //\t\treturn buffer.toString();\n  //\t}\n  //\n  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n  //\t\tfields.forEach(field -> {\n  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n  //\t\t\tfieldNode.setProjectName(this.projectName);\n  //\t\t\tfieldNode.setShingles(shingles);\n  //\t\t\tfieldNode.setFlags(field.getFlags());\n  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n  ////            graph.addVertex(fieldNode);\n  ////            graph.addEdge(classNode, fieldNode);\n  //\t\t\tgraph.addNamedVertex(fieldNode);\n  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n  //\t\t});\n  //\t}\n  //\n\n  /**\n   * This prunes away the javadoc comments\n   *\n   * @param source\n   * @return\n   */\n  private String statementBody(String source) {\n    int lastAtChar = source.lastIndexOf("@");\n    if (lastAtChar == -1) lastAtChar = 0;\n    int openingBracket = source.indexOf("{", lastAtChar);\n    int closingBracket = source.lastIndexOf("}");\n    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n    return source;\n  }\n}\n'
          },
          {
            sha: "8be634a324eb752a884f5bdb1485533113d36ac5",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 57,
            deletions: 57,
            patch:
              '@@ -1,6 +1,6 @@\n /*\n-* This Java source file was generated by the Gradle \'init\' task.\n-*/\n+ * This Java source file was generated by the Gradle \'init\' task.\n+ */\n package refactoring.crawler;\n \n import java.util.Dictionary;\n@@ -12,66 +12,66 @@\n \n class RefactoringCrawlerTest {\n \n-    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n \n-    private static RefactoringCrawler refactoringCrawler;\n+  private static RefactoringCrawler refactoringCrawler;\n \n-    @BeforeAll\n-    static void setUp() {\n-        settings = new Hashtable<>();\n+  @BeforeAll\n+  static void setUp() {\n+    settings = new Hashtable<>();\n \n-        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n \n-        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n-    }\n+    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n+  }\n \n-    @Test\n-    void testRenameMethod() {\n-        String source =\n-                "/*\\n"\n-                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-                        + " */\\n"\n-                        + "package refactoring.crawler;\\n"\n-                        + "\\n"\n-                        + "public class Library {\\n"\n-                        + "\\tprivate int a;\\n"\n-                        + "\\tprivate int b;\\n"\n-                        + "\\n"\n-                        + "\\tpublic void foo() {\\n"\n-                        + "\\t\\tSystem.out.println(11111);\\n"\n-                        + "\\t}\\n"\n-                        + "\\n"\n-                        + "\\tpublic void bar() {\\n"\n-                        + "\\t\\tthis.foo();\\n"\n-                        + "\\t}\\n"\n-                        + "}\\n";\n+  @Test\n+  void testRenameMethod() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n \n-        String newVersion =\n-                "/*\\n"\n-                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-                        + " */\\n"\n-                        + "package refactoring.crawler;\\n"\n-                        + "\\n"\n-                        + "public class Library {\\n"\n-                        + "\\tprivate int a;\\n"\n-                        + "\\tprivate int b;\\n"\n-                        + "\\n"\n-                        + "\\tpublic void foo12() {\\n"\n-                        + "\\t\\tSystem.out.println(11111);\\n"\n-                        + "\\t}\\n"\n-                        + "\\n"\n-                        + "\\tpublic void bar() {\\n"\n-                        + "\\t\\tthis.foo12();\\n"\n-                        + "\\t}\\n"\n-                        + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo12() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo12();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n \n-        refactoringCrawler.detect(source, newVersion);\n-        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-        System.out.println(categories);\n-    }\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    System.out.println(categories);\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  private static RefactoringCrawler refactoringCrawler;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\n    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    System.out.println(categories);\n  }\n}\n'
          }
        ]
      },
      {
        sha: "f38d6d29251fbdacab8f8a7a8390339bd60e65f2",
        message: "chore(*): clean code",
        stats: {
          total: 6706,
          additions: 2984,
          deletions: 3722
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "e730803e9a4a7b487df89013a8a6901f07100860"
          }
        ],
        committedAt: 1585221600000,
        changedFiles: [
          {
            sha: "dbed3f5159f19e4d213ce44a54fa6fdbfe39745c",
            filename: "build.gradle",
            status: "modified",
            additions: 17,
            deletions: 3,
            patch:
              "@@ -9,8 +9,25 @@\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n+    id \"com.diffplug.gradle.spotless\" version \"3.16.0\"\n }\n \n+sourceCompatibility = 1.8\n+\n+spotless {\n+    java {\n+        googleJavaFormat()\n+        indentWithTabs(2)\n+        indentWithSpaces(4)\n+    }\n+}\n+\n+def hook = new File(\"$rootProject.projectDir/.git/hooks/pre-commit\")\n+hook.text = \"\"\"#!/bin/bash\n+echo \"will run nova code format\"\n+./gradlew spotlessApply\n+\"\"\"\n+\n repositories {\n     // Use jcenter for resolving dependencies.\n     // You can declare any Maven/Ivy/file repository here.\n@@ -35,9 +52,6 @@ dependencies {\n \n     testCompileOnly 'org.projectlombok:lombok:1.18.12'\n     testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n-    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n-\n-    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n \n     // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n     implementation 'com.google.guava:guava:27.1-jre'",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id \"com.diffplug.gradle.spotless\" version \"3.16.0\"\n}\n\nsourceCompatibility = 1.8\n\nspotless {\n    java {\n        googleJavaFormat()\n        indentWithTabs(2)\n        indentWithSpaces(4)\n    }\n}\n\ndef hook = new File(\"$rootProject.projectDir/.git/hooks/pre-commit\")\nhook.text = \"\"\"#!/bin/bash\necho \"will run nova code format\"\n./gradlew spotlessApply\n\"\"\"\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "83d2cfcf9d3fac2cb14ed33d480d729a23bc2d31",
            filename: "src/main/java/refactoring/crawler/Library.java",
            status: "removed",
            additions: 0,
            deletions: 10,
            patch:
              "@@ -1,10 +0,0 @@\n-/*\n- * This Java source file was generated by the Gradle 'init' task.\n- */\n-package refactoring.crawler;\n-\n-public class Library {\n-    public boolean someLibraryMethod() {\n-        return true;\n-    }\n-}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\npublic class Library {\n    public boolean someLibraryMethod() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "497ce77693eded861c3d868fd5dbc8f1fa2434e0",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 189,
            deletions: 159,
            patch:
              '@@ -5,170 +5,200 @@\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n+import java.util.*;\n import lombok.Getter;\n+import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.classDetection.RenameClassDetection;\n import refactoring.crawler.detection.methodDetection.*;\n-import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n+import refactoring.crawler.shingles.ShinglesUtil;\n import refactoring.crawler.util.*;\n \n-import java.util.*;\n-\n public class RefactoringCrawler {\n \n-\tpublic static enum Settings {\n-\t\tT_RENAME_METHOD,\n-\t\tT_RENAME_CLASS,\n-\t\tT_MOVE_METHOD,\n-\t\tT_PULL_UP_METHOD,\n-\t\tT_PUSH_DOWN_METHOD,\n-\t\tT_CHANGE_METHOD_SIGNATURE\n-\t}\n-\n-\tprivate String projectName;\n-\tprivate Dictionary<Settings, Double> settings;\n-\n-\t@Getter\n-\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n-\n-\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n-\t\tthis.projectName = projectName;\n-\t\tthis.settings = settings;\n-\t}\n-\n-\tprivate static List<CompilationUnit> parse(List<String> files) {\n-\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n-\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n-\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n-\n-\t\tList<CompilationUnit> resList = new LinkedList<>();\n-\t\tfor (String source : files) {\n-\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n-\t\t\tresList.add(cu);\n-\t\t}\n-\t\treturn resList;\n-\t}\n-\n-\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n-\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n-\n-\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n-\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n-\t\tSourceNavigator navigator = new SourceNavigator();\n-\t\tnavigator.setShinglesUtil(shinglesUtil);\n-\t\tnavigator.browseProject(projectName, oldVersionCU);\n-\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n-\n-\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n-\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n-\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n-\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n-\n-\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n-\n-\t\t// must in this order\n-\n-\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n-\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n-\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n-\n-\n-\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n-\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n-\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n-\t\t\toriginalGraph, versionGraph);\n-\n-\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n-\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n-\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n-\t}\n-\n-\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n-\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tChangeMethodSignature);\n-\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n-\t\tif (changedMethodSignatures.size() > 0) {\n-\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n-\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n-\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n-\t\t}\n-\t}\n-\n-\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n-\t                                NamedDirectedMultigraph newVersionGraph) {\n-\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n-\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-\t\tdetector.setThreshold(tMethod);\n-\n-\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n-\t\tif (renamedMethods.size() > 0) {\n-\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n-\t\t\trenameMethodCategory.setName("RenamedMethods");\n-\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n-\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n-\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n-\t\t\tversionGraph);\n-\t\tdetector.setThreshold(tClass);\n-\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n-\t\tif (renamedClasses.size() > 0) {\n-\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n-\t\t\trenameClassCategory.setName("RenamedClasses");\n-\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n-\t\t\tthis.refactoringCategories.add(renameClassCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n-\t\tse.findSimilarClasses();\n-\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tMoveMethod);\n-\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n-\t\tif (movedMethods.size() > 0) {\n-\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n-\t\t\tmoveMethodCategory.setName("MovedMethods");\n-\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n-\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n-\t\tRefactoringDetection detector = new PullUpMethodDetection(\n-\t\t\toriginalGraph, versionGraph);\n-\t\tdetector.setThreshold(tPullUpMethod);\n-\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n-\t\tif (pullUpMethodResults.size() > 0) {\n-\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n-\t\t\tpullUpCategory.setName("PulledUpMethods");\n-\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n-\t\t\tthis.refactoringCategories.add(pullUpCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n-\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tPushDownMethod);\n-\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n-\t\tif (pushDownMethodResults.size() > 0) {\n-\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n-\t\t\tpushDownCategory.setName("PushedDownMethods");\n-\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n-\t\t\tthis.refactoringCategories.add(pushDownCategory);\n-\t\t}\n-\t}\n+    public static enum Settings {\n+        T_RENAME_METHOD,\n+        T_RENAME_CLASS,\n+        T_MOVE_METHOD,\n+        T_PULL_UP_METHOD,\n+        T_PUSH_DOWN_METHOD,\n+        T_CHANGE_METHOD_SIGNATURE\n+    }\n+\n+    private String projectName;\n+    private Dictionary<Settings, Double> settings;\n+\n+    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n+\n+    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n+        this.projectName = projectName;\n+        this.settings = settings;\n+    }\n+\n+    private static List<CompilationUnit> parse(List<String> files) {\n+        TypeSolver typeSolver = new ReflectionTypeSolver();\n+        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n+        List<CompilationUnit> resList = new LinkedList<>();\n+        for (String source : files) {\n+            CompilationUnit cu = StaticJavaParser.parse(source);\n+            resList.add(cu);\n+        }\n+        return resList;\n+    }\n+\n+    public void detect(String oldVersion, String newVersion) {\n+        List<String> oldVersionList = new LinkedList<>();\n+        List<String> newVersionList = new LinkedList<>();\n+\n+        oldVersionList.add(oldVersion);\n+        newVersionList.add(newVersion);\n+\n+        this.detect(oldVersionList, newVersionList);\n+    }\n+\n+    public void detect(List<String> oldVersion, List<String> newVersion) {\n+        ShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n+        List<CompilationUnit> newVersionCU = parse(newVersion);\n+        SourceNavigator navigator = new SourceNavigator();\n+        navigator.setShinglesUtil(shinglesUtil);\n+        navigator.browseProject(projectName, oldVersionCU);\n+        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+        SourceNavigator navigatorForVersion = new SourceNavigator();\n+        navigatorForVersion.setShinglesUtil(shinglesUtil);\n+        navigatorForVersion.browseProject(projectName, newVersionCU);\n+        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+        shinglesUtil.initialize(originalGraph, versionGraph);\n+\n+        // must in this order\n+\n+        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+    }\n+\n+    private void detectChangeMethodSignature(\n+            double tChangeMethodSignature,\n+            ShinglesUtil shinglesUtil,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tChangeMethodSignature);\n+        List<Node[]> changedMethodSignatures =\n+                detector.detectRefactorings(candidateChangedMethodSignatures);\n+        if (changedMethodSignatures.size() > 0) {\n+            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+            changeSignatureCategory.setName("ChangedMethodSignatures");\n+            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+            this.refactoringCategories.add(changeSignatureCategory);\n+        }\n+    }\n+\n+    private void detectRenameMethod(\n+            double tMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph oldVersionGraph,\n+            NamedDirectedMultigraph newVersionGraph) {\n+        List<Node[]> candidateMethods = se.findSimilarMethods();\n+        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+        detector.setThreshold(tMethod);\n+\n+        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+        if (renamedMethods.size() > 0) {\n+            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+            renameMethodCategory.setName("RenamedMethods");\n+            renameMethodCategory.setRefactoringPairs(renamedMethods);\n+            this.refactoringCategories.add(renameMethodCategory);\n+        }\n+    }\n+\n+    public void detectRenameClass(\n+            double tClass,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidateClasses = se.findSimilarClasses();\n+        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tClass);\n+        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+        if (renamedClasses.size() > 0) {\n+            RefactoringCategory renameClassCategory = new RefactoringCategory();\n+            renameClassCategory.setName("RenamedClasses");\n+            renameClassCategory.setRefactoringPairs(renamedClasses);\n+            this.refactoringCategories.add(renameClassCategory);\n+        }\n+    }\n+\n+    public void detectMoveMethod(\n+            double tMoveMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> methodCandidates = se.findSimilarMethods();\n+        se.findSimilarClasses();\n+        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+        detector.setThreshold(tMoveMethod);\n+        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+        if (movedMethods.size() > 0) {\n+            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n+            moveMethodCategory.setName("MovedMethods");\n+            moveMethodCategory.setRefactoringPairs(movedMethods);\n+            this.refactoringCategories.add(moveMethodCategory);\n+        }\n+    }\n+\n+    public void detectPullUpMethod(\n+            double tPullUpMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tPullUpMethod);\n+        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+        if (pullUpMethodResults.size() > 0) {\n+            RefactoringCategory pullUpCategory = new RefactoringCategory();\n+            pullUpCategory.setName("PulledUpMethods");\n+            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+            this.refactoringCategories.add(pullUpCategory);\n+        }\n+    }\n+\n+    public void detectPushDownMethod(\n+            double tPushDownMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tPushDownMethod);\n+        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+        if (pushDownMethodResults.size() > 0) {\n+            RefactoringCategory pushDownCategory = new RefactoringCategory();\n+            pushDownCategory.setName("PushedDownMethods");\n+            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+            this.refactoringCategories.add(pushDownCategory);\n+        }\n+    }\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n    public static enum Settings {\n        T_RENAME_METHOD,\n        T_RENAME_CLASS,\n        T_MOVE_METHOD,\n        T_PULL_UP_METHOD,\n        T_PUSH_DOWN_METHOD,\n        T_CHANGE_METHOD_SIGNATURE\n    }\n\n    private String projectName;\n    private Dictionary<Settings, Double> settings;\n\n    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n        this.projectName = projectName;\n        this.settings = settings;\n    }\n\n    private static List<CompilationUnit> parse(List<String> files) {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n        List<CompilationUnit> resList = new LinkedList<>();\n        for (String source : files) {\n            CompilationUnit cu = StaticJavaParser.parse(source);\n            resList.add(cu);\n        }\n        return resList;\n    }\n\n    public void detect(String oldVersion, String newVersion) {\n        List<String> oldVersionList = new LinkedList<>();\n        List<String> newVersionList = new LinkedList<>();\n\n        oldVersionList.add(oldVersion);\n        newVersionList.add(newVersion);\n\n        this.detect(oldVersionList, newVersionList);\n    }\n\n    public void detect(List<String> oldVersion, List<String> newVersion) {\n        ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n        List<CompilationUnit> newVersionCU = parse(newVersion);\n        SourceNavigator navigator = new SourceNavigator();\n        navigator.setShinglesUtil(shinglesUtil);\n        navigator.browseProject(projectName, oldVersionCU);\n        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n        SourceNavigator navigatorForVersion = new SourceNavigator();\n        navigatorForVersion.setShinglesUtil(shinglesUtil);\n        navigatorForVersion.browseProject(projectName, newVersionCU);\n        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n        shinglesUtil.initialize(originalGraph, versionGraph);\n\n        // must in this order\n\n        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n    }\n\n    private void detectChangeMethodSignature(\n            double tChangeMethodSignature,\n            ShinglesUtil shinglesUtil,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n        detector.setThreshold(tChangeMethodSignature);\n        List<Node[]> changedMethodSignatures =\n                detector.detectRefactorings(candidateChangedMethodSignatures);\n        if (changedMethodSignatures.size() > 0) {\n            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n            changeSignatureCategory.setName("ChangedMethodSignatures");\n            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n            this.refactoringCategories.add(changeSignatureCategory);\n        }\n    }\n\n    private void detectRenameMethod(\n            double tMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph oldVersionGraph,\n            NamedDirectedMultigraph newVersionGraph) {\n        List<Node[]> candidateMethods = se.findSimilarMethods();\n        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n        detector.setThreshold(tMethod);\n\n        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n        if (renamedMethods.size() > 0) {\n            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n            renameMethodCategory.setName("RenamedMethods");\n            renameMethodCategory.setRefactoringPairs(renamedMethods);\n            this.refactoringCategories.add(renameMethodCategory);\n        }\n    }\n\n    public void detectRenameClass(\n            double tClass,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidateClasses = se.findSimilarClasses();\n        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n        detector.setThreshold(tClass);\n        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n        if (renamedClasses.size() > 0) {\n            RefactoringCategory renameClassCategory = new RefactoringCategory();\n            renameClassCategory.setName("RenamedClasses");\n            renameClassCategory.setRefactoringPairs(renamedClasses);\n            this.refactoringCategories.add(renameClassCategory);\n        }\n    }\n\n    public void detectMoveMethod(\n            double tMoveMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> methodCandidates = se.findSimilarMethods();\n        se.findSimilarClasses();\n        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n        detector.setThreshold(tMoveMethod);\n        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n        if (movedMethods.size() > 0) {\n            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n            moveMethodCategory.setName("MovedMethods");\n            moveMethodCategory.setRefactoringPairs(movedMethods);\n            this.refactoringCategories.add(moveMethodCategory);\n        }\n    }\n\n    public void detectPullUpMethod(\n            double tPullUpMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n        detector.setThreshold(tPullUpMethod);\n        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n        if (pullUpMethodResults.size() > 0) {\n            RefactoringCategory pullUpCategory = new RefactoringCategory();\n            pullUpCategory.setName("PulledUpMethods");\n            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n            this.refactoringCategories.add(pullUpCategory);\n        }\n    }\n\n    public void detectPushDownMethod(\n            double tPushDownMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n        detector.setThreshold(tPushDownMethod);\n        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n        if (pushDownMethodResults.size() > 0) {\n            RefactoringCategory pushDownCategory = new RefactoringCategory();\n            pushDownCategory.setName("PushedDownMethods");\n            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n            this.refactoringCategories.add(pushDownCategory);\n        }\n    }\n}\n'
          },
          {
            sha: "a9cd858ea9df0f73bd311c9de0ef2f0e49c71832",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 417,
            deletions: 444,
            patch:
              '@@ -1,453 +1,426 @@\n package refactoring.crawler.detection;\n \n+import java.util.*;\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n-import refactoring.crawler.util.ClassNode;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n-import java.util.*;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public abstract class RefactoringDetection {\n \n-\n-\t@Getter\n-\t@Setter\n-\tprivate double threshold;\n-\n-\tprotected NamedDirectedMultigraph graph1;\n-\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\tprivate double lowerThreshold;\n-\n-\t/**\n-\t * Dictionary contains <Original, Version> pairs for the renaming.\n-\t */\n-\tprivate static Dictionary<String, String> renamingDictionary;\n-\n-\tpublic static Dictionary<String, String> getRenamingDictionary() {\n-\t\tif (renamingDictionary == null)\n-\t\t\trenamingDictionary = new Hashtable<>();\n-\t\treturn renamingDictionary;\n-\t}\n-\n-\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tthis.graph1 = graph;\n-\t\tthis.graph2 = graph2;\n-\t}\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n-\n-\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-\tpublic abstract boolean isRename();\n-\n-\t/**\n-\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n-\t * refactoring The original candidates are prunned (for getting rid of\n-\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n-\t * the end we eliminate FalsePositives. Subclasses must override\n-\t * computeLikeliness and pruneOriginalCandidates.\n-\t */\n-\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-\t\treturn pruneFalsePositives(listWithFP);\n-\t}\n-\n-\tprotected String extractPotentialRename(String parentClassOriginal) {\n-\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n-\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n-\t}\n-\n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Node[] pair : prunedCandidates) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n-\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n-\t\t\t\t// detect those cases when two\n-\t\t\t\t// types of refactorings happened to the same node\n-\t\t\t}\n-\t\t}\n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n-\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n-\t\t\tif (originalInV2 != null) {\n-\t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n-\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t\t\t.incomingEdgesOf(version)));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t\t\t.incomingEdgesOf(original)));\n-\n-\n-\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n-\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n-\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n-\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Node node : verCallers) {\n-\t\t\t\t\tif (origInV2Callers.contains(node))\n-\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n-\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n-\t\t\t\t// should be different\n-\t\t\t\tfor (Node node : origInV1Callers) {\n-\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n-\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tlistWithFP.remove(pair);\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\n-\t\tpruneOverloadedMethodFP(listWithFP);\n-\n-\t\treturn listWithFP;\n-\t}\n-\n-\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<>();\n-\t\tfor (Edge edge : incomingEdges) {\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n-\n-\t/**\n-\t * This prunes cases like m(i) -> m\'(i)\n-\t * m(i) -> m\'(S)\n-\t * <p>\n-\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n-\t * generated because of a method overload.\n-\t * <p>\n-\t * This method is never called in the ChangeMethodSignature detection.\n-\t */\n-\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n-\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n-\t\t\tboolean hasSameNameAndSignature = false;\n-\t\t\tNode[] pair = listWithFP.get(i);\n-\t\t\tNode source = pair[0];\n-\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\thasSameNameAndSignature = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (hasSameNameAndSignature) {\n-\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\t\tif (source.getSimpleName().equals(\n-\t\t\t\t\t\t\ttarget2.getSimpleName()))\n-\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n-\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-\t\t\tlistWithFP.remove(pair);\n-\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This takes into account the possible renaming in the parent of the node\n-\t *\n-\t * @param g        is the Version2 graph\n-\t * @param original is a node from Version1\n-\t * @return\n-\t */\n-\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tString fqnParent = extractFullyQualifiedParentName(original);\n-\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n-\t\tif (possiblyRenamedFQN != null)\n-\t\t\tfqnParent = possiblyRenamedFQN;\n-\t\tNode parentNode = g.findNamedNode(fqnParent);\n-\n-\t\tif (parentNode != null) {\n-\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-\t\t\t\tEdge edge = (Edge) iter.next();\n-\t\t\t\tNode child = (Node) edge.getTarget();\n-\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n-\t\t\t\t\tif (original.getSignature() != null) {\n-\t\t\t\t\t\t// This handles the method nodes\n-\t\t\t\t\t\tif (original.getSignature()\n-\t\t\t\t\t\t\t.equals(child.getSignature()))\n-\t\t\t\t\t\t\treturn child;\n-\t\t\t\t\t} else\n-\t\t\t\t\t\t// Classes and packages\n-\t\t\t\t\t\treturn child;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (label.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\tprotected String extractFullyQualifiedParentName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\treturn extractFullyQualifiedParentName(originalName);\n-\t}\n-\n-\tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fq_parentName = "";\n-\t\tint lastIndex = originalName.lastIndexOf(".");\n-\t\tif (lastIndex > 0)\n-\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n-\t\treturn fq_parentName;\n-\t}\n-\n-\t/**\n-\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-\t * IDE.openEditor(IWorkbenchPage, IFile)\n-\t */\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null)\n-\t\t\treturn false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n-\t\t\t\t\treturn false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n-\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/**\n-\t * This helper method takes a string containing the dot separated name of a\n-\t * node and it returns the substring from the beginning up to the last dot\n-\t * (e.g. for pack1.class1.method1 it returns class1)\n-\t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName\n-\t\t\t.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n-\t}\n-\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original)))\n-\t\t\treturn true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n-\t\t\tversion.substring(version.lastIndexOf("."))))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original),\n-\t\t\t\textractFullyQualifiedParentName(version));\n-\t\telse\n-\t\t\treturn false;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-\t\t\t\t.getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n-\t\t\t\t\t\t.getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t// TODO this is bug pruned\n-\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-//\t\ttry {\n-\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-\t\tresults.forEach(result -> {\n-\t\t\tif (graph.hasNamedNode(result))\n-\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-\t\t});\n-\t\t// Possible change to methods that instantiate classes\n-\t\t// from class -> class edges.\n-//\t\t\tfor (String result : results) {\n-////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-//\t\t\t\tString callingNode = null;\n-//\t\t\t\tif (resultNode instanceof IMethod) {\n-//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof IType) {\n-//\t\t\t\t\tIType rst = (IType) resultNode;\n-//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-//\t\t\t\t} else if (resultNode instanceof IField) {\n-//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-//\t\t\t\t\t// Workaround\n-//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += ".";\n-//\t\t\t\t\tcallingNode += rsf1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n-//\t\t\t\t\t\t.getParent(initializer,\n-//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-//\t\t\t\t\t\tIType.class);\n-//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-//\t\t\t\t}\n-//\n-//\t\t\t\t// TODO treat the case when resultNode is instance of\n-//\t\t\t\t// ImportDeclaration\n-//\t\t\t\t// TODO treat the case when resultNode is instance of\n-//\t\t\t\t// Initializer\n-//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-//\t\t\t\t// Level\n-//\t\t\t\tif (callingNode == null) {\n-//\t\t\t\t\tSystem.out.print("");\n-//\t\t\t\t}\n-//\t\t\t\tif (callingNode != null) {\n-//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-//\t\t\t\t\tif (callerNode != null)\n-//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-//\t\t\t\t}\n-//\n-//\t\t\t}\n-//\n-//\t\t} catch (CoreException e) {\n-//\t\t\tJavaPlugin.log(e);\n-//\t\t}\n-\t}\n+    @Getter @Setter private double threshold;\n+\n+    protected NamedDirectedMultigraph graph1;\n+\n+    protected NamedDirectedMultigraph graph2;\n+\n+    private double lowerThreshold;\n+\n+    /** Dictionary contains <Original, Version> pairs for the renaming. */\n+    private static Dictionary<String, String> renamingDictionary;\n+\n+    public static Dictionary<String, String> getRenamingDictionary() {\n+        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+        return renamingDictionary;\n+    }\n+\n+    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        this.graph1 = graph;\n+        this.graph2 = graph2;\n+    }\n+\n+    public abstract double computeLikeliness(Node node1, Node node12);\n+\n+    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+    public abstract boolean isRename();\n+\n+    /**\n+    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+    * computeLikeliness and pruneOriginalCandidates.\n+    */\n+    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+        return pruneFalsePositives(listWithFP);\n+    }\n+\n+    protected String extractPotentialRename(String parentClassOriginal) {\n+        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+        return renamedName == null ? parentClassOriginal : renamedName;\n+    }\n+\n+    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+        boolean foundNewRefactoring = false;\n+        for (Node[] pair : prunedCandidates) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            double likeliness = computeLikeliness(original, version);\n+            if (likeliness >= threshold) {\n+                if (!refactoredNodes.contains(pair)) {\n+                    refactoredNodes.add(pair);\n+                    foundNewRefactoring = true;\n+                }\n+                // candidates.remove(pair); acivating this line would fail to\n+                // detect those cases when two\n+                // types of refactorings happened to the same node\n+            }\n+        }\n+        if (foundNewRefactoring) {\n+            doDetectRefactorings(candidates, refactoredNodes);\n+        }\n+        return refactoredNodes;\n+    }\n+\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+        for (Node[] pair : listWithFP) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+            if (originalInV2 != null) {\n+                createCallGraph(originalInV2, graph2);\n+                List<Edge> origIncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+                List<Edge> verIncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+                List<Edge> origInVer1IncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+                List<Node> verCallers = getCallers(verIncomingEdges);\n+                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+                // since a call site cannot be calling both the old and the new entity at the same time\n+                for (Node node : verCallers) {\n+                    if (origInV2Callers.contains(node))\n+                        if (!nodesToRemove.contains(pair)) {\n+                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+                            nodesToRemove.add(pair);\n+                        }\n+                }\n+\n+                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+                // pair\n+                // is a false positive (since there should be either no more callers for N1inV2 or their\n+                // call sites\n+                // should be different\n+                for (Node node : origInV1Callers) {\n+                    for (Node callingNode : origInV2Callers) {\n+                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+                            if (!nodesToRemove.contains(pair)) {\n+                                nodesToRemove.add(pair);\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            listWithFP.remove(pair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+\n+        pruneOverloadedMethodFP(listWithFP);\n+\n+        return listWithFP;\n+    }\n+\n+    private List<Node> getCallers(List<Edge> incomingEdges) {\n+        List<Node> callers = new ArrayList<>();\n+        for (Edge edge : incomingEdges) {\n+            callers.add(edge.getSource());\n+        }\n+        return callers;\n+    }\n+\n+    /**\n+    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+    *\n+    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+    * because of a method overload.\n+    *\n+    * <p>This method is never called in the ChangeMethodSignature detection.\n+    */\n+    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<>();\n+        for (int i = 0; i < listWithFP.size(); i++) {\n+            boolean hasSameNameAndSignature = false;\n+            Node[] pair = listWithFP.get(i);\n+            Node source = pair[0];\n+            for (int j = i; j < listWithFP.size(); j++) {\n+                Node[] pair2 = listWithFP.get(j);\n+                Node source2 = pair2[0];\n+                if (source.equals(source2)) {\n+                    Node target2 = pair2[1];\n+                    if (source.getSimpleName().equals(target2.getSimpleName()))\n+                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+                }\n+            }\n+            if (hasSameNameAndSignature) {\n+                for (int j = i; j < listWithFP.size(); j++) {\n+                    Node[] pair2 = listWithFP.get(j);\n+                    Node source2 = pair2[0];\n+                    if (source.equals(source2)) {\n+                        Node target2 = pair2[1];\n+                        if (source.getSimpleName().equals(target2.getSimpleName()))\n+                            if (!signatureEqualsModuloMoveMethod(source, target2))\n+                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+            listWithFP.remove(pair);\n+\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+    }\n+\n+    /**\n+    * This takes into account the possible renaming in the parent of the node\n+    *\n+    * @param g is the Version2 graph\n+    * @param original is a node from Version1\n+    * @return\n+    */\n+    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        String fqnParent = extractFullyQualifiedParentName(original);\n+        String possiblyRenamedFQN = dictionary.get(fqnParent);\n+        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+        Node parentNode = g.findNamedNode(fqnParent);\n+\n+        if (parentNode != null) {\n+            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+                Edge edge = (Edge) iter.next();\n+                Node child = (Node) edge.getTarget();\n+                if (original.getSimpleName().equals(child.getSimpleName()))\n+                    if (original.getSignature() != null) {\n+                        // This handles the method nodes\n+                        if (original.getSignature().equals(child.getSignature())) return child;\n+                    } else\n+                        // Classes and packages\n+                        return child;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge edge : list) {\n+            if (label.equals(edge.getLabel())) {\n+                results.add(edge);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected String extractFullyQualifiedParentName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        return extractFullyQualifiedParentName(originalName);\n+    }\n+\n+    public String extractFullyQualifiedParentName(String originalName) {\n+        String fq_parentName = "";\n+        int lastIndex = originalName.lastIndexOf(".");\n+        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+        return fq_parentName;\n+    }\n+\n+    /**\n+    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+    * IDE.openEditor(IWorkbenchPage, IFile)\n+    */\n+    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+        boolean retval = false;\n+\n+        if (source.getSignature() == null) return false;\n+\n+        retval = source.getSignature().equals(target.getSignature());\n+\n+        if (!retval && (this instanceof MoveMethodDetection)) {\n+            String sourceParent = extractParentSimpleName(source);\n+            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+            String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+            for (int i = 0; i < sourceTokens.length; i++) {\n+                sourceTokens[i] = sourceTokenizer.nextToken();\n+            }\n+\n+            for (int i = 0; i < targetTokens.length; i++) {\n+                targetTokens[i] = targetTokenizer.nextToken();\n+            }\n+\n+            if (targetTokens.length == sourceTokens.length + 1) {\n+                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+                else {\n+                    for (int i = 0; i < sourceTokens.length; i++) {\n+                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+                    }\n+                    retval = true;\n+                }\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    /**\n+    * This helper method takes a string containing the dot separated name of a node and it returns\n+    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+    * class1)\n+    */\n+    protected String extractParentSimpleName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+        return parentName;\n+    }\n+\n+    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+        double count = 0;\n+\n+        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+        for (Edge edge1 : edges1) {\n+            Node node1 = edge1.getSource();\n+            for (int i = 0; i < arrEdge2.length; i++) {\n+                Edge edge2 = arrEdge2[i];\n+                if (edge2 != null) {\n+                    Node node2 = (Node) edge2.getSource();\n+                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+                        count++;\n+                        // we mark this edge as already counted so that we don\'t\n+                        // count it\n+                        // twice when there are multiple edges between two nodes\n+                        arrEdge2[i] = null;\n+                    }\n+                }\n+            }\n+        }\n+\n+        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+        return (fraction1 + fraction2) / 2.0;\n+    }\n+\n+    protected boolean isTheSameModuloRename(String original, String version) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        if (version.equals(dictionary.get(original))) return true;\n+        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+            return original.equals(version);\n+        else if (original\n+                .substring(original.lastIndexOf("."))\n+                .equals(version.substring(version.lastIndexOf("."))))\n+            return isTheSameModuloRename(\n+                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+        else return false;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+                if (pair[0].isAPI() && pair[1].isAPI()) {\n+                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+                    if ((n2inV1 == null)) {\n+                        prunedCandidates.add(pair);\n+                    }\n+                }\n+            }\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    // TODO this is bug pruned\n+    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+        //\t\ttry {\n+        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+        results.forEach(\n+                result -> {\n+                    if (graph.hasNamedNode(result))\n+                        graph.addEdge(\n+                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+                });\n+        // Possible change to methods that instantiate classes\n+        // from class -> class edges.\n+        //\t\t\tfor (String result : results) {\n+        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+        //\t\t\t\tString callingNode = null;\n+        //\t\t\t\tif (resultNode instanceof IMethod) {\n+        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+        //\t\t\t\t} else if (resultNode instanceof IType) {\n+        //\t\t\t\t\tIType rst = (IType) resultNode;\n+        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t} else if (resultNode instanceof IField) {\n+        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+        //\t\t\t\t\t// Workaround\n+        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += ".";\n+        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+        // ASTNodes\n+        //\t\t\t\t\t\t.getParent(initializer,\n+        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+        //\t\t\t\t\t\tIType.class);\n+        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+        //\t\t\t\t}\n+        //\n+        //\t\t\t\t// TODO treat the case when resultNode is instance of\n+        //\t\t\t\t// ImportDeclaration\n+        //\t\t\t\t// TODO treat the case when resultNode is instance of\n+        //\t\t\t\t// Initializer\n+        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+        //\t\t\t\t// Level\n+        //\t\t\t\tif (callingNode == null) {\n+        //\t\t\t\t\tSystem.out.print("");\n+        //\t\t\t\t}\n+        //\t\t\t\tif (callingNode != null) {\n+        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+        //\t\t\t\t\tif (callerNode != null)\n+        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+        //\t\t\t\t}\n+        //\n+        //\t\t\t}\n+        //\n+        //\t\t} catch (CoreException e) {\n+        //\t\t\tJavaPlugin.log(e);\n+        //\t\t}\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n    @Getter @Setter private double threshold;\n\n    protected NamedDirectedMultigraph graph1;\n\n    protected NamedDirectedMultigraph graph2;\n\n    private double lowerThreshold;\n\n    /** Dictionary contains <Original, Version> pairs for the renaming. */\n    private static Dictionary<String, String> renamingDictionary;\n\n    public static Dictionary<String, String> getRenamingDictionary() {\n        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n        return renamingDictionary;\n    }\n\n    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        this.graph1 = graph;\n        this.graph2 = graph2;\n    }\n\n    public abstract double computeLikeliness(Node node1, Node node12);\n\n    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n    public abstract boolean isRename();\n\n    /**\n    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n    * computeLikeliness and pruneOriginalCandidates.\n    */\n    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n        return pruneFalsePositives(listWithFP);\n    }\n\n    protected String extractPotentialRename(String parentClassOriginal) {\n        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n        return renamedName == null ? parentClassOriginal : renamedName;\n    }\n\n    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n        boolean foundNewRefactoring = false;\n        for (Node[] pair : prunedCandidates) {\n            Node original = pair[0];\n            Node version = pair[1];\n            double likeliness = computeLikeliness(original, version);\n            if (likeliness >= threshold) {\n                if (!refactoredNodes.contains(pair)) {\n                    refactoredNodes.add(pair);\n                    foundNewRefactoring = true;\n                }\n                // candidates.remove(pair); acivating this line would fail to\n                // detect those cases when two\n                // types of refactorings happened to the same node\n            }\n        }\n        if (foundNewRefactoring) {\n            doDetectRefactorings(candidates, refactoredNodes);\n        }\n        return refactoredNodes;\n    }\n\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n        for (Node[] pair : listWithFP) {\n            Node original = pair[0];\n            Node version = pair[1];\n            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n            if (originalInV2 != null) {\n                createCallGraph(originalInV2, graph2);\n                List<Edge> origIncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n                List<Edge> verIncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n                List<Edge> origInVer1IncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n                List<Node> verCallers = getCallers(verIncomingEdges);\n                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n                // since a call site cannot be calling both the old and the new entity at the same time\n                for (Node node : verCallers) {\n                    if (origInV2Callers.contains(node))\n                        if (!nodesToRemove.contains(pair)) {\n                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n                            nodesToRemove.add(pair);\n                        }\n                }\n\n                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n                // pair\n                // is a false positive (since there should be either no more callers for N1inV2 or their\n                // call sites\n                // should be different\n                for (Node node : origInV1Callers) {\n                    for (Node callingNode : origInV2Callers) {\n                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n                            if (!nodesToRemove.contains(pair)) {\n                                nodesToRemove.add(pair);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            listWithFP.remove(pair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n\n        pruneOverloadedMethodFP(listWithFP);\n\n        return listWithFP;\n    }\n\n    private List<Node> getCallers(List<Edge> incomingEdges) {\n        List<Node> callers = new ArrayList<>();\n        for (Edge edge : incomingEdges) {\n            callers.add(edge.getSource());\n        }\n        return callers;\n    }\n\n    /**\n    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n    *\n    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n    * because of a method overload.\n    *\n    * <p>This method is never called in the ChangeMethodSignature detection.\n    */\n    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<>();\n        for (int i = 0; i < listWithFP.size(); i++) {\n            boolean hasSameNameAndSignature = false;\n            Node[] pair = listWithFP.get(i);\n            Node source = pair[0];\n            for (int j = i; j < listWithFP.size(); j++) {\n                Node[] pair2 = listWithFP.get(j);\n                Node source2 = pair2[0];\n                if (source.equals(source2)) {\n                    Node target2 = pair2[1];\n                    if (source.getSimpleName().equals(target2.getSimpleName()))\n                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n                }\n            }\n            if (hasSameNameAndSignature) {\n                for (int j = i; j < listWithFP.size(); j++) {\n                    Node[] pair2 = listWithFP.get(j);\n                    Node source2 = pair2[0];\n                    if (source.equals(source2)) {\n                        Node target2 = pair2[1];\n                        if (source.getSimpleName().equals(target2.getSimpleName()))\n                            if (!signatureEqualsModuloMoveMethod(source, target2))\n                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n                    }\n                }\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n            listWithFP.remove(pair);\n\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n    }\n\n    /**\n    * This takes into account the possible renaming in the parent of the node\n    *\n    * @param g is the Version2 graph\n    * @param original is a node from Version1\n    * @return\n    */\n    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        String fqnParent = extractFullyQualifiedParentName(original);\n        String possiblyRenamedFQN = dictionary.get(fqnParent);\n        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n        Node parentNode = g.findNamedNode(fqnParent);\n\n        if (parentNode != null) {\n            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n                Edge edge = (Edge) iter.next();\n                Node child = (Node) edge.getTarget();\n                if (original.getSimpleName().equals(child.getSimpleName()))\n                    if (original.getSignature() != null) {\n                        // This handles the method nodes\n                        if (original.getSignature().equals(child.getSignature())) return child;\n                    } else\n                        // Classes and packages\n                        return child;\n            }\n        }\n        return null;\n    }\n\n    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge edge : list) {\n            if (label.equals(edge.getLabel())) {\n                results.add(edge);\n            }\n        }\n        return results;\n    }\n\n    protected String extractFullyQualifiedParentName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        return extractFullyQualifiedParentName(originalName);\n    }\n\n    public String extractFullyQualifiedParentName(String originalName) {\n        String fq_parentName = "";\n        int lastIndex = originalName.lastIndexOf(".");\n        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n        return fq_parentName;\n    }\n\n    /**\n    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n    * IDE.openEditor(IWorkbenchPage, IFile)\n    */\n    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n        boolean retval = false;\n\n        if (source.getSignature() == null) return false;\n\n        retval = source.getSignature().equals(target.getSignature());\n\n        if (!retval && (this instanceof MoveMethodDetection)) {\n            String sourceParent = extractParentSimpleName(source);\n            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n            String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n            for (int i = 0; i < sourceTokens.length; i++) {\n                sourceTokens[i] = sourceTokenizer.nextToken();\n            }\n\n            for (int i = 0; i < targetTokens.length; i++) {\n                targetTokens[i] = targetTokenizer.nextToken();\n            }\n\n            if (targetTokens.length == sourceTokens.length + 1) {\n                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n                else {\n                    for (int i = 0; i < sourceTokens.length; i++) {\n                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n                    }\n                    retval = true;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n    * This helper method takes a string containing the dot separated name of a node and it returns\n    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n    * class1)\n    */\n    protected String extractParentSimpleName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n        return parentName;\n    }\n\n    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n        double count = 0;\n\n        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n        for (Edge edge1 : edges1) {\n            Node node1 = edge1.getSource();\n            for (int i = 0; i < arrEdge2.length; i++) {\n                Edge edge2 = arrEdge2[i];\n                if (edge2 != null) {\n                    Node node2 = (Node) edge2.getSource();\n                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n                        count++;\n                        // we mark this edge as already counted so that we don\'t\n                        // count it\n                        // twice when there are multiple edges between two nodes\n                        arrEdge2[i] = null;\n                    }\n                }\n            }\n        }\n\n        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n        return (fraction1 + fraction2) / 2.0;\n    }\n\n    protected boolean isTheSameModuloRename(String original, String version) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        if (version.equals(dictionary.get(original))) return true;\n        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n            return original.equals(version);\n        else if (original\n                .substring(original.lastIndexOf("."))\n                .equals(version.substring(version.lastIndexOf("."))))\n            return isTheSameModuloRename(\n                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n        else return false;\n    }\n\n    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n                if (pair[0].isAPI() && pair[1].isAPI()) {\n                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n                    if ((n2inV1 == null)) {\n                        prunedCandidates.add(pair);\n                    }\n                }\n            }\n        }\n        return prunedCandidates;\n    }\n\n    // TODO this is bug pruned\n    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n        //\t\ttry {\n        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n        results.forEach(\n                result -> {\n                    if (graph.hasNamedNode(result))\n                        graph.addEdge(\n                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n                });\n        // Possible change to methods that instantiate classes\n        // from class -> class edges.\n        //\t\t\tfor (String result : results) {\n        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n        //\t\t\t\tString callingNode = null;\n        //\t\t\t\tif (resultNode instanceof IMethod) {\n        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n        //\t\t\t\t} else if (resultNode instanceof IType) {\n        //\t\t\t\t\tIType rst = (IType) resultNode;\n        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n        //\t\t\t\t} else if (resultNode instanceof IField) {\n        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n        //\t\t\t\t\t// Workaround\n        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += ".";\n        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n        // ASTNodes\n        //\t\t\t\t\t\t.getParent(initializer,\n        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n        //\t\t\t\t\t\tIType.class);\n        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n        //\t\t\t\t}\n        //\n        //\t\t\t\t// TODO treat the case when resultNode is instance of\n        //\t\t\t\t// ImportDeclaration\n        //\t\t\t\t// TODO treat the case when resultNode is instance of\n        //\t\t\t\t// Initializer\n        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n        //\t\t\t\t// Level\n        //\t\t\t\tif (callingNode == null) {\n        //\t\t\t\t\tSystem.out.print("");\n        //\t\t\t\t}\n        //\t\t\t\tif (callingNode != null) {\n        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n        //\t\t\t\t\tif (callerNode != null)\n        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n        //\t\t\t\t}\n        //\n        //\t\t\t}\n        //\n        //\t\t} catch (CoreException e) {\n        //\t\t\tJavaPlugin.log(e);\n        //\t\t}\n    }\n}\n'
          },
          {
            sha: "953bfe0eb3583b4f5968a25ed810ba4f5c388a46",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 45,
            deletions: 35,
            patch:
              "@@ -1,45 +1,55 @@\n package refactoring.crawler.detection;\n \n-import com.github.javaparser.ast.body.MethodDeclaration;\n-import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n-import lombok.Getter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import refactoring.crawler.util.*;\n-\n import java.util.*;\n import java.util.stream.Collectors;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.FieldNode;\n+import refactoring.crawler.graph.MethodNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n \n public class SearchHelper {\n-\tpublic static List<String> findFieldReferences(FieldNode node) {\n-\t\treturn node.getFieldReferenceToMethod();\n-\t}\n-\n-\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n-\t\treturn node.getSuperClasses();\n-\t}\n+    public static List<String> findFieldReferences(FieldNode node) {\n+        return node.getFieldReferenceToMethod();\n+    }\n \n-\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-\t\treturn node.getClassesImported();\n-\t}\n+    public static List<String> findSuperClassesOf(ClassNode node) {\n+        return node.getSuperClasses();\n+    }\n \n-\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-\t\treturn graph.vertexSet()\n-\t\t\t.stream()\n-\t\t\t.filter(n -> (n instanceof MethodNode))\n-\t\t\t.map(methodNode -> (MethodNode) methodNode)\n-\t\t\t.filter(methodNode ->\n-\t\t\t\tmethodNode.getCalledInside()\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.anyMatch(calledMethod -> {\n-\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n-\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n-\t\t\t\t\t\treturn expect.equals(actual);\n-\t\t\t\t\t})\n-\t\t\t)\n-\t\t\t.map(methodNode -> {\n-\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n-\t\t\t})\n-\t\t\t.collect(Collectors.toList());\n-\t}\n+    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+        return node.getClassesImported();\n+    }\n \n+    public static List<String> findMethodCallers(\n+            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+        return graph\n+                .vertexSet()\n+                .stream()\n+                .filter(n -> (n instanceof MethodNode))\n+                .map(methodNode -> (MethodNode) methodNode)\n+                .filter(\n+                        methodNode ->\n+                                methodNode\n+                                        .getCalledInside()\n+                                        .stream()\n+                                        .anyMatch(\n+                                                calledMethod -> {\n+                                                    String expect =\n+                                                            withSignature\n+                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                                                    String actual =\n+                                                            withSignature\n+                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n+                                                                    : node.getFullyQualifiedName();\n+                                                    return expect.equals(actual);\n+                                                }))\n+                .map(\n+                        methodNode -> {\n+                            return withSignature\n+                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                                    : methodNode.getFullyQualifiedName();\n+                        })\n+                .collect(Collectors.toList());\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\n\npublic class SearchHelper {\n    public static List<String> findFieldReferences(FieldNode node) {\n        return node.getFieldReferenceToMethod();\n    }\n\n    public static List<String> findSuperClassesOf(ClassNode node) {\n        return node.getSuperClasses();\n    }\n\n    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n        return node.getClassesImported();\n    }\n\n    public static List<String> findMethodCallers(\n            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n        return graph\n                .vertexSet()\n                .stream()\n                .filter(n -> (n instanceof MethodNode))\n                .map(methodNode -> (MethodNode) methodNode)\n                .filter(\n                        methodNode ->\n                                methodNode\n                                        .getCalledInside()\n                                        .stream()\n                                        .anyMatch(\n                                                calledMethod -> {\n                                                    String expect =\n                                                            withSignature\n                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n                                                    String actual =\n                                                            withSignature\n                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n                                                                    : node.getFullyQualifiedName();\n                                                    return expect.equals(actual);\n                                                }))\n                .map(\n                        methodNode -> {\n                            return withSignature\n                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                                    : methodNode.getFullyQualifiedName();\n                        })\n                .collect(Collectors.toList());\n    }\n}\n"
          },
          {
            sha: "525b7bf00b391ded7649ebbd22f97ae650637125",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "modified",
            additions: 62,
            deletions: 68,
            patch:
              "@@ -1,83 +1,77 @@\n package refactoring.crawler.detection.classDetection;\n \n-import org.eclipse.jdt.core.IType;\n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.ClassNode;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class ClassDetection extends RefactoringDetection {\n \n-\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n+    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn false;\n-\t}\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n \n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n \n-\t/**\n-\t * We need to find all the places that the original and version classes are\n-\t * instantiated. We will incorporate this into the likeliness grade.\n-\t */\n-\tprotected void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateCallGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateCallGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n+    @Override\n+    public boolean isRename() {\n+        // TODO Auto-generated method stub\n+        return false;\n+    }\n \n-\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tcreateClassReferenceGraph(node, graph);\n-\t\tnode.setCreatedCallGraph();\n-\t}\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n \n-\t/**\n-\t * Accepts two class nodes, and determines if first parameter is a\n-\t * superclass of the second parameter.\n-\t */\n-\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n-\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n-\t\tfor (String superClass : superClasses) {\n-\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n-\t\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-//\t\treturn false;\n-\t}\n+    /**\n+    * We need to find all the places that the original and version classes are instantiated. We will\n+    * incorporate this into the likeliness grade.\n+    */\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n \n+    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        createClassReferenceGraph(node, graph);\n+        node.setCreatedCallGraph();\n+    }\n \n+    /**\n+    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n+    * parameter.\n+    */\n+    public static boolean isSuperClassOf(Node node1, Node node2) {\n+        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+        for (String superClass : superClasses) {\n+            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n+        }\n+        return false;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isRename() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n    * We need to find all the places that the original and version classes are instantiated. We will\n    * incorporate this into the likeliness grade.\n    */\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        createClassReferenceGraph(node, graph);\n        node.setCreatedCallGraph();\n    }\n\n    /**\n    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n    * parameter.\n    */\n    public static boolean isSuperClassOf(Node node1, Node node2) {\n        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n        for (String superClass : superClasses) {\n            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n        }\n        return false;\n    }\n}\n"
          },
          {
            sha: "a724f9169daef3acd6b63a8cd61d0f14525a5554",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "modified",
            additions: 34,
            deletions: 35,
            patch:
              "@@ -1,47 +1,46 @@\n package refactoring.crawler.detection.classDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class MoveClassDetection extends ClassDetection {\n \n-\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n+    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n+    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+        double edgeGrade;\n+        createCallGraph(nodeOriginal, nodeVersion);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return edgeGrade;\n+    }\n \n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedClasses) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n-\t\t\t\tparentPackageVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesInDifferentPackages.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesInDifferentPackages;\n-\t}\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+        for (Node[] pair : prePrunedClasses) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n+            String parentPackageVersion = extractFullyQualifiedParentName(version);\n+            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesInDifferentPackages.add(pair);\n+            }\n+        }\n+        return candidatesInDifferentPackages;\n+    }\n \n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+    public boolean isRename() {\n+        return false;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n        double edgeGrade;\n        createCallGraph(nodeOriginal, nodeVersion);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return edgeGrade;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n        for (Node[] pair : prePrunedClasses) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n            String parentPackageVersion = extractFullyQualifiedParentName(version);\n            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesInDifferentPackages.add(pair);\n            }\n        }\n        return candidatesInDifferentPackages;\n    }\n\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "ee75e84569114b0c345231f5f203cb53f3dd8b06",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 51,
            deletions: 52,
            patch:
              "@@ -1,60 +1,59 @@\n package refactoring.crawler.detection.classDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n-\t}\n-\n-\t/**\n-\t * Calls createCallGraph in ClassDetection\n-\t * Calls filterNamedEdges in ClassDetection\n-\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n-\t *\n-\t * @param nodeOriginal\n-\t * @param nodeVersion\n-\t * @return\n-\t */\n-\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-\t\tfor (Node[] pair : prePruned) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n-\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n-\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentPackage;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+        super(graph1, graph2);\n+    }\n+\n+    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+    }\n+\n+    /**\n+    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+    * computeLikelinessIncomingEdges in RefactoringDetection\n+    *\n+    * @param nodeOriginal\n+    * @param nodeVersion\n+    * @return\n+    */\n+    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+        double edgeGrade;\n+        createCallGraph(nodeOriginal, nodeVersion);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return edgeGrade;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+        for (Node[] pair : prePruned) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentPackageOriginal = extractParentSimpleName(original);\n+            String parentPackageVersion = extractParentSimpleName(version);\n+            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithSameParentPackage.add(pair);\n+            }\n+        }\n+\n+        return candidatesWithSameParentPackage;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return true;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n        super(graph1, graph2);\n    }\n\n    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n    }\n\n    /**\n    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n    * computeLikelinessIncomingEdges in RefactoringDetection\n    *\n    * @param nodeOriginal\n    * @param nodeVersion\n    * @return\n    */\n    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n        double edgeGrade;\n        createCallGraph(nodeOriginal, nodeVersion);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return edgeGrade;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n        for (Node[] pair : prePruned) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentPackageOriginal = extractParentSimpleName(original);\n            String parentPackageVersion = extractParentSimpleName(version);\n            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithSameParentPackage.add(pair);\n            }\n        }\n\n        return candidatesWithSameParentPackage;\n    }\n\n    @Override\n    public boolean isRename() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "e7bddc9a625cdf0f9c28c95c1a7a66f5c0d33caa",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "modified",
            additions: 92,
            deletions: 111,
            patch:
              "@@ -1,119 +1,100 @@\n package refactoring.crawler.detection.fieldDetection;\n \n-import org.eclipse.core.runtime.CoreException;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.eclipse.core.runtime.NullProgressMonitor;\n-import org.eclipse.jdt.core.IMember;\n-import org.eclipse.jdt.core.IMethod;\n-import org.eclipse.jdt.core.dom.Initializer;\n-import org.eclipse.jdt.core.dom.SimpleName;\n-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n-import refactoring.crawler.RefactoringCrawler;\n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.FieldNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.FieldNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class FieldDetection extends RefactoringDetection {\n \n-\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t/*\n-\t * (non-Javadoc)\n-\t *\n-\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n-\t */\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n-\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n-\n-\t\tfor (String result : results) {\n-//\t\t\t\tIMember resultNode = (IMember) result;\n-//\t\t\t\tString callingNode = null;\n-//\t\t\t\tif (resultNode instanceof IMethod) {\n-//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n-//\t\t\t\t\t\t.getParent(initializer,\n-//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n-//\t\t\t\t}\n-\n-\t\t\tNode callerNode = graph.findNamedNode(result);\n-\t\t\tif (callerNode != null)\n-\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n-\t\t}\n-\n-\t}\n-\n-\tpublic void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateFieldReferenceGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateFieldReferenceGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n-\n-\tpublic double analyzeIncomingEdges(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade;\n-\t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t.incomingEdgesOf(version)));\n-\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn incomingEdgesGrade;\n-\t}\n+    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n+\n+    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+\n+        for (String result : results) {\n+            //\t\t\t\tIMember resultNode = (IMember) result;\n+            //\t\t\t\tString callingNode = null;\n+            //\t\t\t\tif (resultNode instanceof IMethod) {\n+            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+            // ASTNodes\n+            //\t\t\t\t\t\t.getParent(initializer,\n+            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+            //\t\t\t\t}\n+\n+            Node callerNode = graph.findNamedNode(result);\n+            if (callerNode != null)\n+                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n+        }\n+    }\n+\n+    public void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createFieldReferenceGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createFieldReferenceGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n+\n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        incomingEdgesGrade =\n+                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n\n    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n        for (String result : results) {\n            //\t\t\t\tIMember resultNode = (IMember) result;\n            //\t\t\t\tString callingNode = null;\n            //\t\t\t\tif (resultNode instanceof IMethod) {\n            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n            // ASTNodes\n            //\t\t\t\t\t\t.getParent(initializer,\n            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n            //\t\t\t\t}\n\n            Node callerNode = graph.findNamedNode(result);\n            if (callerNode != null)\n                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n        }\n    }\n\n    public void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createFieldReferenceGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createFieldReferenceGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        incomingEdgesGrade =\n                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "6c56650a6c570fd11124d662aea0f53fbe80386b",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "modified",
            additions: 32,
            deletions: 37,
            patch:
              "@@ -1,45 +1,40 @@\n package refactoring.crawler.detection.fieldDetection;\n \n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class MoveFieldDetection extends FieldDetection {\n \n-\t/*\n-\t * We already have Class - Field edges. So we need to make sure that they\n-\t * are different parents, and also make sure that their call graph is still\n-\t * the same.\n-\t */\n-\n-\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\treturn analyzeIncomingEdges(original, version);\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedFields) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n-\t\t\t\tparentClassVersion);\n-\n-\t\t\tif (!isModRen\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n+    /*\n+    * We already have Class - Field edges. So we need to make sure that they\n+    * are different parents, and also make sure that their call graph is still\n+    * the same.\n+    */\n+\n+    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        return analyzeIncomingEdges(original, version);\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedFields) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+\n+            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+        return candidatesWithDifferentParentClass;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n    /*\n    * We already have Class - Field edges. So we need to make sure that they\n    * are different parents, and also make sure that their call graph is still\n    * the same.\n    */\n\n    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        return analyzeIncomingEdges(original, version);\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedFields) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n        return candidatesWithDifferentParentClass;\n    }\n}\n"
          },
          {
            sha: "e4def2fd22214c6837b2678229bc8813a5d71701",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 122,
            deletions: 137,
            patch:
              '@@ -1,144 +1,129 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.*;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n \n-\t/**\n-\t * @param graph\n-\t * @param graph2\n-\t */\n-\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t/**\n-\t * We need to go from the node to the AST and get the actual method. Then we\n-\t * will call getSignature() on the IMethod to get the signature. We have to\n-\t * make sure the call graphs are checked, since we do not want to detect\n-\t * polymorphism as change method signature.\n-\t */\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\t// Need to find out if in V2 there is a node with the same signature\n-\t\t// as the original\n-\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n-\t\t\treturn 1.0;\n-\t\telse {\n-\t\t\t// This is when we have a method overload or deprecated. So when\n-\t\t\t// we can check deprecated methods we need to add it here\n-\t\t\treturn analyzeIncomingEdges(original, version);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will handle the same name condition, explained above.\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n-\n-\t\t\tif (hasSameNameAndSignature)\n-\t\t\t\tcontinue;\n-\n-\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n-\t\t\t\t.getFullyQualifiedName()))\n-\t\t\t\tprunedCandidates.add(pair);\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n-\t\t// TODO here we have to take into account the RenamigsDictionary\n-\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n-\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n-\n-\t\tboolean hasSameNameAndSignature = false;\n-\n-\t\tif (n2ParentInV1 != null) {\n-\t\t\t// Calling the overloaded method\n-\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n-\t\t\tfor (Edge methodEdge : allMethodEdges) {\n-\t\t\t\tNode targetMethod = methodEdge.getTarget();\n-\t\t\t\tif (targetMethod.getSimpleName()\n-\t\t\t\t\t.equals(pair[1].getSimpleName())\n-\t\t\t\t\t&& targetMethod.getSignature().equals(\n-\t\t\t\t\tpair[1].getSignature()))\n-\t\t\t\t\thasSameNameAndSignature = true;\n-\t\t\t}\n-\t\t}\n-\t\treturn hasSameNameAndSignature;\n-\t}\n-\n-\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n-\t\tNode source = pair[0];\n-\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n-\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n-\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n-\t\tboolean isDeprecated = false;\n-\t\tboolean isRemoved = true;\n-\t\tif (parentOfOriginalInV2 != null) {\n-\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n-\t\t\tfor (Edge edge : methodEdges) {\n-\t\t\t\tNode methodNode = edge.getTarget();\n-\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n-\t\t\t\t\t&& methodNode.getSignature().equals(\n-\t\t\t\t\tsource.getSignature())) {\n-\t\t\t\t\tisRemoved = false;\n-\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn isDeprecated || isRemoved;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n-\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n-\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tString signatureN1 = pair[0].getSignature();\n-\t\t\tString signatureN2 = pair[1].getSignature();\n-\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n-\t\t\t\tgoodResults.add(pair);\n-\t\t}\n-\t\treturn goodResults;\n-\t}\n-\n-\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n-\t\t// TODO filters out (IPluginDescriptor) with\n-\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n-\t\t// right now this is checked only for case when there is a one argument\n-\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n-\t\t\tsignatureN1.length() - 1));\n-\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n-\t\t\tsignatureN2.length() - 1));\n-\t\treturn simpleName1.equals(simpleName2);\n-\t}\n-\n-\tprivate String extractSimpleName(String fqn) {\n-\t\tint lastIndex = fqn.lastIndexOf(".");\n-\t\tif (lastIndex < 0)\n-\t\t\treturn fqn;\n-\t\telse\n-\t\t\treturn fqn.substring(lastIndex + 1);\n-\t}\n-\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n+    /**\n+    * @param graph\n+    * @param graph2\n+    */\n+    public ChangeMethodSignatureDetection(\n+            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    /**\n+    * We need to go from the node to the AST and get the actual method. Then we will call\n+    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n+    * checked, since we do not want to detect polymorphism as change method signature.\n+    */\n+    public double computeLikeliness(Node original, Node version) {\n+        // Need to find out if in V2 there is a node with the same signature\n+        // as the original\n+        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n+        else {\n+            // This is when we have a method overload or deprecated. So when\n+            // we can check deprecated methods we need to add it here\n+            return analyzeIncomingEdges(original, version);\n+        }\n+    }\n+\n+    /** This will handle the same name condition, explained above. */\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n+\n+            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n+\n+            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+\n+            if (hasSameNameAndSignature) continue;\n+\n+            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n+                prunedCandidates.add(pair);\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    private boolean hasTheSameSignatureAndName(Node[] pair) {\n+        // TODO here we have to take into account the RenamigsDictionary\n+        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+        boolean hasSameNameAndSignature = false;\n+\n+        if (n2ParentInV1 != null) {\n+            // Calling the overloaded method\n+            List<Edge> allMethodEdges =\n+                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+            for (Edge methodEdge : allMethodEdges) {\n+                Node targetMethod = methodEdge.getTarget();\n+                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n+                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n+                    hasSameNameAndSignature = true;\n+            }\n+        }\n+        return hasSameNameAndSignature;\n+    }\n+\n+    private boolean isDeprecatedOrRemoved(Node[] pair) {\n+        Node source = pair[0];\n+        String parentOfOriginal = extractFullyQualifiedParentName(source);\n+        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n+        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+        boolean isDeprecated = false;\n+        boolean isRemoved = true;\n+        if (parentOfOriginalInV2 != null) {\n+            List<Edge> methodEdges =\n+                    filterNamedEdges(\n+                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+            for (Edge edge : methodEdges) {\n+                Node methodNode = edge.getTarget();\n+                if (methodNode.getSimpleName().equals(source.getSimpleName())\n+                        && methodNode.getSignature().equals(source.getSignature())) {\n+                    isRemoved = false;\n+                    isDeprecated = methodNode.isDeprecated();\n+                }\n+            }\n+        }\n+\n+        return isDeprecated || isRemoved;\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+        List<Node[]> goodResults = new ArrayList<Node[]>();\n+\n+        for (Node[] pair : listWithFP) {\n+            String signatureN1 = pair[0].getSignature();\n+            String signatureN2 = pair[1].getSignature();\n+            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n+        }\n+        return goodResults;\n+    }\n+\n+    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+        // TODO filters out (IPluginDescriptor) with\n+        // (org.eclipse.core.runtime.IPluginDescriptor)\n+        // right now this is checked only for case when there is a one argument\n+        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n+        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n+        return simpleName1.equals(simpleName2);\n+    }\n+\n+    private String extractSimpleName(String fqn) {\n+        int lastIndex = fqn.lastIndexOf(".");\n+        if (lastIndex < 0) return fqn;\n+        else return fqn.substring(lastIndex + 1);\n+    }\n+\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n    /**\n    * @param graph\n    * @param graph2\n    */\n    public ChangeMethodSignatureDetection(\n            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    /**\n    * We need to go from the node to the AST and get the actual method. Then we will call\n    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n    * checked, since we do not want to detect polymorphism as change method signature.\n    */\n    public double computeLikeliness(Node original, Node version) {\n        // Need to find out if in V2 there is a node with the same signature\n        // as the original\n        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n        else {\n            // This is when we have a method overload or deprecated. So when\n            // we can check deprecated methods we need to add it here\n            return analyzeIncomingEdges(original, version);\n        }\n    }\n\n    /** This will handle the same name condition, explained above. */\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n            if (hasSameNameAndSignature) continue;\n\n            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n                prunedCandidates.add(pair);\n        }\n        return prunedCandidates;\n    }\n\n    private boolean hasTheSameSignatureAndName(Node[] pair) {\n        // TODO here we have to take into account the RenamigsDictionary\n        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n        boolean hasSameNameAndSignature = false;\n\n        if (n2ParentInV1 != null) {\n            // Calling the overloaded method\n            List<Edge> allMethodEdges =\n                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n            for (Edge methodEdge : allMethodEdges) {\n                Node targetMethod = methodEdge.getTarget();\n                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n                    hasSameNameAndSignature = true;\n            }\n        }\n        return hasSameNameAndSignature;\n    }\n\n    private boolean isDeprecatedOrRemoved(Node[] pair) {\n        Node source = pair[0];\n        String parentOfOriginal = extractFullyQualifiedParentName(source);\n        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n        boolean isDeprecated = false;\n        boolean isRemoved = true;\n        if (parentOfOriginalInV2 != null) {\n            List<Edge> methodEdges =\n                    filterNamedEdges(\n                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n            for (Edge edge : methodEdges) {\n                Node methodNode = edge.getTarget();\n                if (methodNode.getSimpleName().equals(source.getSimpleName())\n                        && methodNode.getSignature().equals(source.getSignature())) {\n                    isRemoved = false;\n                    isDeprecated = methodNode.isDeprecated();\n                }\n            }\n        }\n\n        return isDeprecated || isRemoved;\n    }\n\n    @Override\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n        List<Node[]> goodResults = new ArrayList<Node[]>();\n\n        for (Node[] pair : listWithFP) {\n            String signatureN1 = pair[0].getSignature();\n            String signatureN2 = pair[1].getSignature();\n            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n        }\n        return goodResults;\n    }\n\n    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n        // TODO filters out (IPluginDescriptor) with\n        // (org.eclipse.core.runtime.IPluginDescriptor)\n        // right now this is checked only for case when there is a one argument\n        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n        return simpleName1.equals(simpleName2);\n    }\n\n    private String extractSimpleName(String fqn) {\n        int lastIndex = fqn.lastIndexOf(".");\n        if (lastIndex < 0) return fqn;\n        else return fqn.substring(lastIndex + 1);\n    }\n\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "22d6567d6477384c180746c8c4fc18abb6096366",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "modified",
            additions: 67,
            deletions: 69,
            patch:
              "@@ -1,84 +1,82 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.MethodNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.MethodNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n+    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn false;\n-\t}\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n \n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n \n-\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tList<String> callers;\n-\t\tif (this instanceof ChangeMethodSignatureDetection)\n-\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n-\t\telse\n-\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n-\t\tfor (String s : callers) {\n-\t\t\tNode callerNode = graph.findNamedNode(s);\n-\t\t\tif (callerNode != null) {\n-\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n-\t\t\t}\n-\t\t}\n-\t\tnode.setCreatedCallGraph();\n+    @Override\n+    public boolean isRename() {\n+        // TODO Auto-generated method stub\n+        return false;\n+    }\n \n-\t}\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n \n-\tprotected void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateCallGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateCallGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n+    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        List<String> callers;\n+        if (this instanceof ChangeMethodSignatureDetection)\n+            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+        for (String s : callers) {\n+            Node callerNode = graph.findNamedNode(s);\n+            if (callerNode != null) {\n+                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+            }\n+        }\n+        node.setCreatedCallGraph();\n+    }\n \n-\tpublic double analyzeIncomingEdges(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade;\n-\t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n-\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn incomingEdgesGrade;\n-\t}\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n \n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+        incomingEdgesGrade =\n+                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isRename() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        List<String> callers;\n        if (this instanceof ChangeMethodSignatureDetection)\n            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n        for (String s : callers) {\n            Node callerNode = graph.findNamedNode(s);\n            if (callerNode != null) {\n                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n            }\n        }\n        node.setCreatedCallGraph();\n    }\n\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n        incomingEdgesGrade =\n                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "e6ad69dba3d9b0400b7a54a0212510b747b388c5",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "modified",
            additions: 207,
            deletions: 232,
            patch:
              '@@ -1,241 +1,216 @@\n package refactoring.crawler.detection.methodDetection;\n \n+import java.util.*;\n import refactoring.crawler.RefactoringCrawler;\n import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n-import java.util.*;\n-\n public class MoveMethodDetection extends MethodDetection {\n \n-\tprivate Node targetClassInVerGraph;\n-\n-\tprivate Node targetClassInOrigGraph;\n-\n-\tprivate RefactoringCrawler crawler;\n-\n-\t/**\n-\t * Checks for MoveMethod\n-\t * <p>\n-\t * 1. Check that from the old method, all the references to objects having\n-\t * the same type as the destination class were removed\n-\t * <p>\n-\t * 2. Check that the new target class is either a previous argument or a\n-\t * field in the old class\n-\t */\n-\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t\tthis.crawler = crawler;\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tdouble edgeGrade = 0.0;\n-\n-\t\tdouble referenceGrade = 0.0;\n-\n-\t\tif (isTargetARenameOfSourceClass(original, version))\n-\t\t\treturn 0.0;\n-\n-\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n-\t\treferenceGrade = referencesRemoved(original, version);\n-\t\tedgeGrade = analyzeIncomingEdges(original, version);\n-\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n-\t}\n-\n-\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n-\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n-\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n-\t\t// treat case 1\n-\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n-\t}\n-\n-\t/**\n-\t * 1. Check that from the old method, all the references to objects having\n-\t * the same type as the destination class were removed\n-\t */\n-\tprivate double referencesRemoved(Node original, Node version) {\n-\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n-\n-\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n-\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n-\t\t// treat case 2\n-\t\tif (targetClassInOrigGraph == null) {\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tEnumeration<String> keys = dictionary.keys();\n-\t\t\tfor (; keys.hasMoreElements(); ) {\n-\t\t\t\tString aKey = keys.nextElement();\n-\t\t\t\tString aValue = dictionary.get(aKey);\n-\t\t\t\tif (targetInVersion.equals(aValue)) {\n-\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// treat case 3\n-\t\t\tif (targetClassInOrigGraph == null)\n-\t\t\t\treturn 1.0;\n-\n-\t\t}\n-\n-\t\t// treat case 2 and 4\n-\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n-\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n-\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n-\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n-\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n-\t\t}\n-\n-\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n-\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n-\t\t\ttargetClassInVerGraph));\n-\t\tif (originalClassReferences.size() == 0) {\n-\t\t\tif (original.isStatic())\n-\t\t\t\treturn 1.0;\n-\t\t\tif (isTargetClassAFieldInSourceClass(original,\n-\t\t\t\ttargetClassInOrigGraph))\n-\t\t\t\treturn 1.0;\n-\t\t\tif (versionClassReferences.size() == 0)\n-\t\t\t\treturn 1.0;\n-\t\t\treturn 0.0;\n-\t\t} else\n-\t\t\treturn Math\n-\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n-\t\t\t\t\t.size()) / originalClassReferences.size()));\n-\t}\n-\n-\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n-\t\tNode parentClass = graph1\n-\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n-\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n-\t\tList<Node> fields = new ArrayList<Node>();\n-\t\tfor (Edge value : edges) {\n-\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tfields.add((Node) value.getTarget());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn fields.contains(theTargetClassInOrigGraph);\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\n-\t\t\t// Prune toString since the SearchEngine finds all the toString()\n-\t\t\t// methods, even those that are called from different classes\n-\t\t\tif ("toString".equals(original.getSimpleName()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Overriden here to prune false positives due to overlapping PullUp and\n-\t * PushDown detection\n-\t */\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n-\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n-\t\treturn withoutFP;\n-\t}\n-\n-\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n-\t\tboolean needsOneMorePass = false;\n-\t\tList<Node[]> addToPUM = new ArrayList<>();\n-\t\tList<Node[]> addToPDM = new ArrayList<>();\n-\t\tfor (Node[] pair : withoutFP) {\n-\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n-\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n-\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n-\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n-\t\t\tif (sourceClass != null && destinationClass != null) {\n-\t\t\t\tif (ClassDetection\n-\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n-\t\t\t\t\taddToPDM.add(pair);\n-\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n-\t\t\t\t\tsourceClass))\n-\t\t\t\t\taddToPUM.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\n-\t\tRefactoringCategory pulledUpCategory = null;\n-\t\tRefactoringCategory pushedDownCategory = null;\n-\t\t// TODO this only checks whether we already have such a category\n-\t\t// created. It might be\n-\t\t// that such a category has not been created previously (because no\n-\t\t// results were found\n-\t\t// for that category. In this case, will need to create a brand new\n-\t\t// Category object.\n-\t\tfor (RefactoringCategory category : refactoringsList) {\n-\t\t\tif (category.getName().equals("PulledUpMethods"))\n-\t\t\t\tpulledUpCategory = category;\n-\n-\t\t\telse if (category.getName().equals("PushedDownMethods"))\n-\t\t\t\tpushedDownCategory = category;\n-\t\t}\n-\n-\t\tfor (Node[] pair : addToPDM) {\n-\t\t\tif (pushedDownCategory != null)\n-\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n-\t\t\twithoutFP.remove(pair);\n-\t\t\tneedsOneMorePass = true;\n-\t\t}\n-\n-\t\tfor (Node[] pair : addToPUM) {\n-\t\t\tif (pulledUpCategory != null)\n-\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n-\t\t\twithoutFP.remove(pair);\n-\t\t\tneedsOneMorePass = true;\n-\t\t}\n-\t\tif (needsOneMorePass)\n-\t\t\treturn pruneFalsePositives(withoutFP);\n-\t\telse return withoutFP;\n-\t}\n-\n-\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n-\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n-\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\t\tfor (RefactoringCategory category : refactoringsList) {\n-\t\t\tif (category.getName().equals("PulledUpMethods")\n-\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n-\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n-\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n-\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n-\t\t\t\t\t\t// overlappings\n-\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n-\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n-\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n-\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : pairsToRemove) {\n-\t\t\tprunedList.remove(pair);\n-\t\t}\n-\t\treturn prunedList;\n-\t}\n+    private Node targetClassInVerGraph;\n+\n+    private Node targetClassInOrigGraph;\n+\n+    private RefactoringCrawler crawler;\n+\n+    /**\n+    * Checks for MoveMethod\n+    *\n+    * <p>1. Check that from the old method, all the references to objects having the same type as the\n+    * destination class were removed\n+    *\n+    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n+    */\n+    public MoveMethodDetection(\n+            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+        super(graph1, graph2);\n+        this.crawler = crawler;\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        double edgeGrade = 0.0;\n+\n+        double referenceGrade = 0.0;\n+\n+        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+\n+        // FIXME: Potential problem when we subtract 0.01 from reference grade\n+        referenceGrade = referencesRemoved(original, version);\n+        edgeGrade = analyzeIncomingEdges(original, version);\n+        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+    }\n+\n+    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+        String sourceInOriginal = extractFullyQualifiedParentName(original);\n+        String targetInVersion = extractFullyQualifiedParentName(version);\n+        // treat case 1\n+        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+    }\n+\n+    /**\n+    * 1. Check that from the old method, all the references to objects having the same type as the\n+    * destination class were removed\n+    */\n+    private double referencesRemoved(Node original, Node version) {\n+        String targetInVersion = extractFullyQualifiedParentName(version);\n+\n+        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+        // treat case 2\n+        if (targetClassInOrigGraph == null) {\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            Enumeration<String> keys = dictionary.keys();\n+            for (; keys.hasMoreElements(); ) {\n+                String aKey = keys.nextElement();\n+                String aValue = dictionary.get(aKey);\n+                if (targetInVersion.equals(aValue)) {\n+                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n+                }\n+            }\n+\n+            // treat case 3\n+            if (targetClassInOrigGraph == null) return 1.0;\n+        }\n+\n+        // treat case 2 and 4\n+        if (!targetClassInVerGraph.hasCallGraph()) {\n+            createClassReferenceGraph(targetClassInVerGraph, graph2);\n+            targetClassInVerGraph.setCreatedCallGraph();\n+        }\n+        if (!targetClassInOrigGraph.hasCallGraph()) {\n+            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n+            targetClassInOrigGraph.setCreatedCallGraph();\n+        }\n+\n+        List<Edge> originalClassReferences =\n+                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+        List<Edge> versionClassReferences =\n+                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n+        if (originalClassReferences.size() == 0) {\n+            if (original.isStatic()) return 1.0;\n+            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n+            if (versionClassReferences.size() == 0) return 1.0;\n+            return 0.0;\n+        } else\n+            return Math.abs(\n+                    ((originalClassReferences.size() - versionClassReferences.size())\n+                            / originalClassReferences.size()));\n+    }\n+\n+    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n+        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+        List<Node> fields = new ArrayList<Node>();\n+        for (Edge value : edges) {\n+            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+                fields.add((Node) value.getTarget());\n+            }\n+        }\n+\n+        return fields.contains(theTargetClassInOrigGraph);\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+\n+            // Prune toString since the SearchEngine finds all the toString()\n+            // methods, even those that are called from different classes\n+            if ("toString".equals(original.getSimpleName())) continue;\n+\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+        return candidatesWithDifferentParentClass;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n+\n+    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+        return withoutFP;\n+    }\n+\n+    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+        boolean needsOneMorePass = false;\n+        List<Node[]> addToPUM = new ArrayList<>();\n+        List<Node[]> addToPDM = new ArrayList<>();\n+        for (Node[] pair : withoutFP) {\n+            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n+            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n+            if (sourceClass != null && destinationClass != null) {\n+                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n+                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n+            }\n+        }\n+\n+        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+        RefactoringCategory pulledUpCategory = null;\n+        RefactoringCategory pushedDownCategory = null;\n+        // TODO this only checks whether we already have such a category\n+        // created. It might be\n+        // that such a category has not been created previously (because no\n+        // results were found\n+        // for that category. In this case, will need to create a brand new\n+        // Category object.\n+        for (RefactoringCategory category : refactoringsList) {\n+            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n+            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n+        }\n+\n+        for (Node[] pair : addToPDM) {\n+            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n+            withoutFP.remove(pair);\n+            needsOneMorePass = true;\n+        }\n+\n+        for (Node[] pair : addToPUM) {\n+            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n+            withoutFP.remove(pair);\n+            needsOneMorePass = true;\n+        }\n+        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n+        else return withoutFP;\n+    }\n+\n+    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+        List<Node[]> pairsToRemove = new ArrayList<>();\n+        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+        for (RefactoringCategory category : refactoringsList) {\n+            if (category.getName().equals("PulledUpMethods")\n+                    || category.getName().equals("PushedDownMethods")) {\n+                for (Node[] pair : category.getRefactoringPairs()) {\n+                    for (Node[] prunedPair : prunedList) {\n+                        // The OR below takes care about n->1 and 1->n\n+                        // overlappings\n+                        // between PullUp/PushDown and MoveMethod\n+                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : pairsToRemove) {\n+            prunedList.remove(pair);\n+        }\n+        return prunedList;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n    private Node targetClassInVerGraph;\n\n    private Node targetClassInOrigGraph;\n\n    private RefactoringCrawler crawler;\n\n    /**\n    * Checks for MoveMethod\n    *\n    * <p>1. Check that from the old method, all the references to objects having the same type as the\n    * destination class were removed\n    *\n    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n    */\n    public MoveMethodDetection(\n            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n        super(graph1, graph2);\n        this.crawler = crawler;\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        double edgeGrade = 0.0;\n\n        double referenceGrade = 0.0;\n\n        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n        // FIXME: Potential problem when we subtract 0.01 from reference grade\n        referenceGrade = referencesRemoved(original, version);\n        edgeGrade = analyzeIncomingEdges(original, version);\n        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n    }\n\n    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n        String sourceInOriginal = extractFullyQualifiedParentName(original);\n        String targetInVersion = extractFullyQualifiedParentName(version);\n        // treat case 1\n        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n    }\n\n    /**\n    * 1. Check that from the old method, all the references to objects having the same type as the\n    * destination class were removed\n    */\n    private double referencesRemoved(Node original, Node version) {\n        String targetInVersion = extractFullyQualifiedParentName(version);\n\n        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n        // treat case 2\n        if (targetClassInOrigGraph == null) {\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            Enumeration<String> keys = dictionary.keys();\n            for (; keys.hasMoreElements(); ) {\n                String aKey = keys.nextElement();\n                String aValue = dictionary.get(aKey);\n                if (targetInVersion.equals(aValue)) {\n                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n                }\n            }\n\n            // treat case 3\n            if (targetClassInOrigGraph == null) return 1.0;\n        }\n\n        // treat case 2 and 4\n        if (!targetClassInVerGraph.hasCallGraph()) {\n            createClassReferenceGraph(targetClassInVerGraph, graph2);\n            targetClassInVerGraph.setCreatedCallGraph();\n        }\n        if (!targetClassInOrigGraph.hasCallGraph()) {\n            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n            targetClassInOrigGraph.setCreatedCallGraph();\n        }\n\n        List<Edge> originalClassReferences =\n                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n        List<Edge> versionClassReferences =\n                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n        if (originalClassReferences.size() == 0) {\n            if (original.isStatic()) return 1.0;\n            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n            if (versionClassReferences.size() == 0) return 1.0;\n            return 0.0;\n        } else\n            return Math.abs(\n                    ((originalClassReferences.size() - versionClassReferences.size())\n                            / originalClassReferences.size()));\n    }\n\n    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n        List<Node> fields = new ArrayList<Node>();\n        for (Edge value : edges) {\n            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n                fields.add((Node) value.getTarget());\n            }\n        }\n\n        return fields.contains(theTargetClassInOrigGraph);\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n\n            // Prune toString since the SearchEngine finds all the toString()\n            // methods, even those that are called from different classes\n            if ("toString".equals(original.getSimpleName())) continue;\n\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n\n    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n        return withoutFP;\n    }\n\n    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n        boolean needsOneMorePass = false;\n        List<Node[]> addToPUM = new ArrayList<>();\n        List<Node[]> addToPDM = new ArrayList<>();\n        for (Node[] pair : withoutFP) {\n            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n            if (sourceClass != null && destinationClass != null) {\n                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n            }\n        }\n\n        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n        RefactoringCategory pulledUpCategory = null;\n        RefactoringCategory pushedDownCategory = null;\n        // TODO this only checks whether we already have such a category\n        // created. It might be\n        // that such a category has not been created previously (because no\n        // results were found\n        // for that category. In this case, will need to create a brand new\n        // Category object.\n        for (RefactoringCategory category : refactoringsList) {\n            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n        }\n\n        for (Node[] pair : addToPDM) {\n            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n            withoutFP.remove(pair);\n            needsOneMorePass = true;\n        }\n\n        for (Node[] pair : addToPUM) {\n            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n            withoutFP.remove(pair);\n            needsOneMorePass = true;\n        }\n        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n        else return withoutFP;\n    }\n\n    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n        List<Node[]> pairsToRemove = new ArrayList<>();\n        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n        for (RefactoringCategory category : refactoringsList) {\n            if (category.getName().equals("PulledUpMethods")\n                    || category.getName().equals("PushedDownMethods")) {\n                for (Node[] pair : category.getRefactoringPairs()) {\n                    for (Node[] prunedPair : prunedList) {\n                        // The OR below takes care about n->1 and 1->n\n                        // overlappings\n                        // between PullUp/PushDown and MoveMethod\n                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n                    }\n                }\n            }\n        }\n        for (Node[] pair : pairsToRemove) {\n            prunedList.remove(pair);\n        }\n        return prunedList;\n    }\n}\n'
          },
          {
            sha: "9a65c27dea4e74b026c3165812f7abe0280ff32d",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "modified",
            additions: 53,
            deletions: 60,
            patch:
              '@@ -1,73 +1,66 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class PullUpMethodDetection extends MethodDetection {\n \n-\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t/**\n-\t * We should now check for the same method being in the parent class, thus\n-\t * for the two nodes, check if the version now resides in the superclass of\n-\t * the original method\'s parent class.\n-\t */\n-\t// TODO: Check why we get a null pointer exception with parentclassver and\n-\t// parent class orig)\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade = 0.0;\n-\t\tboolean isSuperclass = false;\n-\t\t// TODO: Think about possible different cases that this might be\n-\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n-\t\t// find it.\n-\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n-\t\t// since clearly they are not "like" each other.\n-\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n-\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-\t\tif (parentClassOrig == null)\n-\t\t\treturn 0.0;\n-\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n-\t\t// Now we should check if parentClassOrig is a subclass of\n-\t\t// parentClassVer\n-\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n-\t\t\tisSuperclass = true;\n+    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t\tif (isSuperclass) {\n-\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n-\t\t\treturn incomingEdgesGrade;\n-\t\t} else\n-\t\t\treturn 0.0;\n-\t}\n+    /**\n+    * We should now check for the same method being in the parent class, thus for the two nodes,\n+    * check if the version now resides in the superclass of the original method\'s parent class.\n+    */\n+    // TODO: Check why we get a null pointer exception with parentclassver and\n+    // parent class orig)\n+    public double computeLikeliness(Node original, Node version) {\n+        double incomingEdgesGrade = 0.0;\n+        boolean isSuperclass = false;\n+        // TODO: Think about possible different cases that this might be\n+        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+        // find it.\n+        // TODO: Think about the NULL case. Return 0.0 if you find null,\n+        // since clearly they are not "like" each other.\n+        String parentClassOriginal = extractFullyQualifiedParentName(original);\n+        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+        String parentClassVersion = extractFullyQualifiedParentName(version);\n+        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+        if (parentClassOrig == null) return 0.0;\n+        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+        // Now we should check if parentClassOrig is a subclass of\n+        // parentClassVer\n+        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n \n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n-\t\t\tString parentClassVersion = extractParentSimpleName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n+        if (isSuperclass) {\n+            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n+            return incomingEdgesGrade;\n+        } else return 0.0;\n+    }\n \n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractParentSimpleName(original);\n+            String parentClassVersion = extractParentSimpleName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+        return candidatesWithDifferentParentClass;\n+    }\n \n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    /**\n    * We should now check for the same method being in the parent class, thus for the two nodes,\n    * check if the version now resides in the superclass of the original method\'s parent class.\n    */\n    // TODO: Check why we get a null pointer exception with parentclassver and\n    // parent class orig)\n    public double computeLikeliness(Node original, Node version) {\n        double incomingEdgesGrade = 0.0;\n        boolean isSuperclass = false;\n        // TODO: Think about possible different cases that this might be\n        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n        // find it.\n        // TODO: Think about the NULL case. Return 0.0 if you find null,\n        // since clearly they are not "like" each other.\n        String parentClassOriginal = extractFullyQualifiedParentName(original);\n        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n        String parentClassVersion = extractFullyQualifiedParentName(version);\n        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n        if (parentClassOrig == null) return 0.0;\n        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n        // Now we should check if parentClassOrig is a subclass of\n        // parentClassVer\n        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n        if (isSuperclass) {\n            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n            return incomingEdgesGrade;\n        } else return 0.0;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractParentSimpleName(original);\n            String parentClassVersion = extractParentSimpleName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "42f7911b558ea66066d1d087470193efa249633b",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "modified",
            additions: 46,
            deletions: 51,
            patch:
              '@@ -1,59 +1,54 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class PushDownMethodDetection extends MethodDetection {\n \n-\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tboolean superClassGrade = false;\n-\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n-\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-\t\tif (parentClassOrig == null)\n-\t\t\treturn 0.0;\n-\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n-\t\t// Now we should check if parentClassVer is a subclass of\n-\t\t// parentClassOrig\n-\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n-\t\t\tSystem.out.println("stop");\n-\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n-\t\t\tsuperClassGrade = true;\n-\t\tif (superClassGrade) {\n-\t\t\treturn (analyzeIncomingEdges(original, version));\n-\t\t} else\n-\t\t\treturn 0.0;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n-\t\t\tString parentClassVersion = extractParentSimpleName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        boolean superClassGrade = false;\n+        String parentClassOriginal = extractFullyQualifiedParentName(original);\n+        String parentClassVersion = extractFullyQualifiedParentName(version);\n+        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+        if (parentClassOrig == null) return 0.0;\n+        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+        // Now we should check if parentClassVer is a subclass of\n+        // parentClassOrig\n+        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+            System.out.println("stop");\n+        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n+        if (superClassGrade) {\n+            return (analyzeIncomingEdges(original, version));\n+        } else return 0.0;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractParentSimpleName(original);\n+            String parentClassVersion = extractParentSimpleName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+\n+        return candidatesWithDifferentParentClass;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        boolean superClassGrade = false;\n        String parentClassOriginal = extractFullyQualifiedParentName(original);\n        String parentClassVersion = extractFullyQualifiedParentName(version);\n        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n        if (parentClassOrig == null) return 0.0;\n        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n        // Now we should check if parentClassVer is a subclass of\n        // parentClassOrig\n        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n            System.out.println("stop");\n        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n        if (superClassGrade) {\n            return (analyzeIncomingEdges(original, version));\n        } else return 0.0;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractParentSimpleName(original);\n            String parentClassVersion = extractParentSimpleName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "35f126943b291e74fbe8c0be61f5210fc0c9d019",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 64,
            deletions: 71,
            patch:
              "@@ -1,85 +1,78 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.Dictionary;\n import java.util.List;\n-\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class RenameMethodDetection extends MethodDetection {\n \n-\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\t\tsuper(oldVersion, newVersion);\n-\t}\n-\n+    public RenameMethodDetection(\n+            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+        super(oldVersion, newVersion);\n+    }\n \n-\t/**\n-\t * @param candidates List containing clone methods\n-\t * @return A List containing only the candidate methods that are in the same\n-\t * class\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName()))))\n-\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-\t\t}\n+    /**\n+    * @param candidates List containing clone methods\n+    * @return A List containing only the candidate methods that are in the same class\n+    */\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n+                candidatesWithSameParentClass.add(pair);\n+        }\n \n-\t\treturn candidatesWithSameParentClass;\n-\t}\n+        return candidatesWithSameParentClass;\n+    }\n \n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\t// createCallGraph(original, version);\n-\t\t// return computeLikelinessConsideringEdges(original, version);\n-\t\treturn analyzeIncomingEdges(original, version);\n-\t}\n+    public double computeLikeliness(Node original, Node version) {\n+        // createCallGraph(original, version);\n+        // return computeLikelinessConsideringEdges(original, version);\n+        return analyzeIncomingEdges(original, version);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+    @Override\n+    public boolean isRename() {\n+        return true;\n+    }\n \n-\t/**\n-\t * Prune further for cases that have n-to-1 mappings.\n-\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n-\t */\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-\t\tfor (int i = 0; i < prunedList.size(); i++) {\n-\t\t\tNode[] pair = prunedList.get(i);\n-\t\t\tNode target = pair[1];\n-\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n-\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n-\t\t\tfor (Node[] nodes : prunedList) {\n-\t\t\t\tNode potentialTarget = (nodes)[1];\n-\t\t\t\tif (target == potentialTarget)\n-\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n-\t\t\t}\n-\t\t\tif (allPairsWithSameTarget.size() > 1) {\n-\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n-\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n-\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n-\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n-\t\t\t\t\t\t.toLowerCase().trim();\n-\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n-\t\t\t\t\tif ((!targetName.contains(sourceName))\n-\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n-\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n-\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedList;\n-\t}\n+    /**\n+    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n+    * getStartConnector) in JHD5.3 )\n+    */\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+        for (int i = 0; i < prunedList.size(); i++) {\n+            Node[] pair = prunedList.get(i);\n+            Node target = pair[1];\n+            String targetName = target.getSimpleName().toLowerCase().trim();\n+            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+            for (Node[] nodes : prunedList) {\n+                Node potentialTarget = (nodes)[1];\n+                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n+            }\n+            if (allPairsWithSameTarget.size() > 1) {\n+                for (Object o : allPairsWithSameTarget) {\n+                    Node[] sameTargetPair = (Node[]) o;\n+                    Node sourceNode = sameTargetPair[0];\n+                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n+                    // Changed from || to && and changed the !='s to =='s\n+                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n+                        prunedList.remove(sameTargetPair);\n+                        Dictionary<String, String> dictionary = getRenamingDictionary();\n+                        dictionary.remove(sourceNode.getFullyQualifiedName());\n+                    }\n+                }\n+            }\n+        }\n+        return prunedList;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n    public RenameMethodDetection(\n            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n        super(oldVersion, newVersion);\n    }\n\n    /**\n    * @param candidates List containing clone methods\n    * @return A List containing only the candidate methods that are in the same class\n    */\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n                candidatesWithSameParentClass.add(pair);\n        }\n\n        return candidatesWithSameParentClass;\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        // createCallGraph(original, version);\n        // return computeLikelinessConsideringEdges(original, version);\n        return analyzeIncomingEdges(original, version);\n    }\n\n    @Override\n    public boolean isRename() {\n        return true;\n    }\n\n    /**\n    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n    * getStartConnector) in JHD5.3 )\n    */\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n        for (int i = 0; i < prunedList.size(); i++) {\n            Node[] pair = prunedList.get(i);\n            Node target = pair[1];\n            String targetName = target.getSimpleName().toLowerCase().trim();\n            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n            for (Node[] nodes : prunedList) {\n                Node potentialTarget = (nodes)[1];\n                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n            }\n            if (allPairsWithSameTarget.size() > 1) {\n                for (Object o : allPairsWithSameTarget) {\n                    Node[] sameTargetPair = (Node[]) o;\n                    Node sourceNode = sameTargetPair[0];\n                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n                    // Changed from || to && and changed the !='s to =='s\n                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n                        prunedList.remove(sameTargetPair);\n                        Dictionary<String, String> dictionary = getRenamingDictionary();\n                        dictionary.remove(sourceNode.getFullyQualifiedName());\n                    }\n                }\n            }\n        }\n        return prunedList;\n    }\n}\n"
          },
          {
            sha: "57d8e14adb21db33b91bda9b9596bead5ed00a95",
            filename: "src/main/java/refactoring/crawler/graph/ClassNode.java",
            status: "added",
            additions: 18,
            deletions: 0,
            patch:
              "@@ -0,0 +1,18 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class ClassNode extends Node {\n+\n+    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n+\n+    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public ClassNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.CLASS);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public ClassNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.CLASS);\n    }\n}\n"
          },
          {
            sha: "0a51f2cce0dd323822aef1eda7b82be5271d814c",
            filename: "src/main/java/refactoring/crawler/graph/Edge.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              '@@ -0,0 +1,35 @@\n+package refactoring.crawler.graph;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DefaultEdge;\n+\n+public class Edge extends DefaultEdge {\n+\n+    @Getter @Setter private Node.Type label;\n+\n+    public Edge(Node.Type label) {\n+        this.label = label;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+    }\n+\n+    @Override\n+    public Node getSource() {\n+        return (Node) super.getSource();\n+    }\n+\n+    @Override\n+    public Node getTarget() {\n+        return (Node) super.getTarget();\n+    }\n+\n+    public Node oppositeVertex(Node n) {\n+        Node source = this.getSource();\n+        Node target = this.getTarget();\n+        return n.equals(source) ? target : source;\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n    @Getter @Setter private Node.Type label;\n\n    public Edge(Node.Type label) {\n        this.label = label;\n    }\n\n    @Override\n    public String toString() {\n        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n    }\n\n    @Override\n    public Node getSource() {\n        return (Node) super.getSource();\n    }\n\n    @Override\n    public Node getTarget() {\n        return (Node) super.getTarget();\n    }\n\n    public Node oppositeVertex(Node n) {\n        Node source = this.getSource();\n        Node target = this.getTarget();\n        return n.equals(source) ? target : source;\n    }\n}\n'
          },
          {
            sha: "2b79bc6995c1dd3051b10d8cb540d984cb0ff4e7",
            filename: "src/main/java/refactoring/crawler/graph/FieldNode.java",
            status: "added",
            additions: 15,
            deletions: 0,
            patch:
              "@@ -0,0 +1,15 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FieldNode extends Node {\n+\n+    @Getter @Setter private List<String> fieldReferenceToMethod;\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public FieldNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.FIELD);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n    @Getter @Setter private List<String> fieldReferenceToMethod;\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public FieldNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.FIELD);\n    }\n}\n"
          },
          {
            sha: "3723ff5fff00d30204dcfe1049ea7e5f66d3b72e",
            filename: "src/main/java/refactoring/crawler/graph/MethodNode.java",
            status: "added",
            additions: 24,
            deletions: 0,
            patch:
              "@@ -0,0 +1,24 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class MethodNode extends Node {\n+\n+    @AllArgsConstructor\n+    public static class CalledMethod {\n+        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n+\n+        @Getter @Setter private String fullyQualifiedNameWithSignature;\n+    }\n+\n+    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public MethodNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.METHOD);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n    @AllArgsConstructor\n    public static class CalledMethod {\n        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n        @Getter @Setter private String fullyQualifiedNameWithSignature;\n    }\n\n    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public MethodNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.METHOD);\n    }\n}\n"
          },
          {
            sha: "95512f366ed1570e1bface854dab31a016f59a38",
            filename:
              "src/main/java/refactoring/crawler/graph/NamedDirectedMultigraph.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import lombok.Getter;\n+import org.jgrapht.graph.DirectedMultigraph;\n+\n+public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n+\n+    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+    public NamedDirectedMultigraph() {\n+        super(Edge.class);\n+    }\n+\n+    public NamedDirectedMultigraph(\n+            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+        super(vertexSupplier, edgeSupplier, weighted);\n+    }\n+\n+    public boolean addNamedVertex(Node v) {\n+        if (!addVertex(v)) return false;\n+        namedVertexMap.put(v.getFullyQualifiedName(), v);\n+        return true;\n+    }\n+\n+    public Node findNamedNode(String name) {\n+        return namedVertexMap.get(name);\n+    }\n+\n+    public boolean hasNamedNode(String name) {\n+        return namedVertexMap.containsKey(name);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n    public NamedDirectedMultigraph() {\n        super(Edge.class);\n    }\n\n    public NamedDirectedMultigraph(\n            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n        super(vertexSupplier, edgeSupplier, weighted);\n    }\n\n    public boolean addNamedVertex(Node v) {\n        if (!addVertex(v)) return false;\n        namedVertexMap.put(v.getFullyQualifiedName(), v);\n        return true;\n    }\n\n    public Node findNamedNode(String name) {\n        return namedVertexMap.get(name);\n    }\n\n    public boolean hasNamedNode(String name) {\n        return namedVertexMap.containsKey(name);\n    }\n}\n"
          },
          {
            sha: "b123fcf4966c594a330922d4f004967b16a1d96c",
            filename: "src/main/java/refactoring/crawler/graph/Node.java",
            status: "added",
            additions: 74,
            deletions: 0,
            patch:
              '@@ -0,0 +1,74 @@\n+package refactoring.crawler.graph;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class Node {\n+\n+    public boolean hasCallGraph() {\n+        return false;\n+    }\n+\n+    public void setCreatedCallGraph() {}\n+\n+    public static enum Type {\n+        PROJECT,\n+        PACKAGE,\n+        CLASS,\n+        METHOD,\n+        FIELD,\n+        METHOD_CALL,\n+        IMPORT,\n+        CLASS_REFERENCE,\n+        FIELD_REFERENCE\n+    }\n+\n+    @Getter @Setter private String fullyQualifiedName;\n+\n+    @Setter @Getter private Node.Type type;\n+\n+    @Setter @Getter private int[] shingles;\n+\n+    @Setter @Getter private boolean hasCallGraph;\n+\n+    @Setter @Getter private String projectName;\n+\n+    @Setter @Getter private boolean isAPI = false;\n+\n+    @Setter @Getter private String signature;\n+\n+    @Setter @Getter private int flags;\n+\n+    @Setter @Getter private boolean deprecated = false;\n+\n+    @Setter @Getter private boolean isInterface = false;\n+\n+    @Getter @Setter private boolean isStatic = false;\n+\n+    /**\n+    * @param fullyQualifiedName fullyQualifiedName\n+    * @param type type\n+    */\n+    public Node(String fullyQualifiedName, Node.Type type) {\n+        this.fullyQualifiedName = fullyQualifiedName;\n+        this.type = type;\n+    }\n+\n+    public String getSimpleName() {\n+        int pos = fullyQualifiedName.lastIndexOf(".");\n+        if (pos != -1) {\n+            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n+        }\n+        return fullyQualifiedName;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (getSignature() != null)\n+            return getType()\n+                    + "= "\n+                    + getFullyQualifiedName()\n+                    + getSignature().substring(getSignature().indexOf("("));\n+        else return getType() + "= " + getFullyQualifiedName();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {}\n\n    public static enum Type {\n        PROJECT,\n        PACKAGE,\n        CLASS,\n        METHOD,\n        FIELD,\n        METHOD_CALL,\n        IMPORT,\n        CLASS_REFERENCE,\n        FIELD_REFERENCE\n    }\n\n    @Getter @Setter private String fullyQualifiedName;\n\n    @Setter @Getter private Node.Type type;\n\n    @Setter @Getter private int[] shingles;\n\n    @Setter @Getter private boolean hasCallGraph;\n\n    @Setter @Getter private String projectName;\n\n    @Setter @Getter private boolean isAPI = false;\n\n    @Setter @Getter private String signature;\n\n    @Setter @Getter private int flags;\n\n    @Setter @Getter private boolean deprecated = false;\n\n    @Setter @Getter private boolean isInterface = false;\n\n    @Getter @Setter private boolean isStatic = false;\n\n    /**\n    * @param fullyQualifiedName fullyQualifiedName\n    * @param type type\n    */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType()\n                    + "= "\n                    + getFullyQualifiedName()\n                    + getSignature().substring(getSignature().indexOf("("));\n        else return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "d294a5f56dad1dba561bfd8d25bd70a7ccaa5d42",
            filename: "src/main/java/refactoring/crawler/project/IClass.java",
            status: "removed",
            additions: 0,
            deletions: 22,
            patch:
              "@@ -1,22 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import java.util.List;\n-\n-public interface IClass {\n-\n-    public List<IMethod> getMethods();\n-\n-    public List<IField> getFields();\n-\n-    public String getFullyQualifiedName();\n-\n-    public int getFlags();\n-\n-    public boolean getIsDeprecated();\n-\n-    public boolean getIsInterface();\n-\n-    public boolean isPublic();\n-\n-    public boolean isProtected();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IClass {\n\n    public List<IMethod> getMethods();\n\n    public List<IField> getFields();\n\n    public String getFullyQualifiedName();\n\n    public int getFlags();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsInterface();\n\n    public boolean isPublic();\n\n    public boolean isProtected();\n}\n"
          },
          {
            sha: "dbe2bf76763338d11712c8cb049d27ddc89620bb",
            filename: "src/main/java/refactoring/crawler/project/IField.java",
            status: "removed",
            additions: 0,
            deletions: 14,
            patch:
              "@@ -1,14 +0,0 @@\n-package refactoring.crawler.project;\n-\n-public interface IField {\n-\n-    public String getSource();\n-\n-    public String getElementName();\n-\n-    public int getFlags();\n-\n-    public String getTypeSignature();\n-\n-    public boolean getIsDeprecated();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IField {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public int getFlags();\n\n    public String getTypeSignature();\n\n    public boolean getIsDeprecated();\n}\n"
          },
          {
            sha: "aa5a6b80cb38b51776c717580c642edfd62ca7dd",
            filename: "src/main/java/refactoring/crawler/project/IMethod.java",
            status: "removed",
            additions: 0,
            deletions: 18,
            patch:
              "@@ -1,18 +0,0 @@\n-package refactoring.crawler.project;\n-\n-public interface IMethod {\n-\n-    public String getSource();\n-\n-    public String getElementName();\n-\n-    public boolean getIsPublic();\n-\n-    public boolean getIsDeprecated();\n-\n-    public boolean getIsProtected();\n-\n-    public int getFlags();\n-\n-    public String[] getParameterTypes();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IMethod {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public boolean getIsPublic();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsProtected();\n\n    public int getFlags();\n\n    public String[] getParameterTypes();\n}\n"
          },
          {
            sha: "dab45c8026bdcaef0dfeb04913e60d8153553ec3",
            filename: "src/main/java/refactoring/crawler/project/IPackage.java",
            status: "removed",
            additions: 0,
            deletions: 16,
            patch:
              "@@ -1,16 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import com.github.javaparser.ast.CompilationUnit;\n-\n-import java.util.List;\n-\n-public interface IPackage {\n-\n-    public List<IClass> getClasses();\n-\n-    public List<IPackage> getChildrenPackages();\n-\n-    public String getElementName();\n-\n-//    public List<CompilationUnit> getCompilationUnit();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport java.util.List;\n\npublic interface IPackage {\n\n    public List<IClass> getClasses();\n\n    public List<IPackage> getChildrenPackages();\n\n    public String getElementName();\n\n//    public List<CompilationUnit> getCompilationUnit();\n}\n"
          },
          {
            sha: "1757c698aee63ab8c2e194f2656032cf614d9f39",
            filename: "src/main/java/refactoring/crawler/project/IProject.java",
            status: "removed",
            additions: 0,
            deletions: 10,
            patch:
              "@@ -1,10 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import java.util.List;\n-\n-public interface IProject {\n-\n-    public List<IPackage> getPackages();\n-\n-    public String getProjectName();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IProject {\n\n    public List<IPackage> getPackages();\n\n    public String getProjectName();\n}\n"
          },
          {
            sha: "448f7bcee55deabe401c3a889ce95bd377b9dfd5",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "removed",
            additions: 0,
            deletions: 35,
            patch:
              "@@ -1,35 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import com.github.javaparser.StaticJavaParser;\n-import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.PackageDeclaration;\n-import lombok.Getter;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-public class RCProject implements IProject {\n-\n-\t@Getter\n-\tprivate String projectName;\n-\n-\tprivate List<CompilationUnit> units;\n-\n-\tprivate List<IPackage> packages;\n-\n-\tpublic RCProject(String projectName, List<String> fileSources) {\n-\t\tthis.projectName = projectName;\n-\t\tthis.units = new LinkedList<>();\n-\t\tfor (String source : fileSources) {\n-\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n-\t\t\tthis.units.add(compilationUnit);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<IPackage> getPackages() {\n-\t\treturn null;\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\treturn null;\n\t}\n}\n"
          },
          {
            sha: "b48189ccbf00559dc0d879ba4853cc613404310b",
            filename:
              "src/main/java/refactoring/crawler/shingles/BloomFilter.java",
            status: "added",
            additions: 522,
            deletions: 0,
            patch:
              '@@ -0,0 +1,522 @@\n+package refactoring.crawler.shingles;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.net.URL;\n+\n+/**\n+* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n+*\n+* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n+* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n+* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n+* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n+* can make a useful tool.\n+*\n+* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n+* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n+* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n+* checkers.\n+*\n+* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n+* vector of a given length. We choose the length of the bit vector and the number of hash functions\n+* depending on how many keys we want to add to the set and how high an error rate we are willing to\n+* put up with.\n+*\n+* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n+* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n+* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+* function would increase our false-positive rate.\n+*\n+* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n+* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n+* a Bloom filter.\n+*\n+* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n+* key. We run the key through our set of hash functions, and then check to see whether the bits at\n+* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n+* the filter. If all of the bits are on, we know the key is probably there.\n+*\n+* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n+* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n+* bits we check will be on, unless the key actually exists in the filter. The relationship between\n+* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n+* will be very dense, increasing the probability of collisions. You can calculate the\n+* false-positive rate for any filter using the formula:\n+*\n+* <p><code>c = ( 1 - e(-kn/m) )k</code>\n+*\n+* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n+* in the filter, and m is the length of the filter in bits.\n+*\n+* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n+* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n+* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n+* our limit. The following equation will give us vector length from the error rate and number of\n+* keys:\n+*\n+* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n+*\n+* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n+* combinations of error rate, filter size, and number of hash functions at <a\n+* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n+* -- the math</a>.\n+*\n+* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n+* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n+* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n+* the case of JDK 1.4).\n+*\n+* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n+* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n+* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n+* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n+* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n+* even in this Java implementation the speed is reasonable.\n+*\n+* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+* method" by Andrei Broder. See <a\n+* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+* paper in PDF format.\n+*\n+* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n+* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n+* <code>URL</code>.\n+*\n+* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+* initial value multiplied by a list of distinct values.\n+*\n+* @see java.lang.Object#hashCode()\n+* @see java.util.Map\n+* @author Bruno Martins\n+*/\n+public class BloomFilter implements Cloneable {\n+\n+    /** A buffer for the Rabin fingerprinting algorithm. */\n+    private byte[] buffer;\n+\n+    /**\n+    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n+    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n+    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n+    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+    * bit is the constant coefficient.\n+    *\n+    * <p>For example the integer 0x00000803, in binary, is:\n+    *\n+    * <p><code>00000000 00000000 00001000 00000011</code>\n+    *\n+    * <p>Therefore it correponds to the polynomial:\n+    *\n+    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+    */\n+    private static int POLYNOMIAL = 0x000001C7;\n+\n+    /** Internal values for the Rabin fingerprinting algorithm. */\n+    private static int[] table32, table40, table48, table54;\n+\n+    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+    private static int P_DEGREE = 32;\n+\n+    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n+    private static int READ_BUFFER_SIZE = 2048;\n+\n+    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+\n+    /** The bit vector for the Bloom Filter. */\n+    private boolean keys[];\n+\n+    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+    private boolean useRabin = true;\n+\n+    /** The number of hash functions. */\n+    private int numFunctions;\n+\n+    /**\n+    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n+    * length for the bit vector (1000).\n+    */\n+    public BloomFilter() {\n+        table32 = new int[256];\n+        table40 = new int[256];\n+        table48 = new int[256];\n+        table54 = new int[256];\n+        buffer = new byte[READ_BUFFER_SIZE];\n+        // We want to have mods[i] == x^(P_DEGREE+i)\n+        int[] mods = new int[P_DEGREE];\n+        mods[0] = POLYNOMIAL;\n+        for (int i = 1; i < P_DEGREE; i++) {\n+            // x^i == x(x^(i-1)) (mod P)\n+            mods[i] = mods[i - 1] << 1;\n+            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+            // x^P_DEGREE term that \'fell off\' the top end.\n+            // Since x^P_DEGREE == P (mod P), we should add P\n+            // to account for this:\n+            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n+                mods[i] ^= POLYNOMIAL;\n+            }\n+        }\n+        for (int i = 0; i < 256; i++) {\n+            int c = i;\n+            for (int j = 0; j < 8 && c != 0; j++) {\n+                if ((c & 1) != 0) {\n+                    table32[i] ^= mods[j];\n+                    table40[i] ^= mods[j + 8];\n+                    table48[i] ^= mods[j + 16];\n+                    table54[i] ^= mods[j + 24];\n+                }\n+                c >>>= 1;\n+            }\n+        }\n+        mods = null;\n+        this.keys = new boolean[1000];\n+        this.numFunctions = 10;\n+        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Constructs a Bloom Filter from a string representation.\n+    *\n+    * @see #toString()\n+    */\n+    public BloomFilter(String filter) {\n+        this();\n+        int index1 = filter.indexOf(":");\n+        int index2 = filter.lastIndexOf(":");\n+        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n+        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n+        for (int i = index2 + 1; i < filter.length(); i++) {\n+            if (filter.charAt(i) == \'1\') keys[i] = true;\n+            else keys[i] = false;\n+        }\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n+    * error rate.\n+    *\n+    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n+    */\n+    public BloomFilter(int numKeys, double errorRate) {\n+        this();\n+        double lowest_m = Double.MAX_VALUE;\n+        int best_k = 1;\n+        for (int k = 1; k <= 100; k++) {\n+            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+            if (m < lowest_m) {\n+                lowest_m = m;\n+                best_k = k;\n+            }\n+        }\n+        this.keys = new boolean[numKeys];\n+        this.numFunctions = best_k;\n+        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n+    * length for the bit vector.\n+    *\n+    * @param numKeys The length of the bit vector.\n+    */\n+    public BloomFilter(int numKeys) {\n+        this(numKeys, 10);\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n+    * the bit vector.\n+    *\n+    * @param numKeys The length of the bit vector.\n+    * @param numHashFunctions The number of hash functions.\n+    */\n+    public BloomFilter(int numKeys, int numHashFunctions) {\n+        this();\n+        this.keys = new boolean[numKeys];\n+        this.numFunctions = numHashFunctions;\n+        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Internal method for producing the hash value for a given function number.\n+    *\n+    * @param fnum The number of the hash function.\n+    * @param original The original value for the hash of the object.\n+    * @see java.lang.Object#hashCode()\n+    * @return Returns the hash code value for the given function number.\n+    */\n+    private int getHash(int fnum, int original) {\n+        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n+        int hash[] = {original};\n+        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n+        hash[0] = hash[0] % keys.length;\n+        if (hash[0] < 0) hash[0] = -hash[0];\n+        return hash[0];\n+    }\n+\n+    /**\n+    * Returns true if this Bloom Filter contains the specified key.\n+    *\n+    * @param obj The key whose presence in this Bloom Filter is to be tested.\n+    * @return true if this Bloom Filter contains a mapping for the specified key.\n+    */\n+    public boolean hasKey(Object obj) {\n+        boolean result = true;\n+        int hashCodeObject;\n+        if (!useRabin) hashCodeObject = obj.hashCode();\n+        else\n+            try {\n+                hashCodeObject = hashRabin(obj);\n+            } catch (Exception e) {\n+                useRabin = false;\n+                hashCodeObject = obj.hashCode();\n+            }\n+        for (int i = 0; i < numFunctions && result; i++) {\n+            result &= keys[getHash(i, hashCodeObject)];\n+        }\n+        return result;\n+    }\n+\n+    /**\n+    * Adds the specified key in this Bloom Filter.\n+    *\n+    * @param obj The key to be added to this Bloom Filter.\n+    */\n+    public void put(Object obj) {\n+        int hashCodeObject;\n+        if (!useRabin) hashCodeObject = obj.hashCode();\n+        else\n+            try {\n+                hashCodeObject = hashRabin(obj);\n+            } catch (Exception e) {\n+                useRabin = false;\n+                hashCodeObject = obj.hashCode();\n+            }\n+        for (int i = 0; i < numFunctions; i++) {\n+            keys[getHash(i, hashCodeObject)] = true;\n+        }\n+    }\n+\n+    /**\n+    * Returns a string representation of this Bloom Filter. The string representation consists of an\n+    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n+    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n+    * the character ":".\n+    *\n+    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n+    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n+    * returned.\n+    *\n+    * @return A string representation of this Bloom Filter.\n+    */\n+    public String toString() {\n+        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n+        for (int i = 0; i < keys.length; i++) {\n+            if (keys[i]) aux.append("1");\n+            else aux.append("0");\n+        }\n+        return aux.toString();\n+    }\n+\n+    /**\n+    * Returns a copy of this Bloom Filter instance.\n+    *\n+    * @see java.lang.Object#clone()\n+    */\n+    public Object clone() {\n+        return new BloomFilter(this.toString());\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of bytes.\n+    *\n+    * @param arr An array of bytes.\n+    * @return The Rabin hash value for the array of bytes.\n+    */\n+    public int hashRabin(byte[] arr) {\n+        return hashRabin(arr, 0, arr.length, 0);\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of bytes.\n+    *\n+    * @param arr An array of bytes.\n+    * @param offset Index of the first byte of the array to hash.\n+    * @param length Number of bytes to hash.\n+    * @param ws ??\n+    * @return The Rabin hash value for the array of bytes.\n+    */\n+    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n+        int w = ws;\n+        int start = length % 4;\n+        for (int s = offset; s < offset + start; s++) {\n+            w = (w << 8) ^ (arr[s] & 0xFF);\n+        }\n+        for (int s = start + offset; s < length + offset; s += 4) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ (arr[s] << 24)\n+                            ^ ((arr[s + 1] & 0xFF) << 16)\n+                            ^ ((arr[s + 2] & 0xFF) << 8)\n+                            ^ (arr[s + 3] & 0xFF);\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of chars.\n+    *\n+    * @param arr An array of chars.\n+    * @return The Rabin hash value for the array of chars.\n+    */\n+    public int hashRabin(char[] arr) {\n+        int w = 0;\n+        int start = 0;\n+        if (arr.length % 2 == 1) {\n+            w = arr[0] & 0xFFFF;\n+            start = 1;\n+        }\n+        for (int s = start; s < arr.length; s += 2) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ ((arr[s] & 0xFFFF) << 16)\n+                            ^ (arr[s + 1] & 0xFFFF);\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the contents of a <code>File</code>.\n+    *\n+    * @param f A <code>File</code>.\n+    * @return The Rabin hash value for the contents of the File.\n+    * @throws FileNotFoundException If the file cannot be found.\n+    * @throws IOException If an error occurs while reading the file.\n+    */\n+    public int hashRabin(File f) throws FileNotFoundException, IOException {\n+        FileInputStream fis = new FileInputStream(f);\n+        try {\n+            return hashRabin(fis);\n+        } finally {\n+            fis.close();\n+        }\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+    *\n+    * @param is An InputStream.\n+    * @return The Rabin hash value for the contents read from the InputStream.\n+    * @throws IOException if an error occurs while reading from the InputStream.\n+    */\n+    public int hashRabin(InputStream is) throws IOException {\n+        int hashValue = 0;\n+        int bytesRead;\n+        synchronized (buffer) {\n+            while ((bytesRead = is.read(buffer)) > 0) {\n+                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+            }\n+        }\n+        return hashValue;\n+    }\n+\n+    /**\n+    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n+    * the hash methods, so it should be used when possible.\n+    *\n+    * @param arr An array of integers.\n+    * @return int The Rabin hash value for the array of integers.\n+    */\n+    public int hashRabin(int[] arr) {\n+        int w = 0;\n+        for (int s = 0; s < arr.length; s++) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ arr[s];\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a given Object.\n+    *\n+    * @param obj An Object.\n+    * @return The Rabin hash value for the Object.\n+    * @throws IOException If Object serialization fails.\n+    */\n+    public int hashRabin(Object obj) throws IOException {\n+        return hashRabin((Serializable) obj);\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a given serializable Object.\n+    *\n+    * @param obj An Object.\n+    * @return The Rabin hash value for the Object.\n+    * @throws IOException If serialization fails.\n+    */\n+    public int hashRabin(Serializable obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = null;\n+        try {\n+            oos = new ObjectOutputStream(baos);\n+            oos.writeObject(obj);\n+            return hashRabin(baos.toByteArray());\n+        } finally {\n+            oos.close();\n+            baos.close();\n+            oos = null;\n+            baos = null;\n+        }\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a String.\n+    *\n+    * @param s A <code>String</code>.\n+    * @return The Rabin hash value for the String.\n+    */\n+    public int hashRabin(String s) {\n+        return hashRabin(s.toCharArray());\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n+    *\n+    * @param url The URL of the document to be hashed.\n+    * @return The Rabin hash value for the document.\n+    * @throws IOException If an error occurs while reading the document.\n+    */\n+    public int hashRabin(URL url) throws IOException {\n+        InputStream is = url.openStream();\n+        try {\n+            return hashRabin(is);\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n*\n* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n* can make a useful tool.\n*\n* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n* checkers.\n*\n* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n* vector of a given length. We choose the length of the bit vector and the number of hash functions\n* depending on how many keys we want to add to the set and how high an error rate we are willing to\n* put up with.\n*\n* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n* function would increase our false-positive rate.\n*\n* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n* a Bloom filter.\n*\n* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n* key. We run the key through our set of hash functions, and then check to see whether the bits at\n* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n* the filter. If all of the bits are on, we know the key is probably there.\n*\n* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n* bits we check will be on, unless the key actually exists in the filter. The relationship between\n* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n* will be very dense, increasing the probability of collisions. You can calculate the\n* false-positive rate for any filter using the formula:\n*\n* <p><code>c = ( 1 - e(-kn/m) )k</code>\n*\n* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n* in the filter, and m is the length of the filter in bits.\n*\n* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n* our limit. The following equation will give us vector length from the error rate and number of\n* keys:\n*\n* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n*\n* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n* combinations of error rate, filter size, and number of hash functions at <a\n* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n* -- the math</a>.\n*\n* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n* the case of JDK 1.4).\n*\n* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n* even in this Java implementation the speed is reasonable.\n*\n* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n* method" by Andrei Broder. See <a\n* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n* paper in PDF format.\n*\n* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n* <code>URL</code>.\n*\n* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n* initial value multiplied by a list of distinct values.\n*\n* @see java.lang.Object#hashCode()\n* @see java.util.Map\n* @author Bruno Martins\n*/\npublic class BloomFilter implements Cloneable {\n\n    /** A buffer for the Rabin fingerprinting algorithm. */\n    private byte[] buffer;\n\n    /**\n    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n    * bit is the constant coefficient.\n    *\n    * <p>For example the integer 0x00000803, in binary, is:\n    *\n    * <p><code>00000000 00000000 00001000 00000011</code>\n    *\n    * <p>Therefore it correponds to the polynomial:\n    *\n    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n    */\n    private static int POLYNOMIAL = 0x000001C7;\n\n    /** Internal values for the Rabin fingerprinting algorithm. */\n    private static int[] table32, table40, table48, table54;\n\n    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n    private static int P_DEGREE = 32;\n\n    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n    private static int READ_BUFFER_SIZE = 2048;\n\n    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n    /** The bit vector for the Bloom Filter. */\n    private boolean keys[];\n\n    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n    private boolean useRabin = true;\n\n    /** The number of hash functions. */\n    private int numFunctions;\n\n    /**\n    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n    * length for the bit vector (1000).\n    */\n    public BloomFilter() {\n        table32 = new int[256];\n        table40 = new int[256];\n        table48 = new int[256];\n        table54 = new int[256];\n        buffer = new byte[READ_BUFFER_SIZE];\n        // We want to have mods[i] == x^(P_DEGREE+i)\n        int[] mods = new int[P_DEGREE];\n        mods[0] = POLYNOMIAL;\n        for (int i = 1; i < P_DEGREE; i++) {\n            // x^i == x(x^(i-1)) (mod P)\n            mods[i] = mods[i - 1] << 1;\n            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n            // x^P_DEGREE term that \'fell off\' the top end.\n            // Since x^P_DEGREE == P (mod P), we should add P\n            // to account for this:\n            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n                mods[i] ^= POLYNOMIAL;\n            }\n        }\n        for (int i = 0; i < 256; i++) {\n            int c = i;\n            for (int j = 0; j < 8 && c != 0; j++) {\n                if ((c & 1) != 0) {\n                    table32[i] ^= mods[j];\n                    table40[i] ^= mods[j + 8];\n                    table48[i] ^= mods[j + 16];\n                    table54[i] ^= mods[j + 24];\n                }\n                c >>>= 1;\n            }\n        }\n        mods = null;\n        this.keys = new boolean[1000];\n        this.numFunctions = 10;\n        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Constructs a Bloom Filter from a string representation.\n    *\n    * @see #toString()\n    */\n    public BloomFilter(String filter) {\n        this();\n        int index1 = filter.indexOf(":");\n        int index2 = filter.lastIndexOf(":");\n        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n        for (int i = index2 + 1; i < filter.length(); i++) {\n            if (filter.charAt(i) == \'1\') keys[i] = true;\n            else keys[i] = false;\n        }\n    }\n\n    /**\n    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n    * error rate.\n    *\n    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n    */\n    public BloomFilter(int numKeys, double errorRate) {\n        this();\n        double lowest_m = Double.MAX_VALUE;\n        int best_k = 1;\n        for (int k = 1; k <= 100; k++) {\n            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n            if (m < lowest_m) {\n                lowest_m = m;\n                best_k = k;\n            }\n        }\n        this.keys = new boolean[numKeys];\n        this.numFunctions = best_k;\n        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n    * length for the bit vector.\n    *\n    * @param numKeys The length of the bit vector.\n    */\n    public BloomFilter(int numKeys) {\n        this(numKeys, 10);\n    }\n\n    /**\n    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n    * the bit vector.\n    *\n    * @param numKeys The length of the bit vector.\n    * @param numHashFunctions The number of hash functions.\n    */\n    public BloomFilter(int numKeys, int numHashFunctions) {\n        this();\n        this.keys = new boolean[numKeys];\n        this.numFunctions = numHashFunctions;\n        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Internal method for producing the hash value for a given function number.\n    *\n    * @param fnum The number of the hash function.\n    * @param original The original value for the hash of the object.\n    * @see java.lang.Object#hashCode()\n    * @return Returns the hash code value for the given function number.\n    */\n    private int getHash(int fnum, int original) {\n        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n        int hash[] = {original};\n        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n        hash[0] = hash[0] % keys.length;\n        if (hash[0] < 0) hash[0] = -hash[0];\n        return hash[0];\n    }\n\n    /**\n    * Returns true if this Bloom Filter contains the specified key.\n    *\n    * @param obj The key whose presence in this Bloom Filter is to be tested.\n    * @return true if this Bloom Filter contains a mapping for the specified key.\n    */\n    public boolean hasKey(Object obj) {\n        boolean result = true;\n        int hashCodeObject;\n        if (!useRabin) hashCodeObject = obj.hashCode();\n        else\n            try {\n                hashCodeObject = hashRabin(obj);\n            } catch (Exception e) {\n                useRabin = false;\n                hashCodeObject = obj.hashCode();\n            }\n        for (int i = 0; i < numFunctions && result; i++) {\n            result &= keys[getHash(i, hashCodeObject)];\n        }\n        return result;\n    }\n\n    /**\n    * Adds the specified key in this Bloom Filter.\n    *\n    * @param obj The key to be added to this Bloom Filter.\n    */\n    public void put(Object obj) {\n        int hashCodeObject;\n        if (!useRabin) hashCodeObject = obj.hashCode();\n        else\n            try {\n                hashCodeObject = hashRabin(obj);\n            } catch (Exception e) {\n                useRabin = false;\n                hashCodeObject = obj.hashCode();\n            }\n        for (int i = 0; i < numFunctions; i++) {\n            keys[getHash(i, hashCodeObject)] = true;\n        }\n    }\n\n    /**\n    * Returns a string representation of this Bloom Filter. The string representation consists of an\n    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n    * the character ":".\n    *\n    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n    * returned.\n    *\n    * @return A string representation of this Bloom Filter.\n    */\n    public String toString() {\n        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i]) aux.append("1");\n            else aux.append("0");\n        }\n        return aux.toString();\n    }\n\n    /**\n    * Returns a copy of this Bloom Filter instance.\n    *\n    * @see java.lang.Object#clone()\n    */\n    public Object clone() {\n        return new BloomFilter(this.toString());\n    }\n\n    /**\n    * Return the Rabin hash value of an array of bytes.\n    *\n    * @param arr An array of bytes.\n    * @return The Rabin hash value for the array of bytes.\n    */\n    public int hashRabin(byte[] arr) {\n        return hashRabin(arr, 0, arr.length, 0);\n    }\n\n    /**\n    * Return the Rabin hash value of an array of bytes.\n    *\n    * @param arr An array of bytes.\n    * @param offset Index of the first byte of the array to hash.\n    * @param length Number of bytes to hash.\n    * @param ws ??\n    * @return The Rabin hash value for the array of bytes.\n    */\n    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n        int w = ws;\n        int start = length % 4;\n        for (int s = offset; s < offset + start; s++) {\n            w = (w << 8) ^ (arr[s] & 0xFF);\n        }\n        for (int s = start + offset; s < length + offset; s += 4) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ (arr[s] << 24)\n                            ^ ((arr[s + 1] & 0xFF) << 16)\n                            ^ ((arr[s + 2] & 0xFF) << 8)\n                            ^ (arr[s + 3] & 0xFF);\n        }\n        return w;\n    }\n\n    /**\n    * Return the Rabin hash value of an array of chars.\n    *\n    * @param arr An array of chars.\n    * @return The Rabin hash value for the array of chars.\n    */\n    public int hashRabin(char[] arr) {\n        int w = 0;\n        int start = 0;\n        if (arr.length % 2 == 1) {\n            w = arr[0] & 0xFFFF;\n            start = 1;\n        }\n        for (int s = start; s < arr.length; s += 2) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ ((arr[s] & 0xFFFF) << 16)\n                            ^ (arr[s + 1] & 0xFFFF);\n        }\n        return w;\n    }\n\n    /**\n    * Computes the Rabin hash value of the contents of a <code>File</code>.\n    *\n    * @param f A <code>File</code>.\n    * @return The Rabin hash value for the contents of the File.\n    * @throws FileNotFoundException If the file cannot be found.\n    * @throws IOException If an error occurs while reading the file.\n    */\n    public int hashRabin(File f) throws FileNotFoundException, IOException {\n        FileInputStream fis = new FileInputStream(f);\n        try {\n            return hashRabin(fis);\n        } finally {\n            fis.close();\n        }\n    }\n\n    /**\n    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n    *\n    * @param is An InputStream.\n    * @return The Rabin hash value for the contents read from the InputStream.\n    * @throws IOException if an error occurs while reading from the InputStream.\n    */\n    public int hashRabin(InputStream is) throws IOException {\n        int hashValue = 0;\n        int bytesRead;\n        synchronized (buffer) {\n            while ((bytesRead = is.read(buffer)) > 0) {\n                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n            }\n        }\n        return hashValue;\n    }\n\n    /**\n    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n    * the hash methods, so it should be used when possible.\n    *\n    * @param arr An array of integers.\n    * @return int The Rabin hash value for the array of integers.\n    */\n    public int hashRabin(int[] arr) {\n        int w = 0;\n        for (int s = 0; s < arr.length; s++) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ arr[s];\n        }\n        return w;\n    }\n\n    /**\n    * Computes the Rabin hash value of a given Object.\n    *\n    * @param obj An Object.\n    * @return The Rabin hash value for the Object.\n    * @throws IOException If Object serialization fails.\n    */\n    public int hashRabin(Object obj) throws IOException {\n        return hashRabin((Serializable) obj);\n    }\n\n    /**\n    * Computes the Rabin hash value of a given serializable Object.\n    *\n    * @param obj An Object.\n    * @return The Rabin hash value for the Object.\n    * @throws IOException If serialization fails.\n    */\n    public int hashRabin(Serializable obj) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = null;\n        try {\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            return hashRabin(baos.toByteArray());\n        } finally {\n            oos.close();\n            baos.close();\n            oos = null;\n            baos = null;\n        }\n    }\n\n    /**\n    * Computes the Rabin hash value of a String.\n    *\n    * @param s A <code>String</code>.\n    * @return The Rabin hash value for the String.\n    */\n    public int hashRabin(String s) {\n        return hashRabin(s.toCharArray());\n    }\n\n    /**\n    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n    *\n    * @param url The URL of the document to be hashed.\n    * @return The Rabin hash value for the document.\n    * @throws IOException If an error occurs while reading the document.\n    */\n    public int hashRabin(URL url) throws IOException {\n        InputStream is = url.openStream();\n        try {\n            return hashRabin(is);\n        } finally {\n            is.close();\n        }\n    }\n}\n'
          },
          {
            sha: "71b9d58975181f2920de2f84bbf90a2be29c041a",
            filename:
              "src/main/java/refactoring/crawler/shingles/DefaultStrategy.java",
            status: "added",
            additions: 25,
            deletions: 0,
            patch:
              "@@ -0,0 +1,25 @@\n+package refactoring.crawler.shingles;\n+\n+/** @author Can Comertoglu */\n+public class DefaultStrategy implements ShinglesStrategy {\n+\n+    /** */\n+    public DefaultStrategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+    */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base;\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base;\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n    /** */\n    public DefaultStrategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n    */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base;\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base;\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base;\n    }\n}\n"
          },
          {
            sha: "6659640bccbd3ed85cea5d3f6b628fdb4ee58b0d",
            filename:
              "src/main/java/refactoring/crawler/shingles/FactorOf2Strategy.java",
            status: "added",
            additions: 25,
            deletions: 0,
            patch:
              "@@ -0,0 +1,25 @@\n+package refactoring.crawler.shingles;\n+\n+public class FactorOf2Strategy implements ShinglesStrategy {\n+\n+    /** */\n+    public FactorOf2Strategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+    * @Override\n+    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+    */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base + (2 * loc);\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base + (2 * numMethods);\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base + (2 * numClasses);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n    /** */\n    public FactorOf2Strategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n    * @Override\n    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n    */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base + (2 * loc);\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base + (2 * numMethods);\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base + (2 * numClasses);\n    }\n}\n"
          },
          {
            sha: "3d02565f4d4ec4df212f23cfcadf087258466222",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesStrategy.java",
            status: "renamed",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,4 +1,4 @@\n-package refactoring.crawler.util;\n+package refactoring.crawler.shingles;\n \n public interface ShinglesStrategy {\n     int upperBoundLimitForShinglesBag(int loc, int s_base);",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n    int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n    int upperBoundForClassShingles(int numMethods, int s_base);\n\n    int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "38779039d33f0a3af17286c2834361ec112a6bea",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "added",
            additions: 301,
            deletions: 0,
            patch:
              '@@ -0,0 +1,301 @@\n+package refactoring.crawler.shingles;\n+\n+import java.util.*;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DirectedMultigraph;\n+import org.jgrapht.traverse.BreadthFirstIterator;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n+\n+public class ShinglesUtil {\n+\n+    private int w = 2;\n+    private int sClass = 10;\n+    private int sMethod = 8;\n+    private double classThreshold = 0.0;\n+\n+    @Getter @Setter private double methodThreshold = 0.0;\n+\n+    private ShinglesStrategy shinglesStrategy;\n+\n+    private NamedDirectedMultigraph oldVersionGraph;\n+\n+    private NamedDirectedMultigraph newVersionGraph;\n+\n+    private List<Node[]> similarMethods = new LinkedList<>();\n+    private List<Node[]> similarClasses = new LinkedList<>();\n+\n+    private List<Node> oldVersionPackageList;\n+    private List<Node> oldVersionClassList;\n+    private List<Node> oldVersionMethodList;\n+    private List<Node> oldVersionFieldList;\n+\n+    private List<Node> newVersionPackageList;\n+    private List<Node> newVersionClassList;\n+    private List<Node> newVersionMethodList;\n+    private List<Node> newVersionFieldList;\n+\n+    public ShinglesUtil() {\n+        this.shinglesStrategy = new DefaultStrategy();\n+        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+    }\n+\n+    public List<String> tokenizer(String s) {\n+        List<String> list = new ArrayList<>();\n+        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+        while (st.hasMoreElements()) {\n+            list.add(st.nextToken());\n+        }\n+        return list;\n+    }\n+\n+    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+        List<List<String>> bagOfTokensList = new ArrayList<>();\n+        ListIterator<String> iter = tokenList.listIterator();\n+        while (iter.nextIndex() <= (tokenList.size() - w))\n+        // W=2, iterIndex = size - W identifies the last window\n+        {\n+            List<String> tempList = new ArrayList<>();\n+            for (int i = 1; i <= w; i++) // W=3\n+            {\n+                tempList.add(iter.next());\n+            }\n+            bagOfTokensList.add(tempList);\n+            for (int i = 1; i <= w - 1; i++)\n+                // i<= W-1\n+                iter.previous();\n+        }\n+        return bagOfTokensList;\n+    }\n+\n+    private int findNumberOfLines(String str) {\n+        int retval = 0;\n+        char[] c = str.toCharArray();\n+        for (char value : c) {\n+            if (value == \'\\n\') retval++;\n+        }\n+        return retval;\n+    }\n+\n+    public int[] computeMethodShingles(String str) {\n+        return computeMethodShingles(\n+                str,\n+                w,\n+                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+    }\n+\n+    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+        /*\n+        * We are now introducing the idea of finding the number of lines in the\n+        * method, and incorporate that into the calculation of shingles, so\n+        * that, if there are more lines, then there are going to be more\n+        * shingles associated with the method. However, a 1-1 correspondance\n+        * will be misleading, thus another method is required.\n+        */\n+        BloomFilter bloomFilter = new BloomFilter();\n+        List<String> tokenList = tokenizer(str);\n+        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+        int numberOfWindowedTokens = 0;\n+\n+        for (List<String> tempList : bagOfWindowedTokens) {\n+            StringBuilder tokensInOneWindow = new StringBuilder();\n+            for (int i = 0; i < window; i++) {\n+                tokensInOneWindow.append(tempList.get(i));\n+                if (i != window - 1) tokensInOneWindow.append(" ");\n+            }\n+            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+            shinglesValues[numberOfWindowedTokens] = shingle;\n+            numberOfWindowedTokens++;\n+        }\n+\n+        Arrays.sort(shinglesValues);\n+\n+        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n+\n+        int[] retVal = new int[correctNumberOfShingles];\n+        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+        return retVal;\n+    }\n+\n+    public void initialize(\n+            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+        this.oldVersionGraph = oldVersionGraph;\n+        this.newVersionGraph = newVersionGraph;\n+\n+        this.oldVersionPackageList = new ArrayList<>();\n+        this.oldVersionClassList = new ArrayList<>();\n+        this.oldVersionMethodList = new ArrayList<>();\n+        this.oldVersionFieldList = new ArrayList<>();\n+\n+        this.newVersionPackageList = new ArrayList<>();\n+        this.newVersionClassList = new ArrayList<>();\n+        this.newVersionMethodList = new ArrayList<>();\n+        this.newVersionFieldList = new ArrayList<>();\n+\n+        initializeElementsLists(\n+                oldVersionGraph,\n+                oldVersionMethodList,\n+                oldVersionClassList,\n+                oldVersionPackageList,\n+                oldVersionFieldList);\n+\n+        initializeElementsLists(\n+                newVersionGraph,\n+                newVersionMethodList,\n+                newVersionClassList,\n+                newVersionPackageList,\n+                newVersionFieldList);\n+    }\n+\n+    private void initializeElementsLists(\n+            DirectedMultigraph<Node, Edge> graph,\n+            List<Node> methods,\n+            List<Node> classes,\n+            List<Node> packages,\n+            List<Node> fields) {\n+        // Create a BreadthFirstIterator for the graph\n+        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+        while (bfi.hasNext()) {\n+            Node n = bfi.next();\n+            if (n.getType().equals(Node.Type.CLASS)) {\n+                classes.add(n);\n+            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+                packages.add(n);\n+            } else if (n.getType().equals(Node.Type.METHOD)) {\n+                methods.add(n);\n+            } else if (n.getType().equals(Node.Type.FIELD)) {\n+                fields.add(n);\n+            }\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarMethods() {\n+        if (this.similarMethods.isEmpty()) {\n+            List<Node[]> similarMethods = new ArrayList<>();\n+            for (Node m : this.oldVersionMethodList) {\n+                if (!m.isAPI()) continue;\n+\n+                for (Node m2 : this.newVersionMethodList) {\n+                    if (!m2.isAPI()) continue;\n+\n+                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+                        Node[] arr = {m, m2};\n+                        // if (!isThisArrayInTheList(simMet, arr))\n+                        similarMethods.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarMethods = similarMethods;\n+        }\n+        return this.similarMethods;\n+    }\n+\n+    public double howMuchAlike(int[] arr1, int[] arr2) {\n+        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+        return finalGrade;\n+    }\n+\n+    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+        int[] tempArr = arr2.clone();\n+        double grade = 0.0;\n+        for (int value : arr1) {\n+            for (int j = 0; j < tempArr.length; j++) {\n+                if (value == tempArr[j]) {\n+                    grade += 1.0 / arr1.length;\n+                    tempArr[j] = Integer.MIN_VALUE;\n+                    break;\n+                }\n+            }\n+        }\n+        return grade;\n+    }\n+\n+    /**\n+    * @param classes\n+    * @param graph <br>\n+    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n+    *     its subtree. The parameter s_class will determine the maximum size of shingles\n+    */\n+    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+        for (Node clasz : classes) {\n+            // We will keep the number of methods for the class with the\n+            // numberOfMethods variable.\n+            int numberOfMethods = 0;\n+            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+            int methodsTotalShingleSize = 0;\n+            for (Edge e : outEdges) {\n+                Node neighbor = e.oppositeVertex(clasz);\n+                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+                    methodsTotalShingleSize += neighbor.getShingles().length;\n+                    // Here we update the method count.\n+                    numberOfMethods++;\n+                }\n+            }\n+\n+            // fill allShinglesFromMethods with shingles from all the methods in\n+            // the class\n+            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+            int index = 0;\n+            for (Edge e : outEdges) {\n+                Node neighbor = e.oppositeVertex(clasz);\n+                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n+                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n+                        index++;\n+                    }\n+                }\n+            }\n+\n+            int upperBoundForClassShingles =\n+                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n+            Arrays.sort(allShinglesFromMethods);\n+\n+            upperBoundForClassShingles =\n+                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n+\n+            int[] retVal = new int[upperBoundForClassShingles];\n+            if (upperBoundForClassShingles >= 0)\n+                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+            clasz.setShingles(retVal);\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarClasses() {\n+        if (this.similarClasses.isEmpty()) {\n+            computeClassShingles(oldVersionClassList, oldVersionGraph);\n+            computeClassShingles(newVersionClassList, newVersionGraph);\n+            List<Node[]> simClass = new ArrayList<>();\n+            for (Node c : this.oldVersionClassList) {\n+                if (!c.isAPI()) continue;\n+\n+                for (Node c2 : this.oldVersionClassList) {\n+                    if (!c2.isAPI()) continue;\n+\n+                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+                        Node[] arr = {c, c2};\n+                        simClass.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarClasses = simClass;\n+        }\n+        return this.similarClasses;\n+    }\n+\n+    public List<Node[]> findPullUpMethodCandidates() {\n+        return findSimilarMethods();\n+    }\n+\n+    public List<Node[]> findPushDownMethodCandidates() {\n+        return findSimilarMethods();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n    private int w = 2;\n    private int sClass = 10;\n    private int sMethod = 8;\n    private double classThreshold = 0.0;\n\n    @Getter @Setter private double methodThreshold = 0.0;\n\n    private ShinglesStrategy shinglesStrategy;\n\n    private NamedDirectedMultigraph oldVersionGraph;\n\n    private NamedDirectedMultigraph newVersionGraph;\n\n    private List<Node[]> similarMethods = new LinkedList<>();\n    private List<Node[]> similarClasses = new LinkedList<>();\n\n    private List<Node> oldVersionPackageList;\n    private List<Node> oldVersionClassList;\n    private List<Node> oldVersionMethodList;\n    private List<Node> oldVersionFieldList;\n\n    private List<Node> newVersionPackageList;\n    private List<Node> newVersionClassList;\n    private List<Node> newVersionMethodList;\n    private List<Node> newVersionFieldList;\n\n    public ShinglesUtil() {\n        this.shinglesStrategy = new DefaultStrategy();\n        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n    }\n\n    public List<String> tokenizer(String s) {\n        List<String> list = new ArrayList<>();\n        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n        while (st.hasMoreElements()) {\n            list.add(st.nextToken());\n        }\n        return list;\n    }\n\n    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n        List<List<String>> bagOfTokensList = new ArrayList<>();\n        ListIterator<String> iter = tokenList.listIterator();\n        while (iter.nextIndex() <= (tokenList.size() - w))\n        // W=2, iterIndex = size - W identifies the last window\n        {\n            List<String> tempList = new ArrayList<>();\n            for (int i = 1; i <= w; i++) // W=3\n            {\n                tempList.add(iter.next());\n            }\n            bagOfTokensList.add(tempList);\n            for (int i = 1; i <= w - 1; i++)\n                // i<= W-1\n                iter.previous();\n        }\n        return bagOfTokensList;\n    }\n\n    private int findNumberOfLines(String str) {\n        int retval = 0;\n        char[] c = str.toCharArray();\n        for (char value : c) {\n            if (value == \'\\n\') retval++;\n        }\n        return retval;\n    }\n\n    public int[] computeMethodShingles(String str) {\n        return computeMethodShingles(\n                str,\n                w,\n                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n    }\n\n    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n        /*\n        * We are now introducing the idea of finding the number of lines in the\n        * method, and incorporate that into the calculation of shingles, so\n        * that, if there are more lines, then there are going to be more\n        * shingles associated with the method. However, a 1-1 correspondance\n        * will be misleading, thus another method is required.\n        */\n        BloomFilter bloomFilter = new BloomFilter();\n        List<String> tokenList = tokenizer(str);\n        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n        int numberOfWindowedTokens = 0;\n\n        for (List<String> tempList : bagOfWindowedTokens) {\n            StringBuilder tokensInOneWindow = new StringBuilder();\n            for (int i = 0; i < window; i++) {\n                tokensInOneWindow.append(tempList.get(i));\n                if (i != window - 1) tokensInOneWindow.append(" ");\n            }\n            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n            shinglesValues[numberOfWindowedTokens] = shingle;\n            numberOfWindowedTokens++;\n        }\n\n        Arrays.sort(shinglesValues);\n\n        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n        int[] retVal = new int[correctNumberOfShingles];\n        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n        return retVal;\n    }\n\n    public void initialize(\n            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n        this.oldVersionGraph = oldVersionGraph;\n        this.newVersionGraph = newVersionGraph;\n\n        this.oldVersionPackageList = new ArrayList<>();\n        this.oldVersionClassList = new ArrayList<>();\n        this.oldVersionMethodList = new ArrayList<>();\n        this.oldVersionFieldList = new ArrayList<>();\n\n        this.newVersionPackageList = new ArrayList<>();\n        this.newVersionClassList = new ArrayList<>();\n        this.newVersionMethodList = new ArrayList<>();\n        this.newVersionFieldList = new ArrayList<>();\n\n        initializeElementsLists(\n                oldVersionGraph,\n                oldVersionMethodList,\n                oldVersionClassList,\n                oldVersionPackageList,\n                oldVersionFieldList);\n\n        initializeElementsLists(\n                newVersionGraph,\n                newVersionMethodList,\n                newVersionClassList,\n                newVersionPackageList,\n                newVersionFieldList);\n    }\n\n    private void initializeElementsLists(\n            DirectedMultigraph<Node, Edge> graph,\n            List<Node> methods,\n            List<Node> classes,\n            List<Node> packages,\n            List<Node> fields) {\n        // Create a BreadthFirstIterator for the graph\n        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n        while (bfi.hasNext()) {\n            Node n = bfi.next();\n            if (n.getType().equals(Node.Type.CLASS)) {\n                classes.add(n);\n            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n                packages.add(n);\n            } else if (n.getType().equals(Node.Type.METHOD)) {\n                methods.add(n);\n            } else if (n.getType().equals(Node.Type.FIELD)) {\n                fields.add(n);\n            }\n        }\n    }\n\n    public List<Node[]> findSimilarMethods() {\n        if (this.similarMethods.isEmpty()) {\n            List<Node[]> similarMethods = new ArrayList<>();\n            for (Node m : this.oldVersionMethodList) {\n                if (!m.isAPI()) continue;\n\n                for (Node m2 : this.newVersionMethodList) {\n                    if (!m2.isAPI()) continue;\n\n                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n                        Node[] arr = {m, m2};\n                        // if (!isThisArrayInTheList(simMet, arr))\n                        similarMethods.add(arr);\n                    }\n                }\n            }\n            this.similarMethods = similarMethods;\n        }\n        return this.similarMethods;\n    }\n\n    public double howMuchAlike(int[] arr1, int[] arr2) {\n        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n        return finalGrade;\n    }\n\n    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n        int[] tempArr = arr2.clone();\n        double grade = 0.0;\n        for (int value : arr1) {\n            for (int j = 0; j < tempArr.length; j++) {\n                if (value == tempArr[j]) {\n                    grade += 1.0 / arr1.length;\n                    tempArr[j] = Integer.MIN_VALUE;\n                    break;\n                }\n            }\n        }\n        return grade;\n    }\n\n    /**\n    * @param classes\n    * @param graph <br>\n    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n    *     its subtree. The parameter s_class will determine the maximum size of shingles\n    */\n    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n        for (Node clasz : classes) {\n            // We will keep the number of methods for the class with the\n            // numberOfMethods variable.\n            int numberOfMethods = 0;\n            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n            int methodsTotalShingleSize = 0;\n            for (Edge e : outEdges) {\n                Node neighbor = e.oppositeVertex(clasz);\n                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n                    methodsTotalShingleSize += neighbor.getShingles().length;\n                    // Here we update the method count.\n                    numberOfMethods++;\n                }\n            }\n\n            // fill allShinglesFromMethods with shingles from all the methods in\n            // the class\n            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n            int index = 0;\n            for (Edge e : outEdges) {\n                Node neighbor = e.oppositeVertex(clasz);\n                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n                        index++;\n                    }\n                }\n            }\n\n            int upperBoundForClassShingles =\n                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n            Arrays.sort(allShinglesFromMethods);\n\n            upperBoundForClassShingles =\n                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n            int[] retVal = new int[upperBoundForClassShingles];\n            if (upperBoundForClassShingles >= 0)\n                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n            clasz.setShingles(retVal);\n        }\n    }\n\n    public List<Node[]> findSimilarClasses() {\n        if (this.similarClasses.isEmpty()) {\n            computeClassShingles(oldVersionClassList, oldVersionGraph);\n            computeClassShingles(newVersionClassList, newVersionGraph);\n            List<Node[]> simClass = new ArrayList<>();\n            for (Node c : this.oldVersionClassList) {\n                if (!c.isAPI()) continue;\n\n                for (Node c2 : this.oldVersionClassList) {\n                    if (!c2.isAPI()) continue;\n\n                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n                        Node[] arr = {c, c2};\n                        simClass.add(arr);\n                    }\n                }\n            }\n            this.similarClasses = simClass;\n        }\n        return this.similarClasses;\n    }\n\n    public List<Node[]> findPullUpMethodCandidates() {\n        return findSimilarMethods();\n    }\n\n    public List<Node[]> findPushDownMethodCandidates() {\n        return findSimilarMethods();\n    }\n}\n'
          },
          {
            sha: "fe676e94ebfb94cc6e342fed1ffd6bc08ecda4d1",
            filename: "src/main/java/refactoring/crawler/util/BloomFilter.java",
            status: "removed",
            additions: 0,
            deletions: 544,
            patch:
              '@@ -1,544 +0,0 @@\n-package refactoring.crawler.util;\n-\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-import java.net.URL;\n-\n-/**\n- * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n- * hash table.</p> <p>\n- * \n- * Bloom filters allow you to perform membership tests in just a fraction of the memory \n- * you\'d need to store a full list of keys. As you might suspect, the savings in space \n- * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n- * key from a filter once you\'ve added it in. But in the many cases where those constraints\n- * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n- * \n- * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n- * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n- * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n- * filters were prized primarily for their compactness; in fact, one of their earliest applications\n- *  was in spell checkers.</p> <p>\n- * \n- * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n- * a given length. We choose the length of the bit vector and the number of hash functions\n- * depending on how many keys we want to add to the set and how high an error rate we are\n- * willing to put up with. </p> <p>\n- * \n- * All of the hash functions in a Bloom filter are configured so that their range matches the\n- * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n- * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n- * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n- * function would increase our false-positive rate.</p> <p>\n- * \n- * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n- * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n- * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n- * in a Bloom filter.</p> <p>\n- * \n- * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n- * new key. We run the key through our set of hash functions, and then check to see whether\n- * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n- * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n- * \n- * As you might expect, the false-positive rate depends on the bit vector length and the number\n- * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n- * we check will be on, unless the key actually exists in the filter. The relationship between the\n- * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n- * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n- * filter will be very dense, increasing the probability of collisions. You can calculate the\n- * false-positive rate for any filter using the formula:</p> <p>\n- * \n- * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n- *\n- * Where c is the false positive rate, k is the number of hash functions, n is the number of\n- * keys in the filter, and m is the length of the filter in bits.</p> <p>\n- *\n- * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n- * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n- * need some way of finding out how large a bit vector is to make sure the false-positive rate\n- * never exceeds our limit. The following equation will give us vector length from the error rate\n- * and number of keys:</p> <p>\n- * \n- *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n- *\n- * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n- * possible to use calculus to find a minimum for k. You can also find lookup tables for \n- * various combinations of error rate, filter size, and number of hash functions at \n- * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n- *  \n- * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n- * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n- * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n- *\n- * Alternatively, this class can also use an implementation of a hash function based on Rabin\n- * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n- * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n- * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n- * function with very satisfactory properties. In addition the polynomial operations are fast in\n- * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n- *\n- * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n- * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n- * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n- * paper in PDF format.</p> <p>\n- *\n- * Included in this class are additional methods that can compute the Rabin hash value\n- * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n- *\n- * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n- * initial value multiplied by a list of distinct values.\n- * \n- * @see java.lang.Object#hashCode()\n- * @see java.util.Map\n- *\n- * @author      Bruno Martins\n- */\n-public class BloomFilter implements Cloneable {\n-\n-\t/** A buffer for the Rabin fingerprinting algorithm. */\n-\tprivate byte[] buffer;\n-\t\n-\t/**\n-\t *  The 32 bits of this integer represent the coefficients of the degree 32\n-\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n-\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n-\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n-\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n-\t *  bit is the constant coefficient.</p> <p>\n-\t *\n-\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n-\t *\n-\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n-\t *\n-\t *  Therefore it correponds to the polynomial:</p> <p>\n-\t *\n-\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n-\t */\n-\tprivate static int POLYNOMIAL = 0x000001C7;\n-\n-\t/** Internal values for the Rabin fingerprinting algorithm. */\n-\tprivate static int[] table32, table40, table48, table54;\n-\t\n-\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-\tprivate static int P_DEGREE = 32;\n-\t\n-\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n-\tprivate static int READ_BUFFER_SIZE = 2048;\n-\t\n-\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n-\n-\t/** The bit vector for the Bloom Filter. */\n-\tprivate boolean keys[];\n-\n-\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n-\tprivate boolean useRabin = true;\n-\t\n-\t/** The number of hash functions. */\n-\tprivate int numFunctions;\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n-\t * and the default length for the bit vector (1000).\n-\t */\n-\tpublic BloomFilter() {\n-\t\ttable32 = new int[256];\n-\t\ttable40 = new int[256];\n-\t\ttable48 = new int[256];\n-\t\ttable54 = new int[256];\n-\t\tbuffer = new byte[READ_BUFFER_SIZE];\n-\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n-\t\tint[] mods = new int[P_DEGREE];\n-\t\tmods[0] = POLYNOMIAL;\n-\t\tfor (int i = 1; i < P_DEGREE; i++) {\n-\t\t\t// x^i == x(x^(i-1)) (mod P)\n-\t\t\tmods[i] = mods[i - 1] << 1;\n-\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n-\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n-\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n-\t\t\t// to account for this:\n-\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n-\t\t\t\tmods[i] ^= POLYNOMIAL;\n-\t\t\t}\n-\t\t}\n-\t\tfor (int i = 0; i < 256; i++) {\n-\t\t\tint c = i;\n-\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n-\t\t\t\tif ((c & 1) != 0) {\n-\t\t\t\t\ttable32[i] ^= mods[j];\n-\t\t\t\t\ttable40[i] ^= mods[j + 8];\n-\t\t\t\t\ttable48[i] ^= mods[j + 16];\n-\t\t\t\t\ttable54[i] ^= mods[j + 24];\n-\t\t\t\t}\n-\t\t\t\tc >>>= 1;\n-\t\t\t}\n-\t\t}\n-\t\tmods = null;\n-\t\tthis.keys = new boolean[1000];\n-\t\tthis.numFunctions = 10;\n-\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t * Constructs a Bloom Filter from a string representation.\n-\t *\n-\t * @see #toString()\n-\t */\n-\tpublic BloomFilter(String filter) {\n-\t\tthis();\n-\t\tint index1 = filter.indexOf(":");\n-\t\tint index2 = filter.lastIndexOf(":");\n-\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n-\t\tkeys =\n-\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n-\t\t\t\t.intValue()];\n-\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n-\t\t\tif (filter.charAt(i) == \'1\')\n-\t\t\t\tkeys[i] = true;\n-\t\t\telse\n-\t\t\t\tkeys[i] = false;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with a given length for the bit vector,\n-\t * guarenteeing a maximum error rate.  \n-\t *\n-\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n-\t */\n-\tpublic BloomFilter(int numKeys, double errorRate) {\n-\t\tthis();\n-\t\tdouble lowest_m = Double.MAX_VALUE;\n-\t\tint best_k = 1;\n-\t\tfor (int k = 1; k <= 100; k++) {\n-\t\t\tdouble m =\n-\t\t\t\t(-1 * k * numKeys)\n-\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n-\t\t\tif (m < lowest_m) {\n-\t\t\t\tlowest_m = m;\n-\t\t\t\tbest_k = k;\n-\t\t\t}\n-\t\t}\n-\t\tthis.keys = new boolean[numKeys];\n-\t\tthis.numFunctions = best_k;\n-\t\tfor (int i = 0; i < numKeys; i++)\n-\t\t\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n-\t * and a given length for the bit vector.\n-\t *\n-\t *@param  numKeys           The length of the bit vector.\n-\t */\n-\tpublic BloomFilter(int numKeys) {\n-\t\tthis(numKeys, 10);\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with a given number of hash functions\n-\t * and a given length for the bit vector.\n-\t *\n-\t *@param  numKeys                The length of the bit vector.\n-\t *@param  numHashFunctions  The number of hash functions.\n-\t */\n-\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n-\t\tthis();\n-\t\tthis.keys = new boolean[numKeys];\n-\t\tthis.numFunctions = numHashFunctions;\n-\t\tfor (int i = 0; i < numKeys; i++)\n-\t\t\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t *  Internal method for producing the hash value for a given function number.\n-\t *\n-\t * @param  fnum      The number of the hash function.\n-\t * @param  original   The original value for the hash of the object. \n-\t * @see java.lang.Object#hashCode() \n-\t * @return   Returns the hash code value for the given function number.\n-\t */\n-\tprivate int getHash(int fnum, int original) {\n-\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n-\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n-\t\tint hash[] = { original };\n-\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n-\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n-\t\thash[0] = hash[0] % keys.length;\n-\t\tif (hash[0] < 0) hash[0] = -hash[0];\n-\t\treturn hash[0];\n-\t}\n-\n-\t/**\n-\t *  Returns true if this Bloom Filter contains the specified key.\n-\t *\n-\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n-\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n-\t */\n-\tpublic boolean hasKey(Object obj) {\n-\t\tboolean result = true;\n-\t\tint hashCodeObject;\n-\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n-\t\t\thashCodeObject = hashRabin(obj);\n-\t\t} catch ( Exception e ) {\n-\t\t\tuseRabin = false;\n-\t\t\thashCodeObject = obj.hashCode();\n-\t\t}\n-\t\tfor (int i = 0; i < numFunctions && result; i++) {\n-\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t/**\n-\t *  Adds the specified key in this Bloom Filter.\n-\t *\n-\t *@param  obj  The key to be added to this Bloom Filter.\n-\t */\n-\tpublic void put(Object obj) {\n-\t\tint hashCodeObject;\n-\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n-\t\t\thashCodeObject = hashRabin(obj);\n-\t\t} catch ( Exception e ) {\n-\t\t\tuseRabin = false;\n-\t\t\thashCodeObject = obj.hashCode();\n-\t\t}\n-\t\tfor (int i = 0; i < numFunctions; i++) {\n-\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *\n-\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n-\t * integer specifying the number of hash Functions, an integer specifying the length of the\n-\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n-\t * separated by the character ":".\n-\t * \n-\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n-\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n-\t * \n-\t * @return A string representation of this Bloom Filter.\n-\t */\n-\tpublic String toString() {\n-\t\tStringBuffer aux =\n-\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n-\t\tfor (int i = 0; i < keys.length; i++) {\n-\t\t\tif (keys[i])\n-\t\t\t\taux.append("1");\n-\t\t\telse\n-\t\t\t\taux.append("0");\n-\t\t}\n-\t\treturn aux.toString();\n-\t}\n-\n-\t/**\n-\t * Returns a copy of this Bloom Filter instance.\n-\t *\n-\t * @see java.lang.Object#clone()\n-\t */\n-\tpublic Object clone() {\n-\t\treturn new BloomFilter(this.toString());\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of bytes.\n-\t *\n-\t *@param  arr  An array of bytes.\n-\t *@return    The Rabin hash value for the array of bytes.\n-\t */\n-\tpublic int hashRabin(byte[] arr) {\n-\t\treturn hashRabin(arr, 0, arr.length, 0);\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of bytes.\n-\t *\n-\t *@param  arr        An array of bytes.\n-\t *@param  offset    Index of the first byte of the array to hash.\n-\t *@param  length   Number of bytes to hash.\n-\t *@param  ws          ??         \n-\t *@return  The Rabin hash value for the array of bytes.\n-\t */\n-\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n-\t\tint w = ws;\n-\t\tint start = length % 4;\n-\t\tfor (int s = offset; s < offset + start; s++) {\n-\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n-\t\t}\n-\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ (arr[s] << 24)\n-\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n-\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n-\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of chars.\n-\t *\n-\t *@param  arr  An array of chars.\n-\t *@return   The Rabin hash value for the array of chars.\n-\t */\n-\tpublic int hashRabin(char[] arr) {\n-\t\tint w = 0;\n-\t\tint start = 0;\n-\t\tif (arr.length % 2 == 1) {\n-\t\t\tw = arr[0] & 0xFFFF;\n-\t\t\tstart = 1;\n-\t\t}\n-\t\tfor (int s = start; s < arr.length; s += 2) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n-\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n-\t *\n-\t *@param  f                       A <code>File</code>.\n-\t *@return                          The Rabin hash value for the contents of the File.\n-\t *@throws  FileNotFoundException  If the file cannot be found.\n-\t *@throws  IOException            If an error occurs while reading the file.\n-\t */\n-\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n-\t\tFileInputStream fis = new FileInputStream(f);\n-\t\ttry {\n-\t\t\treturn hashRabin(fis);\n-\t\t} finally {\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n-\t *\n-\t *@param  is          An InputStream.\n-\t *@return               The Rabin hash value for the contents read from the InputStream.\n-\t *@throws  IOException  if an error occurs while reading from the InputStream.\n-\t */\n-\tpublic int hashRabin(InputStream is) throws IOException {\n-\t\tint hashValue = 0;\n-\t\tint bytesRead;\n-\t\tsynchronized (buffer) {\n-\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n-\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n-\t\t\t}\n-\t\t}\n-\t\treturn hashValue;\n-\t}\n-\n-\t/**\n-\t *  Returns the Rabin hash value of an array of integers. This method is the\n-\t *  most efficient of all the hash methods, so it should be used when\n-\t *  possible.\n-\t *\n-\t *@param   arr  An array of integers.\n-\t *@return    int The Rabin hash value for the array of integers.\n-\t */\n-\tpublic int hashRabin(int[] arr) {\n-\t\tint w = 0;\n-\t\tfor (int s = 0; s < arr.length; s++) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ arr[s];\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a given Object.\n-\t *\n-\t *@param  obj            An Object.\n-\t *@return                   The Rabin hash value for the Object.\n-\t *@throws  IOException  If Object serialization fails.\n-\t */\n-\tpublic int hashRabin(Object obj) throws IOException {\n-\t\treturn hashRabin((Serializable) obj);\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a given serializable Object.\n-\t *\n-\t *@param  obj             An Object.\n-\t *@return                   The Rabin hash value for the Object.\n-\t *@throws  IOException  If serialization fails.\n-\t */\n-\tpublic int hashRabin(Serializable obj) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\t\tObjectOutputStream oos = null;\n-\t\ttry {\n-\t\t\toos = new ObjectOutputStream(baos);\n-\t\t\toos.writeObject(obj);\n-\t\t\treturn hashRabin(baos.toByteArray());\n-\t\t} finally {\n-\t\t\toos.close();\n-\t\t\tbaos.close();\n-\t\t\toos = null;\n-\t\t\tbaos = null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a String.\n-\t *\n-\t *@param  s  A <code>String</code>.\n-\t *@return   The Rabin hash value for the String.\n-\t */\n-\tpublic int hashRabin(String s) {\n-\t\treturn hashRabin(s.toCharArray());\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the contents of a Web document,\n-\t *  specified by an URL.\n-\t *\n-\t *@param  url         The URL of the document to be hashed.\n-\t *@return               The Rabin hash value for the document.\n-\t *@throws  IOException If an error occurs while reading the document.\n-\t */\n-\tpublic int hashRabin(URL url) throws IOException {\n-\t\tInputStream is = url.openStream();\n-\t\ttry {\n-\t\t\treturn hashRabin(is);\n-\t\t} finally {\n-\t\t\tis.close();\n-\t\t}\n-\t}\n-\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n * hash table.</p> <p>\n * \n * Bloom filters allow you to perform membership tests in just a fraction of the memory \n * you\'d need to store a full list of keys. As you might suspect, the savings in space \n * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n * key from a filter once you\'ve added it in. But in the many cases where those constraints\n * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n * \n * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n * filters were prized primarily for their compactness; in fact, one of their earliest applications\n *  was in spell checkers.</p> <p>\n * \n * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n * a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are\n * willing to put up with. </p> <p>\n * \n * All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.</p> <p>\n * \n * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n * in a Bloom filter.</p> <p>\n * \n * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n * new key. We run the key through our set of hash functions, and then check to see whether\n * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n * \n * As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n * we check will be on, unless the key actually exists in the filter. The relationship between the\n * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n * filter will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:</p> <p>\n * \n * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n *\n * Where c is the false positive rate, k is the number of hash functions, n is the number of\n * keys in the filter, and m is the length of the filter in bits.</p> <p>\n *\n * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n * need some way of finding out how large a bit vector is to make sure the false-positive rate\n * never exceeds our limit. The following equation will give us vector length from the error rate\n * and number of keys:</p> <p>\n * \n *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n *\n * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for \n * various combinations of error rate, filter size, and number of hash functions at \n * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n *  \n * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n *\n * Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n * function with very satisfactory properties. In addition the polynomial operations are fast in\n * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n *\n * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.</p> <p>\n *\n * Included in this class are additional methods that can compute the Rabin hash value\n * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n *\n * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n * \n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n *\n * @author      Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n\t/** A buffer for the Rabin fingerprinting algorithm. */\n\tprivate byte[] buffer;\n\t\n\t/**\n\t *  The 32 bits of this integer represent the coefficients of the degree 32\n\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n\t *  bit is the constant coefficient.</p> <p>\n\t *\n\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n\t *\n\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n\t *\n\t *  Therefore it correponds to the polynomial:</p> <p>\n\t *\n\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n\t */\n\tprivate static int POLYNOMIAL = 0x000001C7;\n\n\t/** Internal values for the Rabin fingerprinting algorithm. */\n\tprivate static int[] table32, table40, table48, table54;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int P_DEGREE = 32;\n\t\n\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n\tprivate static int READ_BUFFER_SIZE = 2048;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n\t/** The bit vector for the Bloom Filter. */\n\tprivate boolean keys[];\n\n\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n\tprivate boolean useRabin = true;\n\t\n\t/** The number of hash functions. */\n\tprivate int numFunctions;\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and the default length for the bit vector (1000).\n\t */\n\tpublic BloomFilter() {\n\t\ttable32 = new int[256];\n\t\ttable40 = new int[256];\n\t\ttable48 = new int[256];\n\t\ttable54 = new int[256];\n\t\tbuffer = new byte[READ_BUFFER_SIZE];\n\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n\t\tint[] mods = new int[P_DEGREE];\n\t\tmods[0] = POLYNOMIAL;\n\t\tfor (int i = 1; i < P_DEGREE; i++) {\n\t\t\t// x^i == x(x^(i-1)) (mod P)\n\t\t\tmods[i] = mods[i - 1] << 1;\n\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n\t\t\t// to account for this:\n\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n\t\t\t\tmods[i] ^= POLYNOMIAL;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tint c = i;\n\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n\t\t\t\tif ((c & 1) != 0) {\n\t\t\t\t\ttable32[i] ^= mods[j];\n\t\t\t\t\ttable40[i] ^= mods[j + 8];\n\t\t\t\t\ttable48[i] ^= mods[j + 16];\n\t\t\t\t\ttable54[i] ^= mods[j + 24];\n\t\t\t\t}\n\t\t\t\tc >>>= 1;\n\t\t\t}\n\t\t}\n\t\tmods = null;\n\t\tthis.keys = new boolean[1000];\n\t\tthis.numFunctions = 10;\n\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs a Bloom Filter from a string representation.\n\t *\n\t * @see #toString()\n\t */\n\tpublic BloomFilter(String filter) {\n\t\tthis();\n\t\tint index1 = filter.indexOf(":");\n\t\tint index2 = filter.lastIndexOf(":");\n\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n\t\tkeys =\n\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n\t\t\t\t.intValue()];\n\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n\t\t\tif (filter.charAt(i) == \'1\')\n\t\t\t\tkeys[i] = true;\n\t\t\telse\n\t\t\t\tkeys[i] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given length for the bit vector,\n\t * guarenteeing a maximum error rate.  \n\t *\n\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n\t */\n\tpublic BloomFilter(int numKeys, double errorRate) {\n\t\tthis();\n\t\tdouble lowest_m = Double.MAX_VALUE;\n\t\tint best_k = 1;\n\t\tfor (int k = 1; k <= 100; k++) {\n\t\t\tdouble m =\n\t\t\t\t(-1 * k * numKeys)\n\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n\t\t\tif (m < lowest_m) {\n\t\t\t\tlowest_m = m;\n\t\t\t\tbest_k = k;\n\t\t\t}\n\t\t}\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = best_k;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys           The length of the bit vector.\n\t */\n\tpublic BloomFilter(int numKeys) {\n\t\tthis(numKeys, 10);\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given number of hash functions\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys                The length of the bit vector.\n\t *@param  numHashFunctions  The number of hash functions.\n\t */\n\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n\t\tthis();\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = numHashFunctions;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t *  Internal method for producing the hash value for a given function number.\n\t *\n\t * @param  fnum      The number of the hash function.\n\t * @param  original   The original value for the hash of the object. \n\t * @see java.lang.Object#hashCode() \n\t * @return   Returns the hash code value for the given function number.\n\t */\n\tprivate int getHash(int fnum, int original) {\n\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n\t\tint hash[] = { original };\n\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n\t\thash[0] = hash[0] % keys.length;\n\t\tif (hash[0] < 0) hash[0] = -hash[0];\n\t\treturn hash[0];\n\t}\n\n\t/**\n\t *  Returns true if this Bloom Filter contains the specified key.\n\t *\n\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n\t */\n\tpublic boolean hasKey(Object obj) {\n\t\tboolean result = true;\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions && result; i++) {\n\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t *  Adds the specified key in this Bloom Filter.\n\t *\n\t *@param  obj  The key to be added to this Bloom Filter.\n\t */\n\tpublic void put(Object obj) {\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions; i++) {\n\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n\t * integer specifying the number of hash Functions, an integer specifying the length of the\n\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n\t * separated by the character ":".\n\t * \n\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n\t * \n\t * @return A string representation of this Bloom Filter.\n\t */\n\tpublic String toString() {\n\t\tStringBuffer aux =\n\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i])\n\t\t\t\taux.append("1");\n\t\t\telse\n\t\t\t\taux.append("0");\n\t\t}\n\t\treturn aux.toString();\n\t}\n\n\t/**\n\t * Returns a copy of this Bloom Filter instance.\n\t *\n\t * @see java.lang.Object#clone()\n\t */\n\tpublic Object clone() {\n\t\treturn new BloomFilter(this.toString());\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr  An array of bytes.\n\t *@return    The Rabin hash value for the array of bytes.\n\t */\n\tpublic int hashRabin(byte[] arr) {\n\t\treturn hashRabin(arr, 0, arr.length, 0);\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr        An array of bytes.\n\t *@param  offset    Index of the first byte of the array to hash.\n\t *@param  length   Number of bytes to hash.\n\t *@param  ws          ??         \n\t *@return  The Rabin hash value for the array of bytes.\n\t */\n\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n\t\tint w = ws;\n\t\tint start = length % 4;\n\t\tfor (int s = offset; s < offset + start; s++) {\n\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n\t\t}\n\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ (arr[s] << 24)\n\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of chars.\n\t *\n\t *@param  arr  An array of chars.\n\t *@return   The Rabin hash value for the array of chars.\n\t */\n\tpublic int hashRabin(char[] arr) {\n\t\tint w = 0;\n\t\tint start = 0;\n\t\tif (arr.length % 2 == 1) {\n\t\t\tw = arr[0] & 0xFFFF;\n\t\t\tstart = 1;\n\t\t}\n\t\tfor (int s = start; s < arr.length; s += 2) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n\t *\n\t *@param  f                       A <code>File</code>.\n\t *@return                          The Rabin hash value for the contents of the File.\n\t *@throws  FileNotFoundException  If the file cannot be found.\n\t *@throws  IOException            If an error occurs while reading the file.\n\t */\n\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n\t\tFileInputStream fis = new FileInputStream(f);\n\t\ttry {\n\t\t\treturn hashRabin(fis);\n\t\t} finally {\n\t\t\tfis.close();\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n\t *\n\t *@param  is          An InputStream.\n\t *@return               The Rabin hash value for the contents read from the InputStream.\n\t *@throws  IOException  if an error occurs while reading from the InputStream.\n\t */\n\tpublic int hashRabin(InputStream is) throws IOException {\n\t\tint hashValue = 0;\n\t\tint bytesRead;\n\t\tsynchronized (buffer) {\n\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n\t\t\t}\n\t\t}\n\t\treturn hashValue;\n\t}\n\n\t/**\n\t *  Returns the Rabin hash value of an array of integers. This method is the\n\t *  most efficient of all the hash methods, so it should be used when\n\t *  possible.\n\t *\n\t *@param   arr  An array of integers.\n\t *@return    int The Rabin hash value for the array of integers.\n\t */\n\tpublic int hashRabin(int[] arr) {\n\t\tint w = 0;\n\t\tfor (int s = 0; s < arr.length; s++) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ arr[s];\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given Object.\n\t *\n\t *@param  obj            An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If Object serialization fails.\n\t */\n\tpublic int hashRabin(Object obj) throws IOException {\n\t\treturn hashRabin((Serializable) obj);\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given serializable Object.\n\t *\n\t *@param  obj             An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If serialization fails.\n\t */\n\tpublic int hashRabin(Serializable obj) throws IOException {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = null;\n\t\ttry {\n\t\t\toos = new ObjectOutputStream(baos);\n\t\t\toos.writeObject(obj);\n\t\t\treturn hashRabin(baos.toByteArray());\n\t\t} finally {\n\t\t\toos.close();\n\t\t\tbaos.close();\n\t\t\toos = null;\n\t\t\tbaos = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a String.\n\t *\n\t *@param  s  A <code>String</code>.\n\t *@return   The Rabin hash value for the String.\n\t */\n\tpublic int hashRabin(String s) {\n\t\treturn hashRabin(s.toCharArray());\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a Web document,\n\t *  specified by an URL.\n\t *\n\t *@param  url         The URL of the document to be hashed.\n\t *@return               The Rabin hash value for the document.\n\t *@throws  IOException If an error occurs while reading the document.\n\t */\n\tpublic int hashRabin(URL url) throws IOException {\n\t\tInputStream is = url.openStream();\n\t\ttry {\n\t\t\treturn hashRabin(is);\n\t\t} finally {\n\t\t\tis.close();\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "00cee96d44bda296bedd8ace9164f49a11748191",
            filename: "src/main/java/refactoring/crawler/util/ClassNode.java",
            status: "removed",
            additions: 0,
            deletions: 28,
            patch:
              "@@ -1,28 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.List;\n-import java.util.LinkedList;\n-\n-public class ClassNode extends Node {\n-\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> classesImported = new LinkedList<>();\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> superClasses = new LinkedList<>();\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic ClassNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.CLASS);\n-\t}\n-\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\nimport java.util.LinkedList;\n\npublic class ClassNode extends Node {\n\n\n\t@Getter\n\t@Setter\n\tprivate List<String> classesImported = new LinkedList<>();\n\n\t@Getter\n\t@Setter\n\tprivate List<String> superClasses = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic ClassNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.CLASS);\n\t}\n\n\n}\n"
          },
          {
            sha: "12047025139d93dc12dde8e522729241033a06b8",
            filename:
              "src/main/java/refactoring/crawler/util/DefaultStrategy.java",
            status: "removed",
            additions: 0,
            deletions: 30,
            patch:
              "@@ -1,30 +0,0 @@\n-package refactoring.crawler.util;\n-\n-/**\n- * @author Can Comertoglu\n- */\n-public class DefaultStrategy implements ShinglesStrategy {\n-\n-\t/**\n-\t *\n-\t */\n-\tpublic DefaultStrategy() {\n-\t\tsuper();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-\t */\n-\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\n/**\n * @author Can Comertoglu\n */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic DefaultStrategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base;\n\t}\n\n}\n"
          },
          {
            sha: "d6fae800777369e76bd1270cd1dc09563d8cd0cd",
            filename:
              "src/main/java/refactoring/crawler/util/DirectedEdge.java",
            status: "removed",
            additions: 0,
            deletions: 4,
            patch:
              "@@ -1,4 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class DirectedEdge {\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class DirectedEdge {\n}\n"
          },
          {
            sha: "6cebaf36c9c7009584cf32c1ff857cdfb7f4813d",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "removed",
            additions: 0,
            deletions: 37,
            patch:
              '@@ -1,37 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import org.jgrapht.graph.DefaultEdge;\n-\n-public class Edge extends DefaultEdge {\n-\n-\t@Getter\n-\t@Setter\n-\tprivate Node.Type label;\n-\n-\tpublic Edge(Node.Type label) {\n-\t\tthis.label = label;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-\t}\n-\n-\t@Override\n-\tpublic Node getSource() {\n-\t\treturn (Node) super.getSource();\n-\t}\n-\n-\t@Override\n-\tpublic Node getTarget() {\n-\t\treturn (Node) super.getTarget();\n-\t}\n-\n-\tpublic Node oppositeVertex(Node n) {\n-\t\tNode source = this.getSource();\n-\t\tNode target = this.getTarget();\n-\t\treturn n.equals(source) ? target : source;\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n\t@Getter\n\t@Setter\n\tprivate Node.Type label;\n\n\tpublic Edge(Node.Type label) {\n\t\tthis.label = label;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n\t}\n\n\t@Override\n\tpublic Node getSource() {\n\t\treturn (Node) super.getSource();\n\t}\n\n\t@Override\n\tpublic Node getTarget() {\n\t\treturn (Node) super.getTarget();\n\t}\n\n\tpublic Node oppositeVertex(Node n) {\n\t\tNode source = this.getSource();\n\t\tNode target = this.getTarget();\n\t\treturn n.equals(source) ? target : source;\n\t}\n}\n'
          },
          {
            sha: "5e4173ffc4ab3d1c31902027268e6658fe26be2f",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "removed",
            additions: 0,
            deletions: 28,
            patch:
              "@@ -1,28 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class FactorOf2Strategy implements ShinglesStrategy {\n-\n-\t/**\n-\t *\n-\t */\n-\tpublic FactorOf2Strategy() {\n-\t\tsuper();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @Override\n-\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-\t */\n-\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-\t\treturn s_base + (2 * loc);\n-\t}\n-\n-\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n-\t\treturn s_base + (2 * numMethods);\n-\t}\n-\n-\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n-\t\treturn s_base + (2 * numClasses);\n-\t}\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic FactorOf2Strategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @Override\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base + (2 * loc);\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base + (2 * numMethods);\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base + (2 * numClasses);\n\t}\n\n}\n"
          },
          {
            sha: "3edd7e34e34292cefdbea31e40877cd476a0c10b",
            filename: "src/main/java/refactoring/crawler/util/FieldNode.java",
            status: "removed",
            additions: 0,
            deletions: 20,
            patch:
              "@@ -1,20 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.List;\n-\n-public class FieldNode extends Node {\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> fieldReferenceToMethod;\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic FieldNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.FIELD);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\npublic class FieldNode extends Node {\n\n\t@Getter\n\t@Setter\n\tprivate List<String> fieldReferenceToMethod;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic FieldNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.FIELD);\n\t}\n}\n"
          },
          {
            sha: "5e95b415b9c2ed14017572d7f3eb2cb290726203",
            filename: "src/main/java/refactoring/crawler/util/MethodNode.java",
            status: "removed",
            additions: 0,
            deletions: 35,
            patch:
              "@@ -1,35 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import jdk.nashorn.internal.codegen.CompilerConstants;\n-import lombok.AllArgsConstructor;\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class MethodNode extends Node {\n-\n-\t@AllArgsConstructor\n-\tpublic static class CalledMethod {\n-\t\t@Getter\n-\t\t@Setter\n-\t\tprivate String fullyQualifiedNameWithoutSignature;\n-\n-\t\t@Getter\n-\t\t@Setter\n-\t\tprivate String fullyQualifiedNameWithSignature;\n-\t}\n-\n-\t@Setter\n-\t@Getter\n-\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic MethodNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.METHOD);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport jdk.nashorn.internal.codegen.CompilerConstants;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MethodNode extends Node {\n\n\t@AllArgsConstructor\n\tpublic static class CalledMethod {\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithoutSignature;\n\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithSignature;\n\t}\n\n\t@Setter\n\t@Getter\n\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic MethodNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.METHOD);\n\t}\n}\n"
          },
          {
            sha: "b88943178596cfa00a23eb9dfea16003b1d12e03",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "removed",
            additions: 0,
            deletions: 38,
            patch:
              "@@ -1,38 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import org.jgrapht.graph.DirectedMultigraph;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Supplier;\n-\n-public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n-\n-\t@Getter\n-\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n-\n-\tpublic NamedDirectedMultigraph() {\n-\t\tsuper(Edge.class);\n-\t}\n-\n-\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n-\t}\n-\n-\tpublic boolean addNamedVertex(Node v) {\n-\t\tif (!addVertex(v))\n-\t\t\treturn false;\n-\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n-\t\treturn true;\n-\t}\n-\n-\tpublic Node findNamedNode(String name) {\n-\t\treturn namedVertexMap.get(name);\n-\t}\n-\n-\n-\tpublic boolean hasNamedNode(String name) {\n-\t\treturn namedVertexMap.containsKey(name);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n\n\n\tpublic boolean hasNamedNode(String name) {\n\t\treturn namedVertexMap.containsKey(name);\n\t}\n}\n"
          },
          {
            sha: "4b07c12c621dc8ab22d3c950d6c1f96229b7f0e6",
            filename: "src/main/java/refactoring/crawler/util/NamedGraph.java",
            status: "removed",
            additions: 0,
            deletions: 8,
            patch:
              "@@ -1,8 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class NamedGraph {\n-\n-    public Node findNamedNode(String name) {\n-        return null;\n-    }\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class NamedGraph {\n\n    public Node findNamedNode(String name) {\n        return null;\n    }\n}\n"
          },
          {
            sha: "b31e4580aad57d3fb656e5bed35e174040baacd4",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "removed",
            additions: 0,
            deletions: 94,
            patch:
              '@@ -1,94 +0,0 @@\n-package refactoring.crawler.util;\n-\n-\n-import lombok.Getter;\n-import lombok.RequiredArgsConstructor;\n-import lombok.Setter;\n-\n-import java.awt.*;\n-\n-\n-public class Node {\n-\n-\tpublic boolean hasCallGraph() {\n-\t\treturn false;\n-\t}\n-\n-\tpublic void setCreatedCallGraph() {\n-\t}\n-\n-\tpublic static enum Type {\n-\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n-\t}\n-\n-\n-\t@Getter\n-\t@Setter\n-\tprivate String fullyQualifiedName;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate Node.Type type;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate int[] shingles;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean hasCallGraph;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate String projectName;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean isAPI = false;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate String signature;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate int flags;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean deprecated = false;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean isInterface = false;\n-\n-\t@Getter\n-\t@Setter\n-\tprivate boolean isStatic = false;\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t * @param type               type\n-\t */\n-\tpublic Node(String fullyQualifiedName, Node.Type type) {\n-\t\tthis.fullyQualifiedName = fullyQualifiedName;\n-\t\tthis.type = type;\n-\t}\n-\n-\tpublic String getSimpleName() {\n-\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n-\t\tif (pos != -1) {\n-\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n-\t\t\t\t.length());\n-\t\t}\n-\t\treturn fullyQualifiedName;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tif (getSignature() != null)\n-\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n-\t\telse\n-\t\t\treturn getType() + "= " + getFullyQualifiedName();\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isStatic = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "2f92af410009b7345543ded2ab02091f76f920c2",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "modified",
            additions: 22,
            deletions: 25,
            patch:
              '@@ -1,37 +1,34 @@\n package refactoring.crawler.util;\n \n+import java.util.List;\n import lombok.Getter;\n import lombok.Setter;\n-import java.util.List;\n+import refactoring.crawler.graph.Node;\n \n public class RefactoringCategory {\n \n-\t@Getter\n-\t@Setter\n-\tprivate String name;\n+    @Getter @Setter private String name;\n \n-\t@Getter\n-\t@Setter\n-\tprivate List<Node[]> refactoringPairs;\n+    @Getter @Setter private List<Node[]> refactoringPairs;\n \n-\tpublic Node[][] getElements() {\n-\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n-\t\tint i = 0;\n-\t\tfor (Node[] pair : refactoringPairs) {\n-\t\t\telements[i++] = pair;\n-\t\t}\n-\t\treturn elements;\n-\t}\n+    public Node[][] getElements() {\n+        Node[][] elements = new Node[refactoringPairs.size()][];\n+        int i = 0;\n+        for (Node[] pair : refactoringPairs) {\n+            elements[i++] = pair;\n+        }\n+        return elements;\n+    }\n \n-\tpublic String toString() {\n-\t\treturn name + printElements(getElements());\n-\t}\n+    public String toString() {\n+        return name + printElements(getElements());\n+    }\n \n-\tprivate String printElements(Node[][] array) {\n-\t\tStringBuilder res = new StringBuilder();\n-\t\tfor (Node[] nodes : array) {\n-\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n-\t\t}\n-\t\treturn res.toString();\n-\t}\n+    private String printElements(Node[][] array) {\n+        StringBuilder res = new StringBuilder();\n+        for (Node[] nodes : array) {\n+            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n+        }\n+        return res.toString();\n+    }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n    @Getter @Setter private String name;\n\n    @Getter @Setter private List<Node[]> refactoringPairs;\n\n    public Node[][] getElements() {\n        Node[][] elements = new Node[refactoringPairs.size()][];\n        int i = 0;\n        for (Node[] pair : refactoringPairs) {\n            elements[i++] = pair;\n        }\n        return elements;\n    }\n\n    public String toString() {\n        return name + printElements(getElements());\n    }\n\n    private String printElements(Node[][] array) {\n        StringBuilder res = new StringBuilder();\n        for (Node[] nodes : array) {\n            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n        }\n        return res.toString();\n    }\n}\n'
          },
          {
            sha: "9801e24b80c70d9b0bb8d32c20ec878e51851ca6",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "removed",
            additions: 0,
            deletions: 297,
            patch:
              '@@ -1,297 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.jgrapht.graph.DirectedMultigraph;\n-import org.jgrapht.traverse.BreadthFirstIterator;\n-\n-import java.util.*;\n-\n-public class ShinglesUtil {\n-\n-\tprivate int w = 2;\n-\tprivate int sClass = 10;\n-\tprivate int sMethod = 8;\n-\tprivate double classThreshold = 0.0;\n-\n-\t@Getter\n-\t@Setter\n-\tprivate double methodThreshold = 0.0;\n-\n-\n-\tprivate ShinglesStrategy shinglesStrategy;\n-\n-\tprivate NamedDirectedMultigraph oldVersionGraph;\n-\n-\tprivate NamedDirectedMultigraph newVersionGraph;\n-\n-\tprivate List<Node[]> similarMethods = new LinkedList<>();\n-\tprivate List<Node[]> similarClasses = new LinkedList<>();\n-\n-\n-\tprivate List<Node> oldVersionPackageList;\n-\tprivate List<Node> oldVersionClassList;\n-\tprivate List<Node> oldVersionMethodList;\n-\tprivate List<Node> oldVersionFieldList;\n-\n-\tprivate List<Node> newVersionPackageList;\n-\tprivate List<Node> newVersionClassList;\n-\tprivate List<Node> newVersionMethodList;\n-\tprivate List<Node> newVersionFieldList;\n-\n-\tpublic ShinglesUtil() {\n-\t\tthis.shinglesStrategy = new DefaultStrategy();\n-//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n-\t}\n-\n-\tpublic List<String> tokenizer(String s) {\n-\t\tList<String> list = new ArrayList<>();\n-\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n-\t\twhile (st.hasMoreElements()) {\n-\t\t\tlist.add(st.nextToken());\n-\t\t}\n-\t\treturn list;\n-\t}\n-\n-\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n-\n-\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n-\t\tListIterator<String> iter = tokenList.listIterator();\n-\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n-\t\t// W=2, iterIndex = size - W identifies the last window\n-\t\t{\n-\t\t\tList<String> tempList = new ArrayList<>();\n-\t\t\tfor (int i = 1; i <= w; i++) // W=3\n-\t\t\t{\n-\t\t\t\ttempList.add(iter.next());\n-\t\t\t}\n-\t\t\tbagOfTokensList.add(tempList);\n-\t\t\tfor (int i = 1; i <= w - 1; i++)\n-\t\t\t\t// i<= W-1\n-\t\t\t\titer.previous();\n-\t\t}\n-\t\treturn bagOfTokensList;\n-\t}\n-\n-\tprivate int findNumberOfLines(String str) {\n-\t\tint retval = 0;\n-\t\tchar[] c = str.toCharArray();\n-\t\tfor (char value : c) {\n-\t\t\tif (value == \'\\n\')\n-\t\t\t\tretval++;\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\tpublic int[] computeMethodShingles(String str) {\n-\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n-\t}\n-\n-\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n-\t\t/*\n-\t\t * We are now introducing the idea of finding the number of lines in the\n-\t\t * method, and incorporate that into the calculation of shingles, so\n-\t\t * that, if there are more lines, then there are going to be more\n-\t\t * shingles associated with the method. However, a 1-1 correspondance\n-\t\t * will be misleading, thus another method is required.\n-\t\t */\n-\t\tBloomFilter bloomFilter = new BloomFilter();\n-\t\tList<String> tokenList = tokenizer(str);\n-\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n-\n-\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n-\t\tint numberOfWindowedTokens = 0;\n-\n-\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n-\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n-\t\t\tfor (int i = 0; i < window; i++) {\n-\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n-\t\t\t\tif (i != window - 1)\n-\t\t\t\t\ttokensInOneWindow.append(" ");\n-\t\t\t}\n-\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n-\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n-\t\t\tnumberOfWindowedTokens++;\n-\t\t}\n-\n-\t\tArrays.sort(shinglesValues);\n-\n-\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n-\t\t\tnumberOfWindowedTokens);\n-\n-\t\tint[] retVal = new int[correctNumberOfShingles];\n-\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n-\t\treturn retVal;\n-\t}\n-\n-\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n-\t\tthis.oldVersionGraph = oldVersionGraph;\n-\t\tthis.newVersionGraph = newVersionGraph;\n-\n-\t\tthis.oldVersionPackageList = new ArrayList<>();\n-\t\tthis.oldVersionClassList = new ArrayList<>();\n-\t\tthis.oldVersionMethodList = new ArrayList<>();\n-\t\tthis.oldVersionFieldList = new ArrayList<>();\n-\n-\t\tthis.newVersionPackageList = new ArrayList<>();\n-\t\tthis.newVersionClassList = new ArrayList<>();\n-\t\tthis.newVersionMethodList = new ArrayList<>();\n-\t\tthis.newVersionFieldList = new ArrayList<>();\n-\n-\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n-\t\t\toldVersionPackageList, oldVersionFieldList);\n-\n-\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-\t}\n-\n-\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n-\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n-\t\t// Create a BreadthFirstIterator for the graph\n-\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-\t\twhile (bfi.hasNext()) {\n-\t\t\tNode n = bfi.next();\n-\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n-\t\t\t\tclasses.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n-\t\t\t\tpackages.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n-\t\t\t\tmethods.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n-\t\t\t\tfields.add(n);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic List<Node[]> findSimilarMethods() {\n-\t\tif (this.similarMethods.isEmpty()) {\n-\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n-\t\t\tfor (Node m : this.oldVersionMethodList) {\n-\t\t\t\tif (!m.isAPI())\n-\t\t\t\t\tcontinue;\n-\n-\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n-\t\t\t\t\tif (!m2.isAPI())\n-\t\t\t\t\t\tcontinue;\n-\n-\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-\t\t\t\t\t\tNode[] arr = {m, m2};\n-\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n-\t\t\t\t\t\tsimilarMethods.add(arr);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthis.similarMethods = similarMethods;\n-\t\t}\n-\t\treturn this.similarMethods;\n-\t}\n-\n-\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n-\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-\t\treturn finalGrade;\n-\t}\n-\n-\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-\t\tint[] tempArr = arr2.clone();\n-\t\tdouble grade = 0.0;\n-\t\tfor (int value : arr1) {\n-\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n-\t\t\t\tif (value == tempArr[j]) {\n-\t\t\t\t\tgrade += 1.0 / arr1.length;\n-\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn grade;\n-\t}\n-\n-\n-\t/**\n-\t * @param classes\n-\t * @param graph   <br>\n-\t *                For each class nodes in classes, find the shingles by\n-\t *                concatenating shingles in methods of its subtree. The\n-\t *                parameter s_class will determine the maximum size of shingles\n-\t */\n-\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n-\t\tfor (Node clasz : classes) {\n-\t\t\t// We will keep the number of methods for the class with the\n-\t\t\t// numberOfMethods variable.\n-\t\t\tint numberOfMethods = 0;\n-\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n-\t\t\tint methodsTotalShingleSize = 0;\n-\t\t\tfor (Edge e : outEdges) {\n-\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n-\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n-\t\t\t\t\t// Here we update the method count.\n-\t\t\t\t\tnumberOfMethods++;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n-\t\t\t// the class\n-\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n-\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n-\t\t\tint index = 0;\n-\t\t\tfor (Edge e : outEdges) {\n-\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n-\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n-\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n-\t\t\t\t\t\tindex++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n-\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n-\t\t\tArrays.sort(allShinglesFromMethods);\n-\n-\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n-\t\t\t\tallShinglesFromMethods.length);\n-\n-\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n-\t\t\tif (upperBoundForClassShingles >= 0)\n-\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n-\t\t\tclasz.setShingles(retVal);\n-\t\t}\n-\t}\n-\n-\n-\tpublic List<Node[]> findSimilarClasses() {\n-\t\tif (this.similarClasses.isEmpty()) {\n-\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n-\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n-\t\t\tList<Node[]> simClass = new ArrayList<>();\n-\t\t\tfor (Node c : this.oldVersionClassList) {\n-\t\t\t\tif (!c.isAPI())\n-\t\t\t\t\tcontinue;\n-\n-\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n-\t\t\t\t\tif (!c2.isAPI())\n-\t\t\t\t\t\tcontinue;\n-\n-\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n-\t\t\t\t\t\tNode[] arr = {c, c2};\n-\t\t\t\t\t\tsimClass.add(arr);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthis.similarClasses = simClass;\n-\t\t}\n-\t\treturn this.similarClasses;\n-\t}\n-\n-\tpublic List<Node[]> findPullUpMethodCandidates() {\n-\t\treturn findSimilarMethods();\n-\t}\n-\n-\tpublic List<Node[]> findPushDownMethodCandidates() {\n-\t\treturn findSimilarMethods();\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 2;\n\tprivate int sClass = 10;\n\tprivate int sMethod = 8;\n\tprivate double classThreshold = 0.0;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate NamedDirectedMultigraph oldVersionGraph;\n\n\tprivate NamedDirectedMultigraph newVersionGraph;\n\n\tprivate List<Node[]> similarMethods = new LinkedList<>();\n\tprivate List<Node[]> similarClasses = new LinkedList<>();\n\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n\n\n\t/**\n\t * @param classes\n\t * @param graph   <br>\n\t *                For each class nodes in classes, find the shingles by\n\t *                concatenating shingles in methods of its subtree. The\n\t *                parameter s_class will determine the maximum size of shingles\n\t */\n\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n\t\tfor (Node clasz : classes) {\n\t\t\t// We will keep the number of methods for the class with the\n\t\t\t// numberOfMethods variable.\n\t\t\tint numberOfMethods = 0;\n\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n\t\t\tint methodsTotalShingleSize = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n\t\t\t\t\t// Here we update the method count.\n\t\t\t\t\tnumberOfMethods++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n\t\t\t// the class\n\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n\t\t\tint index = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n\t\t\tArrays.sort(allShinglesFromMethods);\n\n\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n\t\t\t\tallShinglesFromMethods.length);\n\n\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n\t\t\tif (upperBoundForClassShingles >= 0)\n\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n\t\t\tclasz.setShingles(retVal);\n\t\t}\n\t}\n\n\n\tpublic List<Node[]> findSimilarClasses() {\n\t\tif (this.similarClasses.isEmpty()) {\n\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n\t\t\tList<Node[]> simClass = new ArrayList<>();\n\t\t\tfor (Node c : this.oldVersionClassList) {\n\t\t\t\tif (!c.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n\t\t\t\t\tif (!c2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n\t\t\t\t\t\tNode[] arr = {c, c2};\n\t\t\t\t\t\tsimClass.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarClasses = simClass;\n\t\t}\n\t\treturn this.similarClasses;\n\t}\n\n\tpublic List<Node[]> findPullUpMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n\n\tpublic List<Node[]> findPushDownMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n}\n'
          },
          {
            sha: "c1a320e6235857a843f5df0f924b580d890979c5",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 327,
            deletions: 295,
            patch:
              '@@ -1,309 +1,341 @@\n package refactoring.crawler.util;\n \n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n import com.github.javaparser.ast.CompilationUnit;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n import com.github.javaparser.ast.expr.FieldAccessExpr;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n+import java.util.*;\n+import java.util.stream.Collectors;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n+import refactoring.crawler.graph.*;\n+import refactoring.crawler.shingles.ShinglesUtil;\n \n public class SourceNavigator {\n \n-\t@Getter\n-\tprivate NamedDirectedMultigraph graph;\n-\n-\tprivate ShinglesUtil shinglesUtil;\n-\n-\tprivate String projectName;\n-\n-\tprivate int packageCounter = 0;\n-\n-\tprivate int allMethodsCounter = 0;\n-\n-\tprivate int allClassCounter = 0;\n-\n-\tprivate int apiClassCounter = 0;\n-\n-\tprivate int apiMethodCounter = 0;\n-\n-\tpublic static boolean useJavadocComments = false;\n-\n-\tpublic SourceNavigator() {\n-\t\tgraph = new NamedDirectedMultigraph();\n-\t}\n-\n-\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n-\t\tthis.shinglesUtil = shinglesUtil;\n-\t}\n-\n-\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n-\t\tthis.projectName = projectName;\n-\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n-\t\tthis.graph.addNamedVertex(projectNode);\n-\t\tcompilationUnits.forEach(cu -> {\n-\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n-\t\t\tval importDeclarations = cu.getImports();\n-\n-\t\t\tval classesImported = new LinkedList<String>();\n-\n-\t\t\timportDeclarations.forEach(importDeclaration -> {\n-\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n-\t\t\t});\n-\n-\t\t\tif (packageDeclaration.isPresent()) {\n-\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n-\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n-\t\t\t\tpackageNode.setProjectName(projectName);\n-\t\t\t\tthis.graph.addNamedVertex(packageNode);\n-\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-\t\t\t\tcu.getTypes().forEach(type -> {\n-\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n-\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n-\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n-\t\t\t\t\t\tif (className.isPresent()) {\n-\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n-\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n-\n-\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n-\t\t\t\t\t\t\t\t.getExtendedTypes()\n-\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n-\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n-\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n-\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n-\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n-\n-\t\t\t\t\t\t\tthis.allClassCounter += 1;\n-\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n-\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n-\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n-\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\n-\t\t\t\t\t\t\t// methods\n-\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n-\n-\t\t\t\t\t\t\t// filed fqn -> methods fqn\n-\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n-\n-\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n-\t\t\t\t\t\t\t\tString statementBody = "";\n-\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n-\n-\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n-\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n-\t\t\t\t\t\t\t\t\t} else\n-\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n-\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n-\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n-\n-\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n-\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n-\t\t\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n-\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n-\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n-\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n-\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n-\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n-\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n-\t\t\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n-\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n-\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n-\n-\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n-\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n-\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n-\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n-\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n-\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n-\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n-\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n-\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n-\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n-\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t\t// fields\n-\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n-\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n-\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n-\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n-\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n-\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n-\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n-\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n-\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\n-\t\t});\n-\n-//\t\tval packages = compilationUnits.stream()\n-//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-//\t\t\t.filter(Optional::isPresent)\n-//\t\t\t.collect(Collectors.toList());\n-////        this.graph.addVertex(projectNode);\n-//\t\tthis.graph.addNamedVertex(projectNode);\n-//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n-\t}\n-\n-//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n-//\t\tval childrenPackages = iPackage.getChildrenPackages();\n-//\t\tchildrenPackages.forEach(childrenPackage -> {\n-//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n-//\t\t\tpackageNode.setProjectName(this.projectName);\n-////            graph.addVertex(packageNode);\n-//\t\t\tgraph.addNamedVertex(packageNode);\n-////            graph.addEdge(projectNode, packageNode);\n-//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-//\t\t\tthis.packageCounter += 1;\n-//\t\t});\n-//\t}\n-\n-//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-//\t\tval classes = pckg.getClasses();\n-//\t\tclasses.forEach(clz -> {\n-//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-//\t\t\tclassNode.setProjectName(this.projectName);\n-//\t\t\tclassNode.setFlags(clz.getFlags());\n-////            graph.addVertex(classNode);\n-////            graph.addEdge(packageNode, classNode);\n-//\t\t\tgraph.addNamedVertex(classNode);\n-//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-//\t\t\tthis.browseClass(clz, classNode);\n-//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-//\t\t\tclassNode.setInterface(clz.getIsInterface());\n-//\t\t\tthis.allClassCounter += 1;\n-//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-//\t\t\t\tclassNode.setAPI(true);\n-//\t\t\t\tthis.apiClassCounter += 1;\n-//\t\t\t}\n-//\t\t});\n-//\t}\n-\n-//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-//\t\tval methods = clz.getMethods();\n-//\t\tbrowseMethods(methods, classNode);\n-//\t\tval fields = clz.getFields();\n-//\t\tbrowseFields(fields, classNode);\n-//\t}\n-//\n-//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-//\t\tmethods.forEach(method -> {\n-//\t\t\tString statementBody = "";\n-//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-//\t\t\t\tstatementBody = method.getSource().trim();\n-//\t\t\t} else\n-//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-//\t\t\t\t+ method.getElementName();\n-//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-//\n-//\t\t\tallMethodsCounter += 1;\n-//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-//\t\t\t\tmethodNode.setAPI(true);\n-//\t\t\t\tthis.apiMethodCounter += 1;\n-//\t\t\t}\n-//\t\t\tif (method.getIsDeprecated())\n-//\t\t\t\tmethodNode.setDeprecated(true);\n-//\t\t\tmethodNode.setProjectName(projectName);\n-//\t\t\tmethodNode.setShingles(shingles);\n-//\t\t\tmethodNode.setFlags(method.getFlags());\n-//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-////            graph.addVertex(methodNode);\n-////            graph.addEdge(classNode, methodNode);\n-//\t\t\tgraph.addNamedVertex(methodNode);\n-//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-//\t\t});\n-//\t}\n-//\n-//\n-//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-//\t\tStringBuilder buffer = new StringBuilder();\n-//\n-//\t\tbuffer.append(\'(\');\n-//\n-//\t\tString[] types = method.getParameterTypes();\n-//\t\tfor (int i = 0; i < types.length; i++) {\n-//\t\t\tif (i > 0)\n-//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-//\t\t\tString typeSig = Signature.toString(types[i]);\n-//\t\t\tbuffer.append(typeSig);\n-//\t\t}\n-//\t\tbuffer.append(\')\');\n-//\n-//\t\treturn buffer.toString();\n-//\t}\n-//\n-//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-//\t\tfields.forEach(field -> {\n-//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-//\t\t\tfieldNode.setProjectName(this.projectName);\n-//\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\tfieldNode.setFlags(field.getFlags());\n-//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-////            graph.addVertex(fieldNode);\n-////            graph.addEdge(classNode, fieldNode);\n-//\t\t\tgraph.addNamedVertex(fieldNode);\n-//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-//\t\t});\n-//\t}\n-//\n-\n-\t/**\n-\t * This prunes away the javadoc comments\n-\t *\n-\t * @param source\n-\t * @return\n-\t */\n-\tprivate String statementBody(String source) {\n-\t\tint lastAtChar = source.lastIndexOf("@");\n-\t\tif (lastAtChar == -1)\n-\t\t\tlastAtChar = 0;\n-\t\tint openingBracket = source.indexOf("{", lastAtChar);\n-\t\tint closingBracket = source.lastIndexOf("}");\n-\t\tif (openingBracket != -1)\n-\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n-\t\treturn source;\n-\t}\n+    @Getter private NamedDirectedMultigraph graph;\n+\n+    private ShinglesUtil shinglesUtil;\n+\n+    private String projectName;\n+\n+    private int packageCounter = 0;\n+\n+    private int allMethodsCounter = 0;\n+\n+    private int allClassCounter = 0;\n+\n+    private int apiClassCounter = 0;\n+\n+    private int apiMethodCounter = 0;\n+\n+    public static boolean useJavadocComments = false;\n+\n+    public SourceNavigator() {\n+        graph = new NamedDirectedMultigraph();\n+    }\n+\n+    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+        this.shinglesUtil = shinglesUtil;\n+    }\n+\n+    public void browseProject(\n+            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+        this.projectName = projectName;\n+        val projectNode = new Node(projectName, Node.Type.PROJECT);\n+        this.graph.addNamedVertex(projectNode);\n+        compilationUnits.forEach(\n+                cu -> {\n+                    val packageDeclaration = cu.getPackageDeclaration();\n+                    val importDeclarations = cu.getImports();\n+\n+                    val classesImported = new LinkedList<String>();\n+\n+                    importDeclarations.forEach(\n+                            importDeclaration -> {\n+                                classesImported.add(importDeclaration.getName().asString());\n+                            });\n+\n+                    if (packageDeclaration.isPresent()) {\n+                        val packageName = packageDeclaration.get().getNameAsString();\n+                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n+                        packageNode.setProjectName(projectName);\n+                        this.graph.addNamedVertex(packageNode);\n+                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+                        cu.getTypes()\n+                                .forEach(\n+                                        type -> {\n+                                            if (type.isClassOrInterfaceDeclaration()) {\n+                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+                                                if (className.isPresent()) {\n+                                                    val classNode = new ClassNode(className.get());\n+                                                    classNode.setProjectName(projectName);\n+\n+                                                    List<String> extendedClasses =\n+                                                            classOrInterfaceDeclaration\n+                                                                    .getExtendedTypes()\n+                                                                    .stream()\n+                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n+                                                                    .collect(Collectors.toList());\n+\n+                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+                                                    classNode.setSuperClasses(extendedClasses);\n+                                                    classNode.setClassesImported(classesImported);\n+                                                    classNode.setDeprecated(\n+                                                            classOrInterfaceDeclaration\n+                                                                    .getAnnotationByClass(Deprecated.class)\n+                                                                    .isPresent());\n+                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n+                                                    this.allClassCounter += 1;\n+                                                    if (classOrInterfaceDeclaration.isProtected()\n+                                                            || classOrInterfaceDeclaration.isPublic()) {\n+                                                        classNode.setAPI(true);\n+                                                        this.apiClassCounter += 1;\n+                                                    }\n+                                                    graph.addNamedVertex(classNode);\n+                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\n+                                                    // methods\n+                                                    List<MethodDeclaration> methodDeclarations =\n+                                                            classOrInterfaceDeclaration.getMethods();\n+\n+                                                    // filed fqn -> methods fqn\n+                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n+                                                    methodDeclarations.forEach(\n+                                                            method -> {\n+                                                                String statementBody = "";\n+                                                                val methodBody = method.getBody();\n+\n+                                                                if (methodBody.isPresent()) {\n+                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n+                                                                        statementBody = methodBody.get().toString().trim();\n+                                                                    } else\n+                                                                        statementBody =\n+                                                                                statementBody(methodBody.get().toString()).trim();\n+                                                                    int[] shingles =\n+                                                                            shinglesUtil.computeMethodShingles(statementBody);\n+                                                                    String qualifiedName =\n+                                                                            classNode.getFullyQualifiedName()\n+                                                                                    + "."\n+                                                                                    + method.getNameAsString();\n+                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n+\n+                                                                    List<String> methodReferencedFields =\n+                                                                            method\n+                                                                                    .findAll(FieldAccessExpr.class)\n+                                                                                    .stream()\n+                                                                                    .map(\n+                                                                                            fieldAccessExpr ->\n+                                                                                                    classNode.getFullyQualifiedName()\n+                                                                                                            + "."\n+                                                                                                            + fieldAccessExpr.resolve().getName())\n+                                                                                    .collect(Collectors.toList());\n+\n+                                                                    methodReferencedFields.forEach(\n+                                                                            field -> {\n+                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n+                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n+                                                                                    methods.add(qualifiedName);\n+                                                                                    fieldReferenceToMethods.put(field, methods);\n+                                                                                }\n+                                                                            });\n+\n+                                                                    List<MethodNode.CalledMethod> calledMethodList =\n+                                                                            method\n+                                                                                    .findAll(MethodCallExpr.class)\n+                                                                                    .stream()\n+                                                                                    .map(MethodCallExpr::resolve)\n+                                                                                    .map(\n+                                                                                            resolved ->\n+                                                                                                    new MethodNode.CalledMethod(\n+                                                                                                            resolved.getQualifiedName(),\n+                                                                                                            resolved.getQualifiedSignature()))\n+                                                                                    .collect(Collectors.toList());\n+\n+                                                                    methodNode.setCalledInside(calledMethodList);\n+\n+                                                                    allMethodsCounter += 1;\n+                                                                    if (method.isPublic() || method.isProtected()) {\n+                                                                        methodNode.setAPI(true);\n+                                                                        this.apiMethodCounter += 1;\n+                                                                    }\n+                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n+                                                                        methodNode.setDeprecated(true);\n+                                                                    methodNode.setStatic(method.isStatic());\n+                                                                    methodNode.setProjectName(projectName);\n+                                                                    methodNode.setShingles(shingles);\n+                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+                                                                    methodNode.setSignature(method.getSignature().toString());\n+                                                                    graph.addNamedVertex(methodNode);\n+                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+                                                                }\n+                                                            });\n+\n+                                                    // fields\n+                                                    List<FieldDeclaration> fieldDeclarations =\n+                                                            classOrInterfaceDeclaration.getFields();\n+                                                    fieldDeclarations.forEach(\n+                                                            field -> {\n+                                                                int[] shingles =\n+                                                                        this.shinglesUtil.computeMethodShingles(\n+                                                                                field.getVariables().toString());\n+                                                                String fullyQualifiedName =\n+                                                                        classNode.getFullyQualifiedName()\n+                                                                                + "."\n+                                                                                + field.getVariables().toString();\n+                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+                                                                fieldNode.setFieldReferenceToMethod(\n+                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n+                                                                fieldNode.setProjectName(this.projectName);\n+                                                                fieldNode.setShingles(shingles);\n+                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+                                                                fieldNode.setStatic(field.isStatic());\n+                                                                fieldNode.setSignature(field.getCommonType().asString());\n+                                                                fieldNode.setDeprecated(\n+                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n+                                                                graph.addNamedVertex(fieldNode);\n+                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+                                                            });\n+                                                }\n+                                            }\n+                                        });\n+                    }\n+                });\n+\n+        //\t\tval packages = compilationUnits.stream()\n+        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+        //\t\t\t.filter(Optional::isPresent)\n+        //\t\t\t.collect(Collectors.toList());\n+        ////        this.graph.addVertex(projectNode);\n+        //\t\tthis.graph.addNamedVertex(projectNode);\n+        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+    }\n+\n+    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n+    //\t\tchildrenPackages.forEach(childrenPackage -> {\n+    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+    //\t\t\tpackageNode.setProjectName(this.projectName);\n+    ////            graph.addVertex(packageNode);\n+    //\t\t\tgraph.addNamedVertex(packageNode);\n+    ////            graph.addEdge(projectNode, packageNode);\n+    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+    //\t\t\tthis.packageCounter += 1;\n+    //\t\t});\n+    //\t}\n+\n+    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+    //\t\tval classes = pckg.getClasses();\n+    //\t\tclasses.forEach(clz -> {\n+    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+    //\t\t\tclassNode.setProjectName(this.projectName);\n+    //\t\t\tclassNode.setFlags(clz.getFlags());\n+    ////            graph.addVertex(classNode);\n+    ////            graph.addEdge(packageNode, classNode);\n+    //\t\t\tgraph.addNamedVertex(classNode);\n+    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+    //\t\t\tthis.browseClass(clz, classNode);\n+    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n+    //\t\t\tthis.allClassCounter += 1;\n+    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+    //\t\t\t\tclassNode.setAPI(true);\n+    //\t\t\t\tthis.apiClassCounter += 1;\n+    //\t\t\t}\n+    //\t\t});\n+    //\t}\n+\n+    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+    //\t\tval methods = clz.getMethods();\n+    //\t\tbrowseMethods(methods, classNode);\n+    //\t\tval fields = clz.getFields();\n+    //\t\tbrowseFields(fields, classNode);\n+    //\t}\n+    //\n+    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+    //\t\tmethods.forEach(method -> {\n+    //\t\t\tString statementBody = "";\n+    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+    //\t\t\t\tstatementBody = method.getSource().trim();\n+    //\t\t\t} else\n+    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+    //\t\t\t\t+ method.getElementName();\n+    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+    //\n+    //\t\t\tallMethodsCounter += 1;\n+    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+    //\t\t\t\tmethodNode.setAPI(true);\n+    //\t\t\t\tthis.apiMethodCounter += 1;\n+    //\t\t\t}\n+    //\t\t\tif (method.getIsDeprecated())\n+    //\t\t\t\tmethodNode.setDeprecated(true);\n+    //\t\t\tmethodNode.setProjectName(projectName);\n+    //\t\t\tmethodNode.setShingles(shingles);\n+    //\t\t\tmethodNode.setFlags(method.getFlags());\n+    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+    ////            graph.addVertex(methodNode);\n+    ////            graph.addEdge(classNode, methodNode);\n+    //\t\t\tgraph.addNamedVertex(methodNode);\n+    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+    //\t\t});\n+    //\t}\n+    //\n+    //\n+    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+    //\t\tStringBuilder buffer = new StringBuilder();\n+    //\n+    //\t\tbuffer.append(\'(\');\n+    //\n+    //\t\tString[] types = method.getParameterTypes();\n+    //\t\tfor (int i = 0; i < types.length; i++) {\n+    //\t\t\tif (i > 0)\n+    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+    //\t\t\tString typeSig = Signature.toString(types[i]);\n+    //\t\t\tbuffer.append(typeSig);\n+    //\t\t}\n+    //\t\tbuffer.append(\')\');\n+    //\n+    //\t\treturn buffer.toString();\n+    //\t}\n+    //\n+    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+    //\t\tfields.forEach(field -> {\n+    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+    //\t\t\tfieldNode.setProjectName(this.projectName);\n+    //\t\t\tfieldNode.setShingles(shingles);\n+    //\t\t\tfieldNode.setFlags(field.getFlags());\n+    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+    ////            graph.addVertex(fieldNode);\n+    ////            graph.addEdge(classNode, fieldNode);\n+    //\t\t\tgraph.addNamedVertex(fieldNode);\n+    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+    //\t\t});\n+    //\t}\n+    //\n+\n+    /**\n+    * This prunes away the javadoc comments\n+    *\n+    * @param source\n+    * @return\n+    */\n+    private String statementBody(String source) {\n+        int lastAtChar = source.lastIndexOf("@");\n+        if (lastAtChar == -1) lastAtChar = 0;\n+        int openingBracket = source.indexOf("{", lastAtChar);\n+        int closingBracket = source.lastIndexOf("}");\n+        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n+        return source;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n    @Getter private NamedDirectedMultigraph graph;\n\n    private ShinglesUtil shinglesUtil;\n\n    private String projectName;\n\n    private int packageCounter = 0;\n\n    private int allMethodsCounter = 0;\n\n    private int allClassCounter = 0;\n\n    private int apiClassCounter = 0;\n\n    private int apiMethodCounter = 0;\n\n    public static boolean useJavadocComments = false;\n\n    public SourceNavigator() {\n        graph = new NamedDirectedMultigraph();\n    }\n\n    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n        this.shinglesUtil = shinglesUtil;\n    }\n\n    public void browseProject(\n            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n        this.projectName = projectName;\n        val projectNode = new Node(projectName, Node.Type.PROJECT);\n        this.graph.addNamedVertex(projectNode);\n        compilationUnits.forEach(\n                cu -> {\n                    val packageDeclaration = cu.getPackageDeclaration();\n                    val importDeclarations = cu.getImports();\n\n                    val classesImported = new LinkedList<String>();\n\n                    importDeclarations.forEach(\n                            importDeclaration -> {\n                                classesImported.add(importDeclaration.getName().asString());\n                            });\n\n                    if (packageDeclaration.isPresent()) {\n                        val packageName = packageDeclaration.get().getNameAsString();\n                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n                        packageNode.setProjectName(projectName);\n                        this.graph.addNamedVertex(packageNode);\n                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n                        cu.getTypes()\n                                .forEach(\n                                        type -> {\n                                            if (type.isClassOrInterfaceDeclaration()) {\n                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                                                if (className.isPresent()) {\n                                                    val classNode = new ClassNode(className.get());\n                                                    classNode.setProjectName(projectName);\n\n                                                    List<String> extendedClasses =\n                                                            classOrInterfaceDeclaration\n                                                                    .getExtendedTypes()\n                                                                    .stream()\n                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n                                                                    .collect(Collectors.toList());\n\n                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                                                    classNode.setSuperClasses(extendedClasses);\n                                                    classNode.setClassesImported(classesImported);\n                                                    classNode.setDeprecated(\n                                                            classOrInterfaceDeclaration\n                                                                    .getAnnotationByClass(Deprecated.class)\n                                                                    .isPresent());\n                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                                                    this.allClassCounter += 1;\n                                                    if (classOrInterfaceDeclaration.isProtected()\n                                                            || classOrInterfaceDeclaration.isPublic()) {\n                                                        classNode.setAPI(true);\n                                                        this.apiClassCounter += 1;\n                                                    }\n                                                    graph.addNamedVertex(classNode);\n                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                                                    // methods\n                                                    List<MethodDeclaration> methodDeclarations =\n                                                            classOrInterfaceDeclaration.getMethods();\n\n                                                    // filed fqn -> methods fqn\n                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                                                    methodDeclarations.forEach(\n                                                            method -> {\n                                                                String statementBody = "";\n                                                                val methodBody = method.getBody();\n\n                                                                if (methodBody.isPresent()) {\n                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n                                                                        statementBody = methodBody.get().toString().trim();\n                                                                    } else\n                                                                        statementBody =\n                                                                                statementBody(methodBody.get().toString()).trim();\n                                                                    int[] shingles =\n                                                                            shinglesUtil.computeMethodShingles(statementBody);\n                                                                    String qualifiedName =\n                                                                            classNode.getFullyQualifiedName()\n                                                                                    + "."\n                                                                                    + method.getNameAsString();\n                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                                                    List<String> methodReferencedFields =\n                                                                            method\n                                                                                    .findAll(FieldAccessExpr.class)\n                                                                                    .stream()\n                                                                                    .map(\n                                                                                            fieldAccessExpr ->\n                                                                                                    classNode.getFullyQualifiedName()\n                                                                                                            + "."\n                                                                                                            + fieldAccessExpr.resolve().getName())\n                                                                                    .collect(Collectors.toList());\n\n                                                                    methodReferencedFields.forEach(\n                                                                            field -> {\n                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n                                                                                    methods.add(qualifiedName);\n                                                                                    fieldReferenceToMethods.put(field, methods);\n                                                                                }\n                                                                            });\n\n                                                                    List<MethodNode.CalledMethod> calledMethodList =\n                                                                            method\n                                                                                    .findAll(MethodCallExpr.class)\n                                                                                    .stream()\n                                                                                    .map(MethodCallExpr::resolve)\n                                                                                    .map(\n                                                                                            resolved ->\n                                                                                                    new MethodNode.CalledMethod(\n                                                                                                            resolved.getQualifiedName(),\n                                                                                                            resolved.getQualifiedSignature()))\n                                                                                    .collect(Collectors.toList());\n\n                                                                    methodNode.setCalledInside(calledMethodList);\n\n                                                                    allMethodsCounter += 1;\n                                                                    if (method.isPublic() || method.isProtected()) {\n                                                                        methodNode.setAPI(true);\n                                                                        this.apiMethodCounter += 1;\n                                                                    }\n                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                                                        methodNode.setDeprecated(true);\n                                                                    methodNode.setStatic(method.isStatic());\n                                                                    methodNode.setProjectName(projectName);\n                                                                    methodNode.setShingles(shingles);\n                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                                                    methodNode.setSignature(method.getSignature().toString());\n                                                                    graph.addNamedVertex(methodNode);\n                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                                                }\n                                                            });\n\n                                                    // fields\n                                                    List<FieldDeclaration> fieldDeclarations =\n                                                            classOrInterfaceDeclaration.getFields();\n                                                    fieldDeclarations.forEach(\n                                                            field -> {\n                                                                int[] shingles =\n                                                                        this.shinglesUtil.computeMethodShingles(\n                                                                                field.getVariables().toString());\n                                                                String fullyQualifiedName =\n                                                                        classNode.getFullyQualifiedName()\n                                                                                + "."\n                                                                                + field.getVariables().toString();\n                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                                                fieldNode.setFieldReferenceToMethod(\n                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n                                                                fieldNode.setProjectName(this.projectName);\n                                                                fieldNode.setShingles(shingles);\n                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                                                fieldNode.setStatic(field.isStatic());\n                                                                fieldNode.setSignature(field.getCommonType().asString());\n                                                                fieldNode.setDeprecated(\n                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n                                                                graph.addNamedVertex(fieldNode);\n                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                                                            });\n                                                }\n                                            }\n                                        });\n                    }\n                });\n\n        //\t\tval packages = compilationUnits.stream()\n        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n        //\t\t\t.filter(Optional::isPresent)\n        //\t\t\t.collect(Collectors.toList());\n        ////        this.graph.addVertex(projectNode);\n        //\t\tthis.graph.addNamedVertex(projectNode);\n        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n    }\n\n    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n    //\t\tchildrenPackages.forEach(childrenPackage -> {\n    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n    //\t\t\tpackageNode.setProjectName(this.projectName);\n    ////            graph.addVertex(packageNode);\n    //\t\t\tgraph.addNamedVertex(packageNode);\n    ////            graph.addEdge(projectNode, packageNode);\n    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n    //\t\t\tthis.packageCounter += 1;\n    //\t\t});\n    //\t}\n\n    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n    //\t\tval classes = pckg.getClasses();\n    //\t\tclasses.forEach(clz -> {\n    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n    //\t\t\tclassNode.setProjectName(this.projectName);\n    //\t\t\tclassNode.setFlags(clz.getFlags());\n    ////            graph.addVertex(classNode);\n    ////            graph.addEdge(packageNode, classNode);\n    //\t\t\tgraph.addNamedVertex(classNode);\n    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n    //\t\t\tthis.browseClass(clz, classNode);\n    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n    //\t\t\tthis.allClassCounter += 1;\n    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n    //\t\t\t\tclassNode.setAPI(true);\n    //\t\t\t\tthis.apiClassCounter += 1;\n    //\t\t\t}\n    //\t\t});\n    //\t}\n\n    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n    //\t\tval methods = clz.getMethods();\n    //\t\tbrowseMethods(methods, classNode);\n    //\t\tval fields = clz.getFields();\n    //\t\tbrowseFields(fields, classNode);\n    //\t}\n    //\n    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n    //\t\tmethods.forEach(method -> {\n    //\t\t\tString statementBody = "";\n    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n    //\t\t\t\tstatementBody = method.getSource().trim();\n    //\t\t\t} else\n    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n    //\t\t\t\t+ method.getElementName();\n    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n    //\n    //\t\t\tallMethodsCounter += 1;\n    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n    //\t\t\t\tmethodNode.setAPI(true);\n    //\t\t\t\tthis.apiMethodCounter += 1;\n    //\t\t\t}\n    //\t\t\tif (method.getIsDeprecated())\n    //\t\t\t\tmethodNode.setDeprecated(true);\n    //\t\t\tmethodNode.setProjectName(projectName);\n    //\t\t\tmethodNode.setShingles(shingles);\n    //\t\t\tmethodNode.setFlags(method.getFlags());\n    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n    ////            graph.addVertex(methodNode);\n    ////            graph.addEdge(classNode, methodNode);\n    //\t\t\tgraph.addNamedVertex(methodNode);\n    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n    //\t\t});\n    //\t}\n    //\n    //\n    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n    //\t\tStringBuilder buffer = new StringBuilder();\n    //\n    //\t\tbuffer.append(\'(\');\n    //\n    //\t\tString[] types = method.getParameterTypes();\n    //\t\tfor (int i = 0; i < types.length; i++) {\n    //\t\t\tif (i > 0)\n    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n    //\t\t\tString typeSig = Signature.toString(types[i]);\n    //\t\t\tbuffer.append(typeSig);\n    //\t\t}\n    //\t\tbuffer.append(\')\');\n    //\n    //\t\treturn buffer.toString();\n    //\t}\n    //\n    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n    //\t\tfields.forEach(field -> {\n    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n    //\t\t\tfieldNode.setProjectName(this.projectName);\n    //\t\t\tfieldNode.setShingles(shingles);\n    //\t\t\tfieldNode.setFlags(field.getFlags());\n    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n    ////            graph.addVertex(fieldNode);\n    ////            graph.addEdge(classNode, fieldNode);\n    //\t\t\tgraph.addNamedVertex(fieldNode);\n    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n    //\t\t});\n    //\t}\n    //\n\n    /**\n    * This prunes away the javadoc comments\n    *\n    * @param source\n    * @return\n    */\n    private String statementBody(String source) {\n        int lastAtChar = source.lastIndexOf("@");\n        if (lastAtChar == -1) lastAtChar = 0;\n        int openingBracket = source.indexOf("{", lastAtChar);\n        int closingBracket = source.lastIndexOf("}");\n        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n        return source;\n    }\n}\n'
          },
          {
            sha: "725ef3d6de620acbc3d0eeed586e1bc21cc5f2b6",
            filename:
              "src/main/java/refactoring/crawler/visitor/ClassVisitor.java",
            status: "removed",
            additions: 0,
            deletions: 8,
            patch:
              "@@ -1,8 +0,0 @@\n-package refactoring.crawler.visitor;\n-\n-import com.github.javaparser.ast.body.MethodDeclaration;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-\n-public class ClassVisitor extends VoidVisitorAdapter<Object> {\n-\n-}",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class ClassVisitor extends VoidVisitorAdapter<Object> {\n\n}\n"
          },
          {
            sha: "da212c011daa35711a7bc770b3a8647fd26e91a3",
            filename:
              "src/main/java/refactoring/crawler/visitor/MethodVisitor.java",
            status: "removed",
            additions: 0,
            deletions: 518,
            patch:
              "@@ -1,518 +0,0 @@\n-package refactoring.crawler.visitor;\n-\n-import com.github.javaparser.ast.*;\n-import com.github.javaparser.ast.body.*;\n-import com.github.javaparser.ast.comments.*;\n-import com.github.javaparser.ast.expr.*;\n-import com.github.javaparser.ast.modules.*;\n-import com.github.javaparser.ast.stmt.*;\n-import com.github.javaparser.ast.type.*;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-\n-public class MethodVisitor extends VoidVisitorAdapter<Object> {\n-\n-    public void visit(MethodDeclaration n, Object arg) {\n-        System.out.println(n.getBody());\n-        System.out.println(n.getName());\n-    }\n-\n-    @Override\n-    public void visit(AnnotationDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AnnotationMemberDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayAccessExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayCreationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayInitializerExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AssertStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AssignExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BinaryExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BlockComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BlockStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BooleanLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BreakStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CastExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CatchClause n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CharLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassOrInterfaceType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CompilationUnit n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ConditionalExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ConstructorDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ContinueStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(DoStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(DoubleLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EmptyStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnclosedExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnumConstantDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnumDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ExpressionStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(FieldAccessExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(FieldDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ForEachStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ForStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IfStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(InitializerDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(InstanceOfExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IntegerLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LabeledStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LineComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LongLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MarkerAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MemberValuePair n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MethodCallExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NameExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NormalAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NullLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ObjectCreationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(PackageDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Parameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(PrimitiveType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Name n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SimpleName n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayCreationLevel n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IntersectionType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnionType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ReturnStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(StringLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SuperExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchEntry n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SynchronizedStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ThisExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ThrowStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TryStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LocalClassDeclarationStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TypeParameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnaryExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnknownType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VariableDeclarationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VariableDeclarator n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VoidType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(WhileStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(WildcardType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LambdaExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MethodReferenceExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TypeExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NodeList n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ImportDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleRequiresDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleExportsDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleProvidesDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleUsesDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleOpensDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnparsableStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ReceiverParameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VarType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Modifier n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TextBlockLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(YieldStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocBlockTag n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocContent n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocDescription n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocInlineTag n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocSnippet n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-}\n\\ No newline at end of file",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.modules.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class MethodVisitor extends VoidVisitorAdapter<Object> {\n\n    public void visit(MethodDeclaration n, Object arg) {\n        System.out.println(n.getBody());\n        System.out.println(n.getName());\n    }\n\n    @Override\n    public void visit(AnnotationDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AnnotationMemberDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayInitializerExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssertStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssignExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BinaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BooleanLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BreakStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CastExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CatchClause n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CharLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CompilationUnit n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConditionalExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConstructorDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ContinueStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoubleLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EmptyStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnclosedExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumConstantDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExpressionStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForEachStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IfStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InitializerDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InstanceOfExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntegerLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LabeledStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LineComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LongLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MarkerAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MemberValuePair n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodCallExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NameExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NormalAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NullLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ObjectCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PackageDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Parameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PrimitiveType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Name n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SimpleName n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntersectionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReturnStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(StringLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SuperExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchEntry n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SynchronizedStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThisExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThrowStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TryStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LocalClassDeclarationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarator n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VoidType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WhileStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WildcardType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NodeList n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ImportDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleRequiresDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleExportsDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleProvidesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleUsesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleOpensDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnparsableStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReceiverParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VarType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Modifier n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TextBlockLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(YieldStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocBlockTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocContent n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocDescription n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocInlineTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocSnippet n, Object arg) {\n        super.visit(n, arg);\n    }\n}"
          },
          {
            sha: "9ab5119f95a2b259504fd1325a9c3933e09bedec",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 62,
            deletions: 23,
            patch:
              '@@ -1,38 +1,77 @@\n /*\n- * This Java source file was generated by the Gradle \'init\' task.\n- */\n+* This Java source file was generated by the Gradle \'init\' task.\n+*/\n package refactoring.crawler;\n \n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-\n import java.util.Dictionary;\n-import java.util.HashMap;\n import java.util.Hashtable;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+    private static RefactoringCrawler refactoringCrawler;\n \n-\tprivate static RefactoringCrawler refactoringCrawler;\n+    @BeforeAll\n+    static void setUp() {\n+        settings = new Hashtable<>();\n \n-\t@BeforeAll\n-\tstatic void setUp() {\n-\t\tsettings = new Hashtable<>();\n+        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n \n-\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n+    }\n \n-\t\trefactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n-\t}\n+    @Test\n+    void testRenameMethod() {\n+        String source =\n+                "/*\\n"\n+                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+                        + " */\\n"\n+                        + "package refactoring.crawler;\\n"\n+                        + "\\n"\n+                        + "public class Library {\\n"\n+                        + "\\tprivate int a;\\n"\n+                        + "\\tprivate int b;\\n"\n+                        + "\\n"\n+                        + "\\tpublic void foo() {\\n"\n+                        + "\\t\\tSystem.out.println(11111);\\n"\n+                        + "\\t}\\n"\n+                        + "\\n"\n+                        + "\\tpublic void bar() {\\n"\n+                        + "\\t\\tthis.foo();\\n"\n+                        + "\\t}\\n"\n+                        + "}\\n";\n \n+        String newVersion =\n+                "/*\\n"\n+                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+                        + " */\\n"\n+                        + "package refactoring.crawler;\\n"\n+                        + "\\n"\n+                        + "public class Library {\\n"\n+                        + "\\tprivate int a;\\n"\n+                        + "\\tprivate int b;\\n"\n+                        + "\\n"\n+                        + "\\tpublic void foo12() {\\n"\n+                        + "\\t\\tSystem.out.println(11111);\\n"\n+                        + "\\t}\\n"\n+                        + "\\n"\n+                        + "\\tpublic void bar() {\\n"\n+                        + "\\t\\tthis.foo12();\\n"\n+                        + "\\t}\\n"\n+                        + "}\\n";\n \n-\t@Test\n-\tvoid testSomeLibraryMethod() {\n-\t}\n+        refactoringCrawler.detect(source, newVersion);\n+        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+        System.out.println(categories);\n+    }\n }',
            rawContent:
              '/*\n* This Java source file was generated by the Gradle \'init\' task.\n*/\npackage refactoring.crawler;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n    private static RefactoringCrawler refactoringCrawler;\n\n    @BeforeAll\n    static void setUp() {\n        settings = new Hashtable<>();\n\n        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\n        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n    }\n\n    @Test\n    void testRenameMethod() {\n        String source =\n                "/*\\n"\n                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n                        + " */\\n"\n                        + "package refactoring.crawler;\\n"\n                        + "\\n"\n                        + "public class Library {\\n"\n                        + "\\tprivate int a;\\n"\n                        + "\\tprivate int b;\\n"\n                        + "\\n"\n                        + "\\tpublic void foo() {\\n"\n                        + "\\t\\tSystem.out.println(11111);\\n"\n                        + "\\t}\\n"\n                        + "\\n"\n                        + "\\tpublic void bar() {\\n"\n                        + "\\t\\tthis.foo();\\n"\n                        + "\\t}\\n"\n                        + "}\\n";\n\n        String newVersion =\n                "/*\\n"\n                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n                        + " */\\n"\n                        + "package refactoring.crawler;\\n"\n                        + "\\n"\n                        + "public class Library {\\n"\n                        + "\\tprivate int a;\\n"\n                        + "\\tprivate int b;\\n"\n                        + "\\n"\n                        + "\\tpublic void foo12() {\\n"\n                        + "\\t\\tSystem.out.println(11111);\\n"\n                        + "\\t}\\n"\n                        + "\\n"\n                        + "\\tpublic void bar() {\\n"\n                        + "\\t\\tthis.foo12();\\n"\n                        + "\\t}\\n"\n                        + "}\\n";\n\n        refactoringCrawler.detect(source, newVersion);\n        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n        System.out.println(categories);\n    }\n}\n'
          }
        ]
      },
      {
        sha: "e730803e9a4a7b487df89013a8a6901f07100860",
        message: "chore(*): wait test",
        stats: {
          total: 1438,
          additions: 1231,
          deletions: 207
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "c3f3ef6c45dd1b13fda0b507cc62de4301cc58de"
          }
        ],
        committedAt: 1585207166000,
        changedFiles: [
          {
            sha: "1498e33720ff8e6f5f1ed0dacefa4d33b293101d",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 106,
            deletions: 79,
            patch:
              '@@ -2,66 +2,40 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.expr.MethodCallExpr;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n-import lombok.val;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.jgrapht.nio.dot.DOTExporter;\n-import refactoring.crawler.detection.ChangeMethodSignatureDetection;\n+import lombok.Getter;\n+import refactoring.crawler.detection.classDetection.RenameClassDetection;\n+import refactoring.crawler.detection.methodDetection.*;\n import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.RenameMethodDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n-import java.io.IOException;\n-import java.rmi.server.ExportException;\n import java.util.*;\n \n public class RefactoringCrawler {\n \n-\tprivate String projectName;\n+\tpublic static enum Settings {\n+\t\tT_RENAME_METHOD,\n+\t\tT_RENAME_CLASS,\n+\t\tT_MOVE_METHOD,\n+\t\tT_PULL_UP_METHOD,\n+\t\tT_PUSH_DOWN_METHOD,\n+\t\tT_CHANGE_METHOD_SIGNATURE\n+\t}\n \n-\tpublic static void main(String[] args) throws IOException {\n-\t\tval crawler = new RefactoringCrawler("project name");\n-\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n-\t\t\t"public class A{" +\n-\t\t\t"   public void foo(){" +\n-\t\t\t"       System.out.println(1);" +\n-\t\t\t"   }" +\n-\t\t\t"   " +\n-\t\t\t"   public void bar(){" +\n-\t\t\t"       this.foo();" +\n-\t\t\t"   }" +\n-\t\t\t"}";\n-\t\tval newSource = "package com.MyCourses.dao.impl;" +\n-\t\t\t"public class A{" +\n-\t\t\t"   public void foo(int i){" +\n-\t\t\t"       System.out.println(i);" +\n-\t\t\t"   }" +\n-\t\t\t"   public void bar(){" +\n-\t\t\t"       this.foo(10);" +\n-\t\t\t"   }" +\n-\t\t\t"}";\n-\n-\t\tval oldList = new ArrayList<String>();\n-\t\tval newList = new ArrayList<String>();\n-\n-\t\toldList.add(oldSource);\n-\t\tnewList.add(newSource);\n-\n-\t\tcrawler.detect(oldList, newList);\n+\tprivate String projectName;\n+\tprivate Dictionary<Settings, Double> settings;\n \n-\t}\n+\t@Getter\n+\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n \n-\tpublic RefactoringCrawler(String projectName) {\n+\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n \t\tthis.projectName = projectName;\n+\t\tthis.settings = settings;\n \t}\n \n-\tprivate List<CompilationUnit> parse(List<String> files) {\n+\tprivate static List<CompilationUnit> parse(List<String> files) {\n \t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n \t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n \t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n@@ -77,8 +51,8 @@ public RefactoringCrawler(String projectName) {\n \tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n \n-\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n-\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n+\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n+\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n \t\tSourceNavigator navigator = new SourceNavigator();\n \t\tnavigator.setShinglesUtil(shinglesUtil);\n \t\tnavigator.browseProject(projectName, oldVersionCU);\n@@ -90,37 +64,41 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n-//\n-//\t\tSystem.out.println("-----original graph-----");\n-//\t\tfor (Edge e : originalGraph.edgeSet()) {\n-//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n-//\t\t}\n-//\n-//\t\tSystem.out.println("-----new version graph-----");\n-//\t\tfor (Edge e : versionGraph.edgeSet()) {\n-//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n-//\t\t}\n-\n-\n-//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n-//\t\tshinglesUtil.setMethodThreshold(0.5);\n-\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\t// must in this order\n+\n+\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+\n+\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n+\t\t\toriginalGraph, versionGraph);\n+\n+\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n \t}\n \n-\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n+\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n \t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n \t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n \t\tdetector.setThreshold(tChangeMethodSignature);\n \t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n \t\tif (changedMethodSignatures.size() > 0) {\n-\t\t\tSystem.out.println("-----change method signature result-----");\n-\t\t\tSystem.out.println(changedMethodSignatures);\n-//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n-//\t\t\tchangeSignatureCategory\n-//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n-//\t\t\trefactoringList.add(changeSignatureCategory);\n+\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n+\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n \t\t}\n \t}\n \n@@ -132,16 +110,65 @@ private void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMu\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {\n-\t\t\tSystem.out.println("-----result below-----");\n-\t\t\trenamedMethods.forEach(r -> {\n-\t\t\t\tSystem.out.println(r[0]);\n-\t\t\t\tSystem.out.println(r[1]);\n-\t\t\t});\n-//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n-//            renameMethodCategory.setName("RenamedMethods");\n-//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n-//            refactoringList.add(renameMethodCategory);\n+\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n+\t\t\trenameMethodCategory.setName("RenamedMethods");\n+\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n+\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n \t\t}\n \t}\n \n+\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n+\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n+\t\t\tversionGraph);\n+\t\tdetector.setThreshold(tClass);\n+\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+\t\tif (renamedClasses.size() > 0) {\n+\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n+\t\t\trenameClassCategory.setName("RenamedClasses");\n+\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n+\t\t\tthis.refactoringCategories.add(renameClassCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n+\t\tse.findSimilarClasses();\n+\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tMoveMethod);\n+\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+\t\tif (movedMethods.size() > 0) {\n+\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n+\t\t\tmoveMethodCategory.setName("MovedMethods");\n+\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n+\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+\t\tRefactoringDetection detector = new PullUpMethodDetection(\n+\t\t\toriginalGraph, versionGraph);\n+\t\tdetector.setThreshold(tPullUpMethod);\n+\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+\t\tif (pullUpMethodResults.size() > 0) {\n+\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n+\t\t\tpullUpCategory.setName("PulledUpMethods");\n+\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+\t\t\tthis.refactoringCategories.add(pullUpCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tPushDownMethod);\n+\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+\t\tif (pushDownMethodResults.size() > 0) {\n+\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n+\t\t\tpushDownCategory.setName("PushedDownMethods");\n+\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+\t\t\tthis.refactoringCategories.add(pushDownCategory);\n+\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.Getter;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.util.*;\n\nimport java.util.*;\n\npublic class RefactoringCrawler {\n\n\tpublic static enum Settings {\n\t\tT_RENAME_METHOD,\n\t\tT_RENAME_CLASS,\n\t\tT_MOVE_METHOD,\n\t\tT_PULL_UP_METHOD,\n\t\tT_PUSH_DOWN_METHOD,\n\t\tT_CHANGE_METHOD_SIGNATURE\n\t}\n\n\tprivate String projectName;\n\tprivate Dictionary<Settings, Double> settings;\n\n\t@Getter\n\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n\t\tthis.projectName = projectName;\n\t\tthis.settings = settings;\n\t}\n\n\tprivate static List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\t// must in this order\n\n\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n\n\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n\t\t\toriginalGraph, versionGraph);\n\n\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tChangeMethodSignature);\n\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n\t\tif (changedMethodSignatures.size() > 0) {\n\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n\t\t}\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n\t\t\trenameMethodCategory.setName("RenamedMethods");\n\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n\t\t}\n\t}\n\n\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n\t\t\tversionGraph);\n\t\tdetector.setThreshold(tClass);\n\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n\t\tif (renamedClasses.size() > 0) {\n\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n\t\t\trenameClassCategory.setName("RenamedClasses");\n\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n\t\t\tthis.refactoringCategories.add(renameClassCategory);\n\t\t}\n\t}\n\n\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n\t\tse.findSimilarClasses();\n\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n\t\tdetector.setThreshold(tMoveMethod);\n\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n\t\tif (movedMethods.size() > 0) {\n\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n\t\t\tmoveMethodCategory.setName("MovedMethods");\n\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n\t\t}\n\t}\n\n\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n\t\tRefactoringDetection detector = new PullUpMethodDetection(\n\t\t\toriginalGraph, versionGraph);\n\t\tdetector.setThreshold(tPullUpMethod);\n\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n\t\tif (pullUpMethodResults.size() > 0) {\n\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n\t\t\tpullUpCategory.setName("PulledUpMethods");\n\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n\t\t\tthis.refactoringCategories.add(pullUpCategory);\n\t\t}\n\t}\n\n\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tPushDownMethod);\n\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n\t\tif (pushDownMethodResults.size() > 0) {\n\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n\t\t\tpushDownCategory.setName("PushedDownMethods");\n\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n\t\t\tthis.refactoringCategories.add(pushDownCategory);\n\t\t}\n\t}\n}\n'
          },
          {
            sha: "e04923c393be759d113e51b42ec573aa46e4095a",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "removed",
            additions: 0,
            deletions: 39,
            patch:
              "@@ -1,39 +0,0 @@\n-package refactoring.crawler.detection;\n-\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-public class MoveMethodDetection extends RefactoringDetection {\n-    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        return null;\n-    }\n-\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n-    }\n-\n-    @Override\n-    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-    }\n-\n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n-}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        return null;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "0b960fc4680ca705d13f9126e0e4cfd015fbbcd1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 66,
            deletions: 3,
            patch:
              '@@ -2,14 +2,13 @@\n \n import lombok.Getter;\n import lombok.Setter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.eclipse.core.runtime.SubProgressMonitor;\n+import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n+import refactoring.crawler.util.ClassNode;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.*;\n-import java.util.stream.Collectors;\n \n public abstract class RefactoringDetection {\n \n@@ -387,4 +386,68 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t}\n \t\treturn prunedCandidates;\n \t}\n+\n+\t// TODO this is bug pruned\n+\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+//\t\ttry {\n+\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+\t\tresults.forEach(result -> {\n+\t\t\tif (graph.hasNamedNode(result))\n+\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+\t\t});\n+\t\t// Possible change to methods that instantiate classes\n+\t\t// from class -> class edges.\n+//\t\t\tfor (String result : results) {\n+////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+//\t\t\t\tString callingNode = null;\n+//\t\t\t\tif (resultNode instanceof IMethod) {\n+//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof IType) {\n+//\t\t\t\t\tIType rst = (IType) resultNode;\n+//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+//\t\t\t\t} else if (resultNode instanceof IField) {\n+//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+//\t\t\t\t\t// Workaround\n+//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += ".";\n+//\t\t\t\t\tcallingNode += rsf1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n+//\t\t\t\t\t\t.getParent(initializer,\n+//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+//\t\t\t\t\t\tIType.class);\n+//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+//\t\t\t\t}\n+//\n+//\t\t\t\t// TODO treat the case when resultNode is instance of\n+//\t\t\t\t// ImportDeclaration\n+//\t\t\t\t// TODO treat the case when resultNode is instance of\n+//\t\t\t\t// Initializer\n+//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+//\t\t\t\t// Level\n+//\t\t\t\tif (callingNode == null) {\n+//\t\t\t\t\tSystem.out.print("");\n+//\t\t\t\t}\n+//\t\t\t\tif (callingNode != null) {\n+//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+//\t\t\t\t\tif (callerNode != null)\n+//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+//\t\t\t\t}\n+//\n+//\t\t\t}\n+//\n+//\t\t} catch (CoreException e) {\n+//\t\t\tJavaPlugin.log(e);\n+//\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.util.ClassNode;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t// TODO this is bug pruned\n\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n//\t\ttry {\n\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n\t\tresults.forEach(result -> {\n\t\t\tif (graph.hasNamedNode(result))\n\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n\t\t});\n\t\t// Possible change to methods that instantiate classes\n\t\t// from class -> class edges.\n//\t\t\tfor (String result : results) {\n////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n//\t\t\t\tString callingNode = null;\n//\t\t\t\tif (resultNode instanceof IMethod) {\n//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof IType) {\n//\t\t\t\t\tIType rst = (IType) resultNode;\n//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n//\t\t\t\t} else if (resultNode instanceof IField) {\n//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n//\t\t\t\t\t// Workaround\n//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += ".";\n//\t\t\t\t\tcallingNode += rsf1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof Initializer) {\n//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n//\t\t\t\t\t\t.getParent(initializer,\n//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n//\t\t\t\t\t\tIType.class);\n//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n//\t\t\t\t}\n//\n//\t\t\t\t// TODO treat the case when resultNode is instance of\n//\t\t\t\t// ImportDeclaration\n//\t\t\t\t// TODO treat the case when resultNode is instance of\n//\t\t\t\t// Initializer\n//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n//\t\t\t\t// Level\n//\t\t\t\tif (callingNode == null) {\n//\t\t\t\t\tSystem.out.print("");\n//\t\t\t\t}\n//\t\t\t\tif (callingNode != null) {\n//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n//\t\t\t\t\tif (callerNode != null)\n//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n//\t\t\t\t}\n//\n//\t\t\t}\n//\n//\t\t} catch (CoreException e) {\n//\t\t\tJavaPlugin.log(e);\n//\t\t}\n\t}\n}\n'
          },
          {
            sha: "1696bc3d11c7a90c2912eaeeb1b69012438fb710",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 13,
            deletions: 3,
            patch:
              "@@ -4,14 +4,24 @@\n import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import org.eclipse.core.runtime.IProgressMonitor;\n-import refactoring.crawler.util.MethodNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n+import refactoring.crawler.util.*;\n \n import java.util.*;\n import java.util.stream.Collectors;\n \n public class SearchHelper {\n+\tpublic static List<String> findFieldReferences(FieldNode node) {\n+\t\treturn node.getFieldReferenceToMethod();\n+\t}\n+\n+\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n+\t\treturn node.getSuperClasses();\n+\t}\n+\n+\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+\t\treturn node.getClassesImported();\n+\t}\n+\n \tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n \t\treturn graph.vertexSet()\n \t\t\t.stream()",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SearchHelper {\n\tpublic static List<String> findFieldReferences(FieldNode node) {\n\t\treturn node.getFieldReferenceToMethod();\n\t}\n\n\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n\t\treturn node.getSuperClasses();\n\t}\n\n\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n\t\treturn node.getClassesImported();\n\t}\n\n\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(methodNode ->\n\t\t\t\tmethodNode.getCalledInside()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.anyMatch(calledMethod -> {\n\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.map(methodNode -> {\n\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n\n}\n"
          },
          {
            sha: "0d1a80e9a16088e7355f78676f2bfb2a8a051b38",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "added",
            additions: 83,
            deletions: 0,
            patch:
              "@@ -0,0 +1,83 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import org.eclipse.jdt.core.IType;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.util.ClassNode;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ClassDetection extends RefactoringDetection {\n+\n+\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn false;\n+\t}\n+\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t/**\n+\t * We need to find all the places that the original and version classes are\n+\t * instantiated. We will incorporate this into the likeliness grade.\n+\t */\n+\tprotected void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateCallGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateCallGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+\t\tcreateClassReferenceGraph(node, graph);\n+\t\tnode.setCreatedCallGraph();\n+\t}\n+\n+\t/**\n+\t * Accepts two class nodes, and determines if first parameter is a\n+\t * superclass of the second parameter.\n+\t */\n+\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n+\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+\t\tfor (String superClass : superClasses) {\n+\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+//\t\treturn false;\n+\t}\n+\n+\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport org.eclipse.jdt.core.IType;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.ClassNode;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassDetection extends RefactoringDetection {\n\n\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * We need to find all the places that the original and version classes are\n\t * instantiated. We will incorporate this into the likeliness grade.\n\t */\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tcreateClassReferenceGraph(node, graph);\n\t\tnode.setCreatedCallGraph();\n\t}\n\n\t/**\n\t * Accepts two class nodes, and determines if first parameter is a\n\t * superclass of the second parameter.\n\t */\n\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n\t\tfor (String superClass : superClasses) {\n\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n//\t\treturn false;\n\t}\n\n\n}\n"
          },
          {
            sha: "ec623de6153010a38b7292c76fd34a0ab7df7bfb",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "added",
            additions: 47,
            deletions: 0,
            patch:
              "@@ -0,0 +1,47 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class MoveClassDetection extends ClassDetection {\n+\n+\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedClasses) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n+\t\t\t\tparentPackageVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesInDifferentPackages.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesInDifferentPackages;\n+\t}\n+\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MoveClassDetection extends ClassDetection {\n\n\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedClasses) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n\t\t\t\tparentPackageVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesInDifferentPackages.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesInDifferentPackages;\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n}\n"
          },
          {
            sha: "954ff3cbdaaa548f8eb95410c1b37bfbb84730f6",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "added",
            additions: 60,
            deletions: 0,
            patch:
              "@@ -0,0 +1,60 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class RenameClassDetection extends ClassDetection {\n+\n+\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n+\t}\n+\n+\t/**\n+\t * Calls createCallGraph in ClassDetection\n+\t * Calls filterNamedEdges in ClassDetection\n+\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n+\t *\n+\t * @param nodeOriginal\n+\t * @param nodeVersion\n+\t * @return\n+\t */\n+\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+\t\tfor (Node[] pair : prePruned) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n+\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n+\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentPackage;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RenameClassDetection extends ClassDetection {\n\n\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n\t}\n\n\t/**\n\t * Calls createCallGraph in ClassDetection\n\t * Calls filterNamedEdges in ClassDetection\n\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n\t *\n\t * @param nodeOriginal\n\t * @param nodeVersion\n\t * @return\n\t */\n\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n\t\tfor (Node[] pair : prePruned) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithSameParentPackage;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n}\n"
          },
          {
            sha: "cc703c79cea5583d04d007cba3f37490cd1c7ac5",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "added",
            additions: 119,
            deletions: 0,
            patch:
              "@@ -0,0 +1,119 @@\n+package refactoring.crawler.detection.fieldDetection;\n+\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.NullProgressMonitor;\n+import org.eclipse.jdt.core.IMember;\n+import org.eclipse.jdt.core.IMethod;\n+import org.eclipse.jdt.core.dom.Initializer;\n+import org.eclipse.jdt.core.dom.SimpleName;\n+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n+import refactoring.crawler.RefactoringCrawler;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.FieldNode;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class FieldDetection extends RefactoringDetection {\n+\n+\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * (non-Javadoc)\n+\t *\n+\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n+\t */\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+\t}\n+\n+\t@Override\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+\n+\t\tfor (String result : results) {\n+//\t\t\t\tIMember resultNode = (IMember) result;\n+//\t\t\t\tString callingNode = null;\n+//\t\t\t\tif (resultNode instanceof IMethod) {\n+//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n+//\t\t\t\t\t\t.getParent(initializer,\n+//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+//\t\t\t\t}\n+\n+\t\t\tNode callerNode = graph.findNamedNode(result);\n+\t\t\tif (callerNode != null)\n+\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n+\t\t}\n+\n+\t}\n+\n+\tpublic void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateFieldReferenceGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateFieldReferenceGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic double analyzeIncomingEdges(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade;\n+\t\tcreateCallGraph(original, version);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t.incomingEdgesOf(version)));\n+\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn incomingEdgesGrade;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport org.eclipse.jdt.core.IMethod;\nimport org.eclipse.jdt.core.dom.Initializer;\nimport org.eclipse.jdt.core.dom.SimpleName;\nimport org.eclipse.jdt.core.dom.VariableDeclarationFragment;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.FieldNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class FieldDetection extends RefactoringDetection {\n\n\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n\t */\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n\t}\n\n\t@Override\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n\t\tfor (String result : results) {\n//\t\t\t\tIMember resultNode = (IMember) result;\n//\t\t\t\tString callingNode = null;\n//\t\t\t\tif (resultNode instanceof IMethod) {\n//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof Initializer) {\n//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n//\t\t\t\t\t\t.getParent(initializer,\n//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n//\t\t\t\t}\n\n\t\t\tNode callerNode = graph.findNamedNode(result);\n\t\t\tif (callerNode != null)\n\t\t\t\tgraph.addEdge(callerNode, originalNode,\n\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n\t\t}\n\n\t}\n\n\tpublic void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateFieldReferenceGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateFieldReferenceGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n}\n"
          },
          {
            sha: "6d0db189d5bc88a34786d8472ae246a5afd787c1",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "added",
            additions: 45,
            deletions: 0,
            patch:
              "@@ -0,0 +1,45 @@\n+package refactoring.crawler.detection.fieldDetection;\n+\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class MoveFieldDetection extends FieldDetection {\n+\n+\t/*\n+\t * We already have Class - Field edges. So we need to make sure that they\n+\t * are different parents, and also make sure that their call graph is still\n+\t * the same.\n+\t */\n+\n+\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\treturn analyzeIncomingEdges(original, version);\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedFields) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n+\t\t\t\tparentClassVersion);\n+\n+\t\t\tif (!isModRen\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n\t/*\n\t * We already have Class - Field edges. So we need to make sure that they\n\t * are different parents, and also make sure that their call graph is still\n\t * the same.\n\t */\n\n\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedFields) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n\t\t\t\tparentClassVersion);\n\n\t\t\tif (!isModRen\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n}\n"
          },
          {
            sha: "8af3d221dea4962b6009868d3896457e7d5747a8",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "renamed",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,4 +1,4 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;",
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n\t/**\n\t * @param graph\n\t * @param graph2\n\t */\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We need to go from the node to the AST and get the actual method. Then we\n\t * will call getSignature() on the IMethod to get the signature. We have to\n\t * make sure the call graphs are checked, since we do not want to detect\n\t * polymorphism as change method signature.\n\t */\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// Need to find out if in V2 there is a node with the same signature\n\t\t// as the original\n\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n\t\t\treturn 1.0;\n\t\telse {\n\t\t\t// This is when we have a method overload or deprecated. So when\n\t\t\t// we can check deprecated methods we need to add it here\n\t\t\treturn analyzeIncomingEdges(original, version);\n\t\t}\n\t}\n\n\t/**\n\t * This will handle the same name condition, explained above.\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n\t\t\t\tcontinue;\n\n\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n\t\t\tif (hasSameNameAndSignature)\n\t\t\t\tcontinue;\n\n\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n\t\t\t\t.getFullyQualifiedName()))\n\t\t\t\tprunedCandidates.add(pair);\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n\t\t// TODO here we have to take into account the RenamigsDictionary\n\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n\t\tboolean hasSameNameAndSignature = false;\n\n\t\tif (n2ParentInV1 != null) {\n\t\t\t// Calling the overloaded method\n\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n\t\t\tfor (Edge methodEdge : allMethodEdges) {\n\t\t\t\tNode targetMethod = methodEdge.getTarget();\n\t\t\t\tif (targetMethod.getSimpleName()\n\t\t\t\t\t.equals(pair[1].getSimpleName())\n\t\t\t\t\t&& targetMethod.getSignature().equals(\n\t\t\t\t\tpair[1].getSignature()))\n\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t}\n\t\t}\n\t\treturn hasSameNameAndSignature;\n\t}\n\n\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n\t\tNode source = pair[0];\n\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n\t\tboolean isDeprecated = false;\n\t\tboolean isRemoved = true;\n\t\tif (parentOfOriginalInV2 != null) {\n\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n\t\t\tfor (Edge edge : methodEdges) {\n\t\t\t\tNode methodNode = edge.getTarget();\n\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n\t\t\t\t\t&& methodNode.getSignature().equals(\n\t\t\t\t\tsource.getSignature())) {\n\t\t\t\t\tisRemoved = false;\n\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn isDeprecated || isRemoved;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tString signatureN1 = pair[0].getSignature();\n\t\t\tString signatureN2 = pair[1].getSignature();\n\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n\t\t\t\tgoodResults.add(pair);\n\t\t}\n\t\treturn goodResults;\n\t}\n\n\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n\t\t// TODO filters out (IPluginDescriptor) with\n\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n\t\t// right now this is checked only for case when there is a one argument\n\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n\t\t\tsignatureN1.length() - 1));\n\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n\t\t\tsignatureN2.length() - 1));\n\t\treturn simpleName1.equals(simpleName2);\n\t}\n\n\tprivate String extractSimpleName(String fqn) {\n\t\tint lastIndex = fqn.lastIndexOf(".");\n\t\tif (lastIndex < 0)\n\t\t\treturn fqn;\n\t\telse\n\t\t\treturn fqn.substring(lastIndex + 1);\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "625c336a140152a6da8374c3d12899e16aa92a5d",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "renamed",
            additions: 3,
            deletions: 4,
            patch:
              "@@ -1,14 +1,13 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n-import org.eclipse.core.runtime.NullProgressMonitor;\n-import org.eclipse.jdt.core.IMember;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.MethodNode;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n ",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList<String> callers;\n\t\tif (this instanceof ChangeMethodSignatureDetection)\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n\t\telse\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n\t\tfor (String s : callers) {\n\t\t\tNode callerNode = graph.findNamedNode(s);\n\t\t\tif (callerNode != null) {\n\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n\t\t\t}\n\t\t}\n\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n\n}\n"
          },
          {
            sha: "97ca243b42ca519b8d59cc5665fe7de3f91aba96",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "added",
            additions: 241,
            deletions: 0,
            patch:
              '@@ -0,0 +1,241 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.RefactoringCrawler;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+import refactoring.crawler.util.RefactoringCategory;\n+\n+import java.util.*;\n+\n+public class MoveMethodDetection extends MethodDetection {\n+\n+\tprivate Node targetClassInVerGraph;\n+\n+\tprivate Node targetClassInOrigGraph;\n+\n+\tprivate RefactoringCrawler crawler;\n+\n+\t/**\n+\t * Checks for MoveMethod\n+\t * <p>\n+\t * 1. Check that from the old method, all the references to objects having\n+\t * the same type as the destination class were removed\n+\t * <p>\n+\t * 2. Check that the new target class is either a previous argument or a\n+\t * field in the old class\n+\t */\n+\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t\tthis.crawler = crawler;\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tdouble edgeGrade = 0.0;\n+\n+\t\tdouble referenceGrade = 0.0;\n+\n+\t\tif (isTargetARenameOfSourceClass(original, version))\n+\t\t\treturn 0.0;\n+\n+\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n+\t\treferenceGrade = referencesRemoved(original, version);\n+\t\tedgeGrade = analyzeIncomingEdges(original, version);\n+\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+\t}\n+\n+\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n+\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n+\t\t// treat case 1\n+\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+\t}\n+\n+\t/**\n+\t * 1. Check that from the old method, all the references to objects having\n+\t * the same type as the destination class were removed\n+\t */\n+\tprivate double referencesRemoved(Node original, Node version) {\n+\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n+\n+\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+\t\t// treat case 2\n+\t\tif (targetClassInOrigGraph == null) {\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tEnumeration<String> keys = dictionary.keys();\n+\t\t\tfor (; keys.hasMoreElements(); ) {\n+\t\t\t\tString aKey = keys.nextElement();\n+\t\t\t\tString aValue = dictionary.get(aKey);\n+\t\t\t\tif (targetInVersion.equals(aValue)) {\n+\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// treat case 3\n+\t\t\tif (targetClassInOrigGraph == null)\n+\t\t\t\treturn 1.0;\n+\n+\t\t}\n+\n+\t\t// treat case 2 and 4\n+\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n+\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n+\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n+\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n+\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n+\t\t}\n+\n+\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n+\t\t\ttargetClassInVerGraph));\n+\t\tif (originalClassReferences.size() == 0) {\n+\t\t\tif (original.isStatic())\n+\t\t\t\treturn 1.0;\n+\t\t\tif (isTargetClassAFieldInSourceClass(original,\n+\t\t\t\ttargetClassInOrigGraph))\n+\t\t\t\treturn 1.0;\n+\t\t\tif (versionClassReferences.size() == 0)\n+\t\t\t\treturn 1.0;\n+\t\t\treturn 0.0;\n+\t\t} else\n+\t\t\treturn Math\n+\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n+\t\t\t\t\t.size()) / originalClassReferences.size()));\n+\t}\n+\n+\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+\t\tNode parentClass = graph1\n+\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n+\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+\t\tList<Node> fields = new ArrayList<Node>();\n+\t\tfor (Edge value : edges) {\n+\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tfields.add((Node) value.getTarget());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn fields.contains(theTargetClassInOrigGraph);\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\n+\t\t\t// Prune toString since the SearchEngine finds all the toString()\n+\t\t\t// methods, even those that are called from different classes\n+\t\t\tif ("toString".equals(original.getSimpleName()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Overriden here to prune false positives due to overlapping PullUp and\n+\t * PushDown detection\n+\t */\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+\t\treturn withoutFP;\n+\t}\n+\n+\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+\t\tboolean needsOneMorePass = false;\n+\t\tList<Node[]> addToPUM = new ArrayList<>();\n+\t\tList<Node[]> addToPDM = new ArrayList<>();\n+\t\tfor (Node[] pair : withoutFP) {\n+\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n+\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n+\t\t\tif (sourceClass != null && destinationClass != null) {\n+\t\t\t\tif (ClassDetection\n+\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n+\t\t\t\t\taddToPDM.add(pair);\n+\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n+\t\t\t\t\tsourceClass))\n+\t\t\t\t\taddToPUM.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+\t\tRefactoringCategory pulledUpCategory = null;\n+\t\tRefactoringCategory pushedDownCategory = null;\n+\t\t// TODO this only checks whether we already have such a category\n+\t\t// created. It might be\n+\t\t// that such a category has not been created previously (because no\n+\t\t// results were found\n+\t\t// for that category. In this case, will need to create a brand new\n+\t\t// Category object.\n+\t\tfor (RefactoringCategory category : refactoringsList) {\n+\t\t\tif (category.getName().equals("PulledUpMethods"))\n+\t\t\t\tpulledUpCategory = category;\n+\n+\t\t\telse if (category.getName().equals("PushedDownMethods"))\n+\t\t\t\tpushedDownCategory = category;\n+\t\t}\n+\n+\t\tfor (Node[] pair : addToPDM) {\n+\t\t\tif (pushedDownCategory != null)\n+\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n+\t\t\twithoutFP.remove(pair);\n+\t\t\tneedsOneMorePass = true;\n+\t\t}\n+\n+\t\tfor (Node[] pair : addToPUM) {\n+\t\t\tif (pulledUpCategory != null)\n+\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n+\t\t\twithoutFP.remove(pair);\n+\t\t\tneedsOneMorePass = true;\n+\t\t}\n+\t\tif (needsOneMorePass)\n+\t\t\treturn pruneFalsePositives(withoutFP);\n+\t\telse return withoutFP;\n+\t}\n+\n+\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n+\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\t\tfor (RefactoringCategory category : refactoringsList) {\n+\t\t\tif (category.getName().equals("PulledUpMethods")\n+\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n+\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n+\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n+\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n+\t\t\t\t\t\t// overlappings\n+\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n+\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n+\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n+\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : pairsToRemove) {\n+\t\t\tprunedList.remove(pair);\n+\t\t}\n+\t\treturn prunedList;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nimport java.util.*;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n\tprivate Node targetClassInVerGraph;\n\n\tprivate Node targetClassInOrigGraph;\n\n\tprivate RefactoringCrawler crawler;\n\n\t/**\n\t * Checks for MoveMethod\n\t * <p>\n\t * 1. Check that from the old method, all the references to objects having\n\t * the same type as the destination class were removed\n\t * <p>\n\t * 2. Check that the new target class is either a previous argument or a\n\t * field in the old class\n\t */\n\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t\tthis.crawler = crawler;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tdouble edgeGrade = 0.0;\n\n\t\tdouble referenceGrade = 0.0;\n\n\t\tif (isTargetARenameOfSourceClass(original, version))\n\t\t\treturn 0.0;\n\n\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n\t\treferenceGrade = referencesRemoved(original, version);\n\t\tedgeGrade = analyzeIncomingEdges(original, version);\n\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n\t}\n\n\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n\t\t// treat case 1\n\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n\t}\n\n\t/**\n\t * 1. Check that from the old method, all the references to objects having\n\t * the same type as the destination class were removed\n\t */\n\tprivate double referencesRemoved(Node original, Node version) {\n\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n\n\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n\t\t// treat case 2\n\t\tif (targetClassInOrigGraph == null) {\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tEnumeration<String> keys = dictionary.keys();\n\t\t\tfor (; keys.hasMoreElements(); ) {\n\t\t\t\tString aKey = keys.nextElement();\n\t\t\t\tString aValue = dictionary.get(aKey);\n\t\t\t\tif (targetInVersion.equals(aValue)) {\n\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// treat case 3\n\t\t\tif (targetClassInOrigGraph == null)\n\t\t\t\treturn 1.0;\n\n\t\t}\n\n\t\t// treat case 2 and 4\n\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n\t\t}\n\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n\t\t}\n\n\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n\t\t\ttargetClassInVerGraph));\n\t\tif (originalClassReferences.size() == 0) {\n\t\t\tif (original.isStatic())\n\t\t\t\treturn 1.0;\n\t\t\tif (isTargetClassAFieldInSourceClass(original,\n\t\t\t\ttargetClassInOrigGraph))\n\t\t\t\treturn 1.0;\n\t\t\tif (versionClassReferences.size() == 0)\n\t\t\t\treturn 1.0;\n\t\t\treturn 0.0;\n\t\t} else\n\t\t\treturn Math\n\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n\t\t\t\t\t.size()) / originalClassReferences.size()));\n\t}\n\n\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n\t\tNode parentClass = graph1\n\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n\t\tList<Node> fields = new ArrayList<Node>();\n\t\tfor (Edge value : edges) {\n\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tfields.add((Node) value.getTarget());\n\t\t\t}\n\t\t}\n\n\t\treturn fields.contains(theTargetClassInOrigGraph);\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\n\t\t\t// Prune toString since the SearchEngine finds all the toString()\n\t\t\t// methods, even those that are called from different classes\n\t\t\tif ("toString".equals(original.getSimpleName()))\n\t\t\t\tcontinue;\n\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Overriden here to prune false positives due to overlapping PullUp and\n\t * PushDown detection\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n\t\treturn withoutFP;\n\t}\n\n\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n\t\tboolean needsOneMorePass = false;\n\t\tList<Node[]> addToPUM = new ArrayList<>();\n\t\tList<Node[]> addToPDM = new ArrayList<>();\n\t\tfor (Node[] pair : withoutFP) {\n\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n\t\t\tif (sourceClass != null && destinationClass != null) {\n\t\t\t\tif (ClassDetection\n\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n\t\t\t\t\taddToPDM.add(pair);\n\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n\t\t\t\t\tsourceClass))\n\t\t\t\t\taddToPUM.add(pair);\n\t\t\t}\n\t\t}\n\n\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n\t\tRefactoringCategory pulledUpCategory = null;\n\t\tRefactoringCategory pushedDownCategory = null;\n\t\t// TODO this only checks whether we already have such a category\n\t\t// created. It might be\n\t\t// that such a category has not been created previously (because no\n\t\t// results were found\n\t\t// for that category. In this case, will need to create a brand new\n\t\t// Category object.\n\t\tfor (RefactoringCategory category : refactoringsList) {\n\t\t\tif (category.getName().equals("PulledUpMethods"))\n\t\t\t\tpulledUpCategory = category;\n\n\t\t\telse if (category.getName().equals("PushedDownMethods"))\n\t\t\t\tpushedDownCategory = category;\n\t\t}\n\n\t\tfor (Node[] pair : addToPDM) {\n\t\t\tif (pushedDownCategory != null)\n\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n\t\t\twithoutFP.remove(pair);\n\t\t\tneedsOneMorePass = true;\n\t\t}\n\n\t\tfor (Node[] pair : addToPUM) {\n\t\t\tif (pulledUpCategory != null)\n\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n\t\t\twithoutFP.remove(pair);\n\t\t\tneedsOneMorePass = true;\n\t\t}\n\t\tif (needsOneMorePass)\n\t\t\treturn pruneFalsePositives(withoutFP);\n\t\telse return withoutFP;\n\t}\n\n\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\t\tfor (RefactoringCategory category : refactoringsList) {\n\t\t\tif (category.getName().equals("PulledUpMethods")\n\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n\t\t\t\t\t\t// overlappings\n\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : pairsToRemove) {\n\t\t\tprunedList.remove(pair);\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n'
          },
          {
            sha: "e178089dc36897c0f9c159a716f4084ed0731325",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "added",
            additions: 73,
            deletions: 0,
            patch:
              '@@ -0,0 +1,73 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PullUpMethodDetection extends MethodDetection {\n+\n+\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t/**\n+\t * We should now check for the same method being in the parent class, thus\n+\t * for the two nodes, check if the version now resides in the superclass of\n+\t * the original method\'s parent class.\n+\t */\n+\t// TODO: Check why we get a null pointer exception with parentclassver and\n+\t// parent class orig)\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade = 0.0;\n+\t\tboolean isSuperclass = false;\n+\t\t// TODO: Think about possible different cases that this might be\n+\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+\t\t// find it.\n+\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n+\t\t// since clearly they are not "like" each other.\n+\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n+\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+\t\tif (parentClassOrig == null)\n+\t\t\treturn 0.0;\n+\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n+\t\t// Now we should check if parentClassOrig is a subclass of\n+\t\t// parentClassVer\n+\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n+\t\t\tisSuperclass = true;\n+\n+\t\tif (isSuperclass) {\n+\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n+\t\t\treturn incomingEdgesGrade;\n+\t\t} else\n+\t\t\treturn 0.0;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n+\t\t\tString parentClassVersion = extractParentSimpleName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We should now check for the same method being in the parent class, thus\n\t * for the two nodes, check if the version now resides in the superclass of\n\t * the original method\'s parent class.\n\t */\n\t// TODO: Check why we get a null pointer exception with parentclassver and\n\t// parent class orig)\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tdouble incomingEdgesGrade = 0.0;\n\t\tboolean isSuperclass = false;\n\t\t// TODO: Think about possible different cases that this might be\n\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n\t\t// find it.\n\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n\t\t// since clearly they are not "like" each other.\n\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n\t\tif (parentClassOrig == null)\n\t\t\treturn 0.0;\n\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n\t\t// Now we should check if parentClassOrig is a subclass of\n\t\t// parentClassVer\n\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n\t\t\tisSuperclass = true;\n\n\t\tif (isSuperclass) {\n\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n\t\t\treturn incomingEdgesGrade;\n\t\t} else\n\t\t\treturn 0.0;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n\t\t\tString parentClassVersion = extractParentSimpleName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "b294ba304e0b455f8e8b43f0d0e623d7b6dd2a76",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "added",
            additions: 59,
            deletions: 0,
            patch:
              '@@ -0,0 +1,59 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PushDownMethodDetection extends MethodDetection {\n+\n+\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tboolean superClassGrade = false;\n+\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n+\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+\t\tif (parentClassOrig == null)\n+\t\t\treturn 0.0;\n+\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n+\t\t// Now we should check if parentClassVer is a subclass of\n+\t\t// parentClassOrig\n+\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+\t\t\tSystem.out.println("stop");\n+\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n+\t\t\tsuperClassGrade = true;\n+\t\tif (superClassGrade) {\n+\t\t\treturn (analyzeIncomingEdges(original, version));\n+\t\t} else\n+\t\t\treturn 0.0;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n+\t\t\tString parentClassVersion = extractParentSimpleName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tboolean superClassGrade = false;\n\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n\t\tif (parentClassOrig == null)\n\t\t\treturn 0.0;\n\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n\t\t// Now we should check if parentClassVer is a subclass of\n\t\t// parentClassOrig\n\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n\t\t\tSystem.out.println("stop");\n\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n\t\t\tsuperClassGrade = true;\n\t\tif (superClassGrade) {\n\t\t\treturn (analyzeIncomingEdges(original, version));\n\t\t} else\n\t\t\treturn 0.0;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n\t\t\tString parentClassVersion = extractParentSimpleName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n}\n'
          },
          {
            sha: "94f098d51ee0471f28ac6927bcb59e39fdcb7761",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "renamed",
            additions: 2,
            deletions: 3,
            patch:
              "@@ -1,11 +1,10 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n import java.util.Dictionary;\n-import java.util.Iterator;\n import java.util.List;\n \n \n@@ -56,7 +55,7 @@ public boolean isRename() {\n \tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n \t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n \t\tfor (int i = 0; i < prunedList.size(); i++) {\n-\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n+\t\t\tNode[] pair = prunedList.get(i);\n \t\t\tNode target = pair[1];\n \t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n \t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\n\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n\n\t/**\n\t * @param candidates List containing clone methods\n\t * @return A List containing only the candidate methods that are in the same\n\t * class\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// createCallGraph(original, version);\n\t\t// return computeLikelinessConsideringEdges(original, version);\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prune further for cases that have n-to-1 mappings.\n\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tfor (int i = 0; i < prunedList.size(); i++) {\n\t\t\tNode[] pair = prunedList.get(i);\n\t\t\tNode target = pair[1];\n\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n\t\t\tfor (Node[] nodes : prunedList) {\n\t\t\t\tNode potentialTarget = (nodes)[1];\n\t\t\t\tif (target == potentialTarget)\n\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n\t\t\t}\n\t\t\tif (allPairsWithSameTarget.size() > 1) {\n\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n\t\t\t\t\t\t.toLowerCase().trim();\n\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n\t\t\t\t\tif ((!targetName.contains(sourceName))\n\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n"
          },
          {
            sha: "00cee96d44bda296bedd8ace9164f49a11748191",
            filename: "src/main/java/refactoring/crawler/util/ClassNode.java",
            status: "added",
            additions: 28,
            deletions: 0,
            patch:
              "@@ -0,0 +1,28 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.List;\n+import java.util.LinkedList;\n+\n+public class ClassNode extends Node {\n+\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> classesImported = new LinkedList<>();\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> superClasses = new LinkedList<>();\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic ClassNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.CLASS);\n+\t}\n+\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\nimport java.util.LinkedList;\n\npublic class ClassNode extends Node {\n\n\n\t@Getter\n\t@Setter\n\tprivate List<String> classesImported = new LinkedList<>();\n\n\t@Getter\n\t@Setter\n\tprivate List<String> superClasses = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic ClassNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.CLASS);\n\t}\n\n\n}\n"
          },
          {
            sha: "6cebaf36c9c7009584cf32c1ff857cdfb7f4813d",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "modified",
            additions: 28,
            deletions: 22,
            patch:
              '@@ -6,26 +6,32 @@\n \n public class Edge extends DefaultEdge {\n \n-    @Getter\n-    @Setter\n-    private Node.Type label;\n-\n-    public Edge(Node.Type label) {\n-        this.label = label;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-    }\n-\n-    @Override\n-    public Node getSource() {\n-        return (Node) super.getSource();\n-    }\n-\n-    @Override\n-    public Node getTarget() {\n-        return (Node) super.getTarget();\n-    }\n+\t@Getter\n+\t@Setter\n+\tprivate Node.Type label;\n+\n+\tpublic Edge(Node.Type label) {\n+\t\tthis.label = label;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+\t}\n+\n+\t@Override\n+\tpublic Node getSource() {\n+\t\treturn (Node) super.getSource();\n+\t}\n+\n+\t@Override\n+\tpublic Node getTarget() {\n+\t\treturn (Node) super.getTarget();\n+\t}\n+\n+\tpublic Node oppositeVertex(Node n) {\n+\t\tNode source = this.getSource();\n+\t\tNode target = this.getTarget();\n+\t\treturn n.equals(source) ? target : source;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n\t@Getter\n\t@Setter\n\tprivate Node.Type label;\n\n\tpublic Edge(Node.Type label) {\n\t\tthis.label = label;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n\t}\n\n\t@Override\n\tpublic Node getSource() {\n\t\treturn (Node) super.getSource();\n\t}\n\n\t@Override\n\tpublic Node getTarget() {\n\t\treturn (Node) super.getTarget();\n\t}\n\n\tpublic Node oppositeVertex(Node n) {\n\t\tNode source = this.getSource();\n\t\tNode target = this.getTarget();\n\t\treturn n.equals(source) ? target : source;\n\t}\n}\n'
          },
          {
            sha: "3edd7e34e34292cefdbea31e40877cd476a0c10b",
            filename: "src/main/java/refactoring/crawler/util/FieldNode.java",
            status: "added",
            additions: 20,
            deletions: 0,
            patch:
              "@@ -0,0 +1,20 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.List;\n+\n+public class FieldNode extends Node {\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> fieldReferenceToMethod;\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic FieldNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.FIELD);\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\npublic class FieldNode extends Node {\n\n\t@Getter\n\t@Setter\n\tprivate List<String> fieldReferenceToMethod;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic FieldNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.FIELD);\n\t}\n}\n"
          },
          {
            sha: "b88943178596cfa00a23eb9dfea16003b1d12e03",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 5,
            deletions: 0,
            patch:
              "@@ -30,4 +30,9 @@ public boolean addNamedVertex(Node v) {\n \tpublic Node findNamedNode(String name) {\n \t\treturn namedVertexMap.get(name);\n \t}\n+\n+\n+\tpublic boolean hasNamedNode(String name) {\n+\t\treturn namedVertexMap.containsKey(name);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n\n\n\tpublic boolean hasNamedNode(String name) {\n\t\treturn namedVertexMap.containsKey(name);\n\t}\n}\n"
          },
          {
            sha: "b31e4580aad57d3fb656e5bed35e174040baacd4",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -62,6 +62,10 @@ public void setCreatedCallGraph() {\n \t@Getter\n \tprivate boolean isInterface = false;\n \n+\t@Getter\n+\t@Setter\n+\tprivate boolean isStatic = false;\n+\n \t/**\n \t * @param fullyQualifiedName fullyQualifiedName\n \t * @param type               type",
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isStatic = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "6b5c0fa502f84f849ff6181575c63b6abf816148",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "added",
            additions: 37,
            deletions: 0,
            patch:
              '@@ -0,0 +1,37 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import java.util.List;\n+\n+public class RefactoringCategory {\n+\n+\t@Getter\n+\t@Setter\n+\tprivate String name;\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<Node[]> refactoringPairs;\n+\n+\tpublic Node[][] getElements() {\n+\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n+\t\tint i = 0;\n+\t\tfor (Node[] pair : refactoringPairs) {\n+\t\t\telements[i++] = pair;\n+\t\t}\n+\t\treturn elements;\n+\t}\n+\n+\tpublic String toString() {\n+\t\treturn name + printElements(getElements());\n+\t}\n+\n+\tprivate String printElements(Node[][] array) {\n+\t\tStringBuilder res = new StringBuilder();\n+\t\tfor (Node[] nodes : array) {\n+\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n+\t\t}\n+\t\treturn res.toString();\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.util.List;\n\npublic class RefactoringCategory {\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate List<Node[]> refactoringPairs;\n\n\tpublic Node[][] getElements() {\n\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n\t\tint i = 0;\n\t\tfor (Node[] pair : refactoringPairs) {\n\t\t\telements[i++] = pair;\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic String toString() {\n\t\treturn name + printElements(getElements());\n\t}\n\n\tprivate String printElements(Node[][] array) {\n\t\tStringBuilder res = new StringBuilder();\n\t\tfor (Node[] nodes : array) {\n\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n\t\t}\n\t\treturn res.toString();\n\t}\n}\n'
          },
          {
            sha: "9801e24b80c70d9b0bb8d32c20ec878e51851ca6",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 95,
            deletions: 6,
            patch:
              "@@ -2,15 +2,18 @@\n \n import lombok.Getter;\n import lombok.Setter;\n+import org.eclipse.core.runtime.IProgressMonitor;\n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n \n import java.util.*;\n \n public class ShinglesUtil {\n \n-\tprivate int w = 3;\n+\tprivate int w = 2;\n+\tprivate int sClass = 10;\n \tprivate int sMethod = 8;\n+\tprivate double classThreshold = 0.0;\n \n \t@Getter\n \t@Setter\n@@ -19,11 +22,13 @@\n \n \tprivate ShinglesStrategy shinglesStrategy;\n \n-\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\tprivate NamedDirectedMultigraph oldVersionGraph;\n \n-\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n+\tprivate NamedDirectedMultigraph newVersionGraph;\n+\n+\tprivate List<Node[]> similarMethods = new LinkedList<>();\n+\tprivate List<Node[]> similarClasses = new LinkedList<>();\n \n-\tprivate List<Node[]> similarMethods;\n \n \tprivate List<Node> oldVersionPackageList;\n \tprivate List<Node> oldVersionClassList;\n@@ -124,8 +129,6 @@ public void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMul\n \t\tthis.oldVersionGraph = oldVersionGraph;\n \t\tthis.newVersionGraph = newVersionGraph;\n \n-\t\tthis.similarMethods = new LinkedList<>();\n-\n \t\tthis.oldVersionPackageList = new ArrayList<>();\n \t\tthis.oldVersionClassList = new ArrayList<>();\n \t\tthis.oldVersionMethodList = new ArrayList<>();\n@@ -205,4 +208,90 @@ private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n \t\t}\n \t\treturn grade;\n \t}\n+\n+\n+\t/**\n+\t * @param classes\n+\t * @param graph   <br>\n+\t *                For each class nodes in classes, find the shingles by\n+\t *                concatenating shingles in methods of its subtree. The\n+\t *                parameter s_class will determine the maximum size of shingles\n+\t */\n+\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+\t\tfor (Node clasz : classes) {\n+\t\t\t// We will keep the number of methods for the class with the\n+\t\t\t// numberOfMethods variable.\n+\t\t\tint numberOfMethods = 0;\n+\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+\t\t\tint methodsTotalShingleSize = 0;\n+\t\t\tfor (Edge e : outEdges) {\n+\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n+\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n+\t\t\t\t\t// Here we update the method count.\n+\t\t\t\t\tnumberOfMethods++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n+\t\t\t// the class\n+\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+\t\t\tint index = 0;\n+\t\t\tfor (Edge e : outEdges) {\n+\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n+\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n+\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n+\t\t\t\t\t\tindex++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n+\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n+\t\t\tArrays.sort(allShinglesFromMethods);\n+\n+\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n+\t\t\t\tallShinglesFromMethods.length);\n+\n+\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n+\t\t\tif (upperBoundForClassShingles >= 0)\n+\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+\t\t\tclasz.setShingles(retVal);\n+\t\t}\n+\t}\n+\n+\n+\tpublic List<Node[]> findSimilarClasses() {\n+\t\tif (this.similarClasses.isEmpty()) {\n+\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n+\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n+\t\t\tList<Node[]> simClass = new ArrayList<>();\n+\t\t\tfor (Node c : this.oldVersionClassList) {\n+\t\t\t\tif (!c.isAPI())\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n+\t\t\t\t\tif (!c2.isAPI())\n+\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+\t\t\t\t\t\tNode[] arr = {c, c2};\n+\t\t\t\t\t\tsimClass.add(arr);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.similarClasses = simClass;\n+\t\t}\n+\t\treturn this.similarClasses;\n+\t}\n+\n+\tpublic List<Node[]> findPullUpMethodCandidates() {\n+\t\treturn findSimilarMethods();\n+\t}\n+\n+\tpublic List<Node[]> findPushDownMethodCandidates() {\n+\t\treturn findSimilarMethods();\n+\t}\n }",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 2;\n\tprivate int sClass = 10;\n\tprivate int sMethod = 8;\n\tprivate double classThreshold = 0.0;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate NamedDirectedMultigraph oldVersionGraph;\n\n\tprivate NamedDirectedMultigraph newVersionGraph;\n\n\tprivate List<Node[]> similarMethods = new LinkedList<>();\n\tprivate List<Node[]> similarClasses = new LinkedList<>();\n\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n\n\n\t/**\n\t * @param classes\n\t * @param graph   <br>\n\t *                For each class nodes in classes, find the shingles by\n\t *                concatenating shingles in methods of its subtree. The\n\t *                parameter s_class will determine the maximum size of shingles\n\t */\n\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n\t\tfor (Node clasz : classes) {\n\t\t\t// We will keep the number of methods for the class with the\n\t\t\t// numberOfMethods variable.\n\t\t\tint numberOfMethods = 0;\n\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n\t\t\tint methodsTotalShingleSize = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n\t\t\t\t\t// Here we update the method count.\n\t\t\t\t\tnumberOfMethods++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n\t\t\t// the class\n\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n\t\t\tint index = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n\t\t\tArrays.sort(allShinglesFromMethods);\n\n\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n\t\t\t\tallShinglesFromMethods.length);\n\n\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n\t\t\tif (upperBoundForClassShingles >= 0)\n\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n\t\t\tclasz.setShingles(retVal);\n\t\t}\n\t}\n\n\n\tpublic List<Node[]> findSimilarClasses() {\n\t\tif (this.similarClasses.isEmpty()) {\n\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n\t\t\tList<Node[]> simClass = new ArrayList<>();\n\t\t\tfor (Node c : this.oldVersionClassList) {\n\t\t\t\tif (!c.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n\t\t\t\t\tif (!c2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n\t\t\t\t\t\tNode[] arr = {c, c2};\n\t\t\t\t\t\tsimClass.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarClasses = simClass;\n\t\t}\n\t\treturn this.similarClasses;\n\t}\n\n\tpublic List<Node[]> findPullUpMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n\n\tpublic List<Node[]> findPushDownMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n}\n'
          },
          {
            sha: "f7a4e3eb7036c93426ffa654744d6420ca8eadbf",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 58,
            deletions: 33,
            patch:
              '@@ -1,28 +1,16 @@\n package refactoring.crawler.util;\n \n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Optional;\n+import java.util.*;\n import java.util.stream.Collectors;\n \n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.NodeList;\n-import com.github.javaparser.ast.PackageDeclaration;\n-import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n-import org.eclipse.jdt.core.Signature;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.project.*;\n-\n-import javax.annotation.Nonnull;\n \n public class SourceNavigator {\n \n@@ -59,6 +47,14 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\tthis.graph.addNamedVertex(projectNode);\n \t\tcompilationUnits.forEach(cu -> {\n \t\t\tval packageDeclaration = cu.getPackageDeclaration();\n+\t\t\tval importDeclarations = cu.getImports();\n+\n+\t\t\tval classesImported = new LinkedList<String>();\n+\n+\t\t\timportDeclarations.forEach(importDeclaration -> {\n+\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n+\t\t\t});\n+\n \t\t\tif (packageDeclaration.isPresent()) {\n \t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n \t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n@@ -70,8 +66,18 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n \t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n \t\t\t\t\t\tif (className.isPresent()) {\n-\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n+\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n \t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n+\n+\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n+\t\t\t\t\t\t\t\t.getExtendedTypes()\n+\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n+\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n+\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n \t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n \t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n \n@@ -83,40 +89,40 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n \t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n \n-\t\t\t\t\t\t\t// fields\n-\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n-\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n-\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n-\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n-\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n-\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t\t\t\t\t\t});\n-\n \t\t\t\t\t\t\t// methods\n \t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n \n+\t\t\t\t\t\t\t// filed fqn -> methods fqn\n+\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n \t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n \t\t\t\t\t\t\t\tString statementBody = "";\n \t\t\t\t\t\t\t\tval methodBody = method.getBody();\n+\n \t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n \t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n \t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n \t\t\t\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n-\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n-\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n \t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n \n+\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n+\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n+\t\t\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n+\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n+\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n+\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n+\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n+\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t});\n+\n \t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n \t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n \t\t\t\t\t\t\t\t\t\t.stream()\n@@ -133,6 +139,7 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n \t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n \t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n \t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n@@ -141,6 +148,24 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t});\n+\n+\t\t\t\t\t\t\t// fields\n+\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n+\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n+\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n+\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n+\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n+\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n+\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n+\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t\t\t\t\t\t});\n+\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t});',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tval importDeclarations = cu.getImports();\n\n\t\t\tval classesImported = new LinkedList<String>();\n\n\t\t\timportDeclarations.forEach(importDeclaration -> {\n\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n\t\t\t});\n\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\n\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n\t\t\t\t\t\t\t\t.getExtendedTypes()\n\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\t// filed fqn -> methods fqn\n\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          },
          {
            sha: "1f2ec2d8c7de952487f2f8c7cf6e125976d6ad20",
            filename: "src/test/java/refactoring/crawler/LibraryTest.java",
            status: "removed",
            additions: 0,
            deletions: 14,
            patch:
              "@@ -1,14 +0,0 @@\n-/*\n- * This Java source file was generated by the Gradle 'init' task.\n- */\n-package refactoring.crawler;\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class LibraryTest {\n-    @Test void testSomeLibraryMethod() {\n-        Library classUnderTest = new Library();\n-        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n-    }\n-}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LibraryTest {\n    @Test void testSomeLibraryMethod() {\n        Library classUnderTest = new Library();\n        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n    }\n}\n"
          },
          {
            sha: "69398cea4eb28ca2b13d692fc180459eb1e14de7",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "added",
            additions: 38,
            deletions: 0,
            patch:
              "@@ -0,0 +1,38 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Dictionary;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RefactoringCrawlerTest {\n+\n+\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+\tprivate static RefactoringCrawler refactoringCrawler;\n+\n+\t@BeforeAll\n+\tstatic void setUp() {\n+\t\tsettings = new Hashtable<>();\n+\n+\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+\n+\t\trefactoringCrawler = new RefactoringCrawler(\"TEST_PROJECT_NAME\", settings);\n+\t}\n+\n+\n+\t@Test\n+\tvoid testSomeLibraryMethod() {\n+\t}\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass RefactoringCrawlerTest {\n\n\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n\tprivate static RefactoringCrawler refactoringCrawler;\n\n\t@BeforeAll\n\tstatic void setUp() {\n\t\tsettings = new Hashtable<>();\n\n\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n\n\t\trefactoringCrawler = new RefactoringCrawler(\"TEST_PROJECT_NAME\", settings);\n\t}\n\n\n\t@Test\n\tvoid testSomeLibraryMethod() {\n\t}\n}\n"
          }
        ]
      },
      {
        sha: "c3f3ef6c45dd1b13fda0b507cc62de4301cc58de",
        message: "chore(*): change method signature done",
        stats: {
          total: 75,
          additions: 55,
          deletions: 20
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ed8cc549a4696b0c444297b28762620e0afa48cc"
          }
        ],
        committedAt: 1585140539000,
        changedFiles: [
          {
            sha: "12047025139d93dc12dde8e522729241033a06b8",
            filename:
              "src/main/java/refactoring/crawler/util/DefaultStrategy.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.util;\n+\n+/**\n+ * @author Can Comertoglu\n+ */\n+public class DefaultStrategy implements ShinglesStrategy {\n+\n+\t/**\n+\t *\n+\t */\n+\tpublic DefaultStrategy() {\n+\t\tsuper();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+\t */\n+\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\n/**\n * @author Can Comertoglu\n */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic DefaultStrategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base;\n\t}\n\n}\n"
          },
          {
            sha: "5e4173ffc4ab3d1c31902027268e6658fe26be2f",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "modified",
            additions: 19,
            deletions: 19,
            patch:
              "@@ -2,27 +2,27 @@\n \n public class FactorOf2Strategy implements ShinglesStrategy {\n \n-    /**\n-     *\n-     */\n-    public FactorOf2Strategy() {\n-        super();\n-    }\n+\t/**\n+\t *\n+\t */\n+\tpublic FactorOf2Strategy() {\n+\t\tsuper();\n+\t}\n \n-    /* (non-Javadoc)\n-     * @Override\n-     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-     */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base + (2 * loc);\n-    }\n+\t/* (non-Javadoc)\n+\t * @Override\n+\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+\t */\n+\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+\t\treturn s_base + (2 * loc);\n+\t}\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base + (2 * numMethods);\n-    }\n+\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n+\t\treturn s_base + (2 * numMethods);\n+\t}\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base + (2 * numClasses);\n-    }\n+\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n+\t\treturn s_base + (2 * numClasses);\n+\t}\n \n }",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic FactorOf2Strategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @Override\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base + (2 * loc);\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base + (2 * numMethods);\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base + (2 * numClasses);\n\t}\n\n}\n"
          },
          {
            sha: "53a045b17a633fbf52372607e489349c0d9047ca",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 2,
            deletions: 1,
            patch:
              "@@ -36,7 +36,8 @@\n \tprivate List<Node> newVersionFieldList;\n \n \tpublic ShinglesUtil() {\n-\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+\t\tthis.shinglesStrategy = new DefaultStrategy();\n+//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n \t}\n \n \tpublic List<String> tokenizer(String s) {",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "629e5440838db0a76f7127c8defbfb8eb5c0abce",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 4,
            deletions: 0,
            patch:
              '@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Optional;\n@@ -108,7 +109,10 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n \t\t\t\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n+\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n+\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n \t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "ed8cc549a4696b0c444297b28762620e0afa48cc",
        message: "chore(*): rename method done",
        stats: {
          total: 585,
          additions: 422,
          deletions: 163
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ec166d65d12437ff89774c5db554e23f66c83c5c"
          }
        ],
        committedAt: 1585139513000,
        changedFiles: [
          {
            sha: "27dbe5826813d518e4e9c1c0ab98f42303748c25",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 42,
            deletions: 23,
            patch:
              '@@ -8,7 +8,9 @@\n import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import lombok.val;\n+import org.eclipse.core.runtime.IProgressMonitor;\n import org.jgrapht.nio.dot.DOTExporter;\n+import refactoring.crawler.detection.ChangeMethodSignatureDetection;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n import refactoring.crawler.detection.SearchHelper;\n@@ -17,10 +19,7 @@\n \n import java.io.IOException;\n import java.rmi.server.ExportException;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class RefactoringCrawler {\n \n@@ -40,11 +39,11 @@ public static void main(String[] args) throws IOException {\n \t\t\t"}";\n \t\tval newSource = "package com.MyCourses.dao.impl;" +\n \t\t\t"public class A{" +\n-\t\t\t"   public void fooA(){" +\n-\t\t\t"       System.out.println(1);" +\n+\t\t\t"   public void foo(int i){" +\n+\t\t\t"       System.out.println(i);" +\n \t\t\t"   }" +\n \t\t\t"   public void bar(){" +\n-\t\t\t"       this.fooA();" +\n+\t\t\t"       this.foo(10);" +\n \t\t\t"   }" +\n \t\t\t"}";\n \n@@ -91,33 +90,53 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n+//\n+//\t\tSystem.out.println("-----original graph-----");\n+//\t\tfor (Edge e : originalGraph.edgeSet()) {\n+//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n+//\t\t}\n+//\n+//\t\tSystem.out.println("-----new version graph-----");\n+//\t\tfor (Edge e : versionGraph.edgeSet()) {\n+//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+//\t\t}\n+\n+\n+//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+//\t\tshinglesUtil.setMethodThreshold(0.5);\n+\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n+\t}\n \n-\t\tSystem.out.println("-----original graph-----");\n-\t\tfor (Edge e : originalGraph.edgeSet()) {\n-\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n-\t\t}\n-\n-\t\tSystem.out.println("-----new version graph-----");\n-\t\tfor (Edge e : versionGraph.edgeSet()) {\n-\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n+\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tChangeMethodSignature);\n+\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n+\t\tif (changedMethodSignatures.size() > 0) {\n+\t\t\tSystem.out.println("-----change method signature result-----");\n+\t\t\tSystem.out.println(changedMethodSignatures);\n+//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n+//\t\t\tchangeSignatureCategory\n+//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n+//\t\t\trefactoringList.add(changeSignatureCategory);\n \t\t}\n-\n-\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n-\n-\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n-\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n-\t\tSystem.out.println(res);\n \t}\n \n \tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n \t                                NamedDirectedMultigraph newVersionGraph) {\n \t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n \t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-//\t\tdetector.setThreshold(tMethod);\n+\t\tdetector.setThreshold(tMethod);\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {\n-\t\t\tSystem.out.println(renamedMethods);\n+\t\t\tSystem.out.println("-----result below-----");\n+\t\t\trenamedMethods.forEach(r -> {\n+\t\t\t\tSystem.out.println(r[0]);\n+\t\t\t\tSystem.out.println(r[1]);\n+\t\t\t});\n //            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n //            renameMethodCategory.setName("RenamedMethods");\n //            renameMethodCategory.setRefactoringPairs(renamedMethods);',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.val;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.ChangeMethodSignatureDetection;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.*;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   " +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(int i){" +\n\t\t\t"       System.out.println(i);" +\n\t\t\t"   }" +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo(10);" +\n\t\t\t"   }" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n//\n//\t\tSystem.out.println("-----original graph-----");\n//\t\tfor (Edge e : originalGraph.edgeSet()) {\n//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n//\t\t}\n//\n//\t\tSystem.out.println("-----new version graph-----");\n//\t\tfor (Edge e : versionGraph.edgeSet()) {\n//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n//\t\t}\n\n\n//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n//\t\tshinglesUtil.setMethodThreshold(0.5);\n\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tChangeMethodSignature);\n\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n\t\tif (changedMethodSignatures.size() > 0) {\n\t\t\tSystem.out.println("-----change method signature result-----");\n\t\t\tSystem.out.println(changedMethodSignatures);\n//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n//\t\t\tchangeSignatureCategory\n//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n//\t\t\trefactoringList.add(changeSignatureCategory);\n\t\t}\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println("-----result below-----");\n\t\t\trenamedMethods.forEach(r -> {\n\t\t\t\tSystem.out.println(r[0]);\n\t\t\t\tSystem.out.println(r[1]);\n\t\t\t});\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "34fccc1f16d30f2566aef991638bf54a7d781af7",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 132,
            deletions: 2,
            patch:
              '@@ -4,11 +4,141 @@\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n+\n+\t/**\n+\t * @param graph\n+\t * @param graph2\n+\t */\n \tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n \t\tsuper(graph, graph2);\n \t}\n+\n+\t/**\n+\t * We need to go from the node to the AST and get the actual method. Then we\n+\t * will call getSignature() on the IMethod to get the signature. We have to\n+\t * make sure the call graphs are checked, since we do not want to detect\n+\t * polymorphism as change method signature.\n+\t */\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\t// Need to find out if in V2 there is a node with the same signature\n+\t\t// as the original\n+\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n+\t\t\treturn 1.0;\n+\t\telse {\n+\t\t\t// This is when we have a method overload or deprecated. So when\n+\t\t\t// we can check deprecated methods we need to add it here\n+\t\t\treturn analyzeIncomingEdges(original, version);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This will handle the same name condition, explained above.\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+\n+\t\t\tif (hasSameNameAndSignature)\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n+\t\t\t\t.getFullyQualifiedName()))\n+\t\t\t\tprunedCandidates.add(pair);\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n+\t\t// TODO here we have to take into account the RenamigsDictionary\n+\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+\t\tboolean hasSameNameAndSignature = false;\n+\n+\t\tif (n2ParentInV1 != null) {\n+\t\t\t// Calling the overloaded method\n+\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+\t\t\tfor (Edge methodEdge : allMethodEdges) {\n+\t\t\t\tNode targetMethod = methodEdge.getTarget();\n+\t\t\t\tif (targetMethod.getSimpleName()\n+\t\t\t\t\t.equals(pair[1].getSimpleName())\n+\t\t\t\t\t&& targetMethod.getSignature().equals(\n+\t\t\t\t\tpair[1].getSignature()))\n+\t\t\t\t\thasSameNameAndSignature = true;\n+\t\t\t}\n+\t\t}\n+\t\treturn hasSameNameAndSignature;\n+\t}\n+\n+\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n+\t\tNode source = pair[0];\n+\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n+\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n+\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+\t\tboolean isDeprecated = false;\n+\t\tboolean isRemoved = true;\n+\t\tif (parentOfOriginalInV2 != null) {\n+\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+\t\t\tfor (Edge edge : methodEdges) {\n+\t\t\t\tNode methodNode = edge.getTarget();\n+\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n+\t\t\t\t\t&& methodNode.getSignature().equals(\n+\t\t\t\t\tsource.getSignature())) {\n+\t\t\t\t\tisRemoved = false;\n+\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn isDeprecated || isRemoved;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n+\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tString signatureN1 = pair[0].getSignature();\n+\t\t\tString signatureN2 = pair[1].getSignature();\n+\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n+\t\t\t\tgoodResults.add(pair);\n+\t\t}\n+\t\treturn goodResults;\n+\t}\n+\n+\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+\t\t// TODO filters out (IPluginDescriptor) with\n+\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n+\t\t// right now this is checked only for case when there is a one argument\n+\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n+\t\t\tsignatureN1.length() - 1));\n+\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n+\t\t\tsignatureN2.length() - 1));\n+\t\treturn simpleName1.equals(simpleName2);\n+\t}\n+\n+\tprivate String extractSimpleName(String fqn) {\n+\t\tint lastIndex = fqn.lastIndexOf(".");\n+\t\tif (lastIndex < 0)\n+\t\t\treturn fqn;\n+\t\telse\n+\t\t\treturn fqn.substring(lastIndex + 1);\n+\t}\n+\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n\t/**\n\t * @param graph\n\t * @param graph2\n\t */\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We need to go from the node to the AST and get the actual method. Then we\n\t * will call getSignature() on the IMethod to get the signature. We have to\n\t * make sure the call graphs are checked, since we do not want to detect\n\t * polymorphism as change method signature.\n\t */\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// Need to find out if in V2 there is a node with the same signature\n\t\t// as the original\n\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n\t\t\treturn 1.0;\n\t\telse {\n\t\t\t// This is when we have a method overload or deprecated. So when\n\t\t\t// we can check deprecated methods we need to add it here\n\t\t\treturn analyzeIncomingEdges(original, version);\n\t\t}\n\t}\n\n\t/**\n\t * This will handle the same name condition, explained above.\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n\t\t\t\tcontinue;\n\n\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n\t\t\tif (hasSameNameAndSignature)\n\t\t\t\tcontinue;\n\n\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n\t\t\t\t.getFullyQualifiedName()))\n\t\t\t\tprunedCandidates.add(pair);\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n\t\t// TODO here we have to take into account the RenamigsDictionary\n\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n\t\tboolean hasSameNameAndSignature = false;\n\n\t\tif (n2ParentInV1 != null) {\n\t\t\t// Calling the overloaded method\n\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n\t\t\tfor (Edge methodEdge : allMethodEdges) {\n\t\t\t\tNode targetMethod = methodEdge.getTarget();\n\t\t\t\tif (targetMethod.getSimpleName()\n\t\t\t\t\t.equals(pair[1].getSimpleName())\n\t\t\t\t\t&& targetMethod.getSignature().equals(\n\t\t\t\t\tpair[1].getSignature()))\n\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t}\n\t\t}\n\t\treturn hasSameNameAndSignature;\n\t}\n\n\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n\t\tNode source = pair[0];\n\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n\t\tboolean isDeprecated = false;\n\t\tboolean isRemoved = true;\n\t\tif (parentOfOriginalInV2 != null) {\n\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n\t\t\tfor (Edge edge : methodEdges) {\n\t\t\t\tNode methodNode = edge.getTarget();\n\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n\t\t\t\t\t&& methodNode.getSignature().equals(\n\t\t\t\t\tsource.getSignature())) {\n\t\t\t\t\tisRemoved = false;\n\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn isDeprecated || isRemoved;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tString signatureN1 = pair[0].getSignature();\n\t\t\tString signatureN2 = pair[1].getSignature();\n\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n\t\t\t\tgoodResults.add(pair);\n\t\t}\n\t\treturn goodResults;\n\t}\n\n\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n\t\t// TODO filters out (IPluginDescriptor) with\n\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n\t\t// right now this is checked only for case when there is a one argument\n\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n\t\t\tsignatureN1.length() - 1));\n\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n\t\t\tsignatureN2.length() - 1));\n\t\treturn simpleName1.equals(simpleName2);\n\t}\n\n\tprivate String extractSimpleName(String fqn) {\n\t\tint lastIndex = fqn.lastIndexOf(".");\n\t\tif (lastIndex < 0)\n\t\t\treturn fqn;\n\t\telse\n\t\t\treturn fqn.substring(lastIndex + 1);\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "10ce3b52ecb7246b266a6b9e8cc53f9d04108ebe",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "modified",
            additions: 23,
            deletions: 34,
            patch:
              "@@ -1,20 +1,18 @@\n package refactoring.crawler.detection;\n \n-import lombok.val;\n import org.eclipse.core.runtime.NullProgressMonitor;\n import org.eclipse.jdt.core.IMember;\n-import refactoring.crawler.project.IMethod;\n import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.MethodNode;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-\n \tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n \t\tsuper(graph, graph2);\n \t}\n@@ -26,7 +24,7 @@ public double computeLikeliness(Node node1, Node node12) {\n \t}\n \n \t@Override\n-\tpublic List pruneOriginalCandidates(List candidates) {\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n \t\t// TODO Auto-generated method stub\n \t\treturn null;\n \t}\n@@ -39,34 +37,27 @@ public boolean isRename() {\n \n \tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n \t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n \t\t\t}\n \t\t}\n \t\treturn results;\n \t}\n \n \tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tList callers;\n-//\t\tif (this instanceof ChangeMethodSignatureDetection)\n-//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n-//\t\t\t\tnew NullProgressMonitor(), true);\n-//\t\telse\n-//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n-//\t\t\t\tnew NullProgressMonitor(), false);\n-//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n-//\t\t\tIMember element = (IMember) iter.next();\n-//\t\t\tString nodeName = element.getElementName();\n-//\t\t\tString qualifiername = element.getDeclaringType()\n-//\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n-//\t\t\tif (caller != null) {\n-//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n-//\t\t\t\tgraph.addEdge(edge);\n-//\t\t\t}\n-//\t\t}\n-//\t\tnode.setCreatedCallGraph();\n+\t\tList<String> callers;\n+\t\tif (this instanceof ChangeMethodSignatureDetection)\n+\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+\t\telse\n+\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+\t\tfor (String s : callers) {\n+\t\t\tNode callerNode = graph.findNamedNode(s);\n+\t\t\tif (callerNode != null) {\n+\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+\t\t\t}\n+\t\t}\n+\t\tnode.setCreatedCallGraph();\n \n \t}\n \n@@ -84,13 +75,11 @@ protected void createCallGraph(Node original, Node version) {\n \tpublic double analyzeIncomingEdges(Node original, Node version) {\n \t\tdouble incomingEdgesGrade;\n \t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t.incomingEdgesOf(version)));\n-//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn 0;\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn incomingEdgesGrade;\n \t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList<String> callers;\n\t\tif (this instanceof ChangeMethodSignatureDetection)\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n\t\telse\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n\t\tfor (String s : callers) {\n\t\t\tNode callerNode = graph.findNamedNode(s);\n\t\t\tif (callerNode != null) {\n\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n\t\t\t}\n\t\t}\n\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n\n}\n"
          },
          {
            sha: "371a3be9c3b244c46853753f69922e2f051ecbe4",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 69,
            deletions: 0,
            patch:
              '@@ -13,6 +13,9 @@\n \n public abstract class RefactoringDetection {\n \n+\n+\t@Getter\n+\t@Setter\n \tprivate double threshold;\n \n \tprotected NamedDirectedMultigraph graph1;\n@@ -61,6 +64,11 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n \t\treturn pruneFalsePositives(listWithFP);\n \t}\n \n+\tprotected String extractPotentialRename(String parentClassOriginal) {\n+\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n+\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n+\t}\n+\n \tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n \t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n \t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n@@ -317,5 +325,66 @@ protected String extractParentSimpleName(Node original) {\n \t\treturn parentName;\n \t}\n \n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n \n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n+\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original)))\n+\t\t\treturn true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n+\t\t\tversion.substring(version.lastIndexOf("."))))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original),\n+\t\t\t\textractFullyQualifiedParentName(version));\n+\t\telse\n+\t\t\treturn false;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+\t\t\t\t.getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n+\t\t\t\t\t\t.getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.SubProgressMonitor;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic abstract class RefactoringDetection {\n\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n}\n'
          },
          {
            sha: "7fbafeccdf5e8625c8206b10f80b0d9bc6795b3d",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 72,
            deletions: 25,
            patch:
              "@@ -1,39 +1,86 @@\n package refactoring.crawler.detection;\n \n-import org.jgrapht.graph.AbstractBaseGraph;\n-import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Dictionary;\n+import java.util.Iterator;\n+import java.util.List;\n+\n \n public class RenameMethodDetection extends MethodDetection {\n \n \tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n \t\tsuper(oldVersion, newVersion);\n \t}\n \n-//\t@Override\n-//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-//\t\tfor (Node[] pair : prePrunedMethods) {\n-//\t\t\tNode original = pair[0];\n-//\t\t\tNode version = pair[1];\n-//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-//\t\t\t\t&& (!(original.getSimpleName().equals(version\n-//\t\t\t\t.getSimpleName()))))\n-//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-//\t\t}\n-//\n-//\t\treturn candidatesWithSameParentClass;\n-//\t}\n-//\n-//\t@Override\n-//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n-//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n-//\t}\n \n+\t/**\n+\t * @param candidates List containing clone methods\n+\t * @return A List containing only the candidate methods that are in the same\n+\t * class\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName()))))\n+\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentClass;\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\t// createCallGraph(original, version);\n+\t\t// return computeLikelinessConsideringEdges(original, version);\n+\t\treturn analyzeIncomingEdges(original, version);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Prune further for cases that have n-to-1 mappings.\n+\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n+\t */\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+\t\tfor (int i = 0; i < prunedList.size(); i++) {\n+\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n+\t\t\tNode target = pair[1];\n+\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n+\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+\t\t\tfor (Node[] nodes : prunedList) {\n+\t\t\t\tNode potentialTarget = (nodes)[1];\n+\t\t\t\tif (target == potentialTarget)\n+\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n+\t\t\t}\n+\t\t\tif (allPairsWithSameTarget.size() > 1) {\n+\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n+\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n+\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n+\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n+\t\t\t\t\t\t.toLowerCase().trim();\n+\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n+\t\t\t\t\tif ((!targetName.contains(sourceName))\n+\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n+\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n+\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedList;\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n\n\t/**\n\t * @param candidates List containing clone methods\n\t * @return A List containing only the candidate methods that are in the same\n\t * class\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// createCallGraph(original, version);\n\t\t// return computeLikelinessConsideringEdges(original, version);\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prune further for cases that have n-to-1 mappings.\n\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tfor (int i = 0; i < prunedList.size(); i++) {\n\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n\t\t\tNode target = pair[1];\n\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n\t\t\tfor (Node[] nodes : prunedList) {\n\t\t\t\tNode potentialTarget = (nodes)[1];\n\t\t\t\tif (target == potentialTarget)\n\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n\t\t\t}\n\t\t\tif (allPairsWithSameTarget.size() > 1) {\n\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n\t\t\t\t\t\t.toLowerCase().trim();\n\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n\t\t\t\t\tif ((!targetName.contains(sourceName))\n\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n"
          },
          {
            sha: "a4e72639da4c9e32b6cec2b81eff3a66d81090ad",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 77,
            deletions: 77,
            patch:
              '@@ -10,81 +10,81 @@\n \n public class Node {\n \n-    public boolean hasCallGraph() {\n-        return false;\n-    }\n-\n-    public void setCreatedCallGraph() {\n-    }\n-\n-    public static enum Type {\n-        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n-    }\n-\n-\n-    @Getter\n-    @Setter\n-    private String fullyQualifiedName;\n-\n-    @Setter\n-    @Getter\n-    private Node.Type type;\n-\n-    @Setter\n-    @Getter\n-    private int[] shingles;\n-\n-    @Setter\n-    @Getter\n-    private boolean hasCallGraph;\n-\n-    @Setter\n-    @Getter\n-    private String projectName;\n-\n-    @Setter\n-    @Getter\n-    private boolean isAPI = false;\n-\n-    @Setter\n-    @Getter\n-    private String signature;\n-\n-    @Setter\n-    @Getter\n-    private int flags;\n-\n-    @Setter\n-    @Getter\n-    private boolean deprecated = false;\n-\n-    @Setter\n-    @Getter\n-    private boolean isInterface = false;\n-\n-    /**\n-     * @param fullyQualifiedName fullyQualifiedName\n-     * @param type               type\n-     */\n-    public Node(String fullyQualifiedName, Node.Type type) {\n-        this.fullyQualifiedName = fullyQualifiedName;\n-        this.type = type;\n-    }\n-\n-    public String getSimpleName() {\n-        int pos = fullyQualifiedName.lastIndexOf(".");\n-        if (pos != -1) {\n-            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n-                    .length());\n-        }\n-        return fullyQualifiedName;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (getSignature() != null)\n-            return getType() + "= " + getFullyQualifiedName() + getSignature();\n-        else\n-            return getType() + "= " + getFullyQualifiedName();\n-    }\n+\tpublic boolean hasCallGraph() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic void setCreatedCallGraph() {\n+\t}\n+\n+\tpublic static enum Type {\n+\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n+\t}\n+\n+\n+\t@Getter\n+\t@Setter\n+\tprivate String fullyQualifiedName;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate Node.Type type;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate int[] shingles;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean hasCallGraph;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate String projectName;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean isAPI = false;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate String signature;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate int flags;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean deprecated = false;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean isInterface = false;\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t * @param type               type\n+\t */\n+\tpublic Node(String fullyQualifiedName, Node.Type type) {\n+\t\tthis.fullyQualifiedName = fullyQualifiedName;\n+\t\tthis.type = type;\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n+\t\tif (pos != -1) {\n+\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n+\t\t\t\t.length());\n+\t\t}\n+\t\treturn fullyQualifiedName;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tif (getSignature() != null)\n+\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n+\t\telse\n+\t\t\treturn getType() + "= " + getFullyQualifiedName();\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "b985ec3efc1794451df364522d497a5b176bcf6e",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 7,
            deletions: 2,
            patch:
              "@@ -1,5 +1,7 @@\n package refactoring.crawler.util;\n \n+import lombok.Getter;\n+import lombok.Setter;\n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n \n@@ -10,6 +12,11 @@\n \tprivate int w = 3;\n \tprivate int sMethod = 8;\n \n+\t@Getter\n+\t@Setter\n+\tprivate double methodThreshold = 0.0;\n+\n+\n \tprivate ShinglesStrategy shinglesStrategy;\n \n \tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n@@ -28,8 +35,6 @@\n \tprivate List<Node> newVersionMethodList;\n \tprivate List<Node> newVersionFieldList;\n \n-\tprivate double methodThreshold;\n-\n \tpublic ShinglesUtil() {\n \t\tthis.shinglesStrategy = new FactorOf2Strategy();\n \t}",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "ec166d65d12437ff89774c5db554e23f66c83c5c",
        message: "chore(*): store callers of method",
        stats: {
          total: 768,
          additions: 383,
          deletions: 385
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "adcac2cd85ee8ad64986e41843ebeccfe40b634e"
          }
        ],
        committedAt: 1585134032000,
        changedFiles: [
          {
            sha: "5154729799dd8700cb1a1de21582a267ddd1e304",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 34,
            deletions: 78,
            patch:
              '@@ -2,10 +2,16 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n+import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import lombok.val;\n import org.jgrapht.nio.dot.DOTExporter;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n@@ -22,83 +28,24 @@\n \n \tpublic static void main(String[] args) throws IOException {\n \t\tval crawler = new RefactoringCrawler("project name");\n-\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n-\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n-\t\t\t" * @ClassName ForumDAO\\n" +\n-\t\t\t" * @Author Lai Kin Meng\\n" +\n-\t\t\t" * @Date 2019-02-25\\n" +\n-\t\t\t" * @ProjectName MyCoursesServer\\n" +\n-\t\t\t" */\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n-\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n-\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n-\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import javax.persistence.EntityManager;\\n" +\n-\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"@Repository\\n" +\n-\t\t\t"@Transactional\\n" +\n-\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @PersistenceContext\\n" +\n-\t\t\t"    private EntityManager entityManager;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n-\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n-\t\t\t"    }\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n-\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n-\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n-\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n-\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n-\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n-\t\t\t"        entityManager.flush();\\n" +\n-\t\t\t"    }\\n" +\n+\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n+\t\t\t"public class A{" +\n+\t\t\t"   public void foo(){" +\n+\t\t\t"       System.out.println(1);" +\n+\t\t\t"   }" +\n+\t\t\t"   " +\n+\t\t\t"   public void bar(){" +\n+\t\t\t"       this.foo();" +\n+\t\t\t"   }" +\n \t\t\t"}";\n-\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n-\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n-\t\t\t" * @ClassName ForumDAO\\n" +\n-\t\t\t" * @Author Lai Kin Meng\\n" +\n-\t\t\t" * @Date 2019-02-25\\n" +\n-\t\t\t" * @ProjectName MyCoursesServer\\n" +\n-\t\t\t" */\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n-\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n-\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n-\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import javax.persistence.EntityManager;\\n" +\n-\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"@Repository\\n" +\n-\t\t\t"@Transactional\\n" +\n-\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @PersistenceContext\\n" +\n-\t\t\t"    private EntityManager entityManager;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n-\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n-\t\t\t"    }\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n-\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n-\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n-\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n-\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n-\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n-\t\t\t"        entityManager.flush();\\n" +\n-\t\t\t"    }\\n" +\n+\t\tval newSource = "package com.MyCourses.dao.impl;" +\n+\t\t\t"public class A{" +\n+\t\t\t"   public void fooA(){" +\n+\t\t\t"       System.out.println(1);" +\n+\t\t\t"   }" +\n+\t\t\t"   public void bar(){" +\n+\t\t\t"       this.fooA();" +\n+\t\t\t"   }" +\n \t\t\t"}";\n \n \t\tval oldList = new ArrayList<String>();\n@@ -116,9 +63,14 @@ public RefactoringCrawler(String projectName) {\n \t}\n \n \tprivate List<CompilationUnit> parse(List<String> files) {\n+\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n+\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n \t\tList<CompilationUnit> resList = new LinkedList<>();\n \t\tfor (String source : files) {\n-\t\t\tresList.add(StaticJavaParser.parse(source));\n+\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n+\t\t\tresList.add(cu);\n \t\t}\n \t\treturn resList;\n \t}\n@@ -150,14 +102,18 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n \t\t}\n \n+\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n+\n \t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n+\t\tSystem.out.println(res);\n \t}\n \n \tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n \t                                NamedDirectedMultigraph newVersionGraph) {\n \t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n \t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-\t\tdetector.setThreshold(tMethod);\n+//\t\tdetector.setThreshold(tMethod);\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.val;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   " +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void fooA(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.fooA();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tSystem.out.println("-----original graph-----");\n\t\tfor (Edge e : originalGraph.edgeSet()) {\n\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println("-----new version graph-----");\n\t\tfor (Edge e : versionGraph.edgeSet()) {\n\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n\t\tSystem.out.println(res);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n//\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "d1ac2fa49b6e77d50b9b70da0ddd06cf1bf6f61c",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 3,
            deletions: 19,
            patch:
              "@@ -8,23 +8,7 @@\n import java.util.Set;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n-        return null;\n-    }\n-\n-    @Override\n-    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-    }\n+\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n}\n"
          },
          {
            sha: "82174d15977e77d326ed89420328c288d576962a",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "modified",
            additions: 74,
            deletions: 49,
            patch:
              "@@ -15,57 +15,82 @@\n \n public abstract class MethodDetection extends RefactoringDetection {\n \n-    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        List callers = new ArrayList();\n-        if (this instanceof ChangeMethodSignatureDetection)\n-            callers = SearchHelper.findMethodCallers(node, true);\n-        else\n-            callers = SearchHelper.findMethodCallers(node, false);\n-        for (Object o : callers) {\n-//            IMethod element = (IMethod) o;\n-//            String nodeName = element.getElementName();\n-//            String qualifiername = element.getDeclaringType()\n-//                    .getFullyQualifiedName('.');\n-//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n-//            if (caller != null) {\n-//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n-//                graph.addEdge(edge);\n-//            }\n-        }\n-        node.setCreatedCallGraph();\n+\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n \n-    }\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n \n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n-        val results = new ArrayList<Edge>();\n-        for (final Edge edge : list) {\n-            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n-                results.add(edge);\n-            }\n-        }\n-        return results;\n-    }\n+\t@Override\n+\tpublic List pruneOriginalCandidates(List candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n \n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n-    }\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn false;\n+\t}\n+\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+\t\tList callers;\n+//\t\tif (this instanceof ChangeMethodSignatureDetection)\n+//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n+//\t\t\t\tnew NullProgressMonitor(), true);\n+//\t\telse\n+//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n+//\t\t\t\tnew NullProgressMonitor(), false);\n+//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n+//\t\t\tIMember element = (IMember) iter.next();\n+//\t\t\tString nodeName = element.getElementName();\n+//\t\t\tString qualifiername = element.getDeclaringType()\n+//\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n+//\t\t\tif (caller != null) {\n+//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n+//\t\t\t\tgraph.addEdge(edge);\n+//\t\t\t}\n+//\t\t}\n+//\t\tnode.setCreatedCallGraph();\n+\n+\t}\n+\n+\tprotected void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateCallGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateCallGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic double analyzeIncomingEdges(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade;\n+\t\tcreateCallGraph(original, version);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t.incomingEdgesOf(version)));\n+//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn 0;\n+\t}\n \n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        val incomingEdgesOriginal = filterNamedEdges(graph1\n-                .incomingEdgesOf(original));\n-        val incomingEdgesVersion = filterNamedEdges(graph2\n-                .incomingEdgesOf(version));\n-        incomingEdgesGrade = computeLikelinessIncomingEdges(\n-                incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n-    }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport lombok.val;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.project.IMethod;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List pruneOriginalCandidates(List candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList callers;\n//\t\tif (this instanceof ChangeMethodSignatureDetection)\n//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n//\t\t\t\tnew NullProgressMonitor(), true);\n//\t\telse\n//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n//\t\t\t\tnew NullProgressMonitor(), false);\n//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n//\t\t\tIMember element = (IMember) iter.next();\n//\t\t\tString nodeName = element.getElementName();\n//\t\t\tString qualifiername = element.getDeclaringType()\n//\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n//\t\t\tif (caller != null) {\n//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n//\t\t\t\tgraph.addEdge(edge);\n//\t\t\t}\n//\t\t}\n//\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t.incomingEdgesOf(version)));\n//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn 0;\n\t}\n\n}\n"
          },
          {
            sha: "e04923c393be759d113e51b42ec573aa46e4095a",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "modified",
            additions: 14,
            deletions: 5,
            patch:
              "@@ -8,9 +8,8 @@\n import java.util.Set;\n \n public class MoveMethodDetection extends RefactoringDetection {\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n+    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n     }\n \n     @Override\n@@ -19,12 +18,22 @@ public double computeLikeliness(Node node1, Node node12) {\n     }\n \n     @Override\n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n         return null;\n     }\n \n     @Override\n-    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n \n+    @Override\n+    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n     }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        return null;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "5548c74e0a9cea9b5119e9c97c6b48d51a780661",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 137,
            deletions: 186,
            patch:
              '@@ -2,30 +2,28 @@\n \n import lombok.Getter;\n import lombok.Setter;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.SubProgressMonitor;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.*;\n+import java.util.stream.Collectors;\n \n public abstract class RefactoringDetection {\n \n-\t@Getter\n-\t@Setter\n \tprivate double threshold;\n \n \tprotected NamedDirectedMultigraph graph1;\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n \n-\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\tprotected NamedDirectedMultigraph graph2;\n \n-\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\tprivate double lowerThreshold;\n \n+\t/**\n+\t * Dictionary contains <Original, Version> pairs for the renaming.\n+\t */\n \tprivate static Dictionary<String, String> renamingDictionary;\n \n \tpublic static Dictionary<String, String> getRenamingDictionary() {\n@@ -34,61 +32,57 @@\n \t\treturn renamingDictionary;\n \t}\n \n+\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tthis.graph1 = graph;\n+\t\tthis.graph2 = graph2;\n+\t}\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tpublic abstract boolean isRename();\n+\n+\t/**\n+\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n+\t * refactoring The original candidates are prunned (for getting rid of\n+\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n+\t * the end we eliminate FalsePositives. Subclasses must override\n+\t * computeLikeliness and pruneOriginalCandidates.\n+\t */\n \tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n+\n+\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n \t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n \t\treturn pruneFalsePositives(listWithFP);\n \t}\n \n-\t/**\n-\t * A default implementation that prunes all those candidates that have the\n-\t * same qualified name. Subclasses might reuse this when they implement the\n-\t * abstract pruneOriginalCanditates, or they can augment to this initial\n-\t * implementation.\n-\t *\n-\t * @param candidates\n-\t * @return\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-\t\t\t\t.getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n-\t\t\t\t\t\t.getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Node[] pair : prunedCandidates) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n \t\t\t\t}\n+\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n+\t\t\t\t// detect those cases when two\n+\t\t\t\t// types of refactorings happened to the same node\n \t\t\t}\n \t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t/**\n-\t * The client is assumed to be passing it\'s parent to this method to\n-\t * determine if they are Modulo Renames of each other.\n-\t *\n-\t * @param original\n-\t * @param version\n-\t * @return\n-\t */\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original)))\n-\t\t\treturn true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n-\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original),\n-\t\t\t\textractFullyQualifiedParentName(version));\n-\t\telse\n-\t\t\treturn false;\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n \t}\n \n \tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n@@ -99,12 +93,12 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n \t\t\tif (originalInV2 != null) {\n \t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n-\t\t\t\t\t.incomingEdgesOf(originalInV2));\n-\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n-\t\t\t\t\t.incomingEdgesOf(version));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n-\t\t\t\t\t.incomingEdgesOf(original));\n+\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n+\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t\t\t.incomingEdgesOf(version)));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t\t\t.incomingEdgesOf(original)));\n \n \n \t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n@@ -113,9 +107,7 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \n \t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n \t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n-\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\tfor (Node node : verCallers) {\n \t\t\t\t\tif (origInV2Callers.contains(node))\n \t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n \t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n@@ -126,15 +118,10 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n \t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n \t\t\t\t// should be different\n-\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n-\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\tNode node = (Node) iterator.next();\n-\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n-\t\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n+\t\t\t\tfor (Node node : origInV1Callers) {\n+\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n \t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n \t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n \t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n@@ -156,66 +143,25 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\treturn listWithFP;\n \t}\n \n-\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null)\n-\t\t\treturn false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n-\t\t\t\t\treturn false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n-\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n+\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<>();\n+\t\tfor (Edge edge : incomingEdges) {\n+\t\t\tcallers.add(edge.getSource());\n \t\t}\n-\t\treturn retval;\n+\t\treturn callers;\n \t}\n \n \t/**\n-\t * This helper method takes a string containing the dot separated name of a\n-\t * node and it returns the subtring from the beginning up to the last dot\n-\t * (e.g. for pack1.class1.method1 it returns class1)\n-\t *\n-\t * @param original\n-\t * @return\n+\t * This prunes cases like m(i) -> m\'(i)\n+\t * m(i) -> m\'(S)\n+\t * <p>\n+\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n+\t * generated because of a method overload.\n+\t * <p>\n+\t * This method is never called in the ChangeMethodSignature detection.\n \t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName\n-\t\t\t.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n \tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n+\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n \t\tfor (int i = 0; i < listWithFP.size(); i++) {\n \t\t\tboolean hasSameNameAndSignature = false;\n \t\t\tNode[] pair = listWithFP.get(i);\n@@ -232,7 +178,7 @@ private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n \t\t\t}\n \t\t\tif (hasSameNameAndSignature) {\n \t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n+\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n \t\t\t\t\tNode source2 = pair2[0];\n \t\t\t\t\tif (source.equals(source2)) {\n \t\t\t\t\t\tNode target2 = pair2[1];\n@@ -255,19 +201,24 @@ private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n \t\t}\n \t}\n \n-\n+\t/**\n+\t * This takes into account the possible renaming in the parent of the node\n+\t *\n+\t * @param g        is the Version2 graph\n+\t * @param original is a node from Version1\n+\t * @return\n+\t */\n \tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n \t\tDictionary<String, String> dictionary = getRenamingDictionary();\n \t\tString fqnParent = extractFullyQualifiedParentName(original);\n \t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n \t\tif (possiblyRenamedFQN != null)\n \t\t\tfqnParent = possiblyRenamedFQN;\n-\t\t// TODO implement find name node\n \t\tNode parentNode = g.findNamedNode(fqnParent);\n \n \t\tif (parentNode != null) {\n \t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n \t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n \t\t\t\tEdge edge = (Edge) iter.next();\n \t\t\t\tNode child = (Node) edge.getTarget();\n@@ -287,9 +238,9 @@ private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original\n \n \tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n \t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge o : list) {\n-\t\t\tif (label.equals(o.getLabel())) {\n-\t\t\t\tresults.add(o);\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (label.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n \t\t\t}\n \t\t}\n \t\treturn results;\n@@ -301,70 +252,70 @@ protected String extractFullyQualifiedParentName(Node original) {\n \t}\n \n \tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fqParentName = "";\n+\t\tString fq_parentName = "";\n \t\tint lastIndex = originalName.lastIndexOf(".");\n \t\tif (lastIndex > 0)\n-\t\t\tfqParentName = originalName.substring(0, lastIndex);\n-\t\treturn fqParentName;\n+\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n+\t\treturn fq_parentName;\n \t}\n \n-\tprivate List<Node> getCallers(List incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<Node>();\n-\t\tfor (Object incomingEdge : incomingEdges) {\n-\t\t\tEdge edge = (Edge) incomingEdge;\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n+\t/**\n+\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+\t * IDE.openEditor(IWorkbenchPage, IFile)\n+\t */\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n \n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Object prunedCandidate : prunedCandidates) {\n-\t\t\tNode[] pair = (Node[]) prunedCandidate;\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n+\t\tif (source.getSignature() == null)\n+\t\t\treturn false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n \t\t\t}\n-\t\t}\n \n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n \n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n+\t\t\t\t\treturn false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n+\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n+\t\t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn retval;\n+\t}\n \n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a\n+\t * node and it returns the substring from the beginning up to the last dot\n+\t * (e.g. for pack1.class1.method1 it returns class1)\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName\n+\t\t\t.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n \t}\n+\n+\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.SubProgressMonitor;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic abstract class RefactoringDetection {\n\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\n}\n'
          },
          {
            sha: "0e829a47dc0fc538dc5627a18def25cba6a8b1b3",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 23,
            deletions: 24,
            patch:
              "@@ -10,31 +10,30 @@\n public class RenameMethodDetection extends MethodDetection {\n \n \tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\t\tthis.graph1 = oldVersion;\n-\t\tthis.graph2 = newVersion;\n+\t\tsuper(oldVersion, newVersion);\n \t}\n \n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName()))))\n-\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n-\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n-\t}\n+//\t@Override\n+//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+//\t\tfor (Node[] pair : prePrunedMethods) {\n+//\t\t\tNode original = pair[0];\n+//\t\t\tNode version = pair[1];\n+//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+//\t\t\t\t&& (!(original.getSimpleName().equals(version\n+//\t\t\t\t.getSimpleName()))))\n+//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+//\t\t}\n+//\n+//\t\treturn candidatesWithSameParentClass;\n+//\t}\n+//\n+//\t@Override\n+//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n+//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n+//\t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n//\t@Override\n//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n//\t\tfor (Node[] pair : prePrunedMethods) {\n//\t\t\tNode original = pair[0];\n//\t\t\tNode version = pair[1];\n//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n//\t\t\t\t&& (!(original.getSimpleName().equals(version\n//\t\t\t\t.getSimpleName()))))\n//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n//\t\t}\n//\n//\t\treturn candidatesWithSameParentClass;\n//\t}\n//\n//\t@Override\n//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n//\t}\n\n}\n"
          },
          {
            sha: "c72a989a7b251464264dc101c26f212f9881e3f5",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 27,
            deletions: 5,
            patch:
              "@@ -1,13 +1,35 @@\n package refactoring.crawler.detection;\n \n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n+import lombok.Getter;\n import org.eclipse.core.runtime.IProgressMonitor;\n+import refactoring.crawler.util.MethodNode;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.Collectors;\n \n public class SearchHelper {\n-    public static List findMethodCallers(Node node, boolean withSignature) {\n-        return new LinkedList();\n-    }\n+\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+\t\treturn graph.vertexSet()\n+\t\t\t.stream()\n+\t\t\t.filter(n -> (n instanceof MethodNode))\n+\t\t\t.map(methodNode -> (MethodNode) methodNode)\n+\t\t\t.filter(methodNode ->\n+\t\t\t\tmethodNode.getCalledInside()\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.anyMatch(calledMethod -> {\n+\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n+\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n+\t\t\t\t\t\treturn expect.equals(actual);\n+\t\t\t\t\t})\n+\t\t\t)\n+\t\t\t.map(methodNode -> {\n+\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n+\t\t\t})\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SearchHelper {\n\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(methodNode ->\n\t\t\t\tmethodNode.getCalledInside()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.anyMatch(calledMethod -> {\n\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.map(methodNode -> {\n\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n\n}\n"
          },
          {
            sha: "5e95b415b9c2ed14017572d7f3eb2cb290726203",
            filename: "src/main/java/refactoring/crawler/util/MethodNode.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.util;\n+\n+import jdk.nashorn.internal.codegen.CompilerConstants;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class MethodNode extends Node {\n+\n+\t@AllArgsConstructor\n+\tpublic static class CalledMethod {\n+\t\t@Getter\n+\t\t@Setter\n+\t\tprivate String fullyQualifiedNameWithoutSignature;\n+\n+\t\t@Getter\n+\t\t@Setter\n+\t\tprivate String fullyQualifiedNameWithSignature;\n+\t}\n+\n+\t@Setter\n+\t@Getter\n+\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic MethodNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.METHOD);\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport jdk.nashorn.internal.codegen.CompilerConstants;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MethodNode extends Node {\n\n\t@AllArgsConstructor\n\tpublic static class CalledMethod {\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithoutSignature;\n\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithSignature;\n\t}\n\n\t@Setter\n\t@Getter\n\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic MethodNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.METHOD);\n\t}\n}\n"
          },
          {
            sha: "fc33acfda6432cefce9e013f18b7ff34937e9ce3",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 18,
            deletions: 16,
            patch:
              "@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import lombok.Getter;\n import org.jgrapht.graph.DirectedMultigraph;\n \n import java.util.HashMap;\n@@ -8,24 +9,25 @@\n \n public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n \n-    private Map<String, Node> namedVertexMap = new HashMap<>();\n+\t@Getter\n+\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n \n-    public NamedDirectedMultigraph() {\n-        super(Edge.class);\n-    }\n+\tpublic NamedDirectedMultigraph() {\n+\t\tsuper(Edge.class);\n+\t}\n \n-    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-        super(vertexSupplier, edgeSupplier, weighted);\n-    }\n+\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n+\t}\n \n-    public boolean addNamedVertex(Node v) {\n-        if (!addVertex(v))\n-            return false;\n-        namedVertexMap.put(v.getFullyQualifiedName(), v);\n-        return true;\n-    }\n+\tpublic boolean addNamedVertex(Node v) {\n+\t\tif (!addVertex(v))\n+\t\t\treturn false;\n+\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n+\t\treturn true;\n+\t}\n \n-    public Node findNamedNode(String name) {\n-        return namedVertexMap.get(name);\n-    }\n+\tpublic Node findNamedNode(String name) {\n+\t\treturn namedVertexMap.get(name);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n}\n"
          },
          {
            sha: "da3fd43afd25a44efeafdbb93ce382240d81e7a1",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -5,6 +5,8 @@\n import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n \n+import java.awt.*;\n+\n \n public class Node {\n ",
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {\n    }\n\n    public static enum Type {\n        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n    }\n\n\n    @Getter\n    @Setter\n    private String fullyQualifiedName;\n\n    @Setter\n    @Getter\n    private Node.Type type;\n\n    @Setter\n    @Getter\n    private int[] shingles;\n\n    @Setter\n    @Getter\n    private boolean hasCallGraph;\n\n    @Setter\n    @Getter\n    private String projectName;\n\n    @Setter\n    @Getter\n    private boolean isAPI = false;\n\n    @Setter\n    @Getter\n    private String signature;\n\n    @Setter\n    @Getter\n    private int flags;\n\n    @Setter\n    @Getter\n    private boolean deprecated = false;\n\n    @Setter\n    @Getter\n    private boolean isInterface = false;\n\n    /**\n     * @param fullyQualifiedName fullyQualifiedName\n     * @param type               type\n     */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n                    .length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType() + "= " + getFullyQualifiedName() + getSignature();\n        else\n            return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "5e122b87f0633073d0de210bc2c673d604778977",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 0,
            deletions: 2,
            patch:
              '@@ -134,8 +134,6 @@ public void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMul\n \t\t\toldVersionPackageList, oldVersionFieldList);\n \n \t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-\n-\t\tSystem.out.println("fuck you");\n \t}\n \n \tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,',
            rawContent:
              'package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tprivate double methodThreshold;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "e0c160b5a0ee4d70a58b822b2d2e803ee9f4cea2",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 16,
            deletions: 1,
            patch:
              '@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n@@ -10,10 +11,14 @@\n import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n import org.eclipse.jdt.core.Signature;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.project.*;\n \n import javax.annotation.Nonnull;\n@@ -68,6 +73,7 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n \t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n \t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n \t\t\t\t\t\t\tthis.allClassCounter += 1;\n \t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n \t\t\t\t\t\t\t\tclassNode.setAPI(true);\n@@ -105,7 +111,16 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n-\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n+\n+\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n+\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n+\t\t\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n+\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n+\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n \n \t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n \t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "adcac2cd85ee8ad64986e41843ebeccfe40b634e",
        message: "chore(deps): add symbol solver core pck",
        stats: {
          total: 2,
          additions: 2,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3fcec084a313374eebbba80657d7a8352cc955c5"
          }
        ],
        committedAt: 1585133997000,
        changedFiles: [
          {
            sha: "f5b97179043b72ae904d32cde7dc67b9f0feff46",
            filename: "build.gradle",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -28,6 +28,8 @@ dependencies {\n \n     compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n \n+    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n+\n     compileOnly 'org.projectlombok:lombok:1.18.12'\n     annotationProcessor 'org.projectlombok:lombok:1.18.12'\n ",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          }
        ]
      },
      {
        sha: "3fcec084a313374eebbba80657d7a8352cc955c5",
        message: "chore(*): source navigator done",
        stats: {
          total: 2064,
          additions: 1408,
          deletions: 656
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "c82267764fe895754822d57203483cc54cd44f7d"
          }
        ],
        committedAt: 1585110635000,
        changedFiles: [
          {
            sha: "ea419d85c301b292fbadf5b1f4da2c8350a1c0f1",
            filename: ".gitignore",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,6 +1,6 @@\n .gradle\n /build/\n-\n+/.idea/\n # Ignore Gradle GUI config\n gradle-app.setting\n ",
            rawContent:
              ".gradle\n/build/\n/.idea/\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n"
          },
          {
            sha: "9f56d869b444336267c0bd57e2f567208acd7aad",
            filename: "build.gradle",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -26,6 +26,8 @@ dependencies {\n \n     implementation 'com.github.javaparser:javaparser-core:3.15.14'\n \n+    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n+\n     compileOnly 'org.projectlombok:lombok:1.18.12'\n     annotationProcessor 'org.projectlombok:lombok:1.18.12'\n ",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "b7cc792f483cfd5c41dde7c729179f7b78a21de3",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 90,
            deletions: 34,
            patch:
              '@@ -2,12 +2,16 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import lombok.val;\n+import org.jgrapht.nio.dot.DOTExporter;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n import java.io.IOException;\n+import java.rmi.server.ExportException;\n+import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n@@ -17,50 +21,93 @@\n \tprivate String projectName;\n \n \tpublic static void main(String[] args) throws IOException {\n-\t\t// creates an input stream for the file to be parsed\n-\t\tString source = "import detections.Detection;\\n" +\n-\t\t\t"import detections.DetectionFactory;\\n" +\n-\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n-\t\t\t"import utils.*;\\n" +\n+\t\tval crawler = new RefactoringCrawler("project name");\n+\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n+\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n+\t\t\t" * @ClassName ForumDAO\\n" +\n+\t\t\t" * @Author Lai Kin Meng\\n" +\n+\t\t\t" * @Date 2019-02-25\\n" +\n+\t\t\t" * @ProjectName MyCoursesServer\\n" +\n+\t\t\t" */\\n" +\n \t\t\t"\\n" +\n-\t\t\t"import java.util.List;\\n" +\n+\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n+\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n+\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n+\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n+\t\t\t"import javax.persistence.EntityManager;\\n" +\n+\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"public class RefactoringCrawler {\\n" +\n-\t\t\t"    public static void main(String[] args) {\\n" +\n-\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n-\t\t\t"//        parser.setSource();\\n" +\n+\t\t\t"@Repository\\n" +\n+\t\t\t"@Transactional\\n" +\n+\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @PersistenceContext\\n" +\n+\t\t\t"    private EntityManager entityManager;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n+\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n \t\t\t"    }\\n" +\n \t\t\t"\\n" +\n-\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n+\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n+\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n+\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n+\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n+\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n+\t\t\t"        entityManager.flush();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"}";\n+\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n+\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n+\t\t\t" * @ClassName ForumDAO\\n" +\n+\t\t\t" * @Author Lai Kin Meng\\n" +\n+\t\t\t" * @Date 2019-02-25\\n" +\n+\t\t\t" * @ProjectName MyCoursesServer\\n" +\n+\t\t\t" */\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n-\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n+\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n+\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n+\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n+\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n-\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n+\t\t\t"import javax.persistence.EntityManager;\\n" +\n+\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n+\t\t\t"@Repository\\n" +\n+\t\t\t"@Transactional\\n" +\n+\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n+\t\t\t"    @PersistenceContext\\n" +\n+\t\t\t"    private EntityManager entityManager;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n+\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n+\t\t\t"    }\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n-\t\t\t"            for (Pair pair : pairs) {\\n" +\n-\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n-\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n-\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n-\t\t\t"                    }\\n" +\n-\t\t\t"                }\\n" +\n-\t\t\t"            }\\n" +\n-\t\t\t"        }\\n" +\n-\t\t\t"        return rlog.getResult();\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n+\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n+\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n+\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n+\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n+\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n+\t\t\t"        entityManager.flush();\\n" +\n \t\t\t"    }\\n" +\n-\t\t\t"}\\n";\n-\t\tCompilationUnit cu;\n-\t\t// parse the file\n-\t\tcu = StaticJavaParser.parse(source);\n+\t\t\t"}";\n \n+\t\tval oldList = new ArrayList<String>();\n+\t\tval newList = new ArrayList<String>();\n+\n+\t\toldList.add(oldSource);\n+\t\tnewList.add(newSource);\n+\n+\t\tcrawler.detect(oldList, newList);\n \n \t}\n \n@@ -88,12 +135,21 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \n \t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n \t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n-\t\tnavigatorForVersion.browseProject(newVersion);\n+\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n-\n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n \n+\t\tSystem.out.println("-----original graph-----");\n+\t\tfor (Edge e : originalGraph.edgeSet()) {\n+\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n+\t\t}\n+\n+\t\tSystem.out.println("-----new version graph-----");\n+\t\tfor (Edge e : versionGraph.edgeSet()) {\n+\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+\t\t}\n+\n \t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n \t}\n ',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport lombok.val;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n\t\t\t" * @ClassName ForumDAO\\n" +\n\t\t\t" * @Author Lai Kin Meng\\n" +\n\t\t\t" * @Date 2019-02-25\\n" +\n\t\t\t" * @ProjectName MyCoursesServer\\n" +\n\t\t\t" */\\n" +\n\t\t\t"\\n" +\n\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import javax.persistence.EntityManager;\\n" +\n\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n\t\t\t"\\n" +\n\t\t\t"@Repository\\n" +\n\t\t\t"@Transactional\\n" +\n\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @PersistenceContext\\n" +\n\t\t\t"    private EntityManager entityManager;\\n" +\n\t\t\t"\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n\t\t\t"        entityManager.flush();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n\t\t\t" * @ClassName ForumDAO\\n" +\n\t\t\t" * @Author Lai Kin Meng\\n" +\n\t\t\t" * @Date 2019-02-25\\n" +\n\t\t\t" * @ProjectName MyCoursesServer\\n" +\n\t\t\t" */\\n" +\n\t\t\t"\\n" +\n\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import javax.persistence.EntityManager;\\n" +\n\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n\t\t\t"\\n" +\n\t\t\t"@Repository\\n" +\n\t\t\t"@Transactional\\n" +\n\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @PersistenceContext\\n" +\n\t\t\t"    private EntityManager entityManager;\\n" +\n\t\t\t"\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n\t\t\t"        entityManager.flush();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tresList.add(StaticJavaParser.parse(source));\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tSystem.out.println("-----original graph-----");\n\t\tfor (Edge e : originalGraph.edgeSet()) {\n\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println("-----new version graph-----");\n\t\tfor (Edge e : versionGraph.edgeSet()) {\n\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "40c414cbaec6302b68b1062229cecdcd8b438ed8",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 357,
            deletions: 357,
            patch:
              '@@ -10,361 +10,361 @@\n \n public abstract class RefactoringDetection {\n \n-    @Getter\n-    @Setter\n-    private double threshold;\n-\n-    protected NamedDirectedMultigraph graph1;\n-    protected NamedDirectedMultigraph graph2;\n-\n-\n-    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-    public abstract double computeLikeliness(Node node1, Node node12);\n-\n-    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n-\n-    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-    private static Dictionary<String, String> renamingDictionary;\n-\n-    public static Dictionary<String, String> getRenamingDictionary() {\n-        if (renamingDictionary == null)\n-            renamingDictionary = new Hashtable<>();\n-        return renamingDictionary;\n-    }\n-\n-    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-        List<Node[]> refactoredNodes = new ArrayList<>();\n-        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-        return pruneFalsePositives(listWithFP);\n-    }\n-\n-    /**\n-     * A default implementation that prunes all those candidates that have the\n-     * same qualified name. Subclasses might reuse this when they implement the\n-     * abstract pruneOriginalCanditates, or they can augment to this initial\n-     * implementation.\n-     *\n-     * @param candidates\n-     * @return\n-     */\n-    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-                    .getFullyQualifiedName()))) {\n-\n-                if (pair[0].isAPI() && pair[1].isAPI()) {\n-                    Node n2inV1 = graph1.findNamedNode(pair[1]\n-                            .getFullyQualifiedName());\n-\n-                    if ((n2inV1 == null)) {\n-                        prunedCandidates.add(pair);\n-                    }\n-                }\n-            }\n-        }\n-        return prunedCandidates;\n-    }\n-\n-    /**\n-     * The client is assumed to be passing it\'s parent to this method to\n-     * determine if they are Modulo Renames of each other.\n-     *\n-     * @param original\n-     * @param version\n-     * @return\n-     */\n-    protected boolean isTheSameModuloRename(String original, String version) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        if (version.equals(dictionary.get(original)))\n-            return true;\n-        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-            return original.equals(version);\n-        else if (original.substring(original.lastIndexOf(".")).equals(\n-                version.substring(version.lastIndexOf("."), version.length())))\n-            return isTheSameModuloRename(\n-                    extractFullyQualifiedParentName(original),\n-                    extractFullyQualifiedParentName(version));\n-        else\n-            return false;\n-    }\n-\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-        for (Node[] pair : listWithFP) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-            if (originalInV2 != null) {\n-                createCallGraph(originalInV2, graph2);\n-                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n-                        .incomingEdgesOf(originalInV2));\n-                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n-                        .incomingEdgesOf(version));\n-                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n-                        .incomingEdgesOf(original));\n-\n-\n-                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-                List<Node> verCallers = getCallers(verIncomingEdges);\n-                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-                // since a call site cannot be calling both the old and the new entity at the same time\n-                for (Iterator iterator = verCallers.iterator(); iterator\n-                        .hasNext(); ) {\n-                    Node node = (Node) iterator.next();\n-                    if (origInV2Callers.contains(node))\n-                        if (!nodesToRemove.contains(pair)) {\n-                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-                            nodesToRemove.add(pair);\n-                        }\n-                }\n-\n-                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n-                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n-                // should be different\n-                for (Iterator iterator = origInV1Callers.iterator(); iterator\n-                        .hasNext(); ) {\n-                    Node node = (Node) iterator.next();\n-                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n-                            .hasNext(); ) {\n-                        Node callingNode = (Node) iterator1.next();\n-                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-                            if (!nodesToRemove.contains(pair)) {\n-                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n-                                nodesToRemove.add(pair);\n-                            }\n-                            break;\n-                        }\n-                    }\n-\n-                }\n-\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            listWithFP.remove(pair);\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-\n-        pruneOverloadedMethodFP(listWithFP);\n-\n-        return listWithFP;\n-    }\n-\n-\n-    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-        boolean retval = false;\n-\n-        if (source.getSignature() == null)\n-            return false;\n-\n-        retval = source.getSignature().equals(target.getSignature());\n-\n-        if (!retval && (this instanceof MoveMethodDetection)) {\n-            String sourceParent = extractParentSimpleName(source);\n-            StringTokenizer sourceTokenizer = new StringTokenizer(source\n-                    .getSignature(), "( , )");\n-            StringTokenizer targetTokenizer = new StringTokenizer(target\n-                    .getSignature(), "( , )");\n-            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-            String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-            for (int i = 0; i < sourceTokens.length; i++) {\n-                sourceTokens[i] = sourceTokenizer.nextToken();\n-            }\n-\n-            for (int i = 0; i < targetTokens.length; i++) {\n-                targetTokens[i] = targetTokenizer.nextToken();\n-            }\n-\n-            if (targetTokens.length == sourceTokens.length + 1) {\n-                if (!targetTokens[0].trim().equals(sourceParent))\n-                    return false;\n-                else {\n-                    for (int i = 0; i < sourceTokens.length; i++) {\n-                        if (!sourceTokens[i].trim().equals(\n-                                targetTokens[i + 1].trim()))\n-                            return false;\n-                    }\n-                    retval = true;\n-                }\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    /**\n-     * This helper method takes a string containing the dot separated name of a\n-     * node and it returns the subtring from the beginning up to the last dot\n-     * (e.g. for pack1.class1.method1 it returns class1)\n-     *\n-     * @param original\n-     * @return\n-     */\n-    protected String extractParentSimpleName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        String parentName = originalName.substring(0, originalName\n-                .lastIndexOf("."));\n-        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-        return parentName;\n-    }\n-\n-    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new LinkedList<>();\n-        for (int i = 0; i < listWithFP.size(); i++) {\n-            boolean hasSameNameAndSignature = false;\n-            Node[] pair = listWithFP.get(i);\n-            Node source = pair[0];\n-            for (int j = i; j < listWithFP.size(); j++) {\n-                Node[] pair2 = listWithFP.get(j);\n-                Node source2 = pair2[0];\n-                if (source.equals(source2)) {\n-                    Node target2 = pair2[1];\n-                    if (source.getSimpleName().equals(target2.getSimpleName()))\n-                        if (signatureEqualsModuloMoveMethod(source, target2))\n-                            hasSameNameAndSignature = true;\n-                }\n-            }\n-            if (hasSameNameAndSignature) {\n-                for (int j = i; j < listWithFP.size(); j++) {\n-                    Node[] pair2 = (Node[]) listWithFP.get(j);\n-                    Node source2 = pair2[0];\n-                    if (source.equals(source2)) {\n-                        Node target2 = pair2[1];\n-                        if (source.getSimpleName().equals(\n-                                target2.getSimpleName()))\n-                            if (!signatureEqualsModuloMoveMethod(source, target2))\n-                                if (!nodesToRemove.contains(pair2))\n-                                    nodesToRemove.add(pair2);\n-                    }\n-                }\n-            }\n-\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-            listWithFP.remove(pair);\n-\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-    }\n-\n-\n-    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        String fqnParent = extractFullyQualifiedParentName(original);\n-        String possiblyRenamedFQN = dictionary.get(fqnParent);\n-        if (possiblyRenamedFQN != null)\n-            fqnParent = possiblyRenamedFQN;\n-        // TODO implement find name node\n-        Node parentNode = g.findNamedNode(fqnParent);\n-\n-        if (parentNode != null) {\n-            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n-            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-                Edge edge = (Edge) iter.next();\n-                Node child = (Node) edge.getTarget();\n-                if (original.getSimpleName().equals(child.getSimpleName()))\n-                    if (original.getSignature() != null) {\n-                        // This handles the method nodes\n-                        if (original.getSignature()\n-                                .equals(child.getSignature()))\n-                            return child;\n-                    } else\n-                        // Classes and packages\n-                        return child;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge o : list) {\n-            if (label.equals(o.getLabel())) {\n-                results.add(o);\n-            }\n-        }\n-        return results;\n-    }\n-\n-    protected String extractFullyQualifiedParentName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        return extractFullyQualifiedParentName(originalName);\n-    }\n-\n-    public String extractFullyQualifiedParentName(String originalName) {\n-        String fqParentName = "";\n-        int lastIndex = originalName.lastIndexOf(".");\n-        if (lastIndex > 0)\n-            fqParentName = originalName.substring(0, lastIndex);\n-        return fqParentName;\n-    }\n-\n-    private List<Node> getCallers(List incomingEdges) {\n-        List<Node> callers = new ArrayList<Node>();\n-        for (Object incomingEdge : incomingEdges) {\n-            Edge edge = (Edge) incomingEdge;\n-            callers.add(edge.getSource());\n-        }\n-        return callers;\n-    }\n-\n-    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-        boolean foundNewRefactoring = false;\n-        for (Object prunedCandidate : prunedCandidates) {\n-            Node[] pair = (Node[]) prunedCandidate;\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            double likeliness = computeLikeliness(original, version);\n-            if (likeliness >= threshold) {\n-                if (!refactoredNodes.contains(pair)) {\n-                    refactoredNodes.add(pair);\n-                    foundNewRefactoring = true;\n-                }\n-            }\n-        }\n-\n-        if (foundNewRefactoring) {\n-            doDetectRefactorings(candidates, refactoredNodes);\n-        }\n-        return refactoredNodes;\n-    }\n-\n-    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-        double count = 0;\n-\n-        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n-\n-        for (Edge edge1 : edges1) {\n-            Node node1 = edge1.getSource();\n-            for (int i = 0; i < arrEdge2.length; i++) {\n-                Edge edge2 = arrEdge2[i];\n-                if (edge2 != null) {\n-                    Node node2 = (Node) edge2.getSource();\n-                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-                            node2.getFullyQualifiedName())) {\n-                        count++;\n-                        // we mark this edge as already counted so that we don\'t\n-                        // count it\n-                        // twice when there are multiple edges between two nodes\n-                        arrEdge2[i] = null;\n-                    }\n-                }\n-            }\n-        }\n-\n-        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-        return (fraction1 + fraction2) / 2.0;\n-    }\n+\t@Getter\n+\t@Setter\n+\tprivate double threshold;\n+\n+\tprotected NamedDirectedMultigraph graph1;\n+\tprotected NamedDirectedMultigraph graph2;\n+\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\n+\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tprivate static Dictionary<String, String> renamingDictionary;\n+\n+\tpublic static Dictionary<String, String> getRenamingDictionary() {\n+\t\tif (renamingDictionary == null)\n+\t\t\trenamingDictionary = new Hashtable<>();\n+\t\treturn renamingDictionary;\n+\t}\n+\n+\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n+\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+\t\treturn pruneFalsePositives(listWithFP);\n+\t}\n+\n+\t/**\n+\t * A default implementation that prunes all those candidates that have the\n+\t * same qualified name. Subclasses might reuse this when they implement the\n+\t * abstract pruneOriginalCanditates, or they can augment to this initial\n+\t * implementation.\n+\t *\n+\t * @param candidates\n+\t * @return\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+\t\t\t\t.getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n+\t\t\t\t\t\t.getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\t/**\n+\t * The client is assumed to be passing it\'s parent to this method to\n+\t * determine if they are Modulo Renames of each other.\n+\t *\n+\t * @param original\n+\t * @param version\n+\t * @return\n+\t */\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original)))\n+\t\t\treturn true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n+\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original),\n+\t\t\t\textractFullyQualifiedParentName(version));\n+\t\telse\n+\t\t\treturn false;\n+\t}\n+\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n+\t\t\tif (originalInV2 != null) {\n+\t\t\t\tcreateCallGraph(originalInV2, graph2);\n+\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n+\t\t\t\t\t.incomingEdgesOf(originalInV2));\n+\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n+\t\t\t\t\t.incomingEdgesOf(version));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n+\t\t\t\t\t.incomingEdgesOf(original));\n+\n+\n+\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n+\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n+\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n+\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n+\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n+\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\t\tif (origInV2Callers.contains(node))\n+\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n+\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n+\t\t\t\t// should be different\n+\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n+\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n+\t\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n+\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tlistWithFP.remove(pair);\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\n+\t\tpruneOverloadedMethodFP(listWithFP);\n+\n+\t\treturn listWithFP;\n+\t}\n+\n+\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n+\n+\t\tif (source.getSignature() == null)\n+\t\t\treturn false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n+\t\t\t\t\treturn false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n+\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a\n+\t * node and it returns the subtring from the beginning up to the last dot\n+\t * (e.g. for pack1.class1.method1 it returns class1)\n+\t *\n+\t * @param original\n+\t * @return\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName\n+\t\t\t.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n+\t}\n+\n+\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n+\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n+\t\t\tboolean hasSameNameAndSignature = false;\n+\t\t\tNode[] pair = listWithFP.get(i);\n+\t\t\tNode source = pair[0];\n+\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\thasSameNameAndSignature = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (hasSameNameAndSignature) {\n+\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n+\t\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\t\tif (source.getSimpleName().equals(\n+\t\t\t\t\t\t\ttarget2.getSimpleName()))\n+\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n+\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+\t\t\tlistWithFP.remove(pair);\n+\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\t}\n+\n+\n+\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tString fqnParent = extractFullyQualifiedParentName(original);\n+\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n+\t\tif (possiblyRenamedFQN != null)\n+\t\t\tfqnParent = possiblyRenamedFQN;\n+\t\t// TODO implement find name node\n+\t\tNode parentNode = g.findNamedNode(fqnParent);\n+\n+\t\tif (parentNode != null) {\n+\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+\t\t\t\tEdge edge = (Edge) iter.next();\n+\t\t\t\tNode child = (Node) edge.getTarget();\n+\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n+\t\t\t\t\tif (original.getSignature() != null) {\n+\t\t\t\t\t\t// This handles the method nodes\n+\t\t\t\t\t\tif (original.getSignature()\n+\t\t\t\t\t\t\t.equals(child.getSignature()))\n+\t\t\t\t\t\t\treturn child;\n+\t\t\t\t\t} else\n+\t\t\t\t\t\t// Classes and packages\n+\t\t\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge o : list) {\n+\t\t\tif (label.equals(o.getLabel())) {\n+\t\t\t\tresults.add(o);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tprotected String extractFullyQualifiedParentName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\treturn extractFullyQualifiedParentName(originalName);\n+\t}\n+\n+\tpublic String extractFullyQualifiedParentName(String originalName) {\n+\t\tString fqParentName = "";\n+\t\tint lastIndex = originalName.lastIndexOf(".");\n+\t\tif (lastIndex > 0)\n+\t\t\tfqParentName = originalName.substring(0, lastIndex);\n+\t\treturn fqParentName;\n+\t}\n+\n+\tprivate List<Node> getCallers(List incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<Node>();\n+\t\tfor (Object incomingEdge : incomingEdges) {\n+\t\t\tEdge edge = (Edge) incomingEdge;\n+\t\t\tcallers.add(edge.getSource());\n+\t\t}\n+\t\treturn callers;\n+\t}\n+\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Object prunedCandidate : prunedCandidates) {\n+\t\t\tNode[] pair = (Node[]) prunedCandidate;\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n+\t}\n+\n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\tprotected NamedDirectedMultigraph graph2;\n\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n\n\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\t/**\n\t * A default implementation that prunes all those candidates that have the\n\t * same qualified name. Subclasses might reuse this when they implement the\n\t * abstract pruneOriginalCanditates, or they can augment to this initial\n\t * implementation.\n\t *\n\t * @param candidates\n\t * @return\n\t */\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t/**\n\t * The client is assumed to be passing it\'s parent to this method to\n\t * determine if they are Modulo Renames of each other.\n\t *\n\t * @param original\n\t * @param version\n\t * @return\n\t */\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n\t\t\t\t\t.incomingEdgesOf(version));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n\t\t\t\t\t.incomingEdgesOf(original));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\tNode node = (Node) iterator.next();\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\tNode node = (Node) iterator.next();\n\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n\t\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the subtring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t *\n\t * @param original\n\t * @return\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\t// TODO implement find name node\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge o : list) {\n\t\t\tif (label.equals(o.getLabel())) {\n\t\t\t\tresults.add(o);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fqParentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfqParentName = originalName.substring(0, lastIndex);\n\t\treturn fqParentName;\n\t}\n\n\tprivate List<Node> getCallers(List incomingEdges) {\n\t\tList<Node> callers = new ArrayList<Node>();\n\t\tfor (Object incomingEdge : incomingEdges) {\n\t\t\tEdge edge = (Edge) incomingEdge;\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Object prunedCandidate : prunedCandidates) {\n\t\t\tNode[] pair = (Node[]) prunedCandidate;\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n}\n'
          },
          {
            sha: "ad23be0bb72541bba39990d23583c5bc90ee1d66",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 27,
            deletions: 26,
            patch:
              "@@ -9,31 +9,32 @@\n \n public class RenameMethodDetection extends MethodDetection {\n \n-    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\n-    }\n-\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && (!(original.getSimpleName().equals(version\n-                    .getSimpleName()))))\n-                candidatesWithSameParentClass.add(pair);\n-        }\n-\n-        return candidatesWithSameParentClass;\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node oldVersion, Node newVersion) {\n-        return super.analyzeIncomingEdges(oldVersion, newVersion);\n-    }\n+\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+\t\tthis.graph1 = oldVersion;\n+\t\tthis.graph2 = newVersion;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName()))))\n+\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n+\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n+\t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tthis.graph1 = oldVersion;\n\t\tthis.graph2 = newVersion;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n\t}\n\n}\n"
          },
          {
            sha: "448f7bcee55deabe401c3a889ce95bd377b9dfd5",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "modified",
            additions: 1,
            deletions: 11,
            patch:
              "@@ -28,18 +28,8 @@ public RCProject(String projectName, List<String> fileSources) {\n \t\t}\n \t}\n \n-\n-\tprivate void browsePackages(){\n-\t\tfor(CompilationUnit unit: this.units){\n-\t\t\tunit.\n-\t\t}\n-\t}\n-\n-\n \t@Override\n \tpublic List<IPackage> getPackages() {\n-\t\tif (null != packages) {\n-\t\t\tbrowsePackages();\n-\t\t}\n+\t\treturn null;\n \t}\n }",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\treturn null;\n\t}\n}\n"
          },
          {
            sha: "fe676e94ebfb94cc6e342fed1ffd6bc08ecda4d1",
            filename: "src/main/java/refactoring/crawler/util/BloomFilter.java",
            status: "added",
            additions: 544,
            deletions: 0,
            patch:
              '@@ -0,0 +1,544 @@\n+package refactoring.crawler.util;\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.net.URL;\n+\n+/**\n+ * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n+ * hash table.</p> <p>\n+ * \n+ * Bloom filters allow you to perform membership tests in just a fraction of the memory \n+ * you\'d need to store a full list of keys. As you might suspect, the savings in space \n+ * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n+ * key from a filter once you\'ve added it in. But in the many cases where those constraints\n+ * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n+ * \n+ * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+ * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n+ * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n+ * filters were prized primarily for their compactness; in fact, one of their earliest applications\n+ *  was in spell checkers.</p> <p>\n+ * \n+ * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n+ * a given length. We choose the length of the bit vector and the number of hash functions\n+ * depending on how many keys we want to add to the set and how high an error rate we are\n+ * willing to put up with. </p> <p>\n+ * \n+ * All of the hash functions in a Bloom filter are configured so that their range matches the\n+ * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n+ * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+ * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+ * function would increase our false-positive rate.</p> <p>\n+ * \n+ * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n+ * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+ * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n+ * in a Bloom filter.</p> <p>\n+ * \n+ * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n+ * new key. We run the key through our set of hash functions, and then check to see whether\n+ * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n+ * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n+ * \n+ * As you might expect, the false-positive rate depends on the bit vector length and the number\n+ * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n+ * we check will be on, unless the key actually exists in the filter. The relationship between the\n+ * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+ * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n+ * filter will be very dense, increasing the probability of collisions. You can calculate the\n+ * false-positive rate for any filter using the formula:</p> <p>\n+ * \n+ * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n+ *\n+ * Where c is the false positive rate, k is the number of hash functions, n is the number of\n+ * keys in the filter, and m is the length of the filter in bits.</p> <p>\n+ *\n+ * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n+ * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n+ * need some way of finding out how large a bit vector is to make sure the false-positive rate\n+ * never exceeds our limit. The following equation will give us vector length from the error rate\n+ * and number of keys:</p> <p>\n+ * \n+ *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n+ *\n+ * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+ * possible to use calculus to find a minimum for k. You can also find lookup tables for \n+ * various combinations of error rate, filter size, and number of hash functions at \n+ * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n+ *  \n+ * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n+ * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n+ * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n+ *\n+ * Alternatively, this class can also use an implementation of a hash function based on Rabin\n+ * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n+ * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n+ * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n+ * function with very satisfactory properties. In addition the polynomial operations are fast in\n+ * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n+ *\n+ * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+ * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+ * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+ * paper in PDF format.</p> <p>\n+ *\n+ * Included in this class are additional methods that can compute the Rabin hash value\n+ * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n+ *\n+ * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+ * initial value multiplied by a list of distinct values.\n+ * \n+ * @see java.lang.Object#hashCode()\n+ * @see java.util.Map\n+ *\n+ * @author      Bruno Martins\n+ */\n+public class BloomFilter implements Cloneable {\n+\n+\t/** A buffer for the Rabin fingerprinting algorithm. */\n+\tprivate byte[] buffer;\n+\t\n+\t/**\n+\t *  The 32 bits of this integer represent the coefficients of the degree 32\n+\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n+\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n+\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n+\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+\t *  bit is the constant coefficient.</p> <p>\n+\t *\n+\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n+\t *\n+\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n+\t *\n+\t *  Therefore it correponds to the polynomial:</p> <p>\n+\t *\n+\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+\t */\n+\tprivate static int POLYNOMIAL = 0x000001C7;\n+\n+\t/** Internal values for the Rabin fingerprinting algorithm. */\n+\tprivate static int[] table32, table40, table48, table54;\n+\t\n+\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+\tprivate static int P_DEGREE = 32;\n+\t\n+\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n+\tprivate static int READ_BUFFER_SIZE = 2048;\n+\t\n+\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+\n+\t/** The bit vector for the Bloom Filter. */\n+\tprivate boolean keys[];\n+\n+\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+\tprivate boolean useRabin = true;\n+\t\n+\t/** The number of hash functions. */\n+\tprivate int numFunctions;\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n+\t * and the default length for the bit vector (1000).\n+\t */\n+\tpublic BloomFilter() {\n+\t\ttable32 = new int[256];\n+\t\ttable40 = new int[256];\n+\t\ttable48 = new int[256];\n+\t\ttable54 = new int[256];\n+\t\tbuffer = new byte[READ_BUFFER_SIZE];\n+\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n+\t\tint[] mods = new int[P_DEGREE];\n+\t\tmods[0] = POLYNOMIAL;\n+\t\tfor (int i = 1; i < P_DEGREE; i++) {\n+\t\t\t// x^i == x(x^(i-1)) (mod P)\n+\t\t\tmods[i] = mods[i - 1] << 1;\n+\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n+\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n+\t\t\t// to account for this:\n+\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n+\t\t\t\tmods[i] ^= POLYNOMIAL;\n+\t\t\t}\n+\t\t}\n+\t\tfor (int i = 0; i < 256; i++) {\n+\t\t\tint c = i;\n+\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n+\t\t\t\tif ((c & 1) != 0) {\n+\t\t\t\t\ttable32[i] ^= mods[j];\n+\t\t\t\t\ttable40[i] ^= mods[j + 8];\n+\t\t\t\t\ttable48[i] ^= mods[j + 16];\n+\t\t\t\t\ttable54[i] ^= mods[j + 24];\n+\t\t\t\t}\n+\t\t\t\tc >>>= 1;\n+\t\t\t}\n+\t\t}\n+\t\tmods = null;\n+\t\tthis.keys = new boolean[1000];\n+\t\tthis.numFunctions = 10;\n+\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t * Constructs a Bloom Filter from a string representation.\n+\t *\n+\t * @see #toString()\n+\t */\n+\tpublic BloomFilter(String filter) {\n+\t\tthis();\n+\t\tint index1 = filter.indexOf(":");\n+\t\tint index2 = filter.lastIndexOf(":");\n+\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n+\t\tkeys =\n+\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n+\t\t\t\t.intValue()];\n+\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n+\t\t\tif (filter.charAt(i) == \'1\')\n+\t\t\t\tkeys[i] = true;\n+\t\t\telse\n+\t\t\t\tkeys[i] = false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with a given length for the bit vector,\n+\t * guarenteeing a maximum error rate.  \n+\t *\n+\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n+\t */\n+\tpublic BloomFilter(int numKeys, double errorRate) {\n+\t\tthis();\n+\t\tdouble lowest_m = Double.MAX_VALUE;\n+\t\tint best_k = 1;\n+\t\tfor (int k = 1; k <= 100; k++) {\n+\t\t\tdouble m =\n+\t\t\t\t(-1 * k * numKeys)\n+\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+\t\t\tif (m < lowest_m) {\n+\t\t\t\tlowest_m = m;\n+\t\t\t\tbest_k = k;\n+\t\t\t}\n+\t\t}\n+\t\tthis.keys = new boolean[numKeys];\n+\t\tthis.numFunctions = best_k;\n+\t\tfor (int i = 0; i < numKeys; i++)\n+\t\t\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n+\t * and a given length for the bit vector.\n+\t *\n+\t *@param  numKeys           The length of the bit vector.\n+\t */\n+\tpublic BloomFilter(int numKeys) {\n+\t\tthis(numKeys, 10);\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with a given number of hash functions\n+\t * and a given length for the bit vector.\n+\t *\n+\t *@param  numKeys                The length of the bit vector.\n+\t *@param  numHashFunctions  The number of hash functions.\n+\t */\n+\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n+\t\tthis();\n+\t\tthis.keys = new boolean[numKeys];\n+\t\tthis.numFunctions = numHashFunctions;\n+\t\tfor (int i = 0; i < numKeys; i++)\n+\t\t\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t *  Internal method for producing the hash value for a given function number.\n+\t *\n+\t * @param  fnum      The number of the hash function.\n+\t * @param  original   The original value for the hash of the object. \n+\t * @see java.lang.Object#hashCode() \n+\t * @return   Returns the hash code value for the given function number.\n+\t */\n+\tprivate int getHash(int fnum, int original) {\n+\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n+\t\tint hash[] = { original };\n+\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n+\t\thash[0] = hash[0] % keys.length;\n+\t\tif (hash[0] < 0) hash[0] = -hash[0];\n+\t\treturn hash[0];\n+\t}\n+\n+\t/**\n+\t *  Returns true if this Bloom Filter contains the specified key.\n+\t *\n+\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n+\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n+\t */\n+\tpublic boolean hasKey(Object obj) {\n+\t\tboolean result = true;\n+\t\tint hashCodeObject;\n+\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n+\t\t\thashCodeObject = hashRabin(obj);\n+\t\t} catch ( Exception e ) {\n+\t\t\tuseRabin = false;\n+\t\t\thashCodeObject = obj.hashCode();\n+\t\t}\n+\t\tfor (int i = 0; i < numFunctions && result; i++) {\n+\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t *  Adds the specified key in this Bloom Filter.\n+\t *\n+\t *@param  obj  The key to be added to this Bloom Filter.\n+\t */\n+\tpublic void put(Object obj) {\n+\t\tint hashCodeObject;\n+\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n+\t\t\thashCodeObject = hashRabin(obj);\n+\t\t} catch ( Exception e ) {\n+\t\t\tuseRabin = false;\n+\t\t\thashCodeObject = obj.hashCode();\n+\t\t}\n+\t\tfor (int i = 0; i < numFunctions; i++) {\n+\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *\n+\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n+\t * integer specifying the number of hash Functions, an integer specifying the length of the\n+\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n+\t * separated by the character ":".\n+\t * \n+\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n+\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n+\t * \n+\t * @return A string representation of this Bloom Filter.\n+\t */\n+\tpublic String toString() {\n+\t\tStringBuffer aux =\n+\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n+\t\tfor (int i = 0; i < keys.length; i++) {\n+\t\t\tif (keys[i])\n+\t\t\t\taux.append("1");\n+\t\t\telse\n+\t\t\t\taux.append("0");\n+\t\t}\n+\t\treturn aux.toString();\n+\t}\n+\n+\t/**\n+\t * Returns a copy of this Bloom Filter instance.\n+\t *\n+\t * @see java.lang.Object#clone()\n+\t */\n+\tpublic Object clone() {\n+\t\treturn new BloomFilter(this.toString());\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of bytes.\n+\t *\n+\t *@param  arr  An array of bytes.\n+\t *@return    The Rabin hash value for the array of bytes.\n+\t */\n+\tpublic int hashRabin(byte[] arr) {\n+\t\treturn hashRabin(arr, 0, arr.length, 0);\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of bytes.\n+\t *\n+\t *@param  arr        An array of bytes.\n+\t *@param  offset    Index of the first byte of the array to hash.\n+\t *@param  length   Number of bytes to hash.\n+\t *@param  ws          ??         \n+\t *@return  The Rabin hash value for the array of bytes.\n+\t */\n+\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n+\t\tint w = ws;\n+\t\tint start = length % 4;\n+\t\tfor (int s = offset; s < offset + start; s++) {\n+\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n+\t\t}\n+\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ (arr[s] << 24)\n+\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n+\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n+\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of chars.\n+\t *\n+\t *@param  arr  An array of chars.\n+\t *@return   The Rabin hash value for the array of chars.\n+\t */\n+\tpublic int hashRabin(char[] arr) {\n+\t\tint w = 0;\n+\t\tint start = 0;\n+\t\tif (arr.length % 2 == 1) {\n+\t\t\tw = arr[0] & 0xFFFF;\n+\t\t\tstart = 1;\n+\t\t}\n+\t\tfor (int s = start; s < arr.length; s += 2) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n+\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n+\t *\n+\t *@param  f                       A <code>File</code>.\n+\t *@return                          The Rabin hash value for the contents of the File.\n+\t *@throws  FileNotFoundException  If the file cannot be found.\n+\t *@throws  IOException            If an error occurs while reading the file.\n+\t */\n+\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n+\t\tFileInputStream fis = new FileInputStream(f);\n+\t\ttry {\n+\t\t\treturn hashRabin(fis);\n+\t\t} finally {\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+\t *\n+\t *@param  is          An InputStream.\n+\t *@return               The Rabin hash value for the contents read from the InputStream.\n+\t *@throws  IOException  if an error occurs while reading from the InputStream.\n+\t */\n+\tpublic int hashRabin(InputStream is) throws IOException {\n+\t\tint hashValue = 0;\n+\t\tint bytesRead;\n+\t\tsynchronized (buffer) {\n+\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n+\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+\t\t\t}\n+\t\t}\n+\t\treturn hashValue;\n+\t}\n+\n+\t/**\n+\t *  Returns the Rabin hash value of an array of integers. This method is the\n+\t *  most efficient of all the hash methods, so it should be used when\n+\t *  possible.\n+\t *\n+\t *@param   arr  An array of integers.\n+\t *@return    int The Rabin hash value for the array of integers.\n+\t */\n+\tpublic int hashRabin(int[] arr) {\n+\t\tint w = 0;\n+\t\tfor (int s = 0; s < arr.length; s++) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ arr[s];\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a given Object.\n+\t *\n+\t *@param  obj            An Object.\n+\t *@return                   The Rabin hash value for the Object.\n+\t *@throws  IOException  If Object serialization fails.\n+\t */\n+\tpublic int hashRabin(Object obj) throws IOException {\n+\t\treturn hashRabin((Serializable) obj);\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a given serializable Object.\n+\t *\n+\t *@param  obj             An Object.\n+\t *@return                   The Rabin hash value for the Object.\n+\t *@throws  IOException  If serialization fails.\n+\t */\n+\tpublic int hashRabin(Serializable obj) throws IOException {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tObjectOutputStream oos = null;\n+\t\ttry {\n+\t\t\toos = new ObjectOutputStream(baos);\n+\t\t\toos.writeObject(obj);\n+\t\t\treturn hashRabin(baos.toByteArray());\n+\t\t} finally {\n+\t\t\toos.close();\n+\t\t\tbaos.close();\n+\t\t\toos = null;\n+\t\t\tbaos = null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a String.\n+\t *\n+\t *@param  s  A <code>String</code>.\n+\t *@return   The Rabin hash value for the String.\n+\t */\n+\tpublic int hashRabin(String s) {\n+\t\treturn hashRabin(s.toCharArray());\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the contents of a Web document,\n+\t *  specified by an URL.\n+\t *\n+\t *@param  url         The URL of the document to be hashed.\n+\t *@return               The Rabin hash value for the document.\n+\t *@throws  IOException If an error occurs while reading the document.\n+\t */\n+\tpublic int hashRabin(URL url) throws IOException {\n+\t\tInputStream is = url.openStream();\n+\t\ttry {\n+\t\t\treturn hashRabin(is);\n+\t\t} finally {\n+\t\t\tis.close();\n+\t\t}\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n * hash table.</p> <p>\n * \n * Bloom filters allow you to perform membership tests in just a fraction of the memory \n * you\'d need to store a full list of keys. As you might suspect, the savings in space \n * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n * key from a filter once you\'ve added it in. But in the many cases where those constraints\n * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n * \n * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n * filters were prized primarily for their compactness; in fact, one of their earliest applications\n *  was in spell checkers.</p> <p>\n * \n * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n * a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are\n * willing to put up with. </p> <p>\n * \n * All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.</p> <p>\n * \n * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n * in a Bloom filter.</p> <p>\n * \n * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n * new key. We run the key through our set of hash functions, and then check to see whether\n * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n * \n * As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n * we check will be on, unless the key actually exists in the filter. The relationship between the\n * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n * filter will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:</p> <p>\n * \n * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n *\n * Where c is the false positive rate, k is the number of hash functions, n is the number of\n * keys in the filter, and m is the length of the filter in bits.</p> <p>\n *\n * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n * need some way of finding out how large a bit vector is to make sure the false-positive rate\n * never exceeds our limit. The following equation will give us vector length from the error rate\n * and number of keys:</p> <p>\n * \n *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n *\n * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for \n * various combinations of error rate, filter size, and number of hash functions at \n * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n *  \n * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n *\n * Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n * function with very satisfactory properties. In addition the polynomial operations are fast in\n * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n *\n * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.</p> <p>\n *\n * Included in this class are additional methods that can compute the Rabin hash value\n * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n *\n * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n * \n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n *\n * @author      Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n\t/** A buffer for the Rabin fingerprinting algorithm. */\n\tprivate byte[] buffer;\n\t\n\t/**\n\t *  The 32 bits of this integer represent the coefficients of the degree 32\n\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n\t *  bit is the constant coefficient.</p> <p>\n\t *\n\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n\t *\n\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n\t *\n\t *  Therefore it correponds to the polynomial:</p> <p>\n\t *\n\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n\t */\n\tprivate static int POLYNOMIAL = 0x000001C7;\n\n\t/** Internal values for the Rabin fingerprinting algorithm. */\n\tprivate static int[] table32, table40, table48, table54;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int P_DEGREE = 32;\n\t\n\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n\tprivate static int READ_BUFFER_SIZE = 2048;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n\t/** The bit vector for the Bloom Filter. */\n\tprivate boolean keys[];\n\n\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n\tprivate boolean useRabin = true;\n\t\n\t/** The number of hash functions. */\n\tprivate int numFunctions;\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and the default length for the bit vector (1000).\n\t */\n\tpublic BloomFilter() {\n\t\ttable32 = new int[256];\n\t\ttable40 = new int[256];\n\t\ttable48 = new int[256];\n\t\ttable54 = new int[256];\n\t\tbuffer = new byte[READ_BUFFER_SIZE];\n\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n\t\tint[] mods = new int[P_DEGREE];\n\t\tmods[0] = POLYNOMIAL;\n\t\tfor (int i = 1; i < P_DEGREE; i++) {\n\t\t\t// x^i == x(x^(i-1)) (mod P)\n\t\t\tmods[i] = mods[i - 1] << 1;\n\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n\t\t\t// to account for this:\n\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n\t\t\t\tmods[i] ^= POLYNOMIAL;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tint c = i;\n\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n\t\t\t\tif ((c & 1) != 0) {\n\t\t\t\t\ttable32[i] ^= mods[j];\n\t\t\t\t\ttable40[i] ^= mods[j + 8];\n\t\t\t\t\ttable48[i] ^= mods[j + 16];\n\t\t\t\t\ttable54[i] ^= mods[j + 24];\n\t\t\t\t}\n\t\t\t\tc >>>= 1;\n\t\t\t}\n\t\t}\n\t\tmods = null;\n\t\tthis.keys = new boolean[1000];\n\t\tthis.numFunctions = 10;\n\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs a Bloom Filter from a string representation.\n\t *\n\t * @see #toString()\n\t */\n\tpublic BloomFilter(String filter) {\n\t\tthis();\n\t\tint index1 = filter.indexOf(":");\n\t\tint index2 = filter.lastIndexOf(":");\n\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n\t\tkeys =\n\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n\t\t\t\t.intValue()];\n\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n\t\t\tif (filter.charAt(i) == \'1\')\n\t\t\t\tkeys[i] = true;\n\t\t\telse\n\t\t\t\tkeys[i] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given length for the bit vector,\n\t * guarenteeing a maximum error rate.  \n\t *\n\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n\t */\n\tpublic BloomFilter(int numKeys, double errorRate) {\n\t\tthis();\n\t\tdouble lowest_m = Double.MAX_VALUE;\n\t\tint best_k = 1;\n\t\tfor (int k = 1; k <= 100; k++) {\n\t\t\tdouble m =\n\t\t\t\t(-1 * k * numKeys)\n\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n\t\t\tif (m < lowest_m) {\n\t\t\t\tlowest_m = m;\n\t\t\t\tbest_k = k;\n\t\t\t}\n\t\t}\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = best_k;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys           The length of the bit vector.\n\t */\n\tpublic BloomFilter(int numKeys) {\n\t\tthis(numKeys, 10);\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given number of hash functions\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys                The length of the bit vector.\n\t *@param  numHashFunctions  The number of hash functions.\n\t */\n\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n\t\tthis();\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = numHashFunctions;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t *  Internal method for producing the hash value for a given function number.\n\t *\n\t * @param  fnum      The number of the hash function.\n\t * @param  original   The original value for the hash of the object. \n\t * @see java.lang.Object#hashCode() \n\t * @return   Returns the hash code value for the given function number.\n\t */\n\tprivate int getHash(int fnum, int original) {\n\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n\t\tint hash[] = { original };\n\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n\t\thash[0] = hash[0] % keys.length;\n\t\tif (hash[0] < 0) hash[0] = -hash[0];\n\t\treturn hash[0];\n\t}\n\n\t/**\n\t *  Returns true if this Bloom Filter contains the specified key.\n\t *\n\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n\t */\n\tpublic boolean hasKey(Object obj) {\n\t\tboolean result = true;\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions && result; i++) {\n\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t *  Adds the specified key in this Bloom Filter.\n\t *\n\t *@param  obj  The key to be added to this Bloom Filter.\n\t */\n\tpublic void put(Object obj) {\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions; i++) {\n\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n\t * integer specifying the number of hash Functions, an integer specifying the length of the\n\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n\t * separated by the character ":".\n\t * \n\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n\t * \n\t * @return A string representation of this Bloom Filter.\n\t */\n\tpublic String toString() {\n\t\tStringBuffer aux =\n\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i])\n\t\t\t\taux.append("1");\n\t\t\telse\n\t\t\t\taux.append("0");\n\t\t}\n\t\treturn aux.toString();\n\t}\n\n\t/**\n\t * Returns a copy of this Bloom Filter instance.\n\t *\n\t * @see java.lang.Object#clone()\n\t */\n\tpublic Object clone() {\n\t\treturn new BloomFilter(this.toString());\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr  An array of bytes.\n\t *@return    The Rabin hash value for the array of bytes.\n\t */\n\tpublic int hashRabin(byte[] arr) {\n\t\treturn hashRabin(arr, 0, arr.length, 0);\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr        An array of bytes.\n\t *@param  offset    Index of the first byte of the array to hash.\n\t *@param  length   Number of bytes to hash.\n\t *@param  ws          ??         \n\t *@return  The Rabin hash value for the array of bytes.\n\t */\n\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n\t\tint w = ws;\n\t\tint start = length % 4;\n\t\tfor (int s = offset; s < offset + start; s++) {\n\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n\t\t}\n\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ (arr[s] << 24)\n\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of chars.\n\t *\n\t *@param  arr  An array of chars.\n\t *@return   The Rabin hash value for the array of chars.\n\t */\n\tpublic int hashRabin(char[] arr) {\n\t\tint w = 0;\n\t\tint start = 0;\n\t\tif (arr.length % 2 == 1) {\n\t\t\tw = arr[0] & 0xFFFF;\n\t\t\tstart = 1;\n\t\t}\n\t\tfor (int s = start; s < arr.length; s += 2) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n\t *\n\t *@param  f                       A <code>File</code>.\n\t *@return                          The Rabin hash value for the contents of the File.\n\t *@throws  FileNotFoundException  If the file cannot be found.\n\t *@throws  IOException            If an error occurs while reading the file.\n\t */\n\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n\t\tFileInputStream fis = new FileInputStream(f);\n\t\ttry {\n\t\t\treturn hashRabin(fis);\n\t\t} finally {\n\t\t\tfis.close();\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n\t *\n\t *@param  is          An InputStream.\n\t *@return               The Rabin hash value for the contents read from the InputStream.\n\t *@throws  IOException  if an error occurs while reading from the InputStream.\n\t */\n\tpublic int hashRabin(InputStream is) throws IOException {\n\t\tint hashValue = 0;\n\t\tint bytesRead;\n\t\tsynchronized (buffer) {\n\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n\t\t\t}\n\t\t}\n\t\treturn hashValue;\n\t}\n\n\t/**\n\t *  Returns the Rabin hash value of an array of integers. This method is the\n\t *  most efficient of all the hash methods, so it should be used when\n\t *  possible.\n\t *\n\t *@param   arr  An array of integers.\n\t *@return    int The Rabin hash value for the array of integers.\n\t */\n\tpublic int hashRabin(int[] arr) {\n\t\tint w = 0;\n\t\tfor (int s = 0; s < arr.length; s++) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ arr[s];\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given Object.\n\t *\n\t *@param  obj            An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If Object serialization fails.\n\t */\n\tpublic int hashRabin(Object obj) throws IOException {\n\t\treturn hashRabin((Serializable) obj);\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given serializable Object.\n\t *\n\t *@param  obj             An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If serialization fails.\n\t */\n\tpublic int hashRabin(Serializable obj) throws IOException {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = null;\n\t\ttry {\n\t\t\toos = new ObjectOutputStream(baos);\n\t\t\toos.writeObject(obj);\n\t\t\treturn hashRabin(baos.toByteArray());\n\t\t} finally {\n\t\t\toos.close();\n\t\t\tbaos.close();\n\t\t\toos = null;\n\t\t\tbaos = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a String.\n\t *\n\t *@param  s  A <code>String</code>.\n\t *@return   The Rabin hash value for the String.\n\t */\n\tpublic int hashRabin(String s) {\n\t\treturn hashRabin(s.toCharArray());\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a Web document,\n\t *  specified by an URL.\n\t *\n\t *@param  url         The URL of the document to be hashed.\n\t *@return               The Rabin hash value for the document.\n\t *@throws  IOException If an error occurs while reading the document.\n\t */\n\tpublic int hashRabin(URL url) throws IOException {\n\t\tInputStream is = url.openStream();\n\t\ttry {\n\t\t\treturn hashRabin(is);\n\t\t} finally {\n\t\t\tis.close();\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "8ab90c54876e0577e1454c425fd77360d1d02109",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 197,
            deletions: 123,
            patch:
              '@@ -2,129 +2,203 @@\n \n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n-import java.util.List;\n-import java.util.ArrayList;\n+\n+import java.util.*;\n \n public class ShinglesUtil {\n-    private ShinglesStrategy shinglesStrategy;\n-\n-    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n-\n-    private DirectedMultigraph<Node, Edge> newVersionGraph;\n-\n-    private List<Node[]> similarMethods;\n-\n-    private List<Node> oldVersionPackageList;\n-    private List<Node> oldVersionClassList;\n-    private List<Node> oldVersionMethodList;\n-    private List<Node> oldVersionFieldList;\n-\n-    private List<Node> newVersionPackageList;\n-    private List<Node> newVersionClassList;\n-    private List<Node> newVersionMethodList;\n-    private List<Node> newVersionFieldList;\n-\n-    private double methodThreshold;\n-\n-    public ShinglesUtil() {\n-        this.shinglesStrategy = new FactorOf2Strategy();\n-    }\n-\n-    public int[] computeMethodShingles(String str) {\n-        return null;\n-    }\n-\n-    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n-        this.oldVersionGraph = oldVersionGraph;\n-        this.newVersionGraph = newVersionGraph;\n-\n-        this.oldVersionPackageList = new ArrayList<>();\n-        this.oldVersionClassList = new ArrayList<>();\n-        this.oldVersionMethodList = new ArrayList<>();\n-        this.oldVersionFieldList = new ArrayList<>();\n-\n-        this.newVersionPackageList = new ArrayList<>();\n-        this.newVersionClassList = new ArrayList<>();\n-        this.newVersionMethodList = new ArrayList<>();\n-        this.newVersionFieldList = new ArrayList<>();\n-\n-        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n-                oldVersionPackageList, oldVersionFieldList);\n-\n-        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-    }\n-\n-    /**\n-     * For the passed graph, fills the respective arrays for packages, classes,\n-     * methods and fields by using a breadth first iterator.\n-     *\n-     * @param graph\n-     * @param methods\n-     * @param classes\n-     * @param packages\n-     * @param fields\n-     */\n-    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n-                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n-        // Create a BreadthFirstIterator for the graph\n-        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-        while (bfi.hasNext()) {\n-            Node n = bfi.next();\n-            if (n.getType().equals(Node.Type.CLASS)) {\n-                classes.add(n);\n-            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n-                packages.add(n);\n-            } else if (n.getType().equals(Node.Type.METHOD)) {\n-                methods.add(n);\n-            } else if (n.getType().equals(Node.Type.FIELD)) {\n-                fields.add(n);\n-            }\n-        }\n-    }\n-\n-    public List<Node[]> findSimilarMethods() {\n-        if (this.similarMethods.isEmpty()) {\n-            List<Node[]> similarMethods = new ArrayList<>();\n-            for (Node m : this.oldVersionMethodList) {\n-                if (!m.isAPI())\n-                    continue;\n-\n-                for (Node m2 : this.newVersionMethodList) {\n-                    if (!m2.isAPI())\n-                        continue;\n-\n-                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-                        Node[] arr = {m, m2};\n-                        // if (!isThisArrayInTheList(simMet, arr))\n-                        similarMethods.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarMethods = similarMethods;\n-        }\n-        return this.similarMethods;\n-    }\n-\n-    public double howMuchAlike(int[] arr1, int[] arr2) {\n-        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-        return finalGrade;\n-    }\n-\n-    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-        int[] tempArr = (int[]) arr2.clone();\n-        double grade = 0.0;\n-        for (int value : arr1) {\n-            for (int j = 0; j < tempArr.length; j++) {\n-                if (value == tempArr[j]) {\n-                    grade += 1.0 / arr1.length;\n-                    tempArr[j] = Integer.MIN_VALUE;\n-                    break;\n-                }\n-            }\n-        }\n-        return grade;\n-    }\n+\n+\tprivate int w = 3;\n+\tprivate int sMethod = 8;\n+\n+\tprivate ShinglesStrategy shinglesStrategy;\n+\n+\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\n+\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n+\n+\tprivate List<Node[]> similarMethods;\n+\n+\tprivate List<Node> oldVersionPackageList;\n+\tprivate List<Node> oldVersionClassList;\n+\tprivate List<Node> oldVersionMethodList;\n+\tprivate List<Node> oldVersionFieldList;\n+\n+\tprivate List<Node> newVersionPackageList;\n+\tprivate List<Node> newVersionClassList;\n+\tprivate List<Node> newVersionMethodList;\n+\tprivate List<Node> newVersionFieldList;\n+\n+\tprivate double methodThreshold;\n+\n+\tpublic ShinglesUtil() {\n+\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+\t}\n+\n+\tpublic List<String> tokenizer(String s) {\n+\t\tList<String> list = new ArrayList<>();\n+\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+\t\twhile (st.hasMoreElements()) {\n+\t\t\tlist.add(st.nextToken());\n+\t\t}\n+\t\treturn list;\n+\t}\n+\n+\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n+\t\tListIterator<String> iter = tokenList.listIterator();\n+\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n+\t\t// W=2, iterIndex = size - W identifies the last window\n+\t\t{\n+\t\t\tList<String> tempList = new ArrayList<>();\n+\t\t\tfor (int i = 1; i <= w; i++) // W=3\n+\t\t\t{\n+\t\t\t\ttempList.add(iter.next());\n+\t\t\t}\n+\t\t\tbagOfTokensList.add(tempList);\n+\t\t\tfor (int i = 1; i <= w - 1; i++)\n+\t\t\t\t// i<= W-1\n+\t\t\t\titer.previous();\n+\t\t}\n+\t\treturn bagOfTokensList;\n+\t}\n+\n+\tprivate int findNumberOfLines(String str) {\n+\t\tint retval = 0;\n+\t\tchar[] c = str.toCharArray();\n+\t\tfor (char value : c) {\n+\t\t\tif (value == \'\\n\')\n+\t\t\t\tretval++;\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\tpublic int[] computeMethodShingles(String str) {\n+\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+\t}\n+\n+\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+\t\t/*\n+\t\t * We are now introducing the idea of finding the number of lines in the\n+\t\t * method, and incorporate that into the calculation of shingles, so\n+\t\t * that, if there are more lines, then there are going to be more\n+\t\t * shingles associated with the method. However, a 1-1 correspondance\n+\t\t * will be misleading, thus another method is required.\n+\t\t */\n+\t\tBloomFilter bloomFilter = new BloomFilter();\n+\t\tList<String> tokenList = tokenizer(str);\n+\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+\t\tint numberOfWindowedTokens = 0;\n+\n+\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n+\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n+\t\t\tfor (int i = 0; i < window; i++) {\n+\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n+\t\t\t\tif (i != window - 1)\n+\t\t\t\t\ttokensInOneWindow.append(" ");\n+\t\t\t}\n+\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n+\t\t\tnumberOfWindowedTokens++;\n+\t\t}\n+\n+\t\tArrays.sort(shinglesValues);\n+\n+\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n+\t\t\tnumberOfWindowedTokens);\n+\n+\t\tint[] retVal = new int[correctNumberOfShingles];\n+\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+\t\treturn retVal;\n+\t}\n+\n+\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+\t\tthis.oldVersionGraph = oldVersionGraph;\n+\t\tthis.newVersionGraph = newVersionGraph;\n+\n+\t\tthis.similarMethods = new LinkedList<>();\n+\n+\t\tthis.oldVersionPackageList = new ArrayList<>();\n+\t\tthis.oldVersionClassList = new ArrayList<>();\n+\t\tthis.oldVersionMethodList = new ArrayList<>();\n+\t\tthis.oldVersionFieldList = new ArrayList<>();\n+\n+\t\tthis.newVersionPackageList = new ArrayList<>();\n+\t\tthis.newVersionClassList = new ArrayList<>();\n+\t\tthis.newVersionMethodList = new ArrayList<>();\n+\t\tthis.newVersionFieldList = new ArrayList<>();\n+\n+\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n+\t\t\toldVersionPackageList, oldVersionFieldList);\n+\n+\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n+\n+\t\tSystem.out.println("fuck you");\n+\t}\n+\n+\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n+\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n+\t\t// Create a BreadthFirstIterator for the graph\n+\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+\t\twhile (bfi.hasNext()) {\n+\t\t\tNode n = bfi.next();\n+\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n+\t\t\t\tclasses.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n+\t\t\t\tpackages.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n+\t\t\t\tmethods.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n+\t\t\t\tfields.add(n);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<Node[]> findSimilarMethods() {\n+\t\tif (this.similarMethods.isEmpty()) {\n+\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n+\t\t\tfor (Node m : this.oldVersionMethodList) {\n+\t\t\t\tif (!m.isAPI())\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n+\t\t\t\t\tif (!m2.isAPI())\n+\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+\t\t\t\t\t\tNode[] arr = {m, m2};\n+\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n+\t\t\t\t\t\tsimilarMethods.add(arr);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.similarMethods = similarMethods;\n+\t\t}\n+\t\treturn this.similarMethods;\n+\t}\n+\n+\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n+\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+\t\treturn finalGrade;\n+\t}\n+\n+\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+\t\tint[] tempArr = arr2.clone();\n+\t\tdouble grade = 0.0;\n+\t\tfor (int value : arr1) {\n+\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n+\t\t\t\tif (value == tempArr[j]) {\n+\t\t\t\t\tgrade += 1.0 / arr1.length;\n+\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn grade;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tprivate double methodThreshold;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\n\t\tSystem.out.println("fuck you");\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "d024c32869d45a2dd958ab6752d813ea8db10d88",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 189,
            deletions: 104,
            patch:
              '@@ -1,10 +1,15 @@\n package refactoring.crawler.util;\n \n import java.util.List;\n+import java.util.Optional;\n import java.util.stream.Collectors;\n \n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.FieldDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n@@ -45,121 +50,201 @@ public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n \tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n \t\tthis.projectName = projectName;\n \t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n-\t\tval packages = compilationUnits.stream()\n-\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-\t\t\t.filter(p -> !p.isPresent())\n-\t\t\t.collect(Collectors.toList());\n-//        this.graph.addVertex(projectNode);\n \t\tthis.graph.addNamedVertex(projectNode);\n-\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n-\t}\n+\t\tcompilationUnits.forEach(cu -> {\n+\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n+\t\t\tif (packageDeclaration.isPresent()) {\n+\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n+\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n+\t\t\t\tpackageNode.setProjectName(projectName);\n+\t\t\t\tthis.graph.addNamedVertex(packageNode);\n+\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+\t\t\t\tcu.getTypes().forEach(type -> {\n+\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n+\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+\t\t\t\t\t\tif (className.isPresent()) {\n+\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n+\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n+\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\t\t\t\t\t\t\tthis.allClassCounter += 1;\n+\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n+\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n+\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n+\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n \n-\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n-\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n-\t\tchildrenPackages.forEach(childrenPackage -> {\n-\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n-\t\t\tpackageNode.setProjectName(this.projectName);\n-//            graph.addVertex(packageNode);\n-\t\t\tgraph.addNamedVertex(packageNode);\n-//            graph.addEdge(projectNode, packageNode);\n-\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-\t\t\tthis.packageCounter += 1;\n-\t\t});\n-\t}\n+\t\t\t\t\t\t\t// fields\n+\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n+\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n+\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n+\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n+\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n+\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t\t\t\t\t\t});\n \n-\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-\t\tval classes = pckg.getClasses();\n-\t\tclasses.forEach(clz -> {\n-\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-\t\t\tclassNode.setProjectName(this.projectName);\n-\t\t\tclassNode.setFlags(clz.getFlags());\n-//            graph.addVertex(classNode);\n-//            graph.addEdge(packageNode, classNode);\n-\t\t\tgraph.addNamedVertex(classNode);\n-\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\t\t\tthis.browseClass(clz, classNode);\n-\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-\t\t\tclassNode.setInterface(clz.getIsInterface());\n-\t\t\tthis.allClassCounter += 1;\n-\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-\t\t\t\tclassNode.setAPI(true);\n-\t\t\t\tthis.apiClassCounter += 1;\n-\t\t\t}\n-\t\t});\n-\t}\n+\t\t\t\t\t\t\t// methods\n+\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n \n-\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-\t\tval methods = clz.getMethods();\n-\t\tbrowseMethods(methods, classNode);\n-\t\tval fields = clz.getFields();\n-\t\tbrowseFields(fields, classNode);\n-\t}\n+\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n+\t\t\t\t\t\t\t\tString statementBody = "";\n+\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n+\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n+\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n+\t\t\t\t\t\t\t\t\t} else\n+\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n+\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n+\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n \n-\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-\t\tmethods.forEach(method -> {\n-\t\t\tString statementBody = "";\n-\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-\t\t\t\tstatementBody = method.getSource().trim();\n-\t\t\t} else\n-\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-\t\t\t\t+ method.getElementName();\n-\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-\n-\t\t\tallMethodsCounter += 1;\n-\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-\t\t\t\tmethodNode.setAPI(true);\n-\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n+\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n+\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n+\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n+\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n+\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n+\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n+\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n \t\t\t}\n-\t\t\tif (method.getIsDeprecated())\n-\t\t\t\tmethodNode.setDeprecated(true);\n-\t\t\tmethodNode.setProjectName(projectName);\n-\t\t\tmethodNode.setShingles(shingles);\n-\t\t\tmethodNode.setFlags(method.getFlags());\n-\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-//            graph.addVertex(methodNode);\n-//            graph.addEdge(classNode, methodNode);\n-\t\t\tgraph.addNamedVertex(methodNode);\n-\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-\t\t});\n-\t}\n \n+\t\t});\n \n-\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-\t\tStringBuilder buffer = new StringBuilder();\n+//\t\tval packages = compilationUnits.stream()\n+//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+//\t\t\t.filter(Optional::isPresent)\n+//\t\t\t.collect(Collectors.toList());\n+////        this.graph.addVertex(projectNode);\n+//\t\tthis.graph.addNamedVertex(projectNode);\n+//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+\t}\n \n-\t\tbuffer.append(\'(\');\n+//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+//\t\tval childrenPackages = iPackage.getChildrenPackages();\n+//\t\tchildrenPackages.forEach(childrenPackage -> {\n+//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+//\t\t\tpackageNode.setProjectName(this.projectName);\n+////            graph.addVertex(packageNode);\n+//\t\t\tgraph.addNamedVertex(packageNode);\n+////            graph.addEdge(projectNode, packageNode);\n+//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+//\t\t\tthis.packageCounter += 1;\n+//\t\t});\n+//\t}\n \n-\t\tString[] types = method.getParameterTypes();\n-\t\tfor (int i = 0; i < types.length; i++) {\n-\t\t\tif (i > 0)\n-\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-\t\t\tString typeSig = Signature.toString(types[i]);\n-\t\t\tbuffer.append(typeSig);\n-\t\t}\n-\t\tbuffer.append(\')\');\n+//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+//\t\tval classes = pckg.getClasses();\n+//\t\tclasses.forEach(clz -> {\n+//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+//\t\t\tclassNode.setProjectName(this.projectName);\n+//\t\t\tclassNode.setFlags(clz.getFlags());\n+////            graph.addVertex(classNode);\n+////            graph.addEdge(packageNode, classNode);\n+//\t\t\tgraph.addNamedVertex(classNode);\n+//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+//\t\t\tthis.browseClass(clz, classNode);\n+//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+//\t\t\tclassNode.setInterface(clz.getIsInterface());\n+//\t\t\tthis.allClassCounter += 1;\n+//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+//\t\t\t\tclassNode.setAPI(true);\n+//\t\t\t\tthis.apiClassCounter += 1;\n+//\t\t\t}\n+//\t\t});\n+//\t}\n \n-\t\treturn buffer.toString();\n-\t}\n-\n-\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-\t\tfields.forEach(field -> {\n-\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\tfieldNode.setShingles(shingles);\n-\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-//            graph.addVertex(fieldNode);\n-//            graph.addEdge(classNode, fieldNode);\n-\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t});\n-\t}\n+//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+//\t\tval methods = clz.getMethods();\n+//\t\tbrowseMethods(methods, classNode);\n+//\t\tval fields = clz.getFields();\n+//\t\tbrowseFields(fields, classNode);\n+//\t}\n+//\n+//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+//\t\tmethods.forEach(method -> {\n+//\t\t\tString statementBody = "";\n+//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+//\t\t\t\tstatementBody = method.getSource().trim();\n+//\t\t\t} else\n+//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+//\t\t\t\t+ method.getElementName();\n+//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+//\n+//\t\t\tallMethodsCounter += 1;\n+//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+//\t\t\t\tmethodNode.setAPI(true);\n+//\t\t\t\tthis.apiMethodCounter += 1;\n+//\t\t\t}\n+//\t\t\tif (method.getIsDeprecated())\n+//\t\t\t\tmethodNode.setDeprecated(true);\n+//\t\t\tmethodNode.setProjectName(projectName);\n+//\t\t\tmethodNode.setShingles(shingles);\n+//\t\t\tmethodNode.setFlags(method.getFlags());\n+//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+////            graph.addVertex(methodNode);\n+////            graph.addEdge(classNode, methodNode);\n+//\t\t\tgraph.addNamedVertex(methodNode);\n+//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+//\t\t});\n+//\t}\n+//\n+//\n+//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+//\t\tStringBuilder buffer = new StringBuilder();\n+//\n+//\t\tbuffer.append(\'(\');\n+//\n+//\t\tString[] types = method.getParameterTypes();\n+//\t\tfor (int i = 0; i < types.length; i++) {\n+//\t\t\tif (i > 0)\n+//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+//\t\t\tString typeSig = Signature.toString(types[i]);\n+//\t\t\tbuffer.append(typeSig);\n+//\t\t}\n+//\t\tbuffer.append(\')\');\n+//\n+//\t\treturn buffer.toString();\n+//\t}\n+//\n+//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+//\t\tfields.forEach(field -> {\n+//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+//\t\t\tfieldNode.setProjectName(this.projectName);\n+//\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\tfieldNode.setFlags(field.getFlags());\n+//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+////            graph.addVertex(fieldNode);\n+////            graph.addEdge(classNode, fieldNode);\n+//\t\t\tgraph.addNamedVertex(fieldNode);\n+//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+//\t\t});\n+//\t}\n+//\n \n \t/**\n \t * This prunes away the javadoc comments',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "c82267764fe895754822d57203483cc54cd44f7d",
        message: "Initial commit",
        stats: {
          total: 2580,
          additions: 2580,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [],
        committedAt: 1585100843000,
        changedFiles: [
          {
            sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
            filename: ".gitattributes",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# Auto detect text files and perform LF normalization\n+* text=auto",
            rawContent:
              "# Auto detect text files and perform LF normalization\n* text=auto\n"
          },
          {
            sha: "a1fc39c070f4f8ba52f278c15cd4d2121d07c8a8",
            filename: ".gitignore",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+.gradle\n+/build/\n+\n+# Ignore Gradle GUI config\n+gradle-app.setting\n+\n+# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n+!gradle-wrapper.jar\n+\n+# Cache of project\n+.gradletasknamecache\n+\n+# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n+# gradle/wrapper/gradle-wrapper.properties",
            rawContent:
              ".gradle\n/build/\n\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n"
          },
          {
            sha: "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d",
            filename: ".idea/compiler.xml",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              '@@ -0,0 +1,14 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="CompilerConfiguration">\n+    <annotationProcessing>\n+      <profile name="Gradle Imported" enabled="true">\n+        <outputRelativeToContentRoot value="true" />\n+        <processorPath useClasspath="false">\n+          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n+        </processorPath>\n+        <module name="refactoring-crawler.main" />\n+      </profile>\n+    </annotationProcessing>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="CompilerConfiguration">\n    <annotationProcessing>\n      <profile name="Gradle Imported" enabled="true">\n        <outputRelativeToContentRoot value="true" />\n        <processorPath useClasspath="false">\n          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n        </processorPath>\n        <module name="refactoring-crawler.main" />\n      </profile>\n    </annotationProcessing>\n  </component>\n</project>'
          },
          {
            sha: "a64b2758bd03a20260566a40b58c116679055c17",
            filename: ".idea/gradle.xml",
            status: "added",
            additions: 20,
            deletions: 0,
            patch:
              '@@ -0,0 +1,20 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="GradleMigrationSettings" migrationVersion="1" />\n+  <component name="GradleSettings">\n+    <option name="linkedExternalProjectsSettings">\n+      <GradleProjectSettings>\n+        <option name="distributionType" value="DEFAULT_WRAPPED" />\n+        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n+        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n+        <option name="gradleJvm" value="1.8" />\n+        <option name="modules">\n+          <set>\n+            <option value="$PROJECT_DIR$" />\n+          </set>\n+        </option>\n+        <option name="useQualifiedModuleNames" value="true" />\n+      </GradleProjectSettings>\n+    </option>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="GradleMigrationSettings" migrationVersion="1" />\n  <component name="GradleSettings">\n    <option name="linkedExternalProjectsSettings">\n      <GradleProjectSettings>\n        <option name="distributionType" value="DEFAULT_WRAPPED" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n        <option name="gradleJvm" value="1.8" />\n        <option name="modules">\n          <set>\n            <option value="$PROJECT_DIR$" />\n          </set>\n        </option>\n        <option name="useQualifiedModuleNames" value="true" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>'
          },
          {
            sha: "4fed64e0de33c78035aa4aa1eb052668eb85c6d4",
            filename: ".idea/jarRepositories.xml",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              '@@ -0,0 +1,30 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="RemoteRepositoriesConfiguration">\n+    <remote-repository>\n+      <option name="id" value="central" />\n+      <option name="name" value="Maven Central repository" />\n+      <option name="url" value="https://repo1.maven.org/maven2" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="jboss.community" />\n+      <option name="name" value="JBoss Community repository" />\n+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="BintrayJCenter" />\n+      <option name="name" value="BintrayJCenter" />\n+      <option name="url" value="https://jcenter.bintray.com/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="MavenRepo" />\n+      <option name="name" value="MavenRepo" />\n+      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="maven" />\n+      <option name="name" value="maven" />\n+      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n+    </remote-repository>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="RemoteRepositoriesConfiguration">\n    <remote-repository>\n      <option name="id" value="central" />\n      <option name="name" value="Maven Central repository" />\n      <option name="url" value="https://repo1.maven.org/maven2" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="jboss.community" />\n      <option name="name" value="JBoss Community repository" />\n      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="BintrayJCenter" />\n      <option name="name" value="BintrayJCenter" />\n      <option name="url" value="https://jcenter.bintray.com/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="MavenRepo" />\n      <option name="name" value="MavenRepo" />\n      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="maven" />\n      <option name="name" value="maven" />\n      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n    </remote-repository>\n  </component>\n</project>'
          },
          {
            sha: "b1662faf91f158c3fc95e7f294260c2ea0cdbc12",
            filename: ".idea/misc.xml",
            status: "added",
            additions: 5,
            deletions: 0,
            patch:
              '@@ -0,0 +1,5 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="ExternalStorageConfigurationManager" enabled="true" />\n+  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ExternalStorageConfigurationManager" enabled="true" />\n  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n</project>'
          },
          {
            sha: "e96534fb27b68192f27f985d3879e173ec77adb8",
            filename: ".idea/uiDesigner.xml",
            status: "added",
            additions: 124,
            deletions: 0,
            patch:
              '@@ -0,0 +1,124 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="Palette2">\n+    <group name="Swing">\n+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n+      </item>\n+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n+      </item>\n+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n+        <initial-values>\n+          <property name="text" value="Button" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="RadioButton" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="CheckBox" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="Label" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n+          <preferred-size width="200" height="200" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n+          <preferred-size width="200" height="200" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n+      </item>\n+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n+          <preferred-size width="-1" height="20" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n+      </item>\n+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n+      </item>\n+    </group>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="Palette2">\n    <group name="Swing">\n      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n      </item>\n      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n        <initial-values>\n          <property name="text" value="Button" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="RadioButton" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="CheckBox" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="Label" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n          <preferred-size width="-1" height="20" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n      </item>\n    </group>\n  </component>\n</project>'
          },
          {
            sha: "0f5826ff690d76f8961058a4fd1cf25f380882c3",
            filename: ".idea/workspace.xml",
            status: "added",
            additions: 143,
            deletions: 0,
            patch:
              '@@ -0,0 +1,143 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="ChangeListManager">\n+    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n+    <option name="SHOW_DIALOG" value="false" />\n+    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n+    <option name="LAST_RESOLUTION" value="IGNORE" />\n+  </component>\n+  <component name="ExternalProjectsData">\n+    <projectState path="$PROJECT_DIR$">\n+      <ProjectState />\n+    </projectState>\n+  </component>\n+  <component name="ExternalProjectsManager">\n+    <system id="GRADLE">\n+      <state>\n+        <projects_view />\n+      </state>\n+    </system>\n+  </component>\n+  <component name="FileTemplateManagerImpl">\n+    <option name="RECENT_TEMPLATES">\n+      <list>\n+        <option value="Interface" />\n+        <option value="Class" />\n+      </list>\n+    </option>\n+  </component>\n+  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n+  <component name="ProjectViewState">\n+    <option name="hideEmptyMiddlePackages" value="true" />\n+    <option name="showExcludedFiles" value="true" />\n+    <option name="showLibraryContents" value="true" />\n+  </component>\n+  <component name="PropertiesComponent">\n+    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n+    <property name="WebServerToolWindowFactoryState" value="false" />\n+    <property name="aspect.path.notification.shown" value="true" />\n+    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n+    <property name="show.unlinked.gradle.project.popup" value="true" />\n+  </component>\n+  <component name="RunManager" selected="Application.RefactoringCrawler">\n+    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n+      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n+      <module name="refactoring-crawler.main" />\n+      <extension name="coverage">\n+        <pattern>\n+          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n+          <option name="ENABLED" value="true" />\n+        </pattern>\n+      </extension>\n+      <method v="2">\n+        <option name="Make" enabled="true" />\n+      </method>\n+    </configuration>\n+    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n+      <ExternalSystemSettings>\n+        <option name="executionName" />\n+        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n+        <option name="externalSystemIdString" value="GRADLE" />\n+        <option name="scriptParameters" />\n+        <option name="taskDescriptions">\n+          <list />\n+        </option>\n+        <option name="taskNames">\n+          <list>\n+            <option value="dependencies" />\n+          </list>\n+        </option>\n+        <option name="vmOptions" />\n+      </ExternalSystemSettings>\n+      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n+      <method v="2" />\n+    </configuration>\n+    <recent_temporary>\n+      <list>\n+        <item itemvalue="Application.RefactoringCrawler" />\n+        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n+      </list>\n+    </recent_temporary>\n+  </component>\n+  <component name="SvnConfiguration">\n+    <configuration />\n+  </component>\n+  <component name="TaskManager">\n+    <task active="true" id="Default" summary="Default task">\n+      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n+      <created>1584971244282</created>\n+      <option name="number" value="Default" />\n+      <option name="presentableId" value="Default" />\n+      <updated>1584971244282</updated>\n+      <workItem from="1584971249949" duration="21487000" />\n+      <workItem from="1585056855574" duration="4355000" />\n+    </task>\n+    <servers />\n+  </component>\n+  <component name="TypeScriptGeneratedFilesManager">\n+    <option name="version" value="1" />\n+  </component>\n+  <component name="WindowStateProjectService">\n+    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n+    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n+    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n+    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n+    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n+    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ChangeListManager">\n    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n    <option name="SHOW_DIALOG" value="false" />\n    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n    <option name="LAST_RESOLUTION" value="IGNORE" />\n  </component>\n  <component name="ExternalProjectsData">\n    <projectState path="$PROJECT_DIR$">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name="ExternalProjectsManager">\n    <system id="GRADLE">\n      <state>\n        <projects_view />\n      </state>\n    </system>\n  </component>\n  <component name="FileTemplateManagerImpl">\n    <option name="RECENT_TEMPLATES">\n      <list>\n        <option value="Interface" />\n        <option value="Class" />\n      </list>\n    </option>\n  </component>\n  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n  <component name="ProjectViewState">\n    <option name="hideEmptyMiddlePackages" value="true" />\n    <option name="showExcludedFiles" value="true" />\n    <option name="showLibraryContents" value="true" />\n  </component>\n  <component name="PropertiesComponent">\n    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n    <property name="WebServerToolWindowFactoryState" value="false" />\n    <property name="aspect.path.notification.shown" value="true" />\n    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n    <property name="show.unlinked.gradle.project.popup" value="true" />\n  </component>\n  <component name="RunManager" selected="Application.RefactoringCrawler">\n    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n      <module name="refactoring-crawler.main" />\n      <extension name="coverage">\n        <pattern>\n          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n          <option name="ENABLED" value="true" />\n        </pattern>\n      </extension>\n      <method v="2">\n        <option name="Make" enabled="true" />\n      </method>\n    </configuration>\n    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n      <ExternalSystemSettings>\n        <option name="executionName" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="externalSystemIdString" value="GRADLE" />\n        <option name="scriptParameters" />\n        <option name="taskDescriptions">\n          <list />\n        </option>\n        <option name="taskNames">\n          <list>\n            <option value="dependencies" />\n          </list>\n        </option>\n        <option name="vmOptions" />\n      </ExternalSystemSettings>\n      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n      <method v="2" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue="Application.RefactoringCrawler" />\n        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name="SvnConfiguration">\n    <configuration />\n  </component>\n  <component name="TaskManager">\n    <task active="true" id="Default" summary="Default task">\n      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n      <created>1584971244282</created>\n      <option name="number" value="Default" />\n      <option name="presentableId" value="Default" />\n      <updated>1584971244282</updated>\n      <workItem from="1584971249949" duration="21487000" />\n      <workItem from="1585056855574" duration="4355000" />\n    </task>\n    <servers />\n  </component>\n  <component name="TypeScriptGeneratedFilesManager">\n    <option name="version" value="1" />\n  </component>\n  <component name="WindowStateProjectService">\n    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n  </component>\n</project>'
          },
          {
            sha: "669e8aabbeb973fc803553332427c4c3309bf0b6",
            filename: ".project",
            status: "added",
            additions: 17,
            deletions: 0,
            patch:
              '@@ -0,0 +1,17 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<projectDescription>\n+\t<name>refactoring-crawler</name>\n+\t<comment>Project refactoring-crawler created by Buildship.</comment>\n+\t<projects>\n+\t</projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n+\t\t\t<arguments>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n+\t</buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n+\t</natures>\n+</projectDescription>',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<projectDescription>\n\t<name>refactoring-crawler</name>\n\t<comment>Project refactoring-crawler created by Buildship.</comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n\t</natures>\n</projectDescription>\n'
          },
          {
            sha: "e8895216fd3c0c3af4c4522334775f41b7deb42e",
            filename: ".settings/org.eclipse.buildship.core.prefs",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+connection.project.dir=\n+eclipse.preferences.version=1",
            rawContent:
              "connection.project.dir=\neclipse.preferences.version=1\n"
          },
          {
            sha: "bd1f8bca1aac632eadf627f03cf51f2c130c8fe2",
            filename: "build.gradle",
            status: "added",
            additions: 52,
            deletions: 0,
            patch:
              "@@ -0,0 +1,52 @@\n+/*\n+ * This file was generated by the Gradle 'init' task.\n+ *\n+ * This generated file contains a sample Java Library project to get you started.\n+ * For more details take a look at the Java Libraries chapter in the Gradle\n+ * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n+ */\n+\n+plugins {\n+    // Apply the java-library plugin to add support for Java Library\n+    id 'java-library'\n+}\n+\n+repositories {\n+    // Use jcenter for resolving dependencies.\n+    // You can declare any Maven/Ivy/file repository here.\n+    jcenter()\n+    mavenCentral()\n+}\n+\n+dependencies {\n+    // This dependency is exported to consumers, that is to say found on their compile classpath.\n+    api 'org.apache.commons:commons-math3:3.6.1'\n+\n+    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n+\n+    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n+\n+    compileOnly 'org.projectlombok:lombok:1.18.12'\n+    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n+\n+    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n+    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n+    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n+\n+    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n+\n+    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n+    implementation 'com.google.guava:guava:27.1-jre'\n+\n+    // Use JUnit Jupiter API for testing.\n+    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n+\n+    // Use JUnit Jupiter Engine for testing.\n+    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n+    implementation 'org.jetbrains:annotations:15.0'\n+}\n+\n+test {\n+    // Use junit platform for unit tests\n+    useJUnitPlatform()\n+}",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "5c2d1cf016b3885f6930543d57b744ea8c220a1a",
            filename: "gradle/wrapper/gradle-wrapper.jar",
            status: "added",
            additions: 0,
            deletions: 0,
            rawContent:
              'PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MFMLK-.\rK-*R03-IM+I,\u0001\n\u0086d\u0096Z)\u0017%*\u0084\u0017%\u0016\u0014\u0016rr\u0001\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/gradle/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000org/gradle/wrapper/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000f\u0003\u0005\u0000\u0000\t\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.class\u008dV[W\u0013W\u0014\u008e\u0099d`\u001c\u0005c@\u0083\u008a\u00837\u0012.\u0089VJ \u0001-\u0001lD\u000e!\u008cNfK\u0017{\u0007O]}\t\u008b\u008b>i\u0099@\u0012\u0082,\u00993}g?\u0005p\n?(\u0088\u0082\u0082\u0001LxKE\u00052(\u0098UL+\b!`\u0006b\u0081Bv\u0007dde\u008c(\u008c\u0005\u0005g(N\u008e\u008c\\\u0007n\nwKb%\u0096\u001dxW{x_\u0086\u0081e+8\u0084\u0082\f\u00109gX\u0086;\u0010J$\u0017\u0019I@\u008caji\u0099;I\u0092h\u0018.\u0094U\u0090N1]t\u0082\u001d\\N\u0082m\u0015\u0097^ftrg\u009c!\\\u0011[\u0086c\u0089\u001d\u009e\u009e6u\u0098\u008ea\u0015}\u0089a/\u0019&\u001f\u009d"EF\u0099AC^K\u0094fc\u0086NPyr\u0003w+\u0095\u008c\u00ad\u00178\t\u0085\\H\u0018\u0097(kO!\'\u0012\fwW\u0002C_\u0083\u0082WL\u009ew\u0019i6\u0013\u001c\u0090\u0017ku{nh\u0082w\u0011W3zS\u0093B.>kVEF\u0091bX\u0085\u008c^\'Zk%CZ1\u0084Ur\u0096N\u009e\u000b9QJ)a\b\u008e8\u0087\u0019m\u0013\u0083x\u001d\u0019wU\u0098(T(@,GpQUq\u000f)e\u0099\u0094_\u0094Y\u0092\u008b\\T<C[L\u0088[R!>b\u0014_[C\u0018\u009fP\u0002\u0093]\u0082G\u0015\u009fh\u0090o\u009d\u0016yX\u0016}s|K|EhF\u0083FSC\u0088\u0012\u0091\u008a\r{3\\r\u008d\u0012(\u0010Ij\u00164v5\u0093*r]\u009a\u000fL\u000b|jWi\u0086\u0015\u0088\u000b\u0006X\n\u000f`JN=]\fCA\u009bG\rv-6J\u0017\u0088DzL\u008d7\u0017{\u0099\u0099!\u009e\u0096r\u0005\u0012+r7RE\f<Zx\u0098u\u0087[43\u0092\b"mc%\u0006GCk:\\\'\nv\u008ep\u0014\u009aR\u0091|\u0085\u0093mE_\u0005:Ma\u0005`\u001dZP\u009e7,mIhD\f\u009e}\u0097l/^4\u008b\u0092[ET1\fG[\u0006J\u001bD\u001ejj\\q.d"\u0099dB8\u008b\u0004n\u0095\u0091MIw\u008a\u0090\u009ev<$+CJ-@\u0090\u0006F\u0017\u0093<@f\u0017\u0002\u0013#\u0090c\u0096\'gxh\rWqZ#\u009ep?N\n\u0018D\u0082\u009e\u00ad\u0018"-2f\u0003\'\u0093\u008c\u000f\u008da\u0013\u0084r\u001f\u0090r\u001a5D\u0090kXC\u0098\u000e%.3.E\u001av\u008d\u0085n\u0085\u001a\u008cE\u0011F\u0082h.4L{o\u0010{,~C\u000f\u0083HN\u0092;\u0081NZ(\u0001q\u0010?\u008d~\\a,@mZ\u0013\u0091\u0015?zb7\u008c\u0011\u000f\u0010(R\u0004$B\u001b\u000b\u0091\u0005\u009cK\u00144\u00ad2\u0081\u0016>O\u0015:S?{\u0095^#I?s\n&\u0018\u0090-\u000f\u0092\u000b0e0N\u0091\u009bSgg*B\'\rG\u00ada\u007f\r\u0099\u0091\u00133R\u008ftG\u001c\u001e\u0091N\t\u0092j\u008b\u001ecD_\u001eI<\\?j\u001d\u0087\u0095VK\t\u00924\u0002=JO\f\u0016th\u001b\u0013\u0004XhMo\u00103<P\u0011z\u0086\u0098\u008c7\u0018;/5:\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQ}\u0000\u0000\u0000\u0000\u0000\u0000#\u0000\u0000\u0000org/gradle/wrapper/Download$1.class}\u008cM\n0\u0010\u0085h5*v/\u0082\u000b\u0006\u0082?B\\x\u0082\u0086\u0012\u0092\u0092T{7\u0017\u001eC\u0089)\u0019\r\u000f^\u0013\u001aC\u00060 $g{s\u0099\u0017Z\u0012[\u0018mE,]\u0010&;\u0093i\u000b\u008e\u009c!!S\\9\u0091k\u001b\'J:-V\u0084\u00186Zx/=!m\u0016F\u0094YM\u0098iH t\u009dnX\u0004\u0017\u0017~\u0084~8\\\u0012\u0018j\u00814\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.class\u0095S]O\u0013A\u0014=-l]XWmEC@v\u008b_\u0098\u0090\u001a\u0012\u0093jHP\u0012N5N3\u009dZ\u008fLD_\u0084h\u000fG\u0019\u0094\u0082\r4Eags=wn?\u0001c\u0007\u0013\u0098ub\\\n\u000enb!\u0085\u0014\u0096\u0096\u0083ev\u0090\u0080oc\u001d\u0086ga\u001c\f\t?\u0090,\u009a`X\tc#\u001b\u0013Q*\u008f\n\u001fLF\u0086\u0092{n\u0088X\u0087Ubp_P\u0088Z\u00820\u008aTx-\u0012AGfS\u0085\u0091\u0002%\u0086\u001bDHU\u001b\u00852fX\u0095\u0003\u000fb\u0083\u0092\u008d\f\u000b%Wd\u0098;\u0007l\u008a\u009e>N\u0015\u008c\u000f\u0017iL\u00929\u009e\u0018&\u001bZ7\u000bM\u0096P6( K\u009b82$\u008b6V]\u009a\u0003S\u008dG\f\u0085L\u0086\u0089S\u0089\u0099\u0091M3dz\u0088`b\u0097aEIB._\u0019\u0080h\u0015Rl\u0088\u0010?R3cdBr\u008358\u0099H2CnH\u0089\u0099\u008861O\u0085\u0012 A/\u0080N\u0001\u00ad4\u0003\u008c\u00ad\u001cJ\u001b\u000b\u0019\u008f\u0082\u001fq\tf>=\u0000<\\5\u0089,r}+\u008a\u009a\\\u0007\u0012!q>D\u001b.\u001cr"\u0011\r\'OtL\u0012\u0003#i\u00021\u0097~J\u0086\u001e\u0001:{\u001b=\fJ[z\u001e\u0097\u009a\u0081eR\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005<\u009b\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000org/gradle/wrapper/Download.class\u009dY\t|\\Y\u007fNXi;\u008e\u001d\u0089\u0013Kd\u0092\u0095v<IO][JJCJ\r%\u00844@@)\u008d&\u0004@\u0081rS(PP\u0016hZ?\u0087v\u00adH_4o\u009bo3^\f\u0080\u009d \u0082g\u009aT\r59\u0013\u0019o\r|>\u0088 ~\'\u0088\u0005\f~_5\u007fxP5\u007f\u0014\u000e\u0081/\u0018\u0093 \u0096O\u0083\b\u0082x\u001e_T_R\u009f\u009b\u008b \u008fT_\u0019u\u0010o\u0082[|E5\u007fWEi\u007fo\u001f\u0082G\u0093\u0081\u007f6z\u0010\u009b/~\u007f\u0080\u0089\u0006j;#\u0088g\u009f&KQ[5E\u009a\u0081+}G5\u009aS7T\u0086j\u009ao)\u009dn\u009aBEL0\u0010_\u0010YSJ\u0080,b\u009eI7IU\u0010]\u00124:\u0088kb\u0099RcH\u00ad"\u0099Ro2\u0003O\u0018\u0012\nrYaJ*CV\u001b\u0094)k\rYg \u0086d\u0083)\u001bME\u001b&\u0094[M\u0094l1vS\u009a6fH!M\u0002+\u0091p\u009dJ9)AM^\u009e9\u0090&\u009d\u0084\u0017\u001b+\u001b9{hWo\u000f\u0017\u009d\u0098h\u008bzn,1OP\u0099L<;\rcJHh\\Qn"\u0090JkAu\u0087EN\u001f\u0004\u001aH\n\u0093\u0013\u0013\u000e\u00adN\u0013m\u0013=\u0016w.uI\u008a18\u001c\u0097!M\u0092\tA\u009b\u009cp\u009dT;\u0096\u009c\u0084>\u0007\u0093\u0097\u0012=\u0080\u009d;\u0007\u008e%b~AG\u0012\u001a,6}1e\u0090\u0099\u001c\u0092u\u0084\u0093\u009e\u001aq\u0001{$(%G\u00908Gy\u00931\u007fR*S\u0092\u009a}7Y3\u008f&\u0013\u0089,L\r\u0006T\u0013\u000b\'\u009c5XN\u0096\u0086\tk\u001bI\u0089%\u000e\u008e\u0096`ccJ5K)+dIyDNVmZ&\u009a\u0084\t;Nn|\\V\u009bN9\u0081\t\'\u0097\fHz|\\eL\u0099\u000e\u0093HO;J\u001aNoyNb\u009bd,9\u0099L+!c"\u007f\u000eW\u008a)\u0011H8JU*P\u0099L{\u0082U\u0005szt\u001d{\u008a\u00151._Y\u0098JO\u001abH!m\u0086l7d\u0087!;o\u001ew\u0006\u0098`\u0002_o[O:$f\u001d\u0094M\u009fwxn+\u001bF\u0005G\u000bc\u0086\\9+1\u009e$\u008c)gC\u0089Q]\u00017\u0094r\u0000R?xE\t\u009bL\u0097k\u008b\\g<Nim9[\u008ef\u001a[\nO#HE]u\u000fn<V\u0016q\u0015\u0012)\u00881#\u0015\u001a2\u0004K\u008cE=\u009a\u008e\u009e3X\u00ad\u0003Rj\\B#\u009a9M/%]Z\u0013*Ng`EC\u001d\u0082\u008a6$\u0014ZWg\u00079X\\6?U\u0005\u0092,\u0080V%S\u0003(\u0093<\u0018MQG\u0095\u0018s;\u009f\u00adj\u001f\u000b\u0097j\u001e"ey\u000bi\\%\u000b\u008fI\u009bn\u009dV`47NKv#\u0082%is\u0087rd\u008f!wYW-\'w[r\u008f.Og,W#@C\u00173V\\M,b(\u009eR\u001fPM\u0087%\u009dr\u0087a\u000b/a\u008e.P\u008ah\u009f[rH\u000e[rD\u008e\\Z\u0000K\u0098%\u0090\u0013\u0096H%}J\'$c\u0012Sp=g\u0090~K2 X^B\t-#\u0097ThaR\u0096T\u000fZ2$\fy\u008b%r\u00923rV\u0000K\u0097\u0001K\u001ePa\u008a\u0013\u0092s\u0098AJ\u0011\u001bU\u0018\u001bX`VWKY2.\u0013\u0082+\u000et\u001c\u0089\f\u0098h\u0091\u0003\u0003}\u0011\u008d\u001a\u0091R\u0088$/:nNP\u00943"2\u008f\f\u0011/\u0019#s\u0084\u008b"G\u0003#c<\u0088HZF\u000e1C-KXQ\u0091tA`\u0095Y%9\u0090Z\u0006:@V=\u009dI\u000b?\u008f\u008fX\u0012SV\u009e\u0097\u000b\u0096\u0085PRlC\u0094%\ta\u0006\u0087@-\u0099\u0096\u0087rTvsaEm\u0016|\u0006\u0092Y\u0085rr\u008a!\u0010\u0092\u0094\u008a\u0083\u0003\u0087[\u0098iX\u0097_\f.\t"\u008azTu$\u0096\u0018k=h{73\u0010\u0094}}\u001a-\u009b\u0006^V\u000e\u001e\u009b\f\u0011t~~\u001eZ)h]&0\u00987DcH"ER$u\u0018\u008b\u00906C\u0088\u001c\u001b:\u0012\u0091,[2\u00ad\u0092Q\u0003\u0094\u0097=\u0015\u0096*@z1\u0007kVn\u0094\u0083pj\u009eb$S\u00adY\u0014\rWB5\u00ad\u0092j\u0092\u008a4lIm+Z<B,)S]\u0007\u000bw\u0099\rK!\u000eV|\u0086\u0088]\u008c\u008fbLH\u0014\u0017\u0017swI\u0082\fLKK\u008a\u008f$<rQW\u0096=Jo\u0086wCJf)\u0010\u008fi\u009d7%W\u0081y{\u0016\u001d\u0082);\u008c8\u0013\u007f]qXQbm\u0097\u0087\u0085/0ua,4\u000bKj\u007f\u00148x\u001a\u0016_4\ro\\j\u0096&\u008a\u0003v\u009e%\u0017\u0010\u00adw\u001eJv:\u00ade9$\u008bL-eD\u009dP[\u00863\u001djX_\u0092\u0012kU\u008fK/\u000fYzR]\u0087LOIA\u0093e\u0094!\u0087]\u0094s\u0085T\u0004En/^9iQSra:US\u009b\u00adC\'\u0010)^:E\u0011\u0089\te\u0005c\u0094Knc\u0002\u001amW\u0097TiJh<\u0099R&$::(1?\u009aLy^\u001fA0ULN\u001d\u0085\u000e\u0094M\\YL\u0096)\u001b\u0002\u001dO-\bUzMsG\u00adz\u0085NQEt[l\u0097Nx1[2MH(\u0095\u0017b\u0092\u007f\bWf\u0099Ek\u008awYX\u009dXb\u0002C\u008c\u001f\u0094qm\u0088rX\u008c~rYUB\u000em\\:G\n\u009f}7t.\u0015+\u0095}\u0092x\u009d\u0005&\u0094T\u0019\u0013r\\\u0084\u0081\u0081\u00810b8\u0005\u0000\u0015\u0088c-\u0090(\u008c\u0093\u001cO\u0017\u008d\u001fBH\u001e\u000f\u0007\u0084s_>#\r\u00922f> [$-\u0090\u00176\u008fh\n\u009b`V\u0095,#\u000fo?UiA{JT\u0085)a\u0095Z9\u0011\u008c!pc,*\u001a\u009b\u001a|\u008da5\u001b\u009b!\tc^F\u001a\rl-vb+V\u0081\u008e\u0086\rB+cA\u0097\u008d\u0005]6j3+t\u009eG*\u001fQ9\u00adz\u0096\u008a\u0090y\u001dU7P;\u0087:,KVo\u000fZ\u001cl+.\'\u009aW\u0096\u0093\u0003x\u0007EdZ\u00175gP\u0093AY\u0098\u000e\u008b;\u0091\u0092\u0082Mu\u0082\u001fC\u008b?\u008f\u0094(\u000b\u0084\u0080\u0086\u000fv\u007fug=0\u0087\u001c\u0096\u000fS\u008aY\t\u00072Xkl\nf\u009a._n\u0084}p`m\u0097v\u0006|l7h`\u009e=5a\u007f`\u008a1u\u001dd\u0010y\n+?\u0086M[3m\u000e\u009b\u0087C[fqjVV]U+u=\u0013\fm\u0094&:{I\t@H}\u009aV\u0006$\u009a\u0002h\t\u009b\u0095+2h~\u009a\u0096\fZ\u001b0\fZn\u0091\u0094/\u0086\u009a\u000fNuu|U\u007f!}/\n}\u0087\u0004\u0097\u008c\u0003\u0089\u000et=\u0088.\u001cF\u001f\u008eG1\u0018\u008e\u008e3\u009d\u0099=\fK/\u009e 8\u0089\u000f\u001f\u001f%1\u0080Wq\u008aO\u000b8\u0083/,\u008c\u0007\u0015\u009c\u0016uY\u0011< ~\u009c\u0093*baD\u008fR\u009bZ\u0082wG\u0018\u009dx\u0016\u008f3q\rJ\'\u0098.\u000f\u007f\u008c\u007fU\u009468{A|\u0004?\u0081\u009fD5u\u008cWCk^OV\u009fJ\u008c|J\u0097K))U!x\u0012C\u008b\u0089h\u0093_\'\u008dk\f73\u0006\u009e5~\u0003\u0019x@\u0081\u0013\u0010\u001fd\u008d.%\u009a\u001bIM\u0003\u008b\u0019\tQ7iM\f\u0014]\f|&\u000b~L\u001f\u0019=e-*\u001cS\u0091*Ms1\u0098Nas\u0007vN\u009eYuP\u0001B\u0011\u000el">H\u000f9\u0011\u0098\u0083\u008dM\u001a|/\u0086\u009b(+\u0083}OI|7\u00939t\u001c\u000f}\u0019\u001ch$\u0014w\u009bA\'s\u001e\u008f\u0098\u001etCtd\n\u0089s\u0011=y\u009c_\u0091\u0005\u001c\u008f\u0017\u0018`:\tw46]cv\u001bf\u008cV\u0014\u008cL&P)q\n\rpq`\u0006\u0087N4\u0087\u000egp$tXOs\u001aw8\u001e\f\u009d\u0088\u0092k\u0011d\u000f~N\fW6\u008528I\u0086W\u007f\u0095+\u0007\u0095a\u009f\u0094nah8tJ\u0001[^\u008a&\u008b$\u0083OK\u001f7Fz\u0006d\u008aa\u0092\u0093,~\u0016$KQ\u0016c,$\u001ar\u0002\u00921j\u001f\u001b\u0092KeFp\u0092>\u001ecE\t\u0012\u001fcOa\u0005_?+\b\u007f\u001c\u009f\u008eMI\u0095:7Y\nTJGo\\\u0015H$h*\u0097d0\u009b;\u009eH\u0005sGh\u0098\u0087\u0089i=7p\u000b\u0091n]._x\u001coLK6_2^-d*}R\u0097\u0001|\u0092\u008fe\u0014a\u0099LQ~\u0087e^au}[\u0004\u0092O\u00162\u001aM4k}9\u0012rz~\u0091BTb\u001f\u009f\u001av\u0087\u001e\u009eS\u0086\u001ed\u000b\u000f\u008dO 4Zo\u00003}a\u001f?0$:\u001c\bg\u0084\u0003a):\\\u001fhfcDcl\nU<\u0000\u0095!\u0096t\u0098GX}[Y}Y\u0085r\u0005\b\u009f\u0091\u0018\u0088OkB\u0004\u0080h\u0084\u0097\r!*z\u0085=?\u008d_a/@W_\u0084FU`\\_M\u0013EN"mPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L\u0000\u0000\u0000\u0000\u0000\u00001\u0000\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classu\u008d\n\u0082@\u0014E+j\u0015DE@\u0096E\u0090\bERI\u001f\u0088#3c[\u008b>\u008f\u008a4v\u0017\u00879\u009c\u0004\u0083O\u0098.r%J[\u0099M\u0016\t\u0084,]\u008a\u0082\u00ad8\u009fk\u009f_\bPU:]\u009a3aG\u00ad\u0012\u0004\\^&at"\u0012-\u009cE\u00adeY\u0016\u0014\u009b\u009b8\\3\u008eK t\u008e\u001cB\u0017Nk\u0081\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.class\u0095Ws\u001bW\u0019\u001dYu|iVMNZ*;\u0095\u0006J\u008alB\u001cNK\u009c\u008e[\u0097\u0090t-\u009d\u001bvj\u0015S\u009aB[(P`x\u000f\f3L$x\u00860\u001b\f\u007f\u0001\u008f}\u0085\u0019\u00180+9%L=sO\u001f\u0000\u001ct<\u008agZYjxNG\u0014_pNG\u001c\u0097\u0086\u000bx^mME\u009cSKA-EH\r\u0017\u009b1\u000b::`vIb3l\u001dI\u009eDIG\u001e\u008equ\u0094fxJ_\u0019~\u0002Oc\u0014\u0097u,J\f\u0004\u0096\u0015\r_5\u0081\u000b#\u000bSgGF\nt\u008e_2/\u009bYtSg9\u0002\u00adCSM\u009f1\u0014h\u00ad\u0092tDE@\u0005v\u0094];.\u009b"\u0007,\u008f\t2|\u008c@t-RmrjiNz\u009c-\u0095=`3gs\u009d\u0018\u0017,j\u008e|v3\u008b.yf,\u0095\u0082]\u00adX\u0097\u0088eBAV*\u0013cK\u008f\u008e\u0080 0\u0098\t\u000fOU\u0005)T=O:~vme{]\u0093s\u0097dW\u0095-3Qd\u0085E\u0081!C\u0085\u0005q]\t\f0\u008aE\u0095(;&f\u0017*2B5\u008f?\u0002^}\u0099\\jL\u0096C\u0087l\u009dtGuZ5["\u0018\n\u000fMn,rQ\u0096\u0087t1\u0095\u0084),,N\u0098@L5|C75|K@gd\u0088\'h\u009awLQtnk\u0011\u008e}2\u0086\u000ets\u0013\u009f&J\',VXjt\u008a\u001d%syN\u000enE>]o3\u0095;6\u0082\u008b\u0010\u0010lKq\u0014o\u001b\u001eF3VB\u008e>%l\u000fW\r\u001c!\u00038$`\u000f\u000b\u0003\u009bD\u008b3"\u0019x\t\u0011D]A\u0085E\u0003U\n\u0081W\u0081x\u0095cLQ\u00adV$\u0081Cn.\u001dO\u0017<i2]6U\u0006\u0018\u0017]/\u00ad \u009aHi\u0003\u0085\u0086~``\u0012\u0005\u001e\u001b,\u0005"\u0092\u0081\u001fG\u0006~\u008c\u009f\u0018x\u001ag4n\r)\u0090\u0098\u000egL\u0098V\u0081\u0094 M\u000f\n\u000b\u0098^2-\u009f\tL\\:l\u0006\u009e(3e:j\u0081qZ/\f\u0012WY;A\u008b}3\u0002\u0005\u0013r\u008dS#\u000e\u008c\r^L/xR\u0092X\u009d\t\u0011|:u\u0098Li\u0091\u0094YLv\u0083;\u0014\u0089\u0099\u00ad\u0012u!I=A\u0011\u008d\u0097\u0016\u0089\u0088\u009e\u000bfUyLX\u0095uc\u008d\u000e\u000fU\\ pv\u008eQ\u009fN\u001cv5|o9Lrt\u0086K\u0093\u0089Ul)\u0095;\u0093Wv\u009c\u008f74O\r\u0086\u0096+,1\u008e\n\u001cF[F\n\bf\u000e>#\u0080&\u0090A7\u0004zx\u008a \u0081N5@T3\u0084(\u0090z\u0098Y4\u0017}\r\u0088\u009e]\u001f \u00034\u0017\b?\u0016\u0088Evq\u008f\u0016\u001c\u000e<\u008f\u0016 \u001d\u008aL\u0010\u0098\u0011N\u0019\u008ap8>K.\u009a\u0089\u00191\u0002\u0089\u0015Dg\u000f\u0010[A|\u00064n\u009bkhLp\u0081SES\u001av\\c\u0016\u0012~\u001d]+\u0098\u00advvR\u00885dw\u0016\u0098\u0019=#r<\u0089\\K\u008f\u0018T8\u0082lo\u00037`.\u0096\u008a\u0090S\u001a\u001e\n\u0018W\u009a\u008aT\u008c\u000bU4]\u0089~T7\u00876\u0095\u0089\u001av\u00067\u000eBZ H\n\u0014@\'\u001dc \u009bKl\u0093\u009d31\u001a\u0099c\u001c\u0089\u000eDQDDwp>\u009ePz\u0013\u008fp}\u0094\u0004@8B \u001cgm*&\u000b_$W\u0099\n\u0002+\u001ak\u0006\u008er}\u000eF\u000eA?~\u008b\u0001(\u0082AZ\u001d8\u0089\u007f\u009f:\u0017\u008aq\u00118\u00ad\r\f\u009b\u0093"\u0089\u0085Q\u0017c\u0000?\u0085\tz5)\u000e\u0093q\u000ej\u0085\u0099sDP\u0019h\thF\u009b9\u0088\u008b\u0006\u008eu\u0011>\u008fc~\u0002iM\u0088vz5HM\u008d\u009d \u008a\u000b\u0086$?b\u0087)nI\u008eP$)S\u0083\u001a\u008a\u009dh\u0007B\u0086\u0086<\u001fq0.\u0003\u0083\u001ex\u008f\u0018d(WW\u008e\u0004w@M\u0089\u0003\u00ad5S<\u009f\r\u0092a\u0084<u.\u009f3\u0012Gh\u0085G\u0004At=\u0092dl@]\u0012\u0085\u0002ys\u008e:m\u008c\u007f\u009aO\u0095\t\r\u0091\t\u008d8\u001bx4?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.class\u008dSN@\u0010=\u000b$v\u008c\u0081\u0094K\n\u0014J)$\u0005\u000bE`@"\\\u0094@<E&Y\u0005\u0083#_\u008b\u0004H}C:\u0084K \u000faf9?~\u00020\u0083\u0005\u0005Q\u008cIx&c\\\u0004\u0012\u0012\nB\u0098\u0094\\_D\u0082)\tI\u0005\nd"\u00941-\u008c\u0084Y\u0086eceq7\u0093_M/.\u008cnH6\f\u0006-u`\u001e\u009bm:%={\u0096S0t\u009b\u0097Nom\u001b\u009d\\~1t,N7\u001d?kUN\u008dl\u008d\u001a\u009e\u001c_`h\u008d\'\fmKn\u00916t,\u0087oV\u008fc\\p\u000b\u009d5=K`\u009boU\u0018\u0012)+%,\\\u00992`[\u009a{S{X-\u0093R\u0003\u0010\u008d\'j\u0016-W_lN\u009c\u008e\u008co\u0016\u000e7r0F+\u0006y`\u0085*\u0019\u00152\u009a\u008dI\u008a~*z0qOi$JV\tO\u001f\u0012^x\u00839\u0006@-o\u009f\u008aw\u0098S\u0000\u001aC\u008fjE1Dx\u000f2+`\u0015H}n\u001d\u0082\u00005B\'\u0015\u009f\u001f1\u0097d?a\u0018\u008f8\u0089fw\u0019\u0091nB\u0098q\u0098\nqhN\u0091a^-N\u00853\u00940d6\u009e\u0088\u001bjEL\u001c\u001bU1tS&>-\u0001sc-\u0011gO\u0088N\u0099Q\u000eM\u009e\u0081}\u000b(1\u008a\u0000#\u008aj\u008d\u0080\u0001\fR\u008e`\b\u008f\u009b\u0004\u0080i\u00ad\u001cmP/\u0010QWM:\u0087\b\u0089;"+\u0006)\tQ\u001cg<D\u0087)\u008e`\u001cW\u0083%L\u0012&|\r\u0007[[\u0088\u0006\u0099_\u009a\u0098%7p\u0001%w\u0086vM%9:)\u009c\u0007"\u001aa\u00ad\u0097h`\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000org/gradle/wrapper/GradleWrapperMain.class\u009dX\u0007x\u0014\u0015\u0007\u009d"\u0013h>c@\'Q\u0084)\u0006\u008bf!\tIp @\u0002"p\u0080H\u0007wbo\u008f\u00928=N%\u0089\u0013;\u001dRN\u0015 8C\u0012?\u0095\u0005\u009d7oW\u0019\u001ey+\u0000V\u0089\u0005\n\u009eb3\u009eBl9\u00ad9**$\u0002U<\u0005\u0005~P\u0012x\u0011^Kx\u0082{TJZ\\\u0090\u008b/SrB+UtRj+a\u0093kZ\u0015u\n^\u001bx\n\u00817)x\u008a\u0085x\u008b\u008a\u0005x\u0082X,\u0001\u0003\n\u001e*x\u0087\u008aw]rx\u008f\u001cE?.*>\u0080\u000f`X\b\u001eR0F\u0015|He\u0015qE]\u0087\u0086\u008fQ\u0005\u001f\u0093\u009f\u001f\u0097\u008b\u009fPI|\n\u009fg\u0014<"9?+!I\u001c>/\u0087/"\u008a\u0082\u008e\t\u0016i?}\u0091\u009dGwvu\u0012\bDN\u009e\u001ch\u00adXr`\u0083V3\u0099_\u008f\r\u0081P\u0096H{[\u000e.g_W{o\u008e:\u0080Zbc,\u00197\u000b\u0094\u0085\u001b\u000bZ~J\u0089\u0092t\u0098a\u0086T\u008c\u0015\u0093,g\u000fR\u0002K"54`q\u008c\u000f\r\u0019VS\u00873=v$\u008d%+03|dGn\r\u0010cY@"o-\u0081j\u0097#f6m\u008b\rV\u000fY&\u0017\u0098\u0091\u0092\u0014\u00012M-F\u008a!J\u0019X\u0098g4\u001ekj5\u0013\t=/\u008d\u00102j&O\u0013HnX[\\6\u0012s\u0000Z\u0011C1\u0087\u0018!\u0091\u009f\u008fREt\u0091k_\u008e\u009bN\u0017k\u001f\u00954\u0013"n\u000e\fHezE!,r_M\u0096~\u0088m\u0093\u008b\u000f\u0014rI\u009f\u008d\u001a9\nn\u0010)\\\u0018\u0090\u0099\u008c\u00adJr\u0095^PP\u001cB2\u0085Kqf-\u0097\u0011In\u008bk\u0082r\u0017\u0010{%ml\u001e\u0084\u0012m\u0097\u001aS663\u009do,=\u001e=S\u001frr^7\u0004V\u0085\'\u008ej\u0089[&F!T{\u00155\u009eYrVH\u0081L\u0003\u000f\u00886L2n\u001aG\u0013\u0091`#(DB7-P2\u0087&s\u0019\nNs\u0096\t|\u0090Y\u008e\u0082j\u001eO\u009eS\u00021\u0016X\u007f\u001c;\r?\u000f5\b?V\u0013\r\u008fC\u0006\u0019D\r?\u0015B/+\r1<E\u0010Ni8\u0081*\u0086\u0002s<\u00928\u001ev\u0017P\u0095+\u0018n\u001elI\u008c\u0004\u0092|\u0097\u001f\u0004=\u0098VlN\u0098pA\u007f\u009f\u0004<I\u0015NY_4\u0015\u007fw\u0019\u007f\u009a\u0086\u007f\u001a\u009d\u000bk\u0091@U\u0096\u007frc\nqW !\u0014E\u0094i\'\u0015Q\tE\u0099O78AxNM\'X-\u0012_TjB\u0095Z\u008eSyMT\tM`s\u009eL\u009av\u0091\t\u00860\u0014\u0095n\u0088\n\u001d7\u00adP\'!qL\u0084lI\u0094\u0011_\u009c_Q\u0090\u0087N\u0018Q[\u0013SE\u0014W\u0088i\u009a\u0015\u0001Eib:47>\u009a\u0098\u0081k\u008a\u0098\u0089Yb63R\u0004\u00151G\u0013s%q\u009e\u000fB\u0004{(,\u00892\\;Nx</y2=\u001f\u0016\u0085\u001b&\u0094*,:y\u0003\u0088\\\u009b\u0088\u0087)2Z\u0081tH\u0013\u0096\u0095xl m19\u0017\u0097Rcd/(w:d\u00adl\u0099y\u009cB=`bX(mJ\u000bl\u009dDUCa\u0005P4\u0017\u0098%F;v\u008b\u0018\u0081p1\u0004}pK\u001bx \u000e\u0014wB\u0010)i\u0093j\u0085\u0006\u0017\u0098`xj\u008be\u0093v\u0086^\u0005u+y\u0016\u0094OG\u0080b8VC^i)\u00ad\u009ek^%\u0091s\u008bU\u0005\u008d\u001e\u0090m\u0093\u0019\u0014\u0097W:wrRZx\u001c\u0098WL.%+d;\u0096f\u0019Cq]\u0017\u0014\u0087\'\u0015]/mWjN\u00aduM64E\u009b\u0000\u0016\u008e)\u009fbH\u00ad\u0098}\u0098gX.\u0087\u001e^qE|\u0094\u008e\u0012oX\u0088\u0014]%s\u0017MxG6\u0014\u0016\b\u000b\u0098m:E\u0088S^;g;w2{\u001d\u0019\u009e\\\u008dSi=N\u0007w\u0086\u0086\u0083dO\f\u001e?+r3<JM\u008e\u0095d\u001c6R6`8u1\u000b\u0099\t\u001d(Ri\u009cL\u0095SR_\u0017\u009d\u001e1\u008b>au%\u0093\u008b\u0082\u008ag\u009f^\u0017\u008e\u0082W4O\u0087x\t\u001fl\u008f\u009b!\u0097\u0004!\u0088\bvB`\u0017gSPyw\\|w\u0086=yi\u009b7u\u008e4Wq\u0018S.9,8V8\u0010s\\\u0006\u001c\u0013[\u0089>\u001c$\u00177\u008b{T\u0015iWGP\u0016Y:\u0002N\u000eFQ7\f\u0017e?\u0010\u0095_Fe_Y\u0017z2\u0098\u009aA8F\u0092I\u0081Qrg<X.\u0005}\u008d\u0019Lo\u0018\u008cf%\u0090Z1\u008a\u0099d\u0099\u0095\f\u0082Ai\u0007G0WN5W.\u001bf56\u008ebA_r\u0014\u0082c@h\u00187\u008fba_?\u008c[\u0086h\u0014\u008b\t$\u0083q#\u009e^\u000e\u0006Tc)fa\u0019c9`\u0005:\u0092\u0095\u008eXZ\u0018\rg\u001eOC3F\u009cg\u008c.`\u000bq\u0090\u001e\u001c\u009dNF<:LwV"\u0083#\u009aB\t\u0097\u0088t\u0018e\u0094 t\u001c#\u001e$\u0011E?]~\u0094\\\u0006\u008e3\u001c\u0006\u009d>\u0080A(\u0094u\u0007\u008e\u0087\u0019\u0004N\u0012\u0002\u008b#p$\u001d9\u0002&F9J)2:r\u0014@0\u001aG\u0094>\u0092\u0096\u0091\u001dRM\u0080mC\u0007\u0096|iL\u0017\n\u0016\u0095\u0080u1J\u0095/b\u0096.\u0016%\u008er\u0002B9\u0088\u0096,,G\f\u0096oE)2\u0083[\u0087\u0018;\u000fnV\u000e\u008e,t\u009d7f:\u00835\u0019\u001d\u000f`jd\u0014\u0096\u000e\u0014\u001c\u00900[\u0012\u0003\u009b|\u0097g\u0004[\u0086qU:!l\u0015\u00186\u008c\u008b\u000er\r\u0093g\u001d6[\u001d\f\u007f\u0099\u0012\u0006\u0007a\u0004a\u001dO<\u009e0\u0089uPN\u0006Ypi\u009c\u008e;\u001cUg$~cO_-|{\u0015{\f\u0095\n\nu)\u0014Gg>\'\u000f\u0080\u0005\u008d\u0081\f\u008bn9S=\u0082.PS\u00819qw.pr\u0015Z\u00061\u0087b\u008aY\u009f\u0015S=\u008aDa(\u008e<,\u009c`*K\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0018\u0000\u0000\u0000\u0000\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/IDownload.classE\u008d\n0\f\u0086\u0014\u0011\n^b*\f\u0004A{(l\u001e|\u0000\u001fJTf $_u\u007f\u0000X! \u0089\u0094<!L\u009b\u009c_9Sd\u0087]\u0014~)l\u009dI\u0011\u008e\u0084`u\u008bEQfZ\u009d=,\u0013\u0006g5\u000f\tcmR\u0096\u001a\u009eH*\u008bB\u0018h\b\u008f*eS.\u00920\u008f\u009aO\u001d\u0002A\u001d\u0012Zp--c\u0003\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@c\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/Install$1.class\u009dW\u007f\u001ce\u001d~1\u0084\u0081\u0006\u0097\u0010\u0096d{\u0007-I+\u0091MZ\u0092&(\u0093f\u009a:;\u0003\u000f<V\u0014/\b\'EE)lS\u0080\u0088\n\u001d~>\u0002n6\u009bmla{<}w\u007f"\u0080Mxk\u0019\u001bC6Ge\u0093\u0093lL\u001c\u008ba3\u0014X1\u0098V`\u0010\u0094\u009c8r\u0094W\u0011r \u001bO6E\u001c\u008f!\u0083\u00131\u009c)\u0015\u0095\u008f\u0095\u008fTD\f\u0093rS4>#\u0005\u009760>\u008cq|^6_PE\u0018\u008cpt\u0096We\u0080\u0082\u008a\u0007U|C7cx\u0080\u0087\u0014<`F#\u0002\u00aduk\u00addtk7-C\u008a1\u009e2\u009d\u0094\u009c\u0010h\u00962Y\u0099\u0095\u0095\u0099kN\u0014=G\\d\u001b^jd\u009fJ+X\u008f\u009aK9\u0081R9WZF\u0084\u0086\u009b\u001a\u000bZQ\fO\u009bl\u001d.N\u000b\u0005,\u0086)`\u0010&\r\u0002\u001by\u000b\u009enYRni\u009bn\u0081\u0013K\t.\u0084FY/P\u008bQw\u008e\n\u0084{\u009d,o}y\u008d\u0084\u001e\'d\u001c2,kyy1,O)6[z`pz\u0012\'Y\u0091\u0087\u000e\u0012\u009a\u000fn\u009bWC\u001f\b\u000b\u008eVV\u000f;\u00991uwp\u0003\u00160\u0085>\u0084m9z\u0096\u008aGA?jC\u009c|8nX\u0010\u0006o\u0094\u0095\b]\u0004\u0017\u001eTr\u008e:\u0095\u009d\u000b\u000f\u009b&Z\u0086==35}\u0015\u0005\u008f*xL\u0004]=AA\u0013\u0002WU\u008f\u0081\u0089cFFBX6ll+tw@\r\u0000:St]RX\u0001\u009eSt3FpWZ9\u001cR\u008cgg,@\u0012\f\u0018\u0093U\u0086{\u001av\u0016\r[U6\u001f5`\u0087\u0086\u009da\u000fO[4\u0000\u0002W\u0093ie\rW\u000f#\rO4LixZ\u001a~\u0082\u009fjxF6?\u0093k?\nhx\u000e\u000bDi\u0085>\u008bYz\u00ad\u0004\u009a;\u0092\u0082s\u001ap^\u000b\u0097\u001a~\u0085\u00175\u0084\u00975\u001a\n~w\u009b3,\u0093\u0019qO\u0007\u0005\u007f\u001auY_W\n7  \u0099\u0014\u00adl\u0087x\u001dE^3Atx\u000e;-\u000e\u0019z{h\ry77\r\u007f\u0097o\u0093wz,\u0090\u000bY2\u0095H\u0094+\u0001B\u008e2\u0087\u0017=\u0083uq+\'\u009c\u009a\u008b\u0083#\u00952{~^\tloX\u001a\u0096\u009cE\u001eJ\u009a\u00923\u0083<K@N\u0085A}O\u008d*mLD\u0083*h=*\u009e\u0013,\t\\\u009fhTEaY\u0090\u0087\u009a\u00125\u000b\u0001wXE8{\u0093\u0018=\u00931\n\u001bX\u0097]\u001b\u001ccV506_\u0014YF\\\u00937A\u007f\u000bY{c\u001eF\u0089q\u0018+h\u001b\u0095i\'\u0097uA\u0018i0/j\u008cwl9\u008cF\u0081\u001d\u009d\u0087IBy\u0090+7"7\u007fj:J\u0017\u0086FR^2\u0090O\u008d:bIT`o\u0094\u0017?MYMD~%)L\u0085A$3l]\u0005\u0012@\u0000 u\u0097\u0098AF5o<*XH,w\\\u0002\u0096Z\u0012\\JV\u001cl\u0095\u000evU)\u001eh\u0080\\MlK\u0094E.\u0099\u0083\t\u0084\u000e~n\u0086\u0088\u0007\u0016`\u00ad\u0099{~\u001a/A\u0088=K[9\u001aG\u0013\u00147&B$o\u009aESk\u0016d<<\u008bp2\u001e\u0099E$\u0019\u008f"\u009a<\u00079J6\u0097m\u0094\u0006m\u001a-`\u001f>\u0000#\u0089\u0098|G?Mo#"\u0088.@=\u009c<\u008b\u0012\u0096]@94\u00073\u00ad\u0084\u0096+\u0094\u001c?\u001a*a\f/m\u0006\\\u0010r1r\u000eW\u009d\t4\u001e\u0081\u0012>\u008dph\u00179\u001c\\=\u0083%W\u0084\u0012\u001e\u0093\u009eh[\u009c\u0002]%\\C\u0012V\u0005\u009bx<\u0084\u0010\u000f\u0007\u001d\u009au=.\u009f\u009eH<r\u001e\u0015\u0098.9z\u009fP{uN\u0093x\u0094g\t\u0094\u001dsX;v?/\u0095-GJ\u001f\u007f\\Wh\n&N\u009e\u009eH\u009d$M\u0006\b4T\u009ea\u008dZ\u0097DD\u0087U\u0081x\u0082#\u001by\u0081xd\u000e)\u009a0\u0016\u008f\u009c\u0081\u0010bH\u008cYg\u0087\u008dU\u009f\u0004Y\u009d,M\u0093\u009bG,99IV>HN>DV\u009e%S^%W GAw\'`\u009fX\u0087"\u0089D/n\u0017C8Hi1\u0086\u0001\u0000\u00068 \u009e\u0090x\u0005u\u001c\u0012obg\u0011,[AfA\u0098\u0096v\u008e\u008b\u0007?\u0084x\u0006\u0083\u00158"N\u0000\u000e\u0092Y\u0091\u001dD\u001b"\u0092\u007fb\b\b\n\u001c\\\u0004#(\u001f\u008d\u0018Wn\u0080\u000e\n\u0096=]xB\u009db\u0082\n\u0085c\n:&(\u001a\u0096Z2%\u000eR\u0002)?E*a\u0099\u0086\u0099\u0005\u0002eU3l?\u007f\u0018\u008e\t\u007f/\u001bQ\u008cR\u009b\\\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000org/gradle/wrapper/Install.class\u009dY\t|T?\'\u0002!\f\u0088\u0004\u0087\u001d\t\u0088\u0084$H4\tHX\u008c\u0014e%\u0019\u0099%!\tj-Vk\u00ad[-ZhUP\u0012 \u008akZ\u00adM\u009f\u0016\u008ad\u0092\f\u0002#w\u0097s?\u0017\u0007\u000f\u0011\u001cMy4#\u0019)(iFg\u0091f\u008c|\u008euS!*<Fcnrs\u009e\u008c\u008d\u0097\t<Q\u009aIn\u009eSt\u0003O\u0095In\u001ad\nOwq\u009b\u001e\u0019\nt\u0004.p\u001e.\u0094\u009e"i\u008a\u0015.qTus)\u0097\u0092s\u00964\u00993\u008c\u000e\\\u0085x\u000bdB7S\u007f\u0091\u008b+X]"c)\u008f\u00974y.J^*v\u00adF\u0015nZ\u00880v4+\u0015\ng\b\u00853]\\\'=\n7(]|\u0096tq2n\u0094f\u00ad\u009b^u\nWx\u0083\u009eZnrJ>G\u008dn\u0017+k.$\u001fJ3Gnj-\nknnf\u009f4~7\u00ad\u0093\u001eMM\u009c\u0016yJ3m\u001cpy.*l\u00079a\u0011.vy\u009e/<E\u0015\u008eU\u00140\u0098lSMA\u0095S&v)]|\u0099\u0017\u0082o\u0088\u0017\u0013H>/\u0092\u008b4\u0017)M&6\u001cUA-\u0016cL\u009e\u009a\u0015\u0095nm\\v\u001a6\\\u0092)<m\u009bV\u001e\u00ad\u008dF4\u0010n]4*\u0012\u008e\u0019ZX\u0005\u008b/ar\u0006#\u00ad\u00adz\u0094ib]$Z\u001aA#:s\u0010+]HG8\u0018LS2M\u00adN\u008c.\u009aV\t\u0016CA<-\u0082sh\u0082\u000bc\u0081m\u008a@PX^\u000bk&o\u0099(\u001cu\u00019\u0097\u0004\u0001c)\u0005_"\u0097Krl\u000b3"~\u009did] 7Czt\u00ad\u0086A@\u0005k\u0080|\':F[\u0000\u0096\u009b\u0094qgM0\b\u0019zu f0-(\u0006\t\u0083\u0004ZQ\bD\u008b\u000b-\u0007"\u00131\u0085/}\u009cIA"?\u008f\u0006\u009a.\u001ad\u001aa\u0091\u000fF5\u0098\u0092\u009b>M\u009b3\u007fAc<4:(W\r*-t\rf\u009awL-O\u001f\n;+su \u009ab_f\u009c@|C\u0097\u0089.b\n\u0080Y0\u008b\u00074\u0086\u0015\fR\u0098{lmz\'\u0013\u0007W\u000bK\u0098Bp\u0089\u0098\u008bG\u0003FWy=\b V\u0007Z\u0098!+[=jq\u0003tu-\u0084Q\u0086\u001a\u009c\u0096\u0016\u0081z.X_34lljq4~\bWUbFCm\u00adM\u009c)|V> \u00adU7*z4\u00955\u0091\b5k\u0090C\u001e\u0082tW1_4n\u000fD!(k\u0005\u0083u\u0001S\u0001\u0006BW{\u001f\u0083.\u0019\n_\u0086,\u0013\u009eYn\u000b\u00862|L\u0081J\u0010\u008c\u00164Q\u0090\u001d\u008b>0]\u0019\u001cq\u0005-A:ofK \u0018h\rkF<\u000f\u0015Cd\u0086cQ\t8\u0019z4\u0014\u0088\u0004p N\u0096k|B\u0085_k~+\u001a\f\u007f$n hn"\u0012\ri\u0086aN\u0007\u0011@\u0019\u00918Me\u0011\u0089\u0081E\u0089\u0099\f\u009d #\u0000\u0084J\u0094\u0095\u0015al\u0019\u008dCSV\bX\u0019\t\u0081p*\u0012\nia\u0097\u008a\u0015\u0091h\u0014\u000e\u001b\u0088m\b\u0084\u0091\u0094 \u00ad\u001c\u0018\u00895h8\u0007u\t\u009e\fD%\u00167\u0093\u0005X\u0097\u0006:;fcF\u0007\u0015z\u008b\u0011\u000fo\u000f@\u0019]&\u001c\u000e=lDR\u00161\u008d\u0088I52"A\nH\u0000\u008f$\u0091Ui\u0012\u0084T@\u0092}^\u001a\u009ap<\u0002d%[(\u0093\u0081/o&\u0087\n_w\u0015\u0012!\u0017iJ\u000bFLe\u0005\u0019\u0083Tf,As6\u0013\\h\u00ad\u0099\u009d>k,\u008c+\u0099N8du\u0092f4s\u009a-[eN\u0093\u00ad2&Tu\u0093$4G\b-9qBO\u0092c:F 5Oh\u0095\u009e\b\u00ads\u0017\u0097g\u001d\u0013\rY\u009dswY ,>asM\u0092\u0013\u0096V\u00167\u009a\u0082\u009a\u0098W&Tz\u009a\u009eQ\u001dzW^zX\u001fTz\u009c\u009eP\u0012\u0096J\u00177Uz\u0090\u001eRr\n\u001b\u009fP)\u008b2\u0095v\u0010U\u0001_\u00ad5|\u00ad*\u0090oPG|\u0003\u0085\u009a>[\u0088TF\t"K\bn\\YY\u008ajE\u001f4G\u0005\u0005\u00ad*|\u0007\u0004%s\u009d*w\u008bQ^4\u009bUg\u0006rA5\u0011\b\u0098tS\u000eoz=\u009d\u0099\u001f\u009bG\u00987\u001c1(?\r-\u0010j.L\u008b"F$\u009a\u0095yk\u0012kD-\b^\u0013\u00898\u009d\u009d\u009aU\u0086R\u007fU[\u009f\u0007T0m:*\u0013\u0089c"\r}5\u000eT\u000ft+COnh\u0085j*3\u00037C\u008b\u0006O\u000f\u0087\u009b\u0000\u008csBZ\u0097M{\u009bu=5PmoGh+\u000f\u009b\u0005y454\u0003\u008d\u009d\u0099\u009em\u008fFB]\u0097\u0005\u0004\u0012\u0010+E7\u0010\u0083r"#\f\u0097%^-\n\u0012A\f\u00001K,D#!5\u0098*\u0092D0ozAET\u008f\u0087\u0093+U\u009f\fY)\u008d\u0012[\u0085i(\u0090V\u009aE\u0090\u0001\u0095{\u008d|\u0080\u000f*bG\u0010u\u007f\u008cF.\t\u0099*?Jo\u0018?\u0013$lF\u000b\u0092\u0081p\u0004>O!;\u001f\u00ad\u0019\u0000d\u0085"(El\u000bW\u0017\u0010PyZgY\u0095\u007f)H\u001c\u00971=CFT~\u008e\u007f%\u0084\u000eK\u0000R\u0099/B\u0081\u008bi\u0003,\u0095_\u0092iSRe\u0095\u007f\u0004\u0091!\u0082H<7\u009d\u0018(\u009c#Y\u008czQoK$Z\u0095\u001b\u0085\u007fk\u0000\u0012\u0004N^9\u008ap@\u008b\t\u000e-l\u00881G`\u0096p\u008cuw%\u0012+\u000b\u008aSu~C{\u0083\u007f?a*T~\u0093R6\n\u008c%\u008eJ;*+\b\u000b5i\u009a!u\u0098I\u009bc`\u00ad\u001aP\u008dO\u000fCb\u008e\u007fW\u009f/\u0095?T\u0090oG<zG\u0089\u009b\u0011\u009fFy7\u008fI\u001c\u0098K\u008b\u00130\u009a\u008e\u009do\u0003!2@i5)L\u0000~E#\u001d\u0019\u0010\u0014\u0005\u009cy\u009c7\u0014`\u0011G\u0081\u0018UP8\u008abIi\u0087\u0005\u0019\u008fcY\u0082i\u0089\\|\u008d\u009cAl\u009b\u0099\u0094xFqc^cW.\u0006j\u0085\\\u0017:2ID\u000b\u00923\u0089c\u0097Q^\u0005\u0004\b\u0003.]l\u000f\u0001\u0087A@S\u0082\u000f\u0012p/<\u008b\u001d\u000b6./\u0005wvfHI\u0085\u000e\u000brN\u007f7\u0005\u0085r2z`\f5 \u0087\u0019\u0091\u009571\u0005\u0019\u0011h31-{\u0089\u0000;jM4eD\u0092|(\u0081XMYb\u000b\u001c4\u0084\u009a~n&F\u008e3\u0016.\u008e\n[\f\u0091=e)~>|l\u0010\u0095vrB\u000e\u0096V6"\u008b+\fL]2\u009d6\u001b\u0085\\<&C7._A\u008a;\u0003A-\u0003\u008cr\u008f#X4/R\n\u0087a\u0081Xu\u0003\u000b\u009a\u001f;Wdb\u0014d\u00910%\u0082\f\u0017\nf\u0003\u009c&\u0015\u007f\u0095th\u0001\u0003\u001faD\u007fZ\u0004K\u000b\u0001\u0003o\u0011g>~c\u0087\u0012WB\u00123}\u0096\u009c\u0010f\u0086\u001eI\u0010O^\u0099\u00121t\tWO~\u000f\fVbI\u0016,\\"y/9^%"\u00adV Y\u009d(\u0094\u0099f\u001c\u0017Iq(qZn5~_I\u001bXl\u0006\u0089H\u0007$\u009f=dCAawj9\u008a\u0003\u009as1\u000b0\u0019<\u0005\u0019x;4M\u008bGzMP\u000f\u0006\u0000i$>\u0007\u001b#\ne9C[\u00ad{]O?\u008c\u0086\\\u0003\u0095:hxu\u0082\u0011\u0092\u0003Q[\u0093h;\u0015\u0012\u0091\u0083<t\u0001}\u0083\u0098.W\u0016]D9rB{\u008e\u001c\'\u000e\u0013n<`\u001dWbP9\u0087\u008bz\u00943l4=C>\u001a^T\u008f\u0094\u0092},*G#\u0098;|\u0017\u0004r\u009d\u0086\u0095^\u001aK\'\u0083\u00874\u00856\u0083H\u0091E\u0093\u0011\u0099o\u0013\u009boU\u0096&|}\u0001z\u0084\u009b&\u00054\u001e\u0086\u0087h\u0004^FW=npcL\u0085\u0013=^\u001aTqz\u001c%=\u0094M\u001e\u0007\u0006Y\b\u0019\u008b@\u0004\u0096D*\u0003L>WZ\\JW5A\u008bZ\u000eT4\u008f\u0087~mX[D?\u009d\u0090l"\u0091ni4\u0089~\u008c7\'\u008cv\u0005kp\u000b9\u0093\u0097&4\u0015\u0006\u0002Q\u0091k\u0095&\u0095z\u001c4i\u0081=~K\'%\u001e\u0087-\u0017BNnI7M\u0080\u0094S\u009bz[\u0016r]\u001e;hh8s]s/O\'Ud{i\u009a6\u001aQF\u00937x\u0014\u009aa\u0087\u008bwQ)_b3\u0082F\u0004\u0091\u0019\u0002\u0013j4\u0095\u009ai&(?\u009dB\u00adPG\u0080Nh\rm\u008c Bt>E\u000b}\u0017QTa\u000b\u0004\u0094CIt\u0006;\'\u0012Sj\u0094\u0084\u0092\u001aXu\u0017\r\u008cm\u008b\u0001?9\u0014{\u000e\u001aA)\u0007.s)\u008c~\u000e3\u000f:4B\u0015S\u0001\u0085B{\u0089|AT>B3\u0014\u008c\u0086\u000f\u0083P\u0002c\u00021AgC\u0011Lh(=@3\u0018f\u001dK3\u009br\n\u008fPa\u0093\u00adq?!\u008a\u001fh\t\u00ad\u0089\u0003T\u0096E\t0\u0081\u0013bv\u0001_\u0007.*xho4\u0094`b\u0089}Pb\u0016Vn\u0081rW5\u0015\'=\u0007#j#4]\u0083S\u0006\u0088K\u000f\'D|\t:\u0014&jJ\u009f\u0092\u001e*\u0097\u008a\u0091\u0002R7QLI\u008a\u001b\u009b\u0098(mlrz"Y\u0085c/\u0013D\u0005{R)2|\t6A`\u0088(\u001e\u0094\u0019x\u009e\u0002Y\u0006\u0086\u009f\\iz\u0093\u0013}*=\u0002\u001cX\u0088\u000eMII_C\u008f\u009aK\u0093L\u008f\u008coo\u0010L\u0097qz"!x\u008a\u0003WB8)\u00121\u0016xT4\u0094\u001eZ`-p oicN\u0085;I-8\u000f\u0092,\u0001xzSL\u0082;\u0001\u001ba\u009b\u0000\\\u008b~\u001a@\u009e`\u0001\\N}J\u009a\u0084-]\u0098/\u0016JY9\u0080\u001e\u0091j"\u0080|P\'\u0019J\u0098)\u0004~\f_\u008c\u0015\u0086cl\u001f\u0006NE\fKyM9K{zneMG\u0096\u001c\u0006\u00829a\u001e\nM\u0018\u009d\u0097V6Rm\u0093|\u009fCgP\u009dD\u0098z(B\u0011\r\u00adjp=My\u001e%g\u0085w\u008f\u009b\u0080x$\u0081dM.\u009ad\u0091]\u008bWD\u009b6H\r\u0080\\!bKMxNn\u009a \f\u008fnM`f\u0081\u0084\u0080h>u\t\u009dKyh\u0082)\u0086A\u00173\u0003vS\u0005rD\u0084\rP\u0016\u0083\u0017Q!\u0005nh\u0007p\u0005\b\u0007`\u008e\u00830\bps\b\u0098iv\u0000r\u0003\u001cY%t\u0005934d:\f\u001az\u009e^\u0080+Lz+0e5\u0087Y_WL8\u001fN\u000100)\u0000\u0018\u0083\u009d\u007fc9\u00176\u0005\u001ar+iyTh\u0099B)Rz#4\u0005}}\u0092\u0097\'\u0011-W\f\u0085\r/\u0004\u008dD\u0006o\u0097x\u0084\u009c-IK+w\u0093\u009eu\'9mS\u001e\u009cc$X\u007f\u008a\u0001b\u00010Q8\u008bBB\f\u0095FL\u0014\u0096]\u0084\u0090:^8\u0092\u009f\u0002\u0012\u0087"\u001cx.,6=\f\u008f\u0096z%M\'\u0015\u0099,\u0099<\u0007!\u001ba&\u0086Y\u009af\nal<\u0082\u000b\u008bp\u0097\u0090\u0087\u009e9\u009e8\u000fc\u001fO\u0010b\u0004\u0019\u001b7-S\u0080\u0085);,?\u009bv\u0010\u0001\u0086\u0093s\u001a<3\u0010\u0092\u009f6\u0012el.nuM/Jfn`\u001d\u0090p\u009ed\u0085\u0000^2 \u0013\u001c(\u0093D\u0012\bCn\u008a/^v8M\u0003z(C1\u0094*\u001et\u0019\u001eg\u000f\u0096m(\u008fN6\u0090N\u0097q=\u0007BnB\u009a\u008d\u0082(\u0019\rK\u0005w\u0019R\nl\u0000\b\u0096qC5\n\u000f\u00941\u009d\u0086S!2z\u000f\u0094\u0007\u00ad\u000f\u0090?\u0004\u000f\u0090\u0095>DF\b>F,\u0004>\u0086>A\u000fSk\u0097t6\u0085\n\u008dmBa\u001e\r\u0016\u001f\u0085>\u001d;Cg)e_\u0003\u008aV\u0006\u0006t\u0005W\u009a\u0086S~D\u0005i\u0014\u001a)\u009f(\u0085>V\b\u0095+\u0014\\F\u00ad\u0080\u0019d\u007f|FY}#5\u0005\u001f\u00adP\u001f,\u0018\u0012[$3E#\'+\u0091)nF\u009f5\u007f\u001deWCq)\u00ad\u0005\u009bhDIYlu\bB\u009f\\h\u000fST{F\u008bK\u009f@\t)Mc=&\u007f1S\u0006\u009a\u0085\u008f!\u0087#=B(\u0017v4t\rV\u0089\u0095bpW\u007fY4\u0098hg\t\u0016\u0014\u00841\u00140+D*w\u0082\u00110n9p9\u009e2!83i\u009a`\u0091//bq-|N,H\u0004,Y\u0080e^m\u0005$gJ*%\u0015d-\u0013\u001d\u0013cgGB\u001d\t\u008b.\u0019\u0087\b\u009e\u008c\u0094\u0095\u0002%pqAVb\u00194\n2\u009a3+6_n\u009b\tp63)\u00833>\u008a2(\u008b\u0087|VQJ\u008eB\u0010\u0093G\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000:o\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000org/gradle/wrapper/Logger.class\u0085\u0093ko`\u0014\u000f\u0097Unc\u008c@&s*\u0017]7\u008b11$KH\u0092`w\u0093\u0014\u008d_OFg\u000b?\u0080\u001fx\u009eR\u0019\u008e5Krw.??\u007f\u0001h\u0019G\fb\u00821TP\u008d\u00864w+\u0002U\u008e\u0082]\u0086\u0010.\u0003;`XxfX\u0086\u009c!R9\u0082!1,j<8\u0014>?4dckq\u0090{0\u001e\u0019#\u0086bvtUwx\u0014\u0007\u0087\u000f\u0087Q;\u000b\u00106m\u009d!W\u001c\\5]1,)\u0081@\u008cF\\\bs\u000e\fw/\'.Hq3:NW\u009c\u008c\u0085\u0089fu\u0085-Ce"\u0084!\u001f\u0014\bl\u0003U#\u0097;\u009bm"x\u0015*\u00ad@ob\u0088w\u0089=C\u0016\u0095\u0098j[$\u0091B#\u0089\u0004\u0092\n%q\u001f\u000f\u0014<L\u0011rI\u0014X\u009a\'<%N`\u0019\u0096\u000f\u008f\u0085F\t\\\u0094\u0012\\\u0091c\u0098~\u001cb@\u0017\u0098r\u0093J\f[}C#qi0\u0082\u000f\u0090\u00054\u0099\u0016\u0083z|\u0014w/\\L~sW(\u0010\u00035\u009aeNSNa\u0091l\u009av{\b\u0003k?j\b}]\bKd\u0017\u0011&{\u0015\u0011\u0092J\u001e\u0019oy\u0093Z\u0016VR\u0095\u0089\u0015|}_3]\u0086\'"\\?ED\n\u0087g\u0084\u008bPP\u008cpz*\u009c\u0093U\u0012{QL[5\u009f\t\u0099\t!1!D>\u009fc\u0094\u0089I![3\u008c\u0094\u0091\u001cJg\u008cX\u0019&\u001dovHIFi\u0014\u000b\u0094\nQV(I\u0094\u0092)r\u008e\r/\u0087,*\u008f\u009c\u008aP*qw(\u0011P&n_\u00967\u009b\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.class\u0095R[K\u001bA\u0014fVK>ER\b\u008aP\bC&\u0090L\\wd\u0014\fB\u001f\u0003JLB1V\b}\u00983\u009d\u009b\'\u0080}l\u0088\u0017%xX3Kc^xBj\u0090\u007fW}B\'EH%t4j\u0096t\'hNd|E/uE` \u009a\u0089\u008c>T\u001f\tih\u0084\u001edmIXlT\u001e\u000f\u009aR\u007f\u0013\f$\u0084\u008d%\u0092\u0013\u0095\u0089\'I\b%,!9U\u0096\u0012\u0082Oi*A"\u0098\u009a[\u0094\u0010~[\u0091\u0094]Ou\u007fw%\u00ad\u009a\u0088\u0083P8\bH\f.@\t\u008f\u0002\u0004\u0006\u0098\\\u0000\u001fs>\t\u0091X)\u0089H;fOrBfVY\u00995\rU\u0019\u001e\u0099\u0002B\u0081\b\u0002e#Vx\u0093xv\u0081.\u001c|D#Pt\u000b\'\u0019\u0010\u008e^s\u009daz\u0014O1\u0014HPL4b\u0089\u000fg8z\u0086\u009eaXWd\u001am\u008a\r\nW\u007fi<\u009bvt0n\u0098\u008c&<}\u0010\u0007_>\u0000v\u001b\u0090\u009aD\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/wrapper/PathAssembler.class\u0095Vic\u001bW\u0015=cK\u001aY\u001e\u008eb\'c\u00171\u00ad,\u0016\t4@\u00065Qk[q\u001d[\u0013y\u0012y\u008eF\u0089\re)\u0090\u0096})P(\u0094C]hP\u0003ob;wf,L\u000fz9wy??\u0000\u009c#\u001cr-\u0088c=\u0002\u0013#\u0094n\u0090\u0097aC\u0085%\u0005Y\u0014U<\u001dA\u00049E*\u0085\\\u008e@M%\u008a\u00ad\b\u008e\u0013\u0011|R\u008b\u00990>\u0015\u0099\bt|VgU|NGp\u0012_\u0090\u008aT<\u001f\u0017#\u0088Ka|Y\u0094"WD\u008ao\u0084M\u0011\u0015\u000ba|;\u0082\u0082b\u0018\u000brE\u0015/)8:]X\u0093fc\u0016,\u0005Z\f{"\u0097JFI\u0089\u008bsc\u0093S+\u008bSs+\u0097f3S+\u000bs\u0099\u008b\n\u009bz*[<\rXQ\u0005m\u0013\u0005\u0096\u0086\u0082#\u0097f\u001f\u0099\u009aX\u009d:\u0092lX,\u0019\u0086hxfBa3oDA2\u009d\u000b\n\u009a\u0083K\n\u0002\u0013\u0085,M\u0098)o\u001a\u0082\u009a7\u0004_/)k\u007f3\u009bd?]s)\u000f*u\u008bEN]\u009d1zAM\u009b@G\u0005\u00ad=g8\u0012od1o\\EwtmQ\u0007\u0012p\u0089^+\n\u001a\u009ai\b \u0097\u008c\u0019]\u0002\u0019\'\u0085\u0002\u0095*\u007fpKW\u0082[.l\u0090yl/uJ\u008c\'\u0000\rTs\u00993J\u008e\u0082>Od\u0095mJeM\u0096#tu\\\u0081B\u001fX\u009d\\3\u008a~|B%\u0017\u0082\b\u008ev#\u0017Bi\u008d\u008dMcj1\u0092\u001b\u0080FKat\u00944cW\u0082\u0017~\u0013pR\u008bsCB ]"@\u000f\u0014Dhw\u009cIs\u0013\u007fx\u0080\u0017" 9B^3d\u0093F\u0084\u0086Q<8\u0087\u001a&\u0086\u0084\u0086\u008fcVC\u001a{-k\u0011^\u008a5\u0083,f>k\u001a~,:?O\u0019\u0094\u0094\u0086\u009fj\u0014?\u000b\u0091~\u0089W\u0014\u009c}E/6~\u001af0\u008b\u009e\u0099|@\u001a~\u0083j\u001d~\u000f\u0082N\u0097\u0006m\\r\u008c\u009cP\u0093(\u008cb[X\u0083+\u0095-0;Q(1Y1*\u0096\u009d\u0098W*#bt\u0097_\u0086;h\u008aw\u0004.v*835_Y\u001f~3]-\u008ddM[\u001b\u001av$A\u001bU*|\u008c\u00173Ku*"\u008e3\u008d5g_\u0083\u0005z@\u001bwk3\u000f*\u008b$/PVV;~\u0089I\u0013s\n>\u009c>\u0093\u001b\u0018Z\u0010\u0098_x\u001c\u001av\u009d\u00117@\u001b\u001a\u0005\'O+D}\u009e\u001f\u0010v\u0016\u0088\u000fJC\u000b\u0095\u008bY`0\ne}P<t\r3\u0093h;\u000bv\u00964@V>$\u009f56g\u0089\u0006\u007fKE\u008f\u008dqU`<]\u0003\u001d\u001drJ\u008e\u0005]`\u009c\u00adC\u0088,\u0014\u0092\u008b\u0019x\u0000\u0083\\5a\u0090\u000fY\'c\u0013\u001c\u001e{"\u0087z?g\u0085s0Q\u0085\u009az\u0081c\u00843\u0087\u0000G(i\u009e\u0012>\u008a1b`705E7"\u0006\u0012;h[9BZwU\u00804[Z:i\u0096D\u0012ZBb\u0002\u0093\u0012I|;\u0091\u008a@&1TEp&1\u009c"t>\u0003uY\nW\u0083r\u0015\u00ad\\i\u0015E\u008fp\u000ep\u008a\u008e]tt]i~(\u0083c\u0089`w\u008a\u009a;=\bq\u008c\u0095A#\u0081\u0013\u008c\u0004\u0086\u0089aK\u001e\u009ak1V\f.2\u0017M<u\u0093Z\u0018\u0096\u0013\u009cch&\u0018G\u0018\u0082 QJ!je\u0083Q*y A\u0086\u0015tUq|\u0089G~#} \u0081g\u0098.\u0084gm\u0094\u009bD\r rk\u0092\u0007G\u007f\u0095H]\u0093!`\u0010zvpr9@FUu\fTpvf\u0007)fM)=W\u008f\u0018q\u000e&\u009f\u0089->@Ce|\u008c\u00ad\u008c\u001cy4\u0005,\u008c\u008f`e\u0018\u0010\u0094U\u00958M\u0094^g2z\u0082\u0081\u0087z_F0\u009dl\u00adm\u0011NQG\u0099id\u0018Y\u0097K;[C\u008bR\n\u0012\u0017%\u0013><)6{\u00182C\u0092\u009a\u0081\u000b}\u0004\u001f\u001e\u000b<Uu\u00181H4zA\u009f\u009e\u00ad\u009e\u001a\u0083\u001e<\u0089\u0015b\u0004\u0085Jx\u0084K\u0005\u0011U\u000b\u001d~t^\u0019\td2:XA%\u0084\u0013i;\u0019M\u000e\u001b\u0018bd[\u0097U4rrk}\u0097\u009b\u0007\u0088?N\'HIj\u0085E\u00935\u0093\u0012E.G\u00165\\\u0094&\u0014\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007f\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.class\u008dVS\u001bU\u0014]\u0092!,-\u0002\r\u0016\u008b-3\u00ad\u008aTR\u0096\u0006\u0089%A(.a\u009b,\u0084\u0094W~\u0093L}\u0019\u0099\u0092\u000e2cW&\r$\u000f9s~s\u007f\u009b?\u0004"\u000b\u0013Q\u0005\u0013\u0001 \u001a\u0018P0\u0019\u0080O\u001ac\u0001(xSN\u0092\u0094\u0082i\u00053\nf\u0003h@\u008f99-\u0014\u0000T,H;XR=.\u008a\u0014r\u0091\u0082~\u001b{x_\u008a\u000f&\u001fc\u0014\u009a\u0082\u0015\u0081r|!:}mn~v\u008e":\u0011B\u009avC\u000b53\u0019\u008e;a&#\u0002\r\u0096\u0099u4Y9]\u0082a\u001a\u0098\u0080\'(\u001dVi=<e\u0098LncE\u0017\u0095.\u0093Y\t-\u0086\u009c\u0017\u008d^\'ed\u0005,;\u0019NjZ\u000foZ&V7l\u008b\u0013\u0093\u009aI\u0012\u008e$u+p2T(\u0013FZ\u008f\u00149H\u0087\f\u0086m\u0086@\f\u001b339"L\u0096\u0092?6\u001b\u00993\u008ea\u0099y-&dnC7\u009dr\u008efW\u0084CL.\u0099\u009e\u0086\u0004\u008b\u0088-V&,5\u0090}\u001dG\u008c\u00adc^\u0087\u0013^8\u0083\u00961%\u0019Q\u0090P\u0080u\u0081\u009145\'g3\u007f\\?z\u0081\u0095\u0013z\u0081\u008e\'t|P\u0086x\u0001\u0005\u009a\u0099)"\u0089\u0094j\u0014\t=2\u009db\r*2\u0091*\u0016hz>g:\u0086VK9#\u0002]Q\u0094nv-m\u0095\u0086v^g-*6`Ja#Y\u0090\u00ad"\u000bGAN\rl\u0089\u0094\u008a-|,\u0083g+[\f*DL\u000b|+|\u00ad\u001b|+Xyvy\u0002\u001a)\'1MnB6\u008bw{/(X,(\u001e~>\fW##\u001f\u000bI\u008e=\u009b(\u0011DWF$v t$\u001c0\u0015;\u0011\u0017/~*\u0098xB\u0007\u0081DV`\n-n|/#\u008e\u0014)\u008d\u0012y\u00ade2FIi\u0019&^\u001d,=A\u008d\u00955\u009d\u0092T\u0091mMfR\u0002\u0018/}6\u0092-\u0084bU\t$eg\u0087Re\u001evX|\u00153%\b_\r~\u008ac\u0017g5hOW\u0082\f-a\u008e\u0082\u001e.\u009b5\u0006\u0011T\u000b\u0000\u0097c\u001dO\u0014\u0083_\u0012\t\u008b\u009a{L\u0011P;\u000be\u0099\u00993\u0003y\u0017\u0086:\u0095J{\u007f\u001b\u009d3P\u0097w@y42ES\u001e\u0003p~\u007f\u001eGw"03\u0083V\u0081;LM`\u001bq=\u008f4\u0088/\u0013Z\u0082>u\u0082\u001d\u009c`iN]xG7\u0006Y c\u0010\u0018A=#7?\u008f\u0094\t\u001cI4lv14$ nq\u0098\u0011R\u0013!9K\u0018\u0080M-z\u009b\u0099\u007f9B\u0018r\u0089\u009cW)\u00105\u001a" ,9z|\u008c~\u0085_=/\u000e\u0092!\u008e~L0\u009b\u00108\u008fWIH-\u0005_\u0084\u0005{\u0010M\nF\u001f1W\u0018U\u0005>\u0085\n\u0005=\u0080\u0092\u0082\u008e\u0087Sp\u001fL<`\u0096_b\u0086qW\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000=\u000f\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/WrapperConfiguration.class\u008d\u0093mO\u0013A\u0010gJK\u009f\u0004|\u0002\u0015i\u000f\n\n"\tHUL\u0015C\u0005\u0012\u0090-\u009cH\u0092&~*M$&\u0003\u008c3w\u000b\u0094e\u009b\u0098&33\u009f_\u0001\u0002:a\u0002\u0092`@E\u0083G\txL<\u0099\u00052O<%\u0092\u0006\u0018\u0018\u0007\u008e\u001fxN\u00138m\u0097P\u0088\u007f\u0096k\u0007\u000635\fQO\u008bM\u008e5)!\u0083Bw~+\u000b1\u0003s\u0012M(\u008d/;\u00130/\u0095w\u0018^\u000f\u009e9s\u000f\nn\u000e\u001cZ\u008bd,8t|\u0006ZkZM\u008f\u001fl\u008bONl\u008d\u008biv<N,\u0088\u009bn\u0093gJei_n\u001a.]!\u009c4*:ZlkBjjttW\u008c(;"v]\u0088s~"DEE,\u008eotGU\u0017<K1\b\u0018\u008c+\u001e\u0085}\u008cZ]U\u00ad\u009bo\u0006d`\u0098\u0098B\u0001o\u00182\u0095\u0006da\u0080<\u0099\u0002\u0099!H\u001b\u0090)SU #l6\u008e\u0000&\u0092W\u001ch"F}\u0084\u00169\u0017B\u009f\u0002FG;\u0082]37\u009fl)l\u00140N\u0084q{(\u001fE[\u0084\u0001y\u0088a\u0090\ff\u008b0\u0086?@p\u0010\\\u0087\u001b\u0019F&\u0016z\r\u0098?@v>,.\u0004\u0017\u0081sm\u0018\u0017\u0015ns\u0014\u000b\u0014=NN8\u0018u\u0089\t\u0014\u0013q\u0015$&\u0083L*A=\u0015HL\u0006)\u0001B\u000fC\u001bO*A4\u0019dF\tr_\r s\u0000\n\u0090)%\f2\u0004)A\u0006e\u0090E,\u0000\t\u0090\u0012$!\u0083<W\u0082\u0098j\u0090\u0084\f\u008a\u009a\u001e y\u00012\u00ad\u0004I U%\u00035HR\u0006@\u009b\u001e \u0005\u00012\u0013jf\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000G\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000org/gradle/wrapper/WrapperExecutor.class\u0095W\u007f\u0013\u0019\u009e-X2\u0006l\f\u0011\u0080\u0090l\f\u0004\b+\u0098Cl\u0088!\u00ad9Kg@)\u0013\u0014\u009at+m\u009a\u0090t\u0099\u0098\u0016l\u001a7\u0013tgy;\u00938(Az\u009e=\u0017_\u0006\u0005\u0092\u0088\u008cGCxLA\u0015*m\n\u00828@q\u0019\b\u009d2\f\u00ad\u0016O(\u0098\u0087s2`!\u0012{yx\u001f\u000f\u008b\u001fI~0\u0084\u000f\u0014\u009f|\u0098WO\u0087\fyx6\u0084\u008fQ&\u007f\u008cW\u001f\u000f\u0013<\u007f\u0092\u0087O\u0085\u001c\u009f32>\u001bX\u0081\u000by\u0005w\u000b\u0017y%^}9\u00843\u000b2y~\u009eO`;)H\u0012\u0083^V0\u0083Y\u0005W\u0010^\u0094;98147243\u0092\u0018Ot\r\f\u000eK\b\u001cNj\u0019-;\u009e-#;[N3\u009b}H\u0014t\t\u008de\u0000\u001d\u0092]\u001e\u0084rbbA\u000fqy\u00191yp\u0096mG\u0092C\u0012\u0096\u001dN\u008c$\u0007\u0007*\u0011=\u0094\n8%g\u00999\r=/az62\u00899u\u0090\u000b\u001cNl=q\u00981.aC\u008fi\u008d\u008f[Z:\u009f\u001ck?\u009d\u0082`iafR\u0098i\u0091\u009czoX4\u009a\u0094\u0084\u00adr!v\u009dS\u0005F`\u0081N3M\u009a-1z_arT\u0006Q5c!2x\u001e\\)\u0002&*\f\u009d\u009f\u0089^-cd\r{\u0084\u0015Zn!\t\u0012]$E\u0094\u009es=\u0010\'\fr|\u009d\u00994g9\u001byJ\u0002\u0083\fY\u0086\u0084E\r\u008e\u0080n\u000f\rts@fJ\u0095BU(E\u00052DK\u0002\u001c2t!cj\u0084\'-BF\u0096\u0012Y&\u008bv\u0090\\v\u008ew\u0086\u008c\u0097dL\u001fmz\u001b\u009d\u0094\u0005^B<d\u0089\u000b\u000f\u0090)GGo..?n.L\u0097a\u009a6z5Kl\u0012q\nh8Y[#\u0083\u00940\u001cH\tM\u0013(a\u000f-W\u0015\n\u0090v\u009c$\u009b\u0091`Pm\u008b\u0006?}Ub4FsN\u0091\u0098V\\;\b\u0088/T\u001f,P(\u008eH\b\u009edH\u0019W)(M5yb-$E\u0016;"6\b\tv\noJ\u0088V;6wT\f\u009b$\u0099-\u001e\u0086T|\u001b]y\u0090\u008dIXj\u0012Z]\u009d"%\u0018)\u0013Y6>\u00926i\u009b5\u0088~\u009ag#\u0095M\t\u007f\u0094;\u0095\u008a{,\u001a5\u009f;\u001e\u0015U\u001ckU\u001cD\n\u008du=\u0082*$$)\u000e-\u0001^Q\u0091I\u0015?dIe\u001c\t\u009eP#1\u0013\u0084F/Q0\'\u000ei\u0015?e6!#\u0097(\u008e\u0084\u009f1e\u0004\u0007\u0017L%\u0013|%y,dK"|\u001cj\u0099\u0093\u001bSRq\u008cm5\u0003\u0006U;^\u001eGQ\u009ah\u0086\u0015&\u001f\u009f\u0085}#Y\u008eI7w<}\u008fEA\u001f\'\u0015\u007fL\u0018Q\u0019\u007fQWMU\u0003\u0094\u008c\u0088D\u008f\u009c2\u0089\t}\u0089x>\u008c1COG\u008c)7r\u0083\u0092a\u0085WTN{R\u0093|88a\u0099\u009cAXTY\u0012oe\u0082zfu\u0094\u001a\u0091ytR{\u0085:\u0089v:\u001dZ\u0098|`\u0016G_8x\u00868\u008a~\u0095\u0010\u009c7:+x\u008b@-I\n:b\u001cqJq(\u000eKq6b\u0085\u0017j\t&\u0099\u009a\u0005\u0098\b};dm\u0003\u0016?\u0019JpE\u0093\u009b)@a\f\u0083\u0095\u001ffhr%\u0092\u0095Q\u000f\u0003\b2&xg\u0093lL\u0011->lDM6uFg\u0096\u0016\u008f\u008a\nC\u009a!\u007fBh^G\n\u009bh_F\u000e~\u0005;=U7_\u008b0kZ\u0087c\u008b\u0099z8Iv\u000fz\u0089\u008fv\u009d\u00150\u0007ix\u000eUp,\u0002s\b\u000ef\u0016\u0080a\\\u0087\u0004\u008ds\to\u0010\u0018(\u0002\u008eC\u0016\fBb\u001cj\u0087J%\u001b\u008e%@\u009d,,V.ZX@3\u0010#\u008c8\u009a\u0091\u009a\u0091\u0014R\u0013M`:BB\u0080NcX@\u000b\txe,\u008e^F8\u0016\u008c8is\u001eO[`I\u0012QfQ?\u0083b\u0019^\f\u0096a\u0006\u008d\nI\u009c\u00adtV9gw\u0091\u0087"3X\u001c6;\u0087k\u0004c\u008bs9[\'_@c\u009fp\u0006\rqvC,bW/\u0092\u0011<\u0085g\u0010u\u001d\u0081E4n"kXB\u0099\u001b\u000fe\u0004(\u0089r\u000f}\u0007NLb\u0017\u001en\u0097\u0010<\u000b\u0014\u0084pa\u0080Kq\b\u0087\u0085K0 VHI8C\u0084K\u0097?\u0004RM\u0093Q%V\u009at<\u008d\u001cZ\u008b0hn!{\u00ad9o(g.n\u0006mt\u0091rg\u0006RH"2\u009d\u0084\u001f\tL\u0013\u008eDr\n.<\u00807\u0092^M\bh\u00967.@#}\u0003\f"\u0004\u0019l\u000e%\u00164\u008b-\u0087pXn\u009d%\u0015PG\n\u00942k\u0082\u009bYu\u001e\u0099\n\u007f2\u009f&"[r\u000e\u0087\u0003[g\u0083~;/@M\u0004\u0096d\u0017T\u00adP, Ia\u0092UOs#M\\#"t[f880\u008c\u0004HyCT!Hs\u0088\u009ac/\u0007\u000e\u0085\u009cTUY<\u001e\b\u001e\u00900\u0001\u000f\u009e8*C\u0006\u00059\u00ad\u008e\u0002m\u0006\u008c=\u0017\u008bHN@N\u0090\u008f3XL\u0088[\u009d[\\\r\u0013mRH\t#\u000bSdL\u00189<Hw\u0015R"\u0087\u0005\u008a\u000e\u0088\u0012\u009d>\\\u0003\u001a\u008a\u0000\u0015l\r9O\u0016\u0086\u008a\u0012C(\u0088.H\']\u0003\u0084T !\u009e \u008cS\u0012\u0098]h\u0017\u0014D\u0019L\u0085yW!p\r5\r\u0081k\bN<\u008fX\u009c\u0012zZ*%q3a\u00810\u0014LQwx\u0088|q\u0086,8\u008bx\u0098\u0092\u0011?cKQ\u0097\u0096.-.\u009a"\u0004c#Lg\u0001\u0091d\n_EX\u0099`-q\u009d-z3Ai\u009aD#76\u0000\u008d^\u0097=\u001en*"-\u0082\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000e\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000gradle-wrapper-classpath.properties+(JM.)M/JLIM**+M\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000gradle-wrapper-parameter-names.properties\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000org/gradle/cli/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.class\u0095T]o\u0012A\u0014=\u0003\u000b\u008b"~C?\u0094\u008fR*O\u0010\u0012h4!\u00ad\u0011aYm`\u0097\fC\u007f/4\u001f\u008f2\u001d\u0090P\u0096a9{s?\u007f\u007f\u0006PF@\u0002;:v\rDc@{\u0011xY\u001d9\u001dy\u001d\u0005\u0086x\\Yc\u0088fs\f\u0091\u0019V\u001bg\u001f\u000f{m[xKH[{\u0085\u001b\'&?\u0003\u0086b\u0017N\u0011KV-\u0003)%\u008f^\u008f{\u009d\u0080m!mQa\u009f|\u0013jU\u0011\u009bn\u008d\u0011\u0086l\u008c\u009fR\u0097{N\u001d\u0085\u0004\u0095\u0019}f[\u0092\u000bC\u0085\u000b\u0087-k\u0092\u0096=,\u008d\u0018\u0082ak^\u0018\u008a^t\f\u0094\u001c-J\u001a\u0019\u008c_,/]\u001bct\u001d\u008f+;X\u009a\u008dr\u008aCu\u0018VQ\u000bCW\u0088\tuhCao\u008f\u0099\u001f1a6C2Q\u0089\u0012\u000eLK\u0086\r&\u0084!9\u0089a{\tQ23Qu\f{\'M\u0086\b~r\u001d\u00903\u0010|i153\f\u0016\u000emn\u009eDevf\u0086J\u0085\u0096\u009a~-C\u007f\u0085\u0004H\b;"d9\u009a\u0093edc\u000b\u001fDq\u0087\u0002SX\u001c\u0007`\u0015Iw/!)\u008c:Fy\u00017\u001a_\u0088|@8_\u001cA\u0017\u000b#F\u0088\u007f\u009fVX!\u000bK`\u009d\u001bR~\u009c;\u0014x\u0086)>=\u0011\u008aN\u0001\u001eRnp\u008e\u009c\u009cc\u001ch\u001a\u0098\u009f\u0090\u0011\u0014\u00944=c/\u0083-e\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0083X\u0004\u0000\u0000\n\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.class\u00adV[W\u001bU\u0014N20\u0012\tH\u0015\u0084KKIQJ\u008d\u0086\u008b\u0082\u001a;L\u00860\u0010f\u0004OZZ_t\u00adA\u0097}N.\u0010\u0012i2Y9};vO\u007f\u00016Q0\u008ce|`\b|`\u0001w\u0015,\u001e\'?\nH`\t=\u0098\n\u001fV\u0089\u0002\u001f>B\u0007\u0083x\u0089&c\u009d\u007f.cC\u0017\f\u0094i\u0099\u001c\u0083?\u0012]c\u0090\u0016\u00971-ci8\u000f"qB\u0019[\u008ak\u009acr\u0094me\u0099\u009dBh\u0091\u008bfb~\u001cMV\u001dd8\u009ei\u000b\u009ef\u0005\'$\u0019\u0006\nF]p\u00990\u0018\u0089fv}-QB"9U \u0091\u0016\u0086\u0099E#0f\u001df[\u00ad-Pv\bT4\u0013V5%\\\u0011\u0092X3LX\u009eQgIW\u0091\u0091W]p\u0005\u008d0\u0099?\u0095:\u0099\u0092VJFO\u0014\u0092MA`i\nq\u0015A1\\W@\n\\\u0005A\u008a\u0080A)5"\u00934\u00828,\u0013Fh\u0015J+g\u008e\f^z\u009aK\u001a\u008e\u008c\u0087\u0004a@7e<f\u0082y"\u001b;D\u0012=\'\u001d\u0003\u0012\u009a+\u009b;\u0086%\u00ad,\u0086\u007f\u0015W\u0092J\u009d\u000b/Gd\u001bL\u001eXg\u0005<mx\u0015#\fx\r*&0.K\u0015o \'+\u0015\u008fA\u001a\u0093|g\u0013\u008c<\u0000o(`[\u0086b\u0007*\u008aSa\u00ad\u0084\u0019\u0081C\u0099\u000f\u0094%M\u0097U\u00114z\u0011%LEu|t\u009a\u0018\u009ag1qBu)\u0094\fk$1\u008b\n5xE;i1g\u0018Yu[sD:2KZMu6?Al\u0010\u0086T\'[\u001a\'\\L\u0092z\t\u001fo\u0092\u001fB\u0091\u0093E\u009f1]^\u0084\u001c\u0086.\u0011&\u0085z6\u001eKZ6\u000e<S+Y\u0082h~\u001au.\u009bV8Xb\bu\u009a2\u001bi\u0095te\u009ed\u008fNH;4A\u007f\u001a\u0086?2\u0018/y\u001a/\u0012\u0095\u0099j\u0013\u0081\u009f~\u0085\u000f4\u0006\u00053\u008c1\u0015\u0002\u0084\u0080$ \u0089<g\u0092y\u001dWjFK$j,\f\rt\u0005\u0086D\u0093\u0094\u00ad \u0014 \u0014\'Rk\u0010$\u001aG\t\u0018}/a\u008aN\b\bj\u008a~\u008cDH\u009bAR \u0018?\u0082\n\u0094#0,_;\u0082\u001d\u0016iq\u00819|\u0011)[Al \u001c\u001e\u0003q"\u008f0\u000f\u0018%\u001f\u000eT\u0010\u001a\u0091\u0001q\u00059\u0084N\u0090\u0004R\u00907\u00133\u0085w\u000f\u0084o\u0083\u0090="\\\u0006\t\fb\u008dj\u008akD\u001aQ0\u0014-\u0013#Kusu\u0010Q\u0091\u0080\u008c\u0090\u0090cc\u000f)\u0000Q\u0082=[tx\u0092V\u0017\u0005\u0000p2\u001d\u008b?`\u0005\'g\u0004[\u0081:YM\u0098\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000org/gradle/cli/CommandLineArgumentException.class\u0095\u0091J\u00031\u0014\u0085O3Zm+U\u0007V\n"\n\u0096i\u0098Ff\u0012\u0007$-U\bfq\u0093{rwO\u001b\u008034K(`\u0084m\u0017u\u0017\r\u0002\u009c\u000b\u009e\b\u0087=}^DESE=\u001a\u0012\u0014.\u0098\u0011T}.m\u0016\u008f\u0098\u001aQ\u0095\u009a/\u0003\u001a\r&\u009f\u008b\u0085t\u0013\u0082\u0013_\u000b\u0015\u001dG\u000b"]8bl \u0017*b&\u0080=\\\u008a.\u0081\u001b$rA^\u009b2\u0098(d[\u0080f\u0089&\u0097V\u0010\u00942S\u0001o/c\u0006PF\u0011\u008e\t\u0015\u0082?^E5.\u0013)\u008f\u0012-/\u0098\u0095\u00031\u0013ttuyNN3\u0005y+:\u0096\u0095;XJk\u0096\u008cu0\u009cug;S~t\u0085\u001d\u00160w\u000e3*6M]\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000org/gradle/cli/CommandLineConverter.class\u008dQMK@\u0010}\'"4\nF<6 EQ\b($x%vS<\u0003Q6\u0085\u0012L\n]Xv\u0086\u0099\u009fo\u00008wupJp\u0092L-6\u0084~/\u009c\u0005S\u0084bf\u0094\u0007%u<\u0089\t*D<.\u0013id\u000e\bn$\u0085b&\u009cpW\'<(a\u0091R\u0089`\u0018qKx\u0085\u0099\u0016l\u0092r?I\u009cOFl$\u0094jw\u0090v\u001a\u001fR\u0014m_U\u0088%J\u0003\u009d\u001bvJQ\u0096\u0084?_\u0094F%p}b\u0011.;o\u0012-\b7\u0089\u000fZ3fSm\u0002\u0081i\bMlg\u0096pl~Qqk*\u001d[9a\u0011\u0091#\u001c\u0017\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\n\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineOption.class\u009dV[w\u0013U\u0018\u0093\u009d4\u0099^\u0088i\\"iB\u001b\u00adZ.^\u0016\u008a\bdL\u0007\u00990\u0099p\u0011w\u0007 .\u0081UY\u0093\u000f\u0017\u0019.\u0097d:\u0099\u0087\u009c\u009dsN\u007f~\u0005&\u008cm8\'|\u0018\u0001\u009ckE\u001f\u0096Zq\u0001o\u000b\u0018\u0089\u0010.E\n.\u008bA\u0095\u001cA\u001a\u0019\u0019\u009a\u008cwh/\niEHz\bW\u009c\u008a\u0085\u00118\u0089\u0014C^&\u0006KFA\u0086-A6n\n\u0012:T\u008d\u009cf\u008fJh\u009d9.Z\u009a\u0084\u0095c9sV[y^\u001a7B\u0081*\u009b\u0012f$\u0015\u00968#!Z\u000b/!eJ\u0082D\u0096Y/\u008a\u0084jL+\u009bZjRiCO\u008d\u009bj.3Y\u0088o8--\u00adZFB\u0098\u009e\u0012bq\u009fI[eC\u001b_\u0090\u0010\u001c73\u009aH\u0015af\u008a\u009a5/\u0084fZ5\u0016TK\u0017kwt\t+:3NU-\u0000\u001ak\u0083j\u009aw(.!a\u0004\u0091\u0081pVg))_C\u009a{\r\u009c\u0089\u0085c.[$\fk\u0091l\u001d\'{\u001bRS|~2v?x+bi\u0085zkN\u008f\u0017u#Y j>2ZfYTR\u00ad\u0011Q\u008e\u0096\u0012\u0002xu\u001d\u009d\u000eWx8R\u008b\fE\u001910o\u0013\u0014gm\u008e\u0019\u009e74\u009f\u008a\u0081r_q9\\\u0085WO\u0095\u001bw\u0096/\u001bjh\u008az"\u001d#\u0081z,Zi.ZFkP*\u008f\u001b$}iB+\nc\u0087\u008c\u009b\nna\u0082]b\u000e\u0005\u00821\u0003|(\f2>R1>aSz\u0081\u00895 \u0082\u0082xA$>U\u0090D\u009cP~.*8\u0085\n\u0095\u000e%\u000f>\u0084\u0082\u0085\u0082\u0082;g+Z\u009aEk\u008cM\'\ng6-\u00870\u000b\u0001:\u000bNV\u0004\u009f=!!{\u008a\u0015LX\u0007`e2zFI\u009c3U\\%N\u0015e5CC]Z]A\u0081mYCYb\u0019Z.+&%b\u000b`)s4\f"(({j^<\u0005Q*>\\\u0005\u001f\u0010{#\u0013\u001c\u0099\u001c\u0015\u009c\u0013%\u009dN\u0000\u0083\\\u0081&\u00049\u009fI<\u0086\u0094x\u0082hz\u0088`G4?DKyGN!$az\u001aZ%V\na\t"2\u0093\t\u00815(\u0001,{\u0003\u0005\u0091\u000b!\u008e\u008a\u0003=V\u0003$IjH\u008d\u009da\u0014\u0011D\u009b\u0084/\u0016\u001a\u0002\u001ci;\u000ea\n\b\u0083\u0094\u0010x\u0090\u009ad8$\u008b\b\u007f\u0011\u0014T\u001a\u0098\u001bf\u008a+qY\u0083\u0090r*6:^\u0094\u009b]%\u0090w\u0018G\\\u009078\u00078\u0089H\u008d\u0080ir`v?/\'\u001c\u0092\u009a\u0017\u0086\u0096\u001c\u0086\u0015c\u0018Gaf\u0084;B\'\u0094\u0088F\u0004|v\u0006vr#x=\u008cz\u0018C8P\u0017c\u001c\u0013.\u001d\u0016}\u0082vrc\u008a\rJR\u008fi1!h\u0088]n\u008aG\u0088\u0095S\u0085\u0086\u00100\u0019 \u0083.j5\u001f"GO\u0090\u001b\u0086 \u008d\u001e\u0099\u001f\u0001\u008enJ0.b4-\u009d\u008f\u0098\u001c\u0010n=\u008cw"`<A\u0082F\b\u001b%H\u000f)$\f\'J ^\u008dz]B\u009a$\u0002\u008etA\u0087\u0081h3_\u0094\u0011?\u001d:kR<M3\r :U\u0010r\u009a\u001a%\u0013n:\u0099\u0016w\u0090\u0083\u0010l\u0005S\u009bu\u0088\u0007\u001d\u0006\u008f\nY\u000fr\u0085\u0010\u0090\u001b .\u0010;*\u0011\u001ca\u0017QN\u0004\u001f"Z\u0013\u0012\\\u001e\u0087\u0081D\u0088u!zq{9z\u00973uzYbU}ye\u0091z\u0088\\\u008a\u0018\r_\u00919q\u0098wA4\u009761\u0001Gu\u000b\u009fM!&\u0095b\u0099c\u0098\'s\u0091B\u0096\u008fJ1\u0098P~YN{YH\u008b\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u008a\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/gradle/cli/CommandLineParser$1.class\u0085\u008cA\n0\u0010Eh\nv\u0088k\u0083^(\b\u008a\u0082\'\u0088P[\u0004\u0092\\x\u0000\u000f%t\f\u0087\u000f\u00048D\u0018bD\u0088fsV\u008a\t4\u008d|\u0092].\t\u008d\u0095q\u0095.\u000f^M\u0011"&\u008d-EieX\u0012?\u008a0i6S9v\u0084\u0013JR\u001c/5-!W\u0093 \u009d_x\u0017`\u007f\u0080_\u0019\u0080$\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099\u00adN\u0003\u0000\u0000\t\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classVN\u0013Q\u0010N[8e[TA#V\u0084\u000b" \u0088\u0016\u0094\u008b\u0014\nAIu\u0092"\u0082\u000b`A%13Q|\u0006c\u009c[X`\u000b!9sf|s\u0099o\u0000\u0098\u0097\u0080D\u001d-I\t\u008dHHH!\u001d@/qq\u0017\u0092\u0001\t\u001c\u0083\u001c\u000f8\u0086%\u00040"A#\u008e\u001c\u0019\u0086ZV\u008c$\u0019\u0086\u0099OMy&\u0094\u0082\u0096\u00183e}%\u009cl\u0016Us\u0088\u00875]F\u0018&:+ezC]\u008b\f1cEeh\u0014\u008ce|./\u0017\u0088\u0013\u001a\u008a\\X\u0094MM\u009cKL\u009fp\u0097b\u0095\u009a\u009aY\u00166\u0097K\u0090\f)]W\u0082\\,c(\u001c\u008a3\u001ch\u001e\u0091\u009aH\u0018\r}\u0092M+ai\u00861\u008e)\u0012Z\u00843*\u0091\u0013\u0005Y\'\u0016,SC\u0095\u009c.w+\u0007lE*\u0019>9U\u0016Z;;:"@\u001bxv.U\u001ek\u0014XRbI3D -\u0018\u009b\u008ek|Z*tzD\u0082\bB\u0010!4q<\rb\u001c\u0013\u001c\u0093AL\u0019C\u009b[j\u0018\u0006]\u001dy\u0096~D=\u001e\'\n*\tf\u0090]\rL\u001f\u0003r\u009c\u0002s\n\u0088Z(\u009a\u0015K\u008eL=VML\u008e\u0096l\u0087c:N\u0090>}PW\u0089E(Q\u009d\u008a\u0016\u008b\u0091\u0081$Uio\u0015\u008d\u0015\u0012U\u000e1\u009dQ>1rb-gq:\u0014f9cy\u009a{:9OR/\u008d\u0095iPFFz\u001cPH\f4\u0088\u0006mi\u0092^\u0083\'x\u000e\u001fA3\u00ad\rB&P&\u0011`Sh!^\u000bH\u001f\u0097p\u0005)\u009aLcN\u001cG{&\u0011\u009e\u0083\u009d\u0081.R\u008c$(A.%\u008bR,N`\u009e~vX\u0012\u0016\u0080l\u0006Ml\u0016,\u0087\b\u009b\u0089:\u0086\u0016\rA&CA\'\u0011\u001d \u001f7"\u001c!\u0081Yr8GR\u0081\f\u0083\f\n(6^f\u008a\u009b"pfSQ;\u0007\u0082\u008a!neGl\u0003=Z\u0089s\u0083\u009b>\tw\u0005DO7R\u0087x\u00850D\u0000\u000f!o)\u008c<\u0098=\u0093\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019D\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.class\u00ad\u0095mO\u0013A\u0010{-r- >W\u0004\u0081+p\u0080\u008a"D!$\u0015M\u0090Fxag9\u0099\u0011.\u0090D%\u000f\u00872^r\u0092\u0003c\u009affwn\u001f\u0000fq\u0080\u008eQ\u0003i\u008cu\u00934h \u0089I\u0003StL\u0098aTz\u009d\u008bj\u00116P\u00935&y\u00ad\u008aXOl}\u009f\u0005\u0086\u001dG8]\u0086\u0091x2Cr\u0012<\f+M[>\u009b.YN\u0094\nw\\:J\u000f\u008dI\u007fi0dm\u008dxBBr\u008d\u0086Mu0r$f\u0090\u0084\u001c\u008eu~^\u009bF\u0086+\u0096[.\u00175k\u0097\u008e-\u008co0$\u0016\u0019z<\u0011A\u0098ekS\r\u001b\u001d\u001db\u0017V\u0085g<\u0089?d`Sm\u0091t\\cX>\u001dcg\u0082>v@]7|\u0094-\f-+CG@\u009b\u00940\u008b\fj\u009eE7\f\u001d7\u0018ck\u0089\u000eW7x\u0092\u008a1f\u001600y\u0006d\u009883\u001e5\u008d?U\u0086\u001b=\nq~\f\u001f:5\u007fh\u0098h\u001fkmq\u0083\u001d_2wC^\u00802\n\\\rG@\u0014I]T\u009f\u0091\u0087Gi4gL\u0007,~Ab\u0097T\r4"A;\u009f\u008b\u00ad`\u001b\u0091m\u008e<N\u0002\u0081\u008c~\u001fBhV^Zc\u008b\u0095"\u001b\u008b\bCk14\u009c\u000e\u0018\u00838\u00172\u001e\u000e\u008a\u008ew$\u008bg$T\u0086]\u009f\u000e\u0000+\u0001tm\u0001s!PIIH\u0080K!z1PW}V\u0016\u0089jF\u0093\u009cW\u0085_\u000eyGO\u0099=\u0003\u0019E2L8)\f\u0005+\u0018\u000e2\u001a\tv^\u009b\u0002L\'\u009d>:C3q\u0091\u0082\u0002\u0007hb\u0002oPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classVRF\u0014\u0016#\u008b\u0098\u0084\u000e5\u0001|\u0092`\u009b$\u0005\u009a[qpZ\'&Bq\u0015l9#M^\u008fHg!):C;=+9`b\u0083L&3=\u009co?\u009d=:\u007f\u000b\u0000sx c\b\u008b\'\u0091\u0091\u0011"GN\u0086\u0084%\u0019Y\\\u000e\nr|$\u0016\u001c+\u0002\f\u00198\u0007p\u0083\u008c[D\u000082X(pa3\u001a\u0019\u0086|+\u0096UZHk5\u001b~G\u001a\u0095#\u0092a\u001a\u0015\u0086\u001b\u0093\u0011\u008ey\r\u0097\u009b`\u0090V[:)aXouW-W\u00125Z\u0086X\u008c\u0092\u0010Y\u001f-a5b2MZ\u00ad\u008d\u0086NEO\u0092\u008eAm\u001fE\u009c0\f\u00adZv\u0091mM\u008e\u0018\u0006\u001b\u008b6m9\u0099\u007f~YI\u0017m0+N\u00947\u000eZ\u0015!]\u0087?vu\u0007O"\u0013w\u0083\u0096\u0085\u0003t\u0081\u001c\u000fIUh8*\u009b\\\u008c\u0010\u008cXkG(2l\u0095>\u0093{\'31+\u001es\f^c\u0090\u008bQ\u0088\u0084\u001cL\u000b\u0015\u009c\u0088\u0082a\u009c\u0090:\u0096{\n69\u0017\nJd\u0088z>dxFgn\u009bf\u0097<s\u0096\u0082s\u0018\u0013aH\u001c\u001e`4ki_{\u00ad<8r\u0019mHJ\u009b\u0080\u00894Ch?Y\u000b\u0087fs|@EYD\u0018.y\u001ei\u0090\u0003\rw\u0010~X\\|\u000b!7c\u000f\u0012:lc\u009d.\u0099w\u001e\u00998.\u0088a\u00ad\u008a\u0092UM\u001b\u008d\f]\u001e\u0094\u001bi\u001b4\u0015\u0003Q\u0018\u000e\u0018Ut\u009b|;M7S^ng\u0090\u0011\f{aAz\u0006\u000fC7UBi/j\u001az\u009d\t\u0095sJ\u009aJd\u007fR{;]\u00117(\u001e\t\u001f%n8^\u0011*BM\u0019\u000b\u0085Dy\u0099\u001f>Q.\u00adnO\u0012O\u0002_<\u0091\u0081\'Z\u001e=O\u008a=6\u008f>\u0080 \u00806L{\u0084(\u00863jK6\u0086\u000fq/\u0004G\u000b\u0094H\u001d\u00ad\u007f\u0086\u0019\u0093}\u001d\u00814"\u0081Y|G\u0084w!\u0097\u0012\f\t<@)|R\rJT\u0019B;\u0018|\u008bpI\u0091\u001a\u0091^!y\u001cJ=\u000bNt3D5\u008bQ\u0096\u0018[B\u0092]F\u008e]q\u0012c\u0002\u0093D[hC\u0010\u009b\u0088#I>GI\u009e\u0014uM;\u0007\u0083\u001c\u0087\u0011\u0018\n\u0081D\u009cm\u001d@X\u0089F\u0017\u008e\u009c\u00138B\u0002sj\u0094O;\u00819\u001d\u0005l\u0001\u0017\u009c/tq\t\u001fBj\u000eQ|\u0096,1\u001a%Mg\u0091yF\n\u0005 U\u0088^9\u008b\u0084\u008bW4~-\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000*ZM\u0002\u0000\u0000\u0004\u0000\u0000F\u0000\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classS]O\u0013A\u0014=wPR\u0087\u008a"\u0088UhA\u0016x1\u0084ML\u009a\u008f\u0084\u001dv\u0097n\u0089\u007f\u008b/\u0098`|\u001f\u0019\u0006\u0083EkC9{Ng?\u007f\u0011&6\u000bQ)`,95=\u001bK&lfc*!|\u0015m\u00132]B\u0011t%a||\u0093zGy\u009c)\u0082\u008ev\u0085V\u009c&+\u0015\u0012\u001b"\u0094M?\u0094~"u$\u0091V~\u0011\u000f\u0085\u0016Q\tNnx"\f%\u0017<i\u0005zxel_]\u0095\u0011\u0094u\u0082\u0089O<r@\u001c\t\u0013~M\u0090L5a\u0002\u007f\u0019\u0002\u009c]o\'\u0010\u0014\u0091~&\u000eS;\u0090\u009d>\u009c6m\u008f#n\u008d\u009buB_\u0084"\u001a\u0018[\u007f\u009af\u0010)m*\u0083\u0081H\u009b\u0019jf\u008a\u001c\u0014p\u001a\\\u0007p\t\u001cLb\u0006\u007fs\u0089 E\u008a\b\u008b"Ld\'h@K\u009f0}\u009b1/d\fMX\u0018En\u0085q\u0015\u007fsYX\'>9|r9\u0012\\=wP5o\u0092\u0005\u0097y$\u0000L\u0091\u008c\u0085ift\u0096cye\u0004\u0099\u001d\u009b}\u0098\u0099\u0098l\u0010\u0015y:E\u0081\u001f1k-LYn\u001a3q2\u0019\u001c\\u\u0099M&:c\u007f#\u00802\u001c\u008b\u0095O\u00ad\u0004\u0088(&J`\u0007R\u0092\u0087\u001c\u00ad\u0001\u0081\u0099\u0004p6k\u000e0\u0019,X\u008c\u001d\\\u0089*w\u0099M\u0003/\u008d\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u00062\t\u0004\u0007\u0000\u0000\u0011\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classXw\u0014\u001dd\u0093l\u0006\b\u0081\u0004\u0013\u0014FMHy\u0012\u0081b\u0098\u0082\u00046\u000b6\u0018\u001a;n\u000663qf6\tZmQj\u0000\u0081\u0016\u0094ji\u0005k\u0012RU\u008f\u00ad\u0087\u007fOn\u0092]\u001f~u\u007f\u001b\u0080NL\u0087\u0004\u008c\u0096!\u0084\u0011\u0093\u0010\u000f!\u0000\u008d1\u008f\u0092e\u0088\u0017\u009d\u0097\u0003L\u007fPB2\u0088a\tF\b\fA\bC\u008f\u0007a\u0095\u0086D\u0010\u001a01\t\u0087BX\u0085\'\u0083x*\u0084\u0016<\u001d3x\u0096O\u009e\u000ba7~\u0084?\u000b\u008cy\u001c\u000f\u0017 E>%\u001f\u001c\u0012^b\u0097%"U\u0001\u001cqtw,HHx\u009d0;gahk\u0018\u009a\u0093Tm[\u0005#\u0095hOXj<\u0092z{\u008f9<\u001a\u0088nhTw\u000b\u0094z\u001a\u0004n\u000eC,2\u000f\u008b">\u008b\u0091XJlGu4\to\u0010gB?#\u0004\n:\u008b\u009eM\u001dU\u0093)eE\u0080:\u001c=\u001em\u0087\u0084:)\u008b\u0004;\u0093\u0091h\u009c!=\u000b\u0098znN\u0097\u0097\u008d\u0085\u0017\u0019\u0085\u009e/9i@ c[\u0098$\u009a\u001aYITF\u0098\u009a\u001cP-\u009d>2\u0012a\u0098c\u0086g\u009chn*l@~Vm4\u00adDjX3\u001c\u0081{\u001bsT\t\u0019y\u0095\u0004\u0096\u0010a`\u009f:n)B\u009c6\u0090)\u0002\u001d\u008d\u008b49T;{\u0093\u0007\u0011HRc/\u0095)L\u0095`:C\u009a/=y\rgz\u009b\u0093`9B\u009b\u0012\u0092\u000fYY\u0098z\u009bE\u001d\u0093\u0097\rl6.\u0005\u0088\u009b)+m994m\u009c52\u0003\u0019\u009bq\u000fC\u0011X\u0091,\u0096\u001eG\u0087e\u0089M2\u009a.\u0003e\u001a<\u001bdl\u001d2\u0010\u0015hM\u00842\u001e\f\u001f&\\:Po7(qS\u0015t\u0014G=)\u0013\u008db6w?\u001d6oB\u0011\u001c\u0015m(\u0088s(\u008c2b\u0099z\\\u008b+\u008f\u0099\u0096\u0012\u00866\td\u008b2v""\u00042N"*w\u0002\u0017ty\u009fn\u0094U^\u0095Q\u0095\u00176\u009eFb\u008cS8-=\u0019\u008c\u008c?\u008c\u000f\u008c?r$RIGz\u0088\u00951\u0016,,$|\u008fpn\u008e\u0091q\u009e\u001d1"\u0013\u0001P\u0019\u0098\u0094\u001d\u007f\nt.0-\u0083k]T\u0083\u0010hYLu\u000b[X[\u0096\u009d\u00ad^GThJ\u0017j\u0081\u0086m!\u009ci-X\u000f7\u0099:{#\u000b\u008a\u0006Q\u009eaR\u0095obf$\u009c!WW/\u0087\u0012B<\u001a\u009a\u001b\u00954N\u0093Is,3QhJ\u0085iS`\u0002\u009c\u0091;\u008e\u0017r5\u0016ln\u000e=\u000b\u0095\u0019y<9R9\u0019B\u000f=rZ:O\u001eS+g_k\u009f`\u009d\u0014\u008a\u0001Y\u0094*\\f,grz\u000es:I\u00804 \u0095\u0086Y\u0094\u009b\u0016x<\u0090I}\u0096\u0099\u001as\u009a-\u009f#_c\u0086%s\u0010bih\u0017\u0006\u009d0\u009a*E%\u008f8\u0082*y_\u001at\u0097f\u009d9\b\u0081\b.\u0015\u0015<<]"\u009etC\u001dF1a\u0080\u0096p$\u008ab\u001a\u008b\b\fNd\u0012\u0096IHI\u00045\u0081I\u0094\u0085k\b\u001b:Ju\r$@\u001cAH\u0083*q\u0014\u0018\u008awQ/\u008eY\u009cD\u0011%,\u001f=\u0002\u0010]Bly\u000b\u0001\u0017bK\u00ad$iahx\nG"%\u0081X:X\u001c\u0004R\u0005,\u009bF\u009b<}\\\u0099{Lpi\fV\u0014a\u000f\tZy\u008e$\u0016e\u000f\u0088S\u0090i}\u0013g%>@A=s\u0083(\u0097lNp\u0000Ek\u0010\u0003\u0011}\u0084\u0013\u00ad\'})TM\u00865Z`\u0002K.b \u0086ss\u008dX\u008e\u0010\u001f\u00119(cW\t\u0015owi\u0085BHz:DA_LlJ\u0019O\u008a\u0082\u0082 \u0006\u008f_[\u0015\u0004\u001af\u00999&#x\u007f\u0001\u009e\u0011\u008fFz]M&\u0017\u00178\u009dv\u009atP\u000f\f]\u0018}-3\u0099V\u0011p\u008b5:\u00853\u0013S?C\u0091\u0090k\u0088ADx\u009b\u0010\u0018:\u0093n\u000eq\t+eO)\u009fQ9\u0017T\u0007&\u00978&\u0085KB|\u0085\u007f\u008a+\u0093)\u000bwQ\u009c\u008bq\u0089<w\u009fW|\u001fvU\u0018~\u0016\u008a\u001d\u0012v_E\u0099\u0084\u0007\u008f\u0090]\n&\u0087H\u001c\u0090psKkMd\u001a\u0090\u009a$\u009d\u008c\u009fP\n\u0017\u001a\u000bH\u0083Y2\u0005$!\u0080\u0018z\u0018\u008fa\u001f\\\u0097\u0094R\u0091\u008d\u0015!F\u0003\u00078~D\u0014\u0003"\u0088U\u007f\u0002\u001f8^\u000b\u0084\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$\u0002\u0000\u0000\u0006\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.class\u009d\u0095mOP\u0014w\u001b\u0015\u0019*\u0088\u008fLD\u0003\r\u0091!\t\u0087\u0018\'\u009a`0W\u0017\u009a\u0016o;\u008doB\u0012\u0085\u0017~\u0000?\u0094\u0001K\u0006\u0092\u009cs~\u009f~\u0003\u0098\u0092\u008e\u0004r:\u0092\'I*(uZG\n7\u008c\u0092\u008aq\u0094\u0098e\u009c-rD\u001c\u0018\u0086_K.]Sz3\u0019\u008cB\u0098js5]\u0086\u009a#\u001b\u0086u,nV4\u009b\\k\u00960\u0003#\u0090%\u008ar\u0012\u0096w\u009f\u0092\u0007\u0090[c\u0088U\u009d:3\fWZ\rS\u001b6\u009d\u009c9\u009b^Rzx\u0018Z\u0094su-\b\u0090\u0011V;\u008b\u009eTJ?n\u0098I/GQw|\u009b\u0017m.\u001aUO\u0092Rn\u009d!eCw&#\u000e  @~\u0011+\u008e\u000f\u0095:0\u0007r\u001d`\u0080#:L\u001e\u0089:\u009e\u00ad1\u0089)[\u0011PR\u00972q\\\u0018U%7\u0096\u0092#63\u0019\u0006\u0086\u0090V\u0097\u0006t\u009c20\u008f1\u0003\u0015,\u0018\u0088K\u0006`<\u008eE\u0086\u0096\u0088a$e\u0098=y\u0003\u0019&z\u0083a\u0018\t\u001a\u009d\u0005io\nS\u009ex[t\u0015\u00ad)<\u0086L/gd\u0095\u001a=Ij\u001a$i\u0088\t0iOH\u008b\u007f*\u0010\u0017~"Cj\u0084AQ\u0000{\u000f\u009dI\u009c\u001cgI\u0082/),9\u008c\u0085\u0010\u000b\u0088}k4\u000f\u001c\rq\u0096\u0084\u009cg\u0014\u009f2`\u0007\u0018(LB~\be\u00026n0)I\')Be\u008c\u0087{a\u0082I\u0005\u001c\u0087\u009f;rLv\u008e\u0019\\\rQ\u0015_\u000fQ\u0094\u0095;\u0082\u0004\u008c0AS\u0016B\u001e\u0092e4h\u001ed\u009a\u001d\u0015v6lo\u0092\u0086_\u0094\u0099\u009a\u0081\th8%\u00181\u0005+a\u0004U\u0015\'\u0014 \u009d\u0007PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>\u0002\u0000\u0000\u0006\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.class\u00adUn@\u0010=\u009bq$\u00946\\%)MK@)p)\u0015E\u0015 \u0005E*o\u001b\u0004\u000e\u0085O\u000bx\u0001$\n\u0088J|\u0000\u001f\u0085\u0098M\u0092*A.\u0015/\u009d\u0099\u008cgf\u009f\u0000P8\u00120*wTz\u008cc\\\u0085\u008e\t\u0005\u0093*\u0014L+(\u0088cVAQu\u0086\u00844\u009b\u0095,d\u0096\u001cQ/\u00055\u0082\nOp\u001f\u0012C{i\u0099\u001e\u000e\\\u0090e;\f\u000f`\nCdQIh5x\r\f\u0094\u001c\u00837*\\X\u009d\u0011\u0099.Cg9\u000e\u0017Z\u001eu6j\u0083I\u0085,s\u0099]SMj\u0092%}\fP\u008a\u0085\u0006\u0085\',4\u009c!E]&\u0015\u00968\u0086c\u001f\u0010$\u008e${\u0017]pG\u008d\u0098o\u0015RNK\u0018\u009a%\u008dti!\u0089\u0094\u0086\u0098\u008fS\u001anbX\u0086[XPa\t\fs\u0081\u0099Lf\t+~\u0098a\u0097[f\u0098:\u001e~\u0081Z)9hOS\u0086\u007f\u00ad\u0082\fcs\u009e\u009bmqr\u000f\u009c\t\u001a|\u001a\u001e\u0004FdU0L-\u001e=\u0094\u0013_qkvrl0.\u0092F\u001f\u0010\u0006|\u0003\u0094\u009cx\u0084\u0011!\u001a\u0000\u0019J\u0084\b\u009a\'vt\u0015!}r\u0017OYY\u008a,T6\u0082$a\u0088|i\u008a\u0019Z\u0003\u009d\b\u0011\u0005\f\u008bdKTT\u009f\u0082\u0087C(\u001d<C\u009e(.\u0012\u0019.#\u008d*\u009f\u0011&>Z7D!\u0007eSZ2B\u0099#\u0087o\u001fo+5U\u0010c\u001dC{\u0095\nB\u008f\u0014*^\bv#8GNi$y6\u0012\u0098\u008e+\u00111E\u00888\u00ad3$r]\u008boPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%\u0002\u0000\u0000\u0006\u0000\u00007\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.class\u0095TmOP\u0014~Q:\u001c\n\u0080\f\n\u00832@\u0010\u008a\b.,Yd\u0086\u008fe4kI\u0011\u007f\u0086?\u0084/~\u0001#\u0089_\u008d\rN6).]}s=~\u000b\u0080E\u0094%d0#\u009f0+bN\u0082\u0000U\u0002J"\u0016E,IHs;\u008d\'"V8|US\u0011k"\u0019z6L7\u0019\u0092\u0005e\u008fA(;\u0007\u0006\u00adi\u001b;\u00ad-\fV\u009dn)L\u008f!{\u009b\u008e]v\u009aG\u008e Wlp\u0096y\u0006!\u0096\u008eP\u001b~`\u0019j2U6u\u0080y\u00ad\u009eN_\u0018z`QW\u0085k\bH-\u001eT\u0088\t\u0012T|%|\u00914y`P?UK\u001bjwM\u0085k\u0004\u0017\u0016w\u000f\u008duz\u0094\u008a\b-\u0000\u009e$/0L\u0004[3\u001bxM7-O7\u000bIRiu;?\u0091~\u009eSb@\u0006\u009e\u0089\u0099ZaBh\u0005\u009f\u0013\\\u0016i\u0082a+6eY\u008c\u008a\u0019g\u0099{"\u0006!c\f/\u0018&q\f\u001e\u000e\u0016v\u008ea[h\u008a\u0082Z00\t}\u008b\u0003\u0005m\fj\u0086]{\u0096\u0090\u0085a=e\u009eB$>\u0095P}4s2|=Q*teK\u008a.@\u0001\t>rd\r\u0092\u0092d$S3gH|$%\u0081!zp\'\u0086a\u0010\u0080\u0011!x\u008b\u000fD\u0096"2{\u008a9\u0084\fO\u0080Sp\u00ad\u000bHswnL8\u0085tr\u0099\u00ad\u001fI"\u008e!\u0003y3\u001c2GYv\u0017\u0082\u009d>i<2\u0087\u0007\u0098<\u001dl\u00924!M{\u0018n\u0095V\u0088\u0017\u0099\u0099\u000b\u0015\u007f\n\u009a#fdY"\u00925\u0092\u0089>{}FCNS\u0098#ZOq\u0080\u0010H\u0005INQ2(R8S<i\u0092\u0018\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000fC\u0098\u0001\u0000\u0000\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.class\u0095\u0092J\u001bA\u0014Y\u001a4\u0001\u0014JoJP\u0003\u0085\u0085H.\u009b$:\u0099\u0095\u0089\n}\u001c\u0004/\u0000}3\u009b\u0080\u0088\u00854\u0017\u0099\u001d\u009c\u0017\u0080#B\u0014\u0011F\u0080\u0000UBXie?\u0013\n\u000eo}IXl)-O\u0087\u00834\u009bpf\u0095D\u0011F8K\u0095\u0011\u0096\u00adJ\u000fa2iVXT4Dd\u0099dVj(6\u009f\u0097\u0099\u000e\u0006B]\u009fQ]\u0019AXH5\u0087\u009e[\u0001\bO\u001c&\u009fBT3k8\u0090\u0012N\u00ad+q#D8j[t\u0098\u009a\u0010KMd\u008fT\u008b\u0011W^\'\u0000\u0084d\u0087\u0086[\u0083w{H\u008f\u009bms+a\u0006\u0000;\u0084@(?^YJx\\\u0011a{(\u0084$\u0093_\u0087{\u008aL \u0004|\u008aX\u0089uf\u001e\u001d\u0007\u001efs\u0013\'\'8.\u008d\f\b\u0002ygXu\u0019+e\u0015\u0097/;\u0018\u0089\u001b0\u0082:^eor[n\u000f\u0014}\u0087y?"k\u0099\u0095\u0097g\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000E\u0002\u0000\u0000\u0005\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.class\u0095TN\u0013A\u0010zq\u0094Z\u0004DQ\u0011\u008bGQ\u009f \u001akL\u008c\b&(\u0006[\u0097rxk\u000e\u008f\u0013/$\u0002\u0089&>\u0080qv[\u0010l\u0093B\u0093|\'\u00809<E?L\u009d\u008e4\u008aB-0\u001a,\r:4\u0014\u0085(\u000b1\u0097m;\u0086{\f\t\u001e\u0018#<8t\u0002CO\u0088\u0012TRXgP+Aa\u0018Xv}ge\u0084o\u0088L\u0081u\u001eBo\u0019x\u008d\u0018\u008cU\u0099\tC\u000bw\u008aSk9\bkV-Ul*AH\u009a\u0087\u0091\u0013NS\u0001\u009a\u0013?s\u0086?:\u0098/t*\u007f-\u0087W!h\u0090\u008a\u0083\u0086\u0007\f/Tww~e\u001b\u0010e!\u0018rg\u0089cDQ<?K\u00959p}-\tm+\u00860\u00860#B\f\\@@\u0016\u0083B<40\u0080\f1/\u0095\f,`\u0091a\u007f;WuB\u0003\u008fd:\u0018\u00189_\u0098\u0086\fsf_v\u0094k{\u000fE(a\u001cs-\u0086\u000e\u0093-+\u001b\r\u0012N\u000emVnD0N/MOWvR/i\u0097\u0015-5)m\u0083\u008bJ\u0006i\tZ\u0007C$}fq\u001flO\u0086\u000e0\u0015`z\u0098\u0082^\u0096@\u009a\u0018&x3\f#\f\u009dHN$RhOh\u0089\u000e,\u009af\u0093\u0007\u0082\u001f6\u000e\u0091\u0012j/\u0019-\u0007b.\'$\u001e\u00814hx\\\u0006e\u00adF\u001f&&E\u008b\u0080EpL\u009a\u00070v\u008fk"\u0019\'\u0090\u0092M\u008cF+x\u0095\u0002\u009c.\u001eB;\u001d\u008e2l\u001c7DD!\u001an\u0086\u0088]\u000e\u0093HdR\u00856fTnG#f\u0013\u0012ZA^\u0002F|\u0014\u001a\u001d\\\u0082N3_&\u0017PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.class\u009dTO\u0013A\u0014fv\u0085e\u000b\u0015*Z@Rd) \u0084\u0094\u0010H\u0013\u0092&ULjH6\u0094MY\\v\u0096\u009b\u0097^@\u0089\u007f\u00931(\u0016\u00ady?\u009buf|{\u0011"VtcF\u0087.\u0017\ry\r:T\u0091\u0086yM\u0090\\];`P\u0085]\u0006[\fC5\u009e\u008e,s(3\\\u001a\u0015-8\u0086\u0007v\u00909\u000em\u00ad\u00876+E\fFu-\u0088 \bVc\u0099\r6\t{$}\u0099\u0003]_5\u0088\u009ak\u0087D\u0098\u008ep\u009bf\u0007Y\u0014t\u008b\u0095$."\u0089\u0010\u001cx~H8G@T=\u0014\u008dWOq<\u0095;{\u0087V#,wg\nU\r\u008b\u0011\u0094\u009c^`\u000b\u009an7]\u0011\u000e\u007fb\nm)z\u001bTJ{-amrLWyy\u0080\u0081\u0094\u0081%,kx\u0093cE\u0004V\r,7C\u0011\u0013=\u0010\u0081Qd\u0018fX\u000btXG,\u0086\u0091b\u0098O%q,\u0019\u001eD\u0086nd3Xw\u0083a\u0080^\n.\u0085h\u0090"\u0093,#\u009b\u0098\u0000\u007fG\u000e\u0010\u00adI\u0099\n\u001b\u001d\u0000n`\u0084,\u0093\u0087?C<U<\u0087\u0081\u0085l\u001a\u00adS\u0019\u0012\u009d=\u0093)\u0012j\u0003\u0017\u0002\u0089"\u0093m*D\u008d\u0001\u009e O"5L>\u008e\u0012\u001f\u0012OE\u0084\u0096;McB\u0085\u0011-!\u008f\u0013%\u008c."\u0087{\u0081N\'\u008dM\u0015\u0006zz\u008b\u0019\u008fY%B65[\u0004m\u008e~kE\u0093T\u0087BZ\u0093q\u00915<\u0016\u0094]/h\u0003\u009f}L\u0082\u0007\u0011>\u0087\u0087\u0091\u009dMc\u0094G\u0001MHx\u008f)\u0088PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000\u0004\u0000\u00002\u0000\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.class\u0095SoP\u0014N)\u0014\u000bs\u00809\u0015\u00117\u0018\u001b\u0019\u008c&\u0012MLf\u0082..vF\'_|\u0007\u0000(-\u009b A\u009aG\u009d\u009c\u0017\u0080\u0003mdQ\u0091C-\u008f6xbaB\u0083\u0090{I/zI4\u009a\u0004\u001b\u008c\\j\u0093d\u000fbs\u000b\u0086?\u00164iF^H(\u0017*tU?\u0012\u0011\'\u008btU\u0017av/Pcgw\u009d9`2\u0011r;$uTy\u0087P\u009a\u0088/\u0003\u0097#\u0015\u001d}\u008c@\u0012\u001b3I8\u0090c\u001f)O\u008e;\u0013B\u000b/ \u0019Z\f\u008e\u0012\u0014\u009b\u0085&\u009cWt\u009fi2qfYC!\u0090\u0087\u0081\u0010z<K)\u0090)\u001b9Ki,yGm|~J\u000f\u009a`\u0083s5tz7f0m=M\u0011\u0016\u0004*l[\u0016ZEla\u009fl<\u001c\raD8X~\u00844K\u008e\u0082g\u0098\u0088hx"\u0006V\u000e`\u0015\u0080p\u0083#\u0087-\u0080\u008d\u001d\u00036?s:I%\u0014/&\u0000\u0080JP\u008e\u0089*l\u0013\u0092\u000eW\u0019\u009aU|\u0087\u001aZL\u0091@\u0012\u009a\u00855\u0010\u0013NL|\u0017\u009b\u009c\'T\u008ac+J)\u0084)O\u000b\u009f5c\u0014\u0097Rz\u0097zx\u0080\u0087qY5?M\u009b\u009bm\u00986Wl6-\r/\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pX\r\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUR\u0013Q\u0010=w\u0092I0@\b\u0010\u0085\u0088(I\b\u0084\u0097\u000f\u0004\u0090*\n\u00adBY$Sqt2CM&//.\u008aG\u0095\u000b?\u0095\u001b_\u000b7n/XvOB\u0084P!.to&\u007f}\u0007`\n5\u0090\u00866Z\u008d\u0099\u0083I\u008dR\u001a5\u0001I\u0088\u0086@#\u0096\rw\u0095\u0003\u0002\u00036%K\u0096FY`|q\u008b+\u000b\u0096\u0091[fn)\u0095]X6m\u008a\u001b\u0083\t\u0084[\u0014H,?\u0093/d\u0092v1]\u0001V`0S\'HdMoAH\u001delNZ5\u0081\u0092S8eR0r2FN^Zk5y\u001f\u0004S\u0093D\u007fb?\u009d\u0097Mt<A\u000b\u0081\u009dE/\u008bnR2l\u008fM)\u0094z+\u0096rO\u00adIs\u0003;\rm\u00991&k|DN\u009b\u0096OlV\u007f\u0098^I\u007f\u0004\u009bI6Sl\u0005\u0086O\u0002k\u00ad:\u00157o3y#9|G\u001d=esSG\u0017:\u0091S\u0010\u0006\u00981\u008f[Q\u009b\u009e!0\u0014\u0000 \u0096mEd6\u0017J`$ua\f6{\u0004\u0002\u001dPrMZ\u00155z\r\u008e\u0094 }\u0005K\u0019B\u0082\u0007B\u0004\u008f4%\u0011(<>P\u0015\u0095h\u0017&\u0097\u0011P2\be\bgvn\u0081\u0082$$T@|\u0084*>A\u0013\u009f%W|):T\t\u008f3\u0080\u0082_qI_q3!\u008a\u009et\u0096<g):\u0011\u008e\u0088o>^=\rx\u0005c @\u0002\u009aC!:Z\u0003_ eYq\u001f>8YMHEF\u0082\u009fw@@9\\"\u009e!v\u0010C\u0094\u009cz1\u008b\u0089vx\u0095\u0095&\u0083\u0080k\u009d\u0014$}\u0011\u008cf!\u000fuTsj]p99\u0086+\u00811\u008c:*\u00854*4\u001ff\u001bE\u0007!\u008a\u0013\u0093\u001e\u0019\u009c./1Y\u009c\u009f\f\u0087?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009b\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineParser.class\u009dYi`\\\u0091J\u009a\u00997zze=`l\u0003\u00961S>\u0000\u0019K6\u0096\u0091\u000fXz\u0092F\u001e\u0088\u0099\u00118B\u0011\u008e\u0010\u008e`\u0013\u0002\u0081`\u0087\u0004\u0082d\u000b\u0081M\u0012\u0012a\u0083=\u0080\r!l\u0000~\u009b\u0019\u0089PwOwUuUuO\u001d{\u0010\u0080YT\u001e:jW5\u0016\u009fh\u0083\u000e/>)s3\rO\r>\u000b\u001dyRa\u001d#|\u001c|1\u001c\u0084\u0014W\u008b%G\u0018cxS5\u0015E\u009e\u008e]%_\u0018\u0019fFe\u0014u\u0091\u0002\u008cPt|\u009de\u008c&cu\u0094\u0013\u0014\u0097q\u00198&&\u0004\u009c\u009e\u009a\u0089JO\u008b\u0094|</\u0093&\u0093uH&\u0098+S4\u00994\u001de\u008eZ9MQDbzAJu\u0095\u001a)\\r%m\u0099\u0097\nzE*J\u0095_.3Us.\f5\u009a\u00ad\u009c|\u0096\u001a\u009c\\5\u009c|\u0002,T\u0017iXG3\u0005\u0012\u001cHx\u0004f\u0019R,Sv-UVY~9[y\u001c]e.*4P\u0013\u009e\u00874Z<V\u0093&\u0081Q\u001f\u0089\u0098e`<n\u0005Vw%BHS"\u0016\u008a/\u008b\n\u0082\u0089hL\u0093u\u0082\u0082q>\u00127#P"t\u0089\u0099M$(\u0017L8?=\u0012\u0019\u0017\u0004cq3\u0094\b&LMssOA0e\u0002AQC(\u001ej]Z-um\t3f5i\u0016\u008cf\n\u0089mkG0J\u0001Kh\u009adc\u0001u;\u008313cM\u0082\u008c\u00890[\u00821_a5u\u00adX(\b\f^\u0012N\u00841U&\u0098V\u0091\u0082QQ[=I\u0019\u001b\u0082]k\nG\u0082\u0089\u0018-\\\u0091\u0019\u000eFm\u0001WEc`kn\t\u0087\u001dV\u0085"\u00adE\u00949:\u0018\u000eGw6\u0084v\u0099\u00ad\u008e\u00041|yqe4\u0015\u001d1P<-l\u0089\u0005H(H\u0090[Rs,\u008b\u009aJ\u007fc\u009b\u0019[\b\u0005\u0085-`,~;\u0093\u009eDG\u0088\u0092|\u0085K\u008d\u0004g\u0096l\u001aloi\u0004\u008b\u00ad5M\u000e%\f9.b\u0088I+v\u0098"\u0098[\u0092FUR\u008a\u000fo;R`\u0090FN\u001b\u0014\u00943#\u00ad\u008cm\u001eL=\u0083 \u009a\u008c4P\u0017%$l\u001bu\r*\tcLa\u0014te+r"n\u0006\u0016\u0093uUC\u009b\u0097i\u0080J\u0006\u0085\u009b]B\\\u0005\b\nk\u0014X5Pj:\u0003)B\u0088p\u0002(^\u0017\u0019H\u0098i%\u0083\u0004\u0085n\tZk\u001bn\f\u0089\u0019\u0092\u009d_\u009d>N\u0082\n\u0017\u000e\u0012\u0011\u0004\u009c&3A\u008632g\u0016\f\u0007R4d\u008a\fZ\u00948?\u001ely\u0006O\u008b\u0001m\'\u0011\u0088f@h\u008c%s\u009eUu6\b\u00923\u0005i\u00ad\n\u0095\u001e%p77\u009a\u0091DL^aE\u0099\u00909\u009aV\\\u0084\u008aEW\r\u0099p vX8\u009d)4iFf(Ma\u0084}\u008e.l?F,\u0083N@6\f7w\u009e3E\u009a\u00045F\u008c\u0086\u0018p\u000bJ\u0004-\u008b\u0086f\u008b\u0015\u0000n1\u0002R^:t\u0004[\u00ad\u0093B\u0014Y\u008b\u0099d3\u0089\u009bR\u00ad\u00adM\u001d\u0084A\u001b-Vvm\u0082\u0081\u0007\u0004.(S\u009eYn\u0091Z\u001cQ_;S\u0099\u0007[Zx|\u009c\u00993\u0005K\u0086F\u0081R^9f\u000epU\u009cg\f\u0087sPY\u0091\u00141O\u0089/ \u009b}\u009bMX\u000bk#\u0085\u0006IRr\f\u008a[\f\u0080\u001b\rFD\u0081-\t;\u008d&-\u0086\u008ai{OP<\u0014\u000e\u00921M\u0083t\u0086\\\u0090\u008dku;5nHXv\u0018\u0012\u0091!]r1\u0011%\f\u0089\t0\u0090\u0084t\u000b*\u00871T\u001b]B\u00adt-\u0086\u0094!\u0090K2C.\u0097+\b\u001d%\u008b\u000e2C!W*o\u001ar\u0095\\MxZm\u0085U\u008c3W\u008cq\u009f\u0006\\lE,\u0016\u008d\u0019r\u008dRz\b\u0085[U\bV3[r!7(G(W\u0018r\u0093|\u0090\u009bjCn\u0086*\u0019\u001d%*\u0006!wYX\u008a\u008d\u00172u]4y\u0082\u0087Y\u0016\r<\'\u0094kP\u009d\u0086%w\'\u008dt3lu\u0002\u008fY9L\u008f\u0018C\'d\u0098R\u0017\u008b\u0005{\u001423$*\u008a\r\u0083\u007f0d\\/\u0080!{^C/hr\u009f\u00817\u0007\u0086\u009f\u009e\u0002kC\u001eP\u0099\u001e\u009f\u001e\u0088:\u001b\u0001\r\\l\u0083\u0010\u0099n\u001d\u008f\u0018Eb`*c\u009d&{\u0015>V\u0004i%\u0010=\u0018f\t\u0083wbeic\u009b^<cz|Fq(^\u001c\f`kOq+\u0088Zr#\u0086DB`$\u0012M\u0014\u0007[[\u008biAF\u00923-6M<\u0011\u008c%\u008aw\u0086\u0012\u001d3*gT\u0019\u0016\u0086<*\u008fi3\u0095\u000eQaJ,\u008eF=-H"\u0018\u008aP\u008e`\u0084B--\u001d<\u0016\u0086X\u009c\u00ad32`qC+E&\u0096l^|\u0094{r\u0096RC\u009e\u0090\'!c\u0089%\u0092!\u0089\u0086|>\u001bR\u0089^\u0089ww`\u007f\u009d\f\u0007\u0084OF\u009f3<,\u001dd\u001fn>g?\u0005\u0015_y2\u001c|\u0097\u009f\u0098%\n\u0007\u0080zX>"Nd1V\u0093f\u0090Y\u001072pLb\u0000h1s}6=Jq\u008a*9DuX\u0004U?\u009b}\u0018e\u000f\u001f\u009b[\u0015\u000e\u0082eN(q\u0019%B=\u0097:\u0082FsWz\u0013~\u008c-)u+Z\u000bv\u0004{\u0097p,\u0091|\u0094\u0015\u0095\u0094\u0083\u001b{`8\u009eE\u0090<\t\u0012\u000fr_nC\u009dc^{[\u0089\u0092z\u0012v\u0084\n4\u00136\u0098\u0097<[]k\u008ct6SNo\u001c;:\u0013\u0082\u0016\u008a\u009a\u0083C\u0093q\u009b[c`|\u009d(~zv\u0082V\u0086\u00127\\e\u009f\b\u0018\u007f"\u009az\u0096>L\u009e\u0019P_kp\u00176#\u0089\u000e+L\u0080h1\u001aI\u001e`\u0081E\u00994c\u0085/]Ain\u0016\u0099\u0019<hw\u0086\u00900=\u0097\u0002\u0015g3\u0086Nj\'"@#yYk>nV\u0017\u000e\u007f\u00050=t\u001a\u0090zi\u008fH_\u0085r3\u0012\u000b%?~u\'\\\u0017\u0093\u0087\u0004vB\u0091\u0003\u008b\rA\f\u008a7o}mh~\r\u001d\u001dW\u0084\u0081\u0087s\t\u000f\u0001_\u001a&%@,y\u008e\u0091<\u0080\fM<k\u009a\u0019\u0013\u00ad0nGRZ\u009eA<\u0005[1Q; h\u0019K&\u0019i13|d7L]$7$\u008dJ\u0093Ah5\u0098\u009az=\u0004\u0082\u009e_\u0091.\u009fq*:\u0016\u0080\u0017\'\u0097\u001cF\u0086&kml\u008doU}\u0004\u0011\u001b\u009awk\u0011r9r\u0001xm>\u00003y\u0083\u00ad\u001e\u0098\u0003\u000fN\u008e\f\u009b\u001ewnW}\u000f)\u0094\u0085\u0015m^YAhO\tYL+,\u0001l"G\u0080\u001a\u001e\u00877<\u00157hb>x\u0091\u000fi!_p\u0000\u0001\u008ch\n9\u0080Q\u008d}(\u000b\u0013a`F\u0085\u0082\u0098Zoe\u008b\u0080\u0017v\u001f\u009b\u0015\u0084}r\u001f\u00038i7N"eK\u0093{1\u0017\u0014\u0012\\N\u0082I\u0016AU[\u0017\u0093k|6e\u0011)\u008a\u0015\u00ad\u0016\u0002=\u0095Lg\u0093i\u008atE:\u0014\u001bRt\u0093\u009f=("4RA~?(N{\u0081,$)\u0003>)Y>gGK;,J\u001f%\u0014TZX\u008brE\\\u008b\nO\u0007\u008d\u0080?i.UMj[\u0093W\u0094\\V *Rv\u0015\u0099"uG\u009e\u0012Yxm\u009e;>,.\u0092\u000f\u0087K\u0011\u0091lwlfe/NoE\u0088\u008a\'Q<L`\u0012LE\u0013\u000e+q>\bb\u0003\u0002\u0019Wb#`\u0013cm3\u001e\u0016<\u008d\u000b\u008a_"K\r\u009f\u0005*#`x)h\u0097btH):Ll\u0097&\u0084e\u0013vH\'\u0085.\u0002\u0017M\u0088^Q~\u0006;9T7C\\)\u007f5\u0019\u0093?z9\u0086\u001bsr\u0098\u0096*\u001fh\u000fp?0\u0019\u000f\u0087\u001c=\u008cQ\u009cF\f{\u0095t\u001aw\u009b\u0082\u0007\u0010t\u0089c1~D\u008e<jZs<gT\u008aW)!r|i9\u001fY)\u0099}\u001c\u008f\u0099q\u0013#<\u0082\u009f07)5ct~\u009cY\u0080\u0082c(\u0090j\r\u008f`\u008e\u00861g\u008c?\u0082\u0012\u008e\u008e\u009e\u00ad\u0086]Ga,:h\u0012\u001c\u0086\u008f,\u0081\t\u008e\u009fS\u000e\u001c\u008cB\n\u00ad\frg\u00adT4\u0014\u001c3\u0084+"d\u0090\u0088;(N\u0017\u0011W16\u009eE\u0088\u0097k\u009c\u0000f5\u00947V\u001ex\u008bE\u009e\u0007\u0099EY\u008adN\u009e\u0091\u0083>\u0086k\u008cUa\u008e\u0006!\u008ct0F!SE/w\u0083\u0081X\u009eS\u0002\'Md_8\u008f\u0081\u0091g\u009dM\'9K\f(=SX\u0019\u0007-,3\u0013,-N\u009e=\u0019u\u0086S9Pi\u009c\u0086\n\u0005\u001dQ\u000fc"\u0099\u000e\u0005%p;\u001fs\u009b\u000f`\u001eq\u0096x<\u0099\u0000\u00166V\u0080\u000f\u008b\u008b~,\u0096z*-w\u0012\u001c\u0087F\u008eG|\u0098:%f)X\u0010JX\u0096\u0014\u009cBV\u0010\u00124[J^ \u0091^\u008d\u001cl\u0015T{\u001e\u0094\u0080\r\u009cp\u0016\u0085\u0081\u0006\u0085g\u001f9\u0085*+/#\u0092\u0007ZJNx\u0002y\u0001\u000f*\u0099\u008c\buR6+|*\u001a,&\u0091\u009dVUV}\u0010\r5^\u0087bi\u001c\u0095bY\u00ad\u00875\u0016\u0015\u0085y\u009e\\$h:\u001a4"i4\u0088hp\u0083m\u00947\u0083H\u0019\u008f8\u0089T\f^R\u0094x\t0K\u0019%\u001fk\u0098\u009fAg\u0084\u0093\u0019r7s~!o\u0019_\u008c\u0001\u009e\u009c9`9\u0086\u009f\u008b\u008e_\u0010K_\u0094\u0002$,+\fJ;~);\u009a\u0086%!My\u009dxw\u0095#){9%qG\u00882\u0007wR\u009f\u0017\u008c\u000f0\r/r5\u008f{\u009d\u0082\u0097,5\u001cq\u001fBH\u008d\\\u0088\u0097\u0089\u0083\u009a\nd^pKP\u0093\u00177x\u009dY\u0010\u0090+b\u0096\u008b7X:yx\u0093YF\u009b\u00adS\u009a-18gO{zSe\r\u0018y\u001cNva\u0095`aZ\u0081x\u0002\u0005\r5m\u008b\b\u0016\u0012C\u000fd"QLtLq:\u009b\n\u001cec%,3w\u0084\u0085]}\u0018s\u0014\u0013S\u009e}~e?\u009a\u00192\u001b\u001b<\u008b_\u0081p>lJ\u009b0\u009bjA^\u0005i\u0086\nu\u0017oQE\u008ep\u0000\u00148~?\u009eoSw\b/-Ow\u0089g\u0012K/\u0014\u009eU\u001aGy\u0095^}B\u0095\u008c\u0087,ZJ,;\u0096\u0090\u0096;\u007f\u009f\u0004x\u008eb\u0086f9\u0002r\u0002\u009dKa2J|\u008b\u007fs=S\u009e8TPqhQn\u008ds\u0083YQ\u0099U@\u0094O\u0081~lm.I=oA\u0004\u000f`\u001b\u008b2\u0005/-\'a*o}\u008fC\u0091Ms\u00ad\u0087w\u008diV\u0001\u0084\u001a*,K:&U@cHb{V5\u0094ky\u0086E=!#&\u001fP==\tkO\u0086?r]\u008d?1>g\u008e\u007fA\u0092y{8u\nca*^\u008eH*\u0087R!V\u0095g-y\u0087h.\u008e#f\u0080N>\u008c_{\u0014EV43$\u0016\u000fff\u000eN8\u009c;ldO\u0097\u000bsN\u009d]w\u0096a\u009f\u0013i\u0089\u0002\u0004\n;{\u009d\u0017\u0081g\u001f<Oaja v<\u0005s[\u0080G%.X"\u009c"\bQ\u000bkG\u0011OaXg\\\u0017\u009fp\u0017\u008f\u009f>>\u009b.a\u0093\u009cxtv2\u008fg\u007f9+\u007f\u0083#_\u009b;q\re\u007f\u001dV\u0013)^?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008b>\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/ParsedCommandLine.class\u0095Wiw\u001bg\u0015~F\u008b%v\u0093TMc[\u0096\u0018\u0092\u0000R\u008e\u009b\u00908S)-L\u0089T(\u0091\u0013\u0094.Phli7\u0003\t\u0090\u0014\u0092`rX;\u009f\u009c\u009c\u0098}g$K1G}\u009f.3?\u0019\u0001.\u0082v\u0098*\u0011`!\u0089\u008b*\b\u0082 .\u008ab\u0004u\u008ef\u001e\u0013T\u008f\u0093,.+*\u009eWB\u0004M0#h\'".T=^a\b}:\u0082\u0016|Fk\u0011t\f0^\u00177\u0084/\u008b$\u0096_\u0012\u0000_V\u00950\u001aA\u0017V\u008fMa\rq[\n\u001a\u009d1s\u0085#+3\u0095\u0099/\u0003E;\u0093\u001d\u0098\nf2\u009cn\u0017-C#2\u0003\u000ei\u0007\u0096\u009e\u001a\u0003\u000b\u0093U0R\u0092\u009eKMfr)y(\u0091\u001b\u0096Q0r*T\u001f>c4yZq\u0004\u008c%sH\u0095\u0081\u001a\u008c\u008fY\u0012h\u0099\u0014\u0004M-C#\u0099\\\u001eU\u001e08a\u001b\u0096~.k\f*\b\u008c\u009b)Cx\u008bK\f)LAt\\\u0095\u0011kWYp#\u0084A\u0099\n\tFA|\u0094Ww\u001e/\u0080\u0098)xV5Kx\u00ad:\u0095|)\u001e#wOPc\u0017\u009ec\u009dI(\u0015V\u001d\u0005^y\u0016U6K\u0012b\u008d\\j\b3Tp\u0091UG(\u0088\u008c\u0014|VQH1\u0093M\u0019\u0096 7S8\u0096\nR\u008a|{\u0085Y\u009b#nQ/\u00945^kKo\u009a\u0016u\u0012O;=F\u0082m,R\u0011hq3\u009b5\u0016$bwcLO\u001aF\u0099m\n\u0012\u009e\u000f\bLn"\u00149mG7M\u0094hz*gJw\u008dr\u008b\u0000v\u0094D\u009cEc\u000bYey\u001dK\u0084?a{?\u009cqZ:f\u0002y\u008cY\u0016\u008cc\u0019m5\u0085\u001a\u000e\n\t ^Xd\u008bk\u009a\u0007\u001c\u001a\u008f\u0003\u001a\u000e\u0080\u0082\u00076\u009e\u008eY\u0096"\b\u0001|P[x[w=\r\u000f\u00141s=>4\u0010?RcfUDO3\u0005\u00078\u0014*$c/\u001fGW\u0086\u0012*S.\u00845\u009c\u0093\u001a~\u008eUn\u0098\u0017\n|\u0098\u0086_\u0097\u001c\u0017=\u001a0\u00ada\f4\nWU\\0\u008f\u001a~\u008dpWL\u0007HZ\u0096:zypy\u0014*r\u001dK\u0019\u0019}j\u0015c\u00ad\u0086\u0006\u009e\u000e\u0092[\u001cv.\u0095\u00942}Ri\u009b\u008c\u001f\u0097c9SVUPP\u008cI\u009dir+\u00039\u001e\u000e\u0091\u008egS\nQZ\u001ey\u0088\u009c\u0087\u001aO\u000fBMkI\'G> \u001b\u0014=\u009f7r\u008d\u0091W=~\u0084\u0017\u009c\u00adgD\u00ad\u001e1\b\u0002[f(\u0003O\u000b:6y\u0085P=\u009fJ8\u009eJ\u008de\u0014\u009c2m\u0087s\u0000QP0\u0095\u000f\u009a-^^\u001f5[\u0010y?\u008cAC\u00802\u000e?TjH\u0086\u0092\u0003mo"@1H1t\u0013\u0086\u0018XG1r\u0013}k\u0014L%C\u0015\u009ch\u009c\u0083&4\u000f\u0005o!\u0086\u0007\u0014\f\u0005;\u0082]LHe(\u0094=\u0002\u001d\u008e\u001aZ\u0098[];7d\u0090?\u0082k\'W\u00ado\u009d\fA\u0013\u0085\u0019\u0086\u008d=x\u0015\u000f5:I\u001a\u008eC\u000fa\u0001\u008fb\u0014!Z\u001dcx\u009c(\u0013D\u001d\u0011\u0006p1\u008e\'\u0000)\u001d1a\u001a\u008e8\u0013\u0094!N*\u0092*&T=thT\u007f_\u0012P;=\u009c\'\u0092X\u009c\u0002\u00ad/\u0016\u0013\tF\u0099\u0080\u0010\u0018\u0014bX\u0088\u007f@u\t#Bwvp\u001c\\\u0087}b9\u0087x?}\u0007\u009dd\u0093\u0095\u0080T}HH.o!\u0092\u008c\u0085s\u001ey\bV\u007fOCI/\u0017a$\u0010\u0017qa\u0092\u0015x\u0090A\u000f1\u0015cx\u0082\u009a)R_J@\u001c{\u0011& (+\u0093}\u009a?Av\u00983x\u008aG\ff\u0099\u0094\u008d\u0004\b97\u0001\u00adCTEB"]t\u008c\u007f\u0094F\u009c.\'\u009c\u0085\u009c\u009bt<2\u0011i 1i\u009b_3\u0019%\u009c\u0082\u00036\r;A\u0093\u0081\u0018\u009eq\u00936\u0001A-V4Rg\u0091Z\u0013lG \u0018orN$g\u0010dy\u008eE:\u008f\u001e+\u008e\u008e\u0091N:$\u000e\u0095\u009cxU\u000b\'\\\u009e5B%6\nZ3\u001b]\u001e^\u009c\u0090\u0088k>\u001f\u009dl\u009aJ\r;k>\u001d\u0090e\'*6z\u0092\u0014E\u0097\u000eGe)A<\u009d],;[S\u0003;\\O\u0016\u0086r\u0017=l8>Y \u008a\u0080\u0013\b\u008a^9\u008a\tNL\u0006\u0091vcz\u00ad&@\u0018S\u0087\u001b\u009b\u009ag\u0007\\HVvWc\u0018\u008c\f.\u008897\u00ad{X\u009a\u0016\u0098\u0094\u0097Go )\u0010\u0091,I8\bsQHI\f0\u001f\u00ad\u009b$Abs\u008c9\u008a{`_i\u0096*^QUt\u007f\r\t\u001f\r\u009a\u0089\u001b\u008c9%<\'\u000btEB^Krvs\u000e?\u0096`A^EAEXP\tQP\n\u0096d\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0005t\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000org/gradle/cli/ParsedCommandLineOption.class\u008dS]O@\u0014=G\u0081eP\u0004a\u0015\u0084eQ\u0001"\u0088hHV1Y\u0083awR\u0006\u0012l\u008b\u000f\u0098\u0004Ig\u007f\u0094N[`Y$\u0099{=?\u007f\u0000\u0098\u00934(\u0098H#\u0082b\n\u001d\u009e\u0086\u008a$4\u0012\u0099-L%q[+r\u008a\u0007\n\u0012[lpWA\u0098\u0084\u0097\u0084(H\u0095\u0085a1p\u0005#-\u009fg\u0083,C/{\u008e\u008c\u00999*I\nKxs\n\u0085U\u0005EJ\u001d%a\u0097\u008d:w^u\u0093"\u0092]a*s\u0084<\u0087\u0098!\u0088Id;\u0086n8jrb\n\u0015s\\^]k5fU%J\u0013E\u0092\u0006V\u0000\u0005\u0085\u0094\u0014\u0095=Vy\u0082\u001e\nj\u0094;*i\u0016=z&x\u008e\fV\u0017\u001cQ\u0096p6K:\u0090d)\u007fKn07T@\u0096U\u0090.\r\u009f\tv\u001c\u0093\u0012IC\u000fz\u0015t\u009d]p\u001c-)kDN(\u0014\f\u009dt]6Mn0\u0093,\n(#\u0000Wm-o-\u009egv\u001c\u0093\u008a\u0087\u001af0?L\'ZDAK\u008f@*\u0018\u001a\u0016$\u001b)\u0094\u0095M^!\u000fO\u008f\u0086\u008c+v\u0002\u0096iQ,7_\u0085\u0094\u008eZ\u0006\u0015~\u0093]m\\\u007f(K?\u0018\rLH.:E\u008d8rZ/Pd\u000eQ\u0001>\u0094!"k\u0088~E\u009f}\u0091V_\u0082*bTG;-%\u0003\u001cb\u0084Xo\u0088\u0010\u0089\u009c\u008f\u0017\u000e\u0090"\u001fp(\u001c=@&\u0082_2w%\u008e^*$APPS =1D:\u009a!\u0089If%\u0090\u0084\u001f\u001cn\u0082\u0089\u00870\u00815W(v\u0095\u0007b\u009eRD\n$\u0001"xj\u00182D\u0086xr7\u0082k>\r!\u0090V.p].G\u0080D\u0013\\\u00938"y\tR\u0089\u008c\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.class\u009d\u0092KO@\u0014\u0085\u0005\u0004D|?P\u0004\u009a\u0018u#Q\u008c+$\u0018C;\u00961m\u0087\f\u0003\tJW&.\u0001(\u00141D,\u009c9vo/\u0000[@\u0016\u001byl\u0095G)\u0087\u001cv\b\u0013\u0011\n}FHWkw\u0084LS\u009c\u0012!\u001e\u0006]nY7ZK:cJD\u009e\u0018\u0010\u008eZRy\u0098s\u0085V\u0081;H\u009f+-)\u0083\u0080\u0085nkS\u0086#cruLXgh|B\u0086\u0084\u008dj\u00adFY\u001d\u00adD\u0099\u008f%L%\u0094\u0013\u0006\u008e\u0012\u008e\u0085\u008e\u001c*\u0087_\u0089?\u0088:("\u0087<\u0081\u0084b\u007fJ\u008d\t\u0017\u001d\u00ad\u008atf^*K\u001d\n\rXU\u001aV\u001d\u008ci0\u001e1\u007fk\r\u007f\u000e\u008dp8\u0083\u009dw\u0007Z8T0g?\u001a\u0019Pa\u009b\u0099m\u0094\u008c=\u0083\u009eC\n\u0005S\u0013s\u001d\u000b\u0016\u0001\u008b\u0013|\t1\\\u008fZq\u0006-}C_J\u0002\u009a\u009eE\u0089j\u0002\u009a\u0099E+\tw\'\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\n8=|\u0001\u0000\u0000\u0002\u0000\u00009\u0000\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.class\u009d\u0092J@\u0014\u0086mjE5B\u0013P\u0085\u0017\u0090\u0016\u0017R/P~\u009a\u001e\u0091$\u0013&BJW\u0082\u000b\u001f\u0087\u0012\'i\u0010AY\u009c3\u009c\u007f\u0001\u0001l\u0097 \u000f\u008d"l\u0014Y\u0084\u0002l\u0015E \u007f<&\td\u0090@Hg\u001eL\u0011\u008a{:r\u0094Rs\u008b:C*X4N\u009c\u0080Q\u009f\u000b\u0005\u001d;hZ\u000e3\u0007a \u0013G!\u0019\u0006]\u001bG\u008bv7S"\u008a\u0013\u00025\u001beb\no}G\u008ftFM\u0087z9\u0090\u0082y~X{()spL`7e.\u0004KV,\rTXx\u008a\u0094fD\u0005T\u0000E\u0002G\u001cPW\u0014\u0081\u0001Jmh~\u00ad\u001f49Ajx\u00ad\r\u00adsh\rg\u0099n\u001085].F\u0081\u0014\u0092s\u00079Q\u0002\u0089\u001a\u0099*\u0013\u0095s/@\u009eUg\tJ*c\u000ee\u0015+s\u0083+1\n\u0004$p\u00806\u0099/t-\u0005,;h-\u0005.Z\n>kZ\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000gradle-cli-classpath.properties+(JM.)**+M\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000gradle-cli-parameter-names.properties\u0003\u0000PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081)\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u009b\u0000\u0000\u0000org/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000org/gradle/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000org/gradle/wrapper/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000f\u0003\u0005\u0000\u0000\t\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u001d\u0001\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQ}\u0000\u0000\u0000\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081k\u0006\u0000\u0000org/gradle/wrapper/Download$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081N\u0007\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005<\u009b\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\t\u0000\u0000org/gradle/wrapper/Download.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L\u0000\u0000\u0000\u0000\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0018\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0019\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081 \u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081u#\u0000\u0000org/gradle/wrapper/GradleWrapperMain.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0018\u0000\u0000\u0000\u0000\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081d-\u0000\u0000org/gradle/wrapper/IDownload.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@c\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081N.\u0000\u0000org/gradle/wrapper/Install$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00815\u0000\u0000org/gradle/wrapper/Install.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000:o\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\\J\u0000\u0000org/gradle/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\bM\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0014O\u0000\u0000org/gradle/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007f\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081nV\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000=\u000f\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081~[\u0000\u0000org/gradle/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000G\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081y^\u0000\u0000org/gradle/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000e\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081g\u0000\u0000gradle-wrapper-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00814h\u0000\u0000gradle-wrapper-parameter-names.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A}h\u0000\u0000org/gradle/cli/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081h\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0083X\u0004\u0000\u0000\n\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00817k\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081o\u0000\u0000org/gradle/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081~q\u0000\u0000org/gradle/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\n\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081r\u0000\u0000org/gradle/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u008a\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081$y\u0000\u0000org/gradle/cli/CommandLineParser$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099\u00adN\u0003\u0000\u0000\t\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u000fz\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019D\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081}\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0080\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000*ZM\u0002\u0000\u0000\u0004\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0004\u0085\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u00062\t\u0004\u0007\u0000\u0000\u0011\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0087\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$\u0002\u0000\u0000\u0006\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0014\u008f\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>\u0002\u0000\u0000\u0006\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0013\u0092\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%\u0002\u0000\u0000\u0006\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0018\u0095\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000fC\u0098\u0001\u0000\u0000\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081(\u0098\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000E\u0002\u0000\u0000\u0005\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081%\u009a\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081!\u009d\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000\u0004\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0010\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pX\r\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081d\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009b\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u009e\u0000\u0000org/gradle/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008b>\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000org/gradle/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0005t\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0005\u0000\u0000org/gradle/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081)\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\n8=|\u0001\u0000\u0000\u0002\u0000\u00009\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000gradle-cli-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081"\u0000\u0000gradle-cli-parameter-names.propertiesPK\u0005\u0006\u0000\u0000\u0000\u00003\u00003\u0000\u0011\u0000\u0000g\u0000\u0000\u0000\u0000'
          },
          {
            sha: "f3b4dae340056399e69926fa62aba660b3e9404e",
            filename: "gradle/wrapper/gradle-wrapper.properties",
            status: "added",
            additions: 6,
            deletions: 0,
            patch:
              "@@ -0,0 +1,6 @@\n+#Mon Mar 23 21:48:17 CST 2020\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\n+distributionBase=GRADLE_USER_HOME\n+distributionPath=wrapper/dists\n+zipStorePath=wrapper/dists\n+zipStoreBase=GRADLE_USER_HOME",
            rawContent:
              "#Mon Mar 23 21:48:17 CST 2020\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStorePath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\n"
          },
          {
            sha: "8e25e6c19d5748190b8cc39e98c2b56e496a5717",
            filename: "gradlew",
            status: "added",
            additions: 188,
            deletions: 0,
            patch:
              '@@ -0,0 +1,188 @@\n+#!/usr/bin/env sh\n+\n+#\n+# Copyright 2015 the original author or authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the "License");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#      https://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an "AS IS" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+##############################################################################\n+##\n+##  Gradle start up script for UN*X\n+##\n+##############################################################################\n+\n+# Attempt to set APP_HOME\n+# Resolve links: $0 may be a link\n+PRG="$0"\n+# Need this for relative symlinks.\n+while [ -h "$PRG" ] ; do\n+    ls=`ls -ld "$PRG"`\n+    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n+    if expr "$link" : \'/.*\' > /dev/null; then\n+        PRG="$link"\n+    else\n+        PRG=`dirname "$PRG"`"/$link"\n+    fi\n+done\n+SAVED="`pwd`"\n+cd "`dirname \\"$PRG\\"`/" >/dev/null\n+APP_HOME="`pwd -P`"\n+cd "$SAVED" >/dev/null\n+\n+APP_NAME="Gradle"\n+APP_BASE_NAME=`basename "$0"`\n+\n+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n+DEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n+\n+# Use the maximum available, or set MAX_FD != -1 to use that value.\n+MAX_FD="maximum"\n+\n+warn () {\n+    echo "$*"\n+}\n+\n+die () {\n+    echo\n+    echo "$*"\n+    echo\n+    exit 1\n+}\n+\n+# OS specific support (must be \'true\' or \'false\').\n+cygwin=false\n+msys=false\n+darwin=false\n+nonstop=false\n+case "`uname`" in\n+  CYGWIN* )\n+    cygwin=true\n+    ;;\n+  Darwin* )\n+    darwin=true\n+    ;;\n+  MINGW* )\n+    msys=true\n+    ;;\n+  NONSTOP* )\n+    nonstop=true\n+    ;;\n+esac\n+\n+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n+\n+# Determine the Java command to use to start the JVM.\n+if [ -n "$JAVA_HOME" ] ; then\n+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n+        # IBM\'s JDK on AIX uses strange locations for the executables\n+        JAVACMD="$JAVA_HOME/jre/sh/java"\n+    else\n+        JAVACMD="$JAVA_HOME/bin/java"\n+    fi\n+    if [ ! -x "$JAVACMD" ] ; then\n+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation."\n+    fi\n+else\n+    JAVACMD="java"\n+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation."\n+fi\n+\n+# Increase the maximum file descriptors if we can.\n+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n+    MAX_FD_LIMIT=`ulimit -H -n`\n+    if [ $? -eq 0 ] ; then\n+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n+            MAX_FD="$MAX_FD_LIMIT"\n+        fi\n+        ulimit -n $MAX_FD\n+        if [ $? -ne 0 ] ; then\n+            warn "Could not set maximum file descriptor limit: $MAX_FD"\n+        fi\n+    else\n+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n+    fi\n+fi\n+\n+# For Darwin, add options to specify how the application appears in the dock\n+if $darwin; then\n+    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\n+fi\n+\n+# For Cygwin, switch paths to Windows format before running java\n+if $cygwin ; then\n+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n+    JAVACMD=`cygpath --unix "$JAVACMD"`\n+\n+    # We build the pattern for arguments to be converted via cygpath\n+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n+    SEP=""\n+    for dir in $ROOTDIRSRAW ; do\n+        ROOTDIRS="$ROOTDIRS$SEP$dir"\n+        SEP="|"\n+    done\n+    OURCYGPATTERN="(^($ROOTDIRS))"\n+    # Add a user-defined pattern to the cygpath arguments\n+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n+    fi\n+    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n+    i=0\n+    for arg in "$@" ; do\n+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n+\n+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n+        else\n+            eval `echo args$i`="\\"$arg\\""\n+        fi\n+        i=$((i+1))\n+    done\n+    case $i in\n+        (0) set -- ;;\n+        (1) set -- "$args0" ;;\n+        (2) set -- "$args0" "$args1" ;;\n+        (3) set -- "$args0" "$args1" "$args2" ;;\n+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n+    esac\n+fi\n+\n+# Escape application args\n+save () {\n+    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n+    echo " "\n+}\n+APP_ARGS=$(save "$@")\n+\n+# Collect all arguments for the java command, following the shell quoting and substitution rules\n+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n+\n+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\n+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n+  cd "$(dirname "$0")"\n+fi\n+\n+exec "$JAVACMD" "$@"',
            rawContent:
              '#!/usr/bin/env sh\n\n#\n# Copyright 2015 the original author or authors.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG="$0"\n# Need this for relative symlinks.\nwhile [ -h "$PRG" ] ; do\n    ls=`ls -ld "$PRG"`\n    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n    if expr "$link" : \'/.*\' > /dev/null; then\n        PRG="$link"\n    else\n        PRG=`dirname "$PRG"`"/$link"\n    fi\ndone\nSAVED="`pwd`"\ncd "`dirname \\"$PRG\\"`/" >/dev/null\nAPP_HOME="`pwd -P`"\ncd "$SAVED" >/dev/null\n\nAPP_NAME="Gradle"\nAPP_BASE_NAME=`basename "$0"`\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD="maximum"\n\nwarn () {\n    echo "$*"\n}\n\ndie () {\n    echo\n    echo "$*"\n    echo\n    exit 1\n}\n\n# OS specific support (must be \'true\' or \'false\').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase "`uname`" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\n  NONSTOP* )\n    nonstop=true\n    ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n "$JAVA_HOME" ] ; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n        # IBM\'s JDK on AIX uses strange locations for the executables\n        JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n        JAVACMD="$JAVA_HOME/bin/java"\n    fi\n    if [ ! -x "$JAVACMD" ] ; then\n        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\n    fi\nelse\n    JAVACMD="java"\n    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n            MAX_FD="$MAX_FD_LIMIT"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn "Could not set maximum file descriptor limit: $MAX_FD"\n        fi\n    else\n        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n    JAVACMD=`cygpath --unix "$JAVACMD"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=""\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS="$ROOTDIRS$SEP$dir"\n        SEP="|"\n    done\n    OURCYGPATTERN="(^($ROOTDIRS))"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in "$@" ; do\n        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n        else\n            eval `echo args$i`="\\"$arg\\""\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- "$args0" ;;\n        (2) set -- "$args0" "$args1" ;;\n        (3) set -- "$args0" "$args1" "$args2" ;;\n        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n    esac\nfi\n\n# Escape application args\nsave () {\n    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n    echo " "\n}\nAPP_ARGS=$(save "$@")\n\n# Collect all arguments for the java command, following the shell quoting and substitution rules\neval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n\n# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\nif [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n  cd "$(dirname "$0")"\nfi\n\nexec "$JAVACMD" "$@"\n'
          },
          {
            sha: "9618d8d9607cd91a0efb866bcac4810064ba6fac",
            filename: "gradlew.bat",
            status: "added",
            additions: 100,
            deletions: 0,
            patch:
              '@@ -0,0 +1,100 @@\n+@rem\n+@rem Copyright 2015 the original author or authors.\n+@rem\n+@rem Licensed under the Apache License, Version 2.0 (the "License");\n+@rem you may not use this file except in compliance with the License.\n+@rem You may obtain a copy of the License at\n+@rem\n+@rem      https://www.apache.org/licenses/LICENSE-2.0\n+@rem\n+@rem Unless required by applicable law or agreed to in writing, software\n+@rem distributed under the License is distributed on an "AS IS" BASIS,\n+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+@rem See the License for the specific language governing permissions and\n+@rem limitations under the License.\n+@rem\n+\n+@if "%DEBUG%" == "" @echo off\n+@rem ##########################################################################\n+@rem\n+@rem  Gradle startup script for Windows\n+@rem\n+@rem ##########################################################################\n+\n+@rem Set local scope for the variables with windows NT shell\n+if "%OS%"=="Windows_NT" setlocal\n+\n+set DIRNAME=%~dp0\n+if "%DIRNAME%" == "" set DIRNAME=.\n+set APP_BASE_NAME=%~n0\n+set APP_HOME=%DIRNAME%\n+\n+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n+\n+@rem Find java.exe\n+if defined JAVA_HOME goto findJavaFromJavaHome\n+\n+set JAVA_EXE=java.exe\n+%JAVA_EXE% -version >NUL 2>&1\n+if "%ERRORLEVEL%" == "0" goto init\n+\n+echo.\n+echo ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n+echo.\n+echo Please set the JAVA_HOME variable in your environment to match the\n+echo location of your Java installation.\n+\n+goto fail\n+\n+:findJavaFromJavaHome\n+set JAVA_HOME=%JAVA_HOME:"=%\n+set JAVA_EXE=%JAVA_HOME%/bin/java.exe\n+\n+if exist "%JAVA_EXE%" goto init\n+\n+echo.\n+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\n+echo.\n+echo Please set the JAVA_HOME variable in your environment to match the\n+echo location of your Java installation.\n+\n+goto fail\n+\n+:init\n+@rem Get command-line arguments, handling Windows variants\n+\n+if not "%OS%" == "Windows_NT" goto win9xME_args\n+\n+:win9xME_args\n+@rem Slurp the command line arguments.\n+set CMD_LINE_ARGS=\n+set _SKIP=2\n+\n+:win9xME_args_slurp\n+if "x%~1" == "x" goto execute\n+\n+set CMD_LINE_ARGS=%*\n+\n+:execute\n+@rem Setup the command line\n+\n+set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n+\n+@rem Execute Gradle\n+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n+\n+:end\n+@rem End local scope for the variables with windows NT shell\n+if "%ERRORLEVEL%"=="0" goto mainEnd\n+\n+:fail\n+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\n+rem the _cmd.exe /c_ return code!\n+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\n+exit /b 1\n+\n+:mainEnd\n+if "%OS%"=="Windows_NT" endlocal\n+\n+:omega',
            rawContent:
              '@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the "License");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an "AS IS" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if "%DEBUG%" == "" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif "%OS%"=="Windows_NT" setlocal\n\nset DIRNAME=%~dp0\nif "%DIRNAME%" == "" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif "%ERRORLEVEL%" == "0" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist "%JAVA_EXE%" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windows variants\n\nif not "%OS%" == "Windows_NT" goto win9xME_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif "x%~1" == "x" goto execute\n\nset CMD_LINE_ARGS=%*\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif "%ERRORLEVEL%"=="0" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\nexit /b 1\n\n:mainEnd\nif "%OS%"=="Windows_NT" endlocal\n\n:omega\n'
          },
          {
            sha: "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc",
            filename: "settings.gradle",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+/*\n+ * This file was generated by the Gradle 'init' task.\n+ *\n+ * The settings file is used to specify which projects to include in your build.\n+ *\n+ * Detailed information about configuring a multi-project build in Gradle can be found\n+ * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n+ */\n+\n+rootProject.name = 'refactoring-crawler'",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * The settings file is used to specify which projects to include in your build.\n *\n * Detailed information about configuring a multi-project build in Gradle can be found\n * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n */\n\nrootProject.name = 'refactoring-crawler'\n"
          },
          {
            sha: "83d2cfcf9d3fac2cb14ed33d480d729a23bc2d31",
            filename: "src/main/java/refactoring/crawler/Library.java",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+public class Library {\n+    public boolean someLibraryMethod() {\n+        return true;\n+    }\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\npublic class Library {\n    public boolean someLibraryMethod() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "0664cc91a699f71271f0658ea3cf1d299d40d9e9",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "added",
            additions: 116,
            deletions: 0,
            patch:
              '@@ -0,0 +1,116 @@\n+package refactoring.crawler;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.RenameMethodDetection;\n+import refactoring.crawler.project.IProject;\n+import refactoring.crawler.util.*;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class RefactoringCrawler {\n+\n+\tprivate String projectName;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\t// creates an input stream for the file to be parsed\n+\t\tString source = "import detections.Detection;\\n" +\n+\t\t\t"import detections.DetectionFactory;\\n" +\n+\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n+\t\t\t"import utils.*;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"import java.util.List;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"public class RefactoringCrawler {\\n" +\n+\t\t\t"    public static void main(String[] args) {\\n" +\n+\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n+\t\t\t"//        parser.setSource();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n+\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n+\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n+\t\t\t"            for (Pair pair : pairs) {\\n" +\n+\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n+\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n+\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n+\t\t\t"                    }\\n" +\n+\t\t\t"                }\\n" +\n+\t\t\t"            }\\n" +\n+\t\t\t"        }\\n" +\n+\t\t\t"        return rlog.getResult();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"}\\n";\n+\t\tCompilationUnit cu;\n+\t\t// parse the file\n+\t\tcu = StaticJavaParser.parse(source);\n+\n+\n+\t}\n+\n+\tpublic RefactoringCrawler(String projectName) {\n+\t\tthis.projectName = projectName;\n+\t}\n+\n+\tprivate List<CompilationUnit> parse(List<String> files) {\n+\t\tList<CompilationUnit> resList = new LinkedList<>();\n+\t\tfor (String source : files) {\n+\t\t\tresList.add(StaticJavaParser.parse(source));\n+\t\t}\n+\t\treturn resList;\n+\t}\n+\n+\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n+\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n+\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n+\t\tSourceNavigator navigator = new SourceNavigator();\n+\t\tnavigator.setShinglesUtil(shinglesUtil);\n+\t\tnavigator.browseProject(projectName, oldVersionCU);\n+\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n+\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n+\t\tnavigatorForVersion.browseProject(newVersion);\n+\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+\n+\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n+\n+\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+\t}\n+\n+\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n+\t                                NamedDirectedMultigraph newVersionGraph) {\n+\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n+\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+\t\tdetector.setThreshold(tMethod);\n+\n+\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+\t\tif (renamedMethods.size() > 0) {\n+\t\t\tSystem.out.println(renamedMethods);\n+//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+//            renameMethodCategory.setName("RenamedMethods");\n+//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n+//            refactoringList.add(renameMethodCategory);\n+\t\t}\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// creates an input stream for the file to be parsed\n\t\tString source = "import detections.Detection;\\n" +\n\t\t\t"import detections.DetectionFactory;\\n" +\n\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n\t\t\t"import utils.*;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import java.util.List;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n\t\t\t"\\n" +\n\t\t\t"public class RefactoringCrawler {\\n" +\n\t\t\t"    public static void main(String[] args) {\\n" +\n\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n\t\t\t"//        parser.setSource();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n\t\t\t"\\n" +\n\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n\t\t\t"\\n" +\n\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n\t\t\t"            for (Pair pair : pairs) {\\n" +\n\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n\t\t\t"                    }\\n" +\n\t\t\t"                }\\n" +\n\t\t\t"            }\\n" +\n\t\t\t"        }\\n" +\n\t\t\t"        return rlog.getResult();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}\\n";\n\t\tCompilationUnit cu;\n\t\t// parse the file\n\t\tcu = StaticJavaParser.parse(source);\n\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tresList.add(StaticJavaParser.parse(source));\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(newVersion);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "3a4ac180d4529de1ef206ad58592439d28556c90",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.detection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class ChangeMethodSignatureDetection extends MethodDetection {\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        return null;\n    }\n\n    @Override\n    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n}\n"
          },
          {
            sha: "a3f39c027c687155881ad197d953830da6480536",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "added",
            additions: 71,
            deletions: 0,
            patch:
              "@@ -0,0 +1,71 @@\n+package refactoring.crawler.detection;\n+\n+import lombok.val;\n+import org.eclipse.core.runtime.NullProgressMonitor;\n+import org.eclipse.jdt.core.IMember;\n+import refactoring.crawler.project.IMethod;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public abstract class MethodDetection extends RefactoringDetection {\n+\n+    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        List callers = new ArrayList();\n+        if (this instanceof ChangeMethodSignatureDetection)\n+            callers = SearchHelper.findMethodCallers(node, true);\n+        else\n+            callers = SearchHelper.findMethodCallers(node, false);\n+        for (Object o : callers) {\n+//            IMethod element = (IMethod) o;\n+//            String nodeName = element.getElementName();\n+//            String qualifiername = element.getDeclaringType()\n+//                    .getFullyQualifiedName('.');\n+//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n+//            if (caller != null) {\n+//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n+//                graph.addEdge(edge);\n+//            }\n+        }\n+        node.setCreatedCallGraph();\n+\n+    }\n+\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        val results = new ArrayList<Edge>();\n+        for (final Edge edge : list) {\n+            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n+                results.add(edge);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n+\n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        val incomingEdgesOriginal = filterNamedEdges(graph1\n+                .incomingEdgesOf(original));\n+        val incomingEdgesVersion = filterNamedEdges(graph2\n+                .incomingEdgesOf(version));\n+        incomingEdgesGrade = computeLikelinessIncomingEdges(\n+                incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport lombok.val;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.project.IMethod;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\n    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        List callers = new ArrayList();\n        if (this instanceof ChangeMethodSignatureDetection)\n            callers = SearchHelper.findMethodCallers(node, true);\n        else\n            callers = SearchHelper.findMethodCallers(node, false);\n        for (Object o : callers) {\n//            IMethod element = (IMethod) o;\n//            String nodeName = element.getElementName();\n//            String qualifiername = element.getDeclaringType()\n//                    .getFullyQualifiedName('.');\n//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n//            if (caller != null) {\n//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n//                graph.addEdge(edge);\n//            }\n        }\n        node.setCreatedCallGraph();\n\n    }\n\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        val results = new ArrayList<Edge>();\n        for (final Edge edge : list) {\n            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n                results.add(edge);\n            }\n        }\n        return results;\n    }\n\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        val incomingEdgesOriginal = filterNamedEdges(graph1\n                .incomingEdgesOf(original));\n        val incomingEdgesVersion = filterNamedEdges(graph2\n                .incomingEdgesOf(version));\n        incomingEdgesGrade = computeLikelinessIncomingEdges(\n                incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "4cf9a1a8afa81c2cef5bba0091ad48c4d5e7d3a2",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.detection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class MoveMethodDetection extends RefactoringDetection {\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        return null;\n    }\n\n    @Override\n    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n}\n"
          },
          {
            sha: "2ee90c7dee42de68600be172bfe65d64b1ec21d8",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "added",
            additions: 370,
            deletions: 0,
            patch:
              '@@ -0,0 +1,370 @@\n+package refactoring.crawler.detection;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.*;\n+\n+public abstract class RefactoringDetection {\n+\n+    @Getter\n+    @Setter\n+    private double threshold;\n+\n+    protected NamedDirectedMultigraph graph1;\n+    protected NamedDirectedMultigraph graph2;\n+\n+\n+    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+    public abstract double computeLikeliness(Node node1, Node node12);\n+\n+    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\n+    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+    private static Dictionary<String, String> renamingDictionary;\n+\n+    public static Dictionary<String, String> getRenamingDictionary() {\n+        if (renamingDictionary == null)\n+            renamingDictionary = new Hashtable<>();\n+        return renamingDictionary;\n+    }\n+\n+    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+        List<Node[]> refactoredNodes = new ArrayList<>();\n+        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+        return pruneFalsePositives(listWithFP);\n+    }\n+\n+    /**\n+     * A default implementation that prunes all those candidates that have the\n+     * same qualified name. Subclasses might reuse this when they implement the\n+     * abstract pruneOriginalCanditates, or they can augment to this initial\n+     * implementation.\n+     *\n+     * @param candidates\n+     * @return\n+     */\n+    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+                    .getFullyQualifiedName()))) {\n+\n+                if (pair[0].isAPI() && pair[1].isAPI()) {\n+                    Node n2inV1 = graph1.findNamedNode(pair[1]\n+                            .getFullyQualifiedName());\n+\n+                    if ((n2inV1 == null)) {\n+                        prunedCandidates.add(pair);\n+                    }\n+                }\n+            }\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    /**\n+     * The client is assumed to be passing it\'s parent to this method to\n+     * determine if they are Modulo Renames of each other.\n+     *\n+     * @param original\n+     * @param version\n+     * @return\n+     */\n+    protected boolean isTheSameModuloRename(String original, String version) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        if (version.equals(dictionary.get(original)))\n+            return true;\n+        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+            return original.equals(version);\n+        else if (original.substring(original.lastIndexOf(".")).equals(\n+                version.substring(version.lastIndexOf("."), version.length())))\n+            return isTheSameModuloRename(\n+                    extractFullyQualifiedParentName(original),\n+                    extractFullyQualifiedParentName(version));\n+        else\n+            return false;\n+    }\n+\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+        for (Node[] pair : listWithFP) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+            if (originalInV2 != null) {\n+                createCallGraph(originalInV2, graph2);\n+                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n+                        .incomingEdgesOf(originalInV2));\n+                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n+                        .incomingEdgesOf(version));\n+                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n+                        .incomingEdgesOf(original));\n+\n+\n+                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+                List<Node> verCallers = getCallers(verIncomingEdges);\n+                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+                // since a call site cannot be calling both the old and the new entity at the same time\n+                for (Iterator iterator = verCallers.iterator(); iterator\n+                        .hasNext(); ) {\n+                    Node node = (Node) iterator.next();\n+                    if (origInV2Callers.contains(node))\n+                        if (!nodesToRemove.contains(pair)) {\n+                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+                            nodesToRemove.add(pair);\n+                        }\n+                }\n+\n+                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n+                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n+                // should be different\n+                for (Iterator iterator = origInV1Callers.iterator(); iterator\n+                        .hasNext(); ) {\n+                    Node node = (Node) iterator.next();\n+                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n+                            .hasNext(); ) {\n+                        Node callingNode = (Node) iterator1.next();\n+                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+                            if (!nodesToRemove.contains(pair)) {\n+                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n+                                nodesToRemove.add(pair);\n+                            }\n+                            break;\n+                        }\n+                    }\n+\n+                }\n+\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            listWithFP.remove(pair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+\n+        pruneOverloadedMethodFP(listWithFP);\n+\n+        return listWithFP;\n+    }\n+\n+\n+    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+        boolean retval = false;\n+\n+        if (source.getSignature() == null)\n+            return false;\n+\n+        retval = source.getSignature().equals(target.getSignature());\n+\n+        if (!retval && (this instanceof MoveMethodDetection)) {\n+            String sourceParent = extractParentSimpleName(source);\n+            StringTokenizer sourceTokenizer = new StringTokenizer(source\n+                    .getSignature(), "( , )");\n+            StringTokenizer targetTokenizer = new StringTokenizer(target\n+                    .getSignature(), "( , )");\n+            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+            String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+            for (int i = 0; i < sourceTokens.length; i++) {\n+                sourceTokens[i] = sourceTokenizer.nextToken();\n+            }\n+\n+            for (int i = 0; i < targetTokens.length; i++) {\n+                targetTokens[i] = targetTokenizer.nextToken();\n+            }\n+\n+            if (targetTokens.length == sourceTokens.length + 1) {\n+                if (!targetTokens[0].trim().equals(sourceParent))\n+                    return false;\n+                else {\n+                    for (int i = 0; i < sourceTokens.length; i++) {\n+                        if (!sourceTokens[i].trim().equals(\n+                                targetTokens[i + 1].trim()))\n+                            return false;\n+                    }\n+                    retval = true;\n+                }\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    /**\n+     * This helper method takes a string containing the dot separated name of a\n+     * node and it returns the subtring from the beginning up to the last dot\n+     * (e.g. for pack1.class1.method1 it returns class1)\n+     *\n+     * @param original\n+     * @return\n+     */\n+    protected String extractParentSimpleName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        String parentName = originalName.substring(0, originalName\n+                .lastIndexOf("."));\n+        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+        return parentName;\n+    }\n+\n+    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new LinkedList<>();\n+        for (int i = 0; i < listWithFP.size(); i++) {\n+            boolean hasSameNameAndSignature = false;\n+            Node[] pair = listWithFP.get(i);\n+            Node source = pair[0];\n+            for (int j = i; j < listWithFP.size(); j++) {\n+                Node[] pair2 = listWithFP.get(j);\n+                Node source2 = pair2[0];\n+                if (source.equals(source2)) {\n+                    Node target2 = pair2[1];\n+                    if (source.getSimpleName().equals(target2.getSimpleName()))\n+                        if (signatureEqualsModuloMoveMethod(source, target2))\n+                            hasSameNameAndSignature = true;\n+                }\n+            }\n+            if (hasSameNameAndSignature) {\n+                for (int j = i; j < listWithFP.size(); j++) {\n+                    Node[] pair2 = (Node[]) listWithFP.get(j);\n+                    Node source2 = pair2[0];\n+                    if (source.equals(source2)) {\n+                        Node target2 = pair2[1];\n+                        if (source.getSimpleName().equals(\n+                                target2.getSimpleName()))\n+                            if (!signatureEqualsModuloMoveMethod(source, target2))\n+                                if (!nodesToRemove.contains(pair2))\n+                                    nodesToRemove.add(pair2);\n+                    }\n+                }\n+            }\n+\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+            listWithFP.remove(pair);\n+\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+    }\n+\n+\n+    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        String fqnParent = extractFullyQualifiedParentName(original);\n+        String possiblyRenamedFQN = dictionary.get(fqnParent);\n+        if (possiblyRenamedFQN != null)\n+            fqnParent = possiblyRenamedFQN;\n+        // TODO implement find name node\n+        Node parentNode = g.findNamedNode(fqnParent);\n+\n+        if (parentNode != null) {\n+            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+                Edge edge = (Edge) iter.next();\n+                Node child = (Node) edge.getTarget();\n+                if (original.getSimpleName().equals(child.getSimpleName()))\n+                    if (original.getSignature() != null) {\n+                        // This handles the method nodes\n+                        if (original.getSignature()\n+                                .equals(child.getSignature()))\n+                            return child;\n+                    } else\n+                        // Classes and packages\n+                        return child;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge o : list) {\n+            if (label.equals(o.getLabel())) {\n+                results.add(o);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected String extractFullyQualifiedParentName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        return extractFullyQualifiedParentName(originalName);\n+    }\n+\n+    public String extractFullyQualifiedParentName(String originalName) {\n+        String fqParentName = "";\n+        int lastIndex = originalName.lastIndexOf(".");\n+        if (lastIndex > 0)\n+            fqParentName = originalName.substring(0, lastIndex);\n+        return fqParentName;\n+    }\n+\n+    private List<Node> getCallers(List incomingEdges) {\n+        List<Node> callers = new ArrayList<Node>();\n+        for (Object incomingEdge : incomingEdges) {\n+            Edge edge = (Edge) incomingEdge;\n+            callers.add(edge.getSource());\n+        }\n+        return callers;\n+    }\n+\n+    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+        boolean foundNewRefactoring = false;\n+        for (Object prunedCandidate : prunedCandidates) {\n+            Node[] pair = (Node[]) prunedCandidate;\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            double likeliness = computeLikeliness(original, version);\n+            if (likeliness >= threshold) {\n+                if (!refactoredNodes.contains(pair)) {\n+                    refactoredNodes.add(pair);\n+                    foundNewRefactoring = true;\n+                }\n+            }\n+        }\n+\n+        if (foundNewRefactoring) {\n+            doDetectRefactorings(candidates, refactoredNodes);\n+        }\n+        return refactoredNodes;\n+    }\n+\n+    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+        double count = 0;\n+\n+        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n+\n+        for (Edge edge1 : edges1) {\n+            Node node1 = edge1.getSource();\n+            for (int i = 0; i < arrEdge2.length; i++) {\n+                Edge edge2 = arrEdge2[i];\n+                if (edge2 != null) {\n+                    Node node2 = (Node) edge2.getSource();\n+                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+                            node2.getFullyQualifiedName())) {\n+                        count++;\n+                        // we mark this edge as already counted so that we don\'t\n+                        // count it\n+                        // twice when there are multiple edges between two nodes\n+                        arrEdge2[i] = null;\n+                    }\n+                }\n+            }\n+        }\n+\n+        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+        return (fraction1 + fraction2) / 2.0;\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n    @Getter\n    @Setter\n    private double threshold;\n\n    protected NamedDirectedMultigraph graph1;\n    protected NamedDirectedMultigraph graph2;\n\n\n    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n    public abstract double computeLikeliness(Node node1, Node node12);\n\n    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n\n    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n    private static Dictionary<String, String> renamingDictionary;\n\n    public static Dictionary<String, String> getRenamingDictionary() {\n        if (renamingDictionary == null)\n            renamingDictionary = new Hashtable<>();\n        return renamingDictionary;\n    }\n\n    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n        List<Node[]> refactoredNodes = new ArrayList<>();\n        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n        return pruneFalsePositives(listWithFP);\n    }\n\n    /**\n     * A default implementation that prunes all those candidates that have the\n     * same qualified name. Subclasses might reuse this when they implement the\n     * abstract pruneOriginalCanditates, or they can augment to this initial\n     * implementation.\n     *\n     * @param candidates\n     * @return\n     */\n    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n                    .getFullyQualifiedName()))) {\n\n                if (pair[0].isAPI() && pair[1].isAPI()) {\n                    Node n2inV1 = graph1.findNamedNode(pair[1]\n                            .getFullyQualifiedName());\n\n                    if ((n2inV1 == null)) {\n                        prunedCandidates.add(pair);\n                    }\n                }\n            }\n        }\n        return prunedCandidates;\n    }\n\n    /**\n     * The client is assumed to be passing it\'s parent to this method to\n     * determine if they are Modulo Renames of each other.\n     *\n     * @param original\n     * @param version\n     * @return\n     */\n    protected boolean isTheSameModuloRename(String original, String version) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        if (version.equals(dictionary.get(original)))\n            return true;\n        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n            return original.equals(version);\n        else if (original.substring(original.lastIndexOf(".")).equals(\n                version.substring(version.lastIndexOf("."), version.length())))\n            return isTheSameModuloRename(\n                    extractFullyQualifiedParentName(original),\n                    extractFullyQualifiedParentName(version));\n        else\n            return false;\n    }\n\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n        for (Node[] pair : listWithFP) {\n            Node original = pair[0];\n            Node version = pair[1];\n            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n            if (originalInV2 != null) {\n                createCallGraph(originalInV2, graph2);\n                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n                        .incomingEdgesOf(originalInV2));\n                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n                        .incomingEdgesOf(version));\n                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n                        .incomingEdgesOf(original));\n\n\n                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n                List<Node> verCallers = getCallers(verIncomingEdges);\n                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n                // since a call site cannot be calling both the old and the new entity at the same time\n                for (Iterator iterator = verCallers.iterator(); iterator\n                        .hasNext(); ) {\n                    Node node = (Node) iterator.next();\n                    if (origInV2Callers.contains(node))\n                        if (!nodesToRemove.contains(pair)) {\n                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n                            nodesToRemove.add(pair);\n                        }\n                }\n\n                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n                // should be different\n                for (Iterator iterator = origInV1Callers.iterator(); iterator\n                        .hasNext(); ) {\n                    Node node = (Node) iterator.next();\n                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n                            .hasNext(); ) {\n                        Node callingNode = (Node) iterator1.next();\n                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n                            if (!nodesToRemove.contains(pair)) {\n                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n                                nodesToRemove.add(pair);\n                            }\n                            break;\n                        }\n                    }\n\n                }\n\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            listWithFP.remove(pair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n\n        pruneOverloadedMethodFP(listWithFP);\n\n        return listWithFP;\n    }\n\n\n    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n        boolean retval = false;\n\n        if (source.getSignature() == null)\n            return false;\n\n        retval = source.getSignature().equals(target.getSignature());\n\n        if (!retval && (this instanceof MoveMethodDetection)) {\n            String sourceParent = extractParentSimpleName(source);\n            StringTokenizer sourceTokenizer = new StringTokenizer(source\n                    .getSignature(), "( , )");\n            StringTokenizer targetTokenizer = new StringTokenizer(target\n                    .getSignature(), "( , )");\n            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n            String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n            for (int i = 0; i < sourceTokens.length; i++) {\n                sourceTokens[i] = sourceTokenizer.nextToken();\n            }\n\n            for (int i = 0; i < targetTokens.length; i++) {\n                targetTokens[i] = targetTokenizer.nextToken();\n            }\n\n            if (targetTokens.length == sourceTokens.length + 1) {\n                if (!targetTokens[0].trim().equals(sourceParent))\n                    return false;\n                else {\n                    for (int i = 0; i < sourceTokens.length; i++) {\n                        if (!sourceTokens[i].trim().equals(\n                                targetTokens[i + 1].trim()))\n                            return false;\n                    }\n                    retval = true;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This helper method takes a string containing the dot separated name of a\n     * node and it returns the subtring from the beginning up to the last dot\n     * (e.g. for pack1.class1.method1 it returns class1)\n     *\n     * @param original\n     * @return\n     */\n    protected String extractParentSimpleName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        String parentName = originalName.substring(0, originalName\n                .lastIndexOf("."));\n        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n        return parentName;\n    }\n\n    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new LinkedList<>();\n        for (int i = 0; i < listWithFP.size(); i++) {\n            boolean hasSameNameAndSignature = false;\n            Node[] pair = listWithFP.get(i);\n            Node source = pair[0];\n            for (int j = i; j < listWithFP.size(); j++) {\n                Node[] pair2 = listWithFP.get(j);\n                Node source2 = pair2[0];\n                if (source.equals(source2)) {\n                    Node target2 = pair2[1];\n                    if (source.getSimpleName().equals(target2.getSimpleName()))\n                        if (signatureEqualsModuloMoveMethod(source, target2))\n                            hasSameNameAndSignature = true;\n                }\n            }\n            if (hasSameNameAndSignature) {\n                for (int j = i; j < listWithFP.size(); j++) {\n                    Node[] pair2 = (Node[]) listWithFP.get(j);\n                    Node source2 = pair2[0];\n                    if (source.equals(source2)) {\n                        Node target2 = pair2[1];\n                        if (source.getSimpleName().equals(\n                                target2.getSimpleName()))\n                            if (!signatureEqualsModuloMoveMethod(source, target2))\n                                if (!nodesToRemove.contains(pair2))\n                                    nodesToRemove.add(pair2);\n                    }\n                }\n            }\n\n        }\n        for (Node[] pair : nodesToRemove) {\n            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n            listWithFP.remove(pair);\n\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n    }\n\n\n    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        String fqnParent = extractFullyQualifiedParentName(original);\n        String possiblyRenamedFQN = dictionary.get(fqnParent);\n        if (possiblyRenamedFQN != null)\n            fqnParent = possiblyRenamedFQN;\n        // TODO implement find name node\n        Node parentNode = g.findNamedNode(fqnParent);\n\n        if (parentNode != null) {\n            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n                Edge edge = (Edge) iter.next();\n                Node child = (Node) edge.getTarget();\n                if (original.getSimpleName().equals(child.getSimpleName()))\n                    if (original.getSignature() != null) {\n                        // This handles the method nodes\n                        if (original.getSignature()\n                                .equals(child.getSignature()))\n                            return child;\n                    } else\n                        // Classes and packages\n                        return child;\n            }\n        }\n        return null;\n    }\n\n    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge o : list) {\n            if (label.equals(o.getLabel())) {\n                results.add(o);\n            }\n        }\n        return results;\n    }\n\n    protected String extractFullyQualifiedParentName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        return extractFullyQualifiedParentName(originalName);\n    }\n\n    public String extractFullyQualifiedParentName(String originalName) {\n        String fqParentName = "";\n        int lastIndex = originalName.lastIndexOf(".");\n        if (lastIndex > 0)\n            fqParentName = originalName.substring(0, lastIndex);\n        return fqParentName;\n    }\n\n    private List<Node> getCallers(List incomingEdges) {\n        List<Node> callers = new ArrayList<Node>();\n        for (Object incomingEdge : incomingEdges) {\n            Edge edge = (Edge) incomingEdge;\n            callers.add(edge.getSource());\n        }\n        return callers;\n    }\n\n    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n        boolean foundNewRefactoring = false;\n        for (Object prunedCandidate : prunedCandidates) {\n            Node[] pair = (Node[]) prunedCandidate;\n            Node original = pair[0];\n            Node version = pair[1];\n            double likeliness = computeLikeliness(original, version);\n            if (likeliness >= threshold) {\n                if (!refactoredNodes.contains(pair)) {\n                    refactoredNodes.add(pair);\n                    foundNewRefactoring = true;\n                }\n            }\n        }\n\n        if (foundNewRefactoring) {\n            doDetectRefactorings(candidates, refactoredNodes);\n        }\n        return refactoredNodes;\n    }\n\n    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n        double count = 0;\n\n        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n\n        for (Edge edge1 : edges1) {\n            Node node1 = edge1.getSource();\n            for (int i = 0; i < arrEdge2.length; i++) {\n                Edge edge2 = arrEdge2[i];\n                if (edge2 != null) {\n                    Node node2 = (Node) edge2.getSource();\n                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n                            node2.getFullyQualifiedName())) {\n                        count++;\n                        // we mark this edge as already counted so that we don\'t\n                        // count it\n                        // twice when there are multiple edges between two nodes\n                        arrEdge2[i] = null;\n                    }\n                }\n            }\n        }\n\n        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n        return (fraction1 + fraction2) / 2.0;\n    }\n}\n'
          },
          {
            sha: "cbe3a28746d3df68550f245b019a9aa42d979ea9",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "added",
            additions: 39,
            deletions: 0,
            patch:
              "@@ -0,0 +1,39 @@\n+package refactoring.crawler.detection;\n+\n+import org.jgrapht.graph.AbstractBaseGraph;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.*;\n+\n+public class RenameMethodDetection extends MethodDetection {\n+\n+    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && (!(original.getSimpleName().equals(version\n+                    .getSimpleName()))))\n+                candidatesWithSameParentClass.add(pair);\n+        }\n+\n+        return candidatesWithSameParentClass;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node oldVersion, Node newVersion) {\n+        return super.analyzeIncomingEdges(oldVersion, newVersion);\n+    }\n+\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && (!(original.getSimpleName().equals(version\n                    .getSimpleName()))))\n                candidatesWithSameParentClass.add(pair);\n        }\n\n        return candidatesWithSameParentClass;\n    }\n\n    @Override\n    public double computeLikeliness(Node oldVersion, Node newVersion) {\n        return super.analyzeIncomingEdges(oldVersion, newVersion);\n    }\n\n}\n"
          },
          {
            sha: "0ee7ed647e5ce12c67fe481dc6b3225c519765ab",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package refactoring.crawler.detection;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class SearchHelper {\n+    public static List findMethodCallers(Node node, boolean withSignature) {\n+        return new LinkedList();\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.Node;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class SearchHelper {\n    public static List findMethodCallers(Node node, boolean withSignature) {\n        return new LinkedList();\n    }\n}\n"
          },
          {
            sha: "d294a5f56dad1dba561bfd8d25bd70a7ccaa5d42",
            filename: "src/main/java/refactoring/crawler/project/IClass.java",
            status: "added",
            additions: 22,
            deletions: 0,
            patch:
              "@@ -0,0 +1,22 @@\n+package refactoring.crawler.project;\n+\n+import java.util.List;\n+\n+public interface IClass {\n+\n+    public List<IMethod> getMethods();\n+\n+    public List<IField> getFields();\n+\n+    public String getFullyQualifiedName();\n+\n+    public int getFlags();\n+\n+    public boolean getIsDeprecated();\n+\n+    public boolean getIsInterface();\n+\n+    public boolean isPublic();\n+\n+    public boolean isProtected();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IClass {\n\n    public List<IMethod> getMethods();\n\n    public List<IField> getFields();\n\n    public String getFullyQualifiedName();\n\n    public int getFlags();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsInterface();\n\n    public boolean isPublic();\n\n    public boolean isProtected();\n}\n"
          },
          {
            sha: "dbe2bf76763338d11712c8cb049d27ddc89620bb",
            filename: "src/main/java/refactoring/crawler/project/IField.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.project;\n+\n+public interface IField {\n+\n+    public String getSource();\n+\n+    public String getElementName();\n+\n+    public int getFlags();\n+\n+    public String getTypeSignature();\n+\n+    public boolean getIsDeprecated();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IField {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public int getFlags();\n\n    public String getTypeSignature();\n\n    public boolean getIsDeprecated();\n}\n"
          },
          {
            sha: "aa5a6b80cb38b51776c717580c642edfd62ca7dd",
            filename: "src/main/java/refactoring/crawler/project/IMethod.java",
            status: "added",
            additions: 18,
            deletions: 0,
            patch:
              "@@ -0,0 +1,18 @@\n+package refactoring.crawler.project;\n+\n+public interface IMethod {\n+\n+    public String getSource();\n+\n+    public String getElementName();\n+\n+    public boolean getIsPublic();\n+\n+    public boolean getIsDeprecated();\n+\n+    public boolean getIsProtected();\n+\n+    public int getFlags();\n+\n+    public String[] getParameterTypes();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IMethod {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public boolean getIsPublic();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsProtected();\n\n    public int getFlags();\n\n    public String[] getParameterTypes();\n}\n"
          },
          {
            sha: "dab45c8026bdcaef0dfeb04913e60d8153553ec3",
            filename: "src/main/java/refactoring/crawler/project/IPackage.java",
            status: "added",
            additions: 16,
            deletions: 0,
            patch:
              "@@ -0,0 +1,16 @@\n+package refactoring.crawler.project;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+\n+import java.util.List;\n+\n+public interface IPackage {\n+\n+    public List<IClass> getClasses();\n+\n+    public List<IPackage> getChildrenPackages();\n+\n+    public String getElementName();\n+\n+//    public List<CompilationUnit> getCompilationUnit();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport java.util.List;\n\npublic interface IPackage {\n\n    public List<IClass> getClasses();\n\n    public List<IPackage> getChildrenPackages();\n\n    public String getElementName();\n\n//    public List<CompilationUnit> getCompilationUnit();\n}\n"
          },
          {
            sha: "1757c698aee63ab8c2e194f2656032cf614d9f39",
            filename: "src/main/java/refactoring/crawler/project/IProject.java",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+package refactoring.crawler.project;\n+\n+import java.util.List;\n+\n+public interface IProject {\n+\n+    public List<IPackage> getPackages();\n+\n+    public String getProjectName();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IProject {\n\n    public List<IPackage> getPackages();\n\n    public String getProjectName();\n}\n"
          },
          {
            sha: "e5a3c3b50a35f8f1f21593a3bc3548800599fb37",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "added",
            additions: 45,
            deletions: 0,
            patch:
              "@@ -0,0 +1,45 @@\n+package refactoring.crawler.project;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import lombok.Getter;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+public class RCProject implements IProject {\n+\n+\t@Getter\n+\tprivate String projectName;\n+\n+\tprivate List<CompilationUnit> units;\n+\n+\tprivate List<IPackage> packages;\n+\n+\tpublic RCProject(String projectName, List<String> fileSources) {\n+\t\tthis.projectName = projectName;\n+\t\tthis.units = new LinkedList<>();\n+\t\tfor (String source : fileSources) {\n+\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n+\t\t\tthis.units.add(compilationUnit);\n+\t\t}\n+\t}\n+\n+\n+\tprivate void browsePackages(){\n+\t\tfor(CompilationUnit unit: this.units){\n+\t\t\tunit.\n+\t\t}\n+\t}\n+\n+\n+\t@Override\n+\tpublic List<IPackage> getPackages() {\n+\t\tif (null != packages) {\n+\t\t\tbrowsePackages();\n+\t\t}\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\n\tprivate void browsePackages(){\n\t\tfor(CompilationUnit unit: this.units){\n\t\t\tunit.\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\tif (null != packages) {\n\t\t\tbrowsePackages();\n\t\t}\n\t}\n}\n"
          },
          {
            sha: "d6fae800777369e76bd1270cd1dc09563d8cd0cd",
            filename:
              "src/main/java/refactoring/crawler/util/DirectedEdge.java",
            status: "added",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -0,0 +1,4 @@\n+package refactoring.crawler.util;\n+\n+public class DirectedEdge {\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class DirectedEdge {\n}\n"
          },
          {
            sha: "8ed1aa2b553e7aa5e07e802ed1ddf31bbac4f227",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              '@@ -0,0 +1,31 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DefaultEdge;\n+\n+public class Edge extends DefaultEdge {\n+\n+    @Getter\n+    @Setter\n+    private Node.Type label;\n+\n+    public Edge(Node.Type label) {\n+        this.label = label;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+    }\n+\n+    @Override\n+    public Node getSource() {\n+        return (Node) super.getSource();\n+    }\n+\n+    @Override\n+    public Node getTarget() {\n+        return (Node) super.getTarget();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n    @Getter\n    @Setter\n    private Node.Type label;\n\n    public Edge(Node.Type label) {\n        this.label = label;\n    }\n\n    @Override\n    public String toString() {\n        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n    }\n\n    @Override\n    public Node getSource() {\n        return (Node) super.getSource();\n    }\n\n    @Override\n    public Node getTarget() {\n        return (Node) super.getTarget();\n    }\n}\n'
          },
          {
            sha: "f9c3e922b3febe11864095e3ac7ce7ad280e705a",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "added",
            additions: 28,
            deletions: 0,
            patch:
              "@@ -0,0 +1,28 @@\n+package refactoring.crawler.util;\n+\n+public class FactorOf2Strategy implements ShinglesStrategy {\n+\n+    /**\n+     *\n+     */\n+    public FactorOf2Strategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @Override\n+     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+     */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base + (2 * loc);\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base + (2 * numMethods);\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base + (2 * numClasses);\n+    }\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n    /**\n     *\n     */\n    public FactorOf2Strategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n     * @Override\n     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n     */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base + (2 * loc);\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base + (2 * numMethods);\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base + (2 * numClasses);\n    }\n\n}\n"
          },
          {
            sha: "28d14a892748261ace56edbd47ef89599c251dac",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.util;\n+\n+import org.jgrapht.graph.DirectedMultigraph;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n+\n+    private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+    public NamedDirectedMultigraph() {\n+        super(Edge.class);\n+    }\n+\n+    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+        super(vertexSupplier, edgeSupplier, weighted);\n+    }\n+\n+    public boolean addNamedVertex(Node v) {\n+        if (!addVertex(v))\n+            return false;\n+        namedVertexMap.put(v.getFullyQualifiedName(), v);\n+        return true;\n+    }\n+\n+    public Node findNamedNode(String name) {\n+        return namedVertexMap.get(name);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n    private Map<String, Node> namedVertexMap = new HashMap<>();\n\n    public NamedDirectedMultigraph() {\n        super(Edge.class);\n    }\n\n    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n        super(vertexSupplier, edgeSupplier, weighted);\n    }\n\n    public boolean addNamedVertex(Node v) {\n        if (!addVertex(v))\n            return false;\n        namedVertexMap.put(v.getFullyQualifiedName(), v);\n        return true;\n    }\n\n    public Node findNamedNode(String name) {\n        return namedVertexMap.get(name);\n    }\n}\n"
          },
          {
            sha: "4b07c12c621dc8ab22d3c950d6c1f96229b7f0e6",
            filename: "src/main/java/refactoring/crawler/util/NamedGraph.java",
            status: "added",
            additions: 8,
            deletions: 0,
            patch:
              "@@ -0,0 +1,8 @@\n+package refactoring.crawler.util;\n+\n+public class NamedGraph {\n+\n+    public Node findNamedNode(String name) {\n+        return null;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class NamedGraph {\n\n    public Node findNamedNode(String name) {\n        return null;\n    }\n}\n"
          },
          {
            sha: "4504a1ebed11d791cc0e676301d079e352a28dde",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "added",
            additions: 88,
            deletions: 0,
            patch:
              '@@ -0,0 +1,88 @@\n+package refactoring.crawler.util;\n+\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+\n+\n+public class Node {\n+\n+    public boolean hasCallGraph() {\n+        return false;\n+    }\n+\n+    public void setCreatedCallGraph() {\n+    }\n+\n+    public static enum Type {\n+        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n+    }\n+\n+\n+    @Getter\n+    @Setter\n+    private String fullyQualifiedName;\n+\n+    @Setter\n+    @Getter\n+    private Node.Type type;\n+\n+    @Setter\n+    @Getter\n+    private int[] shingles;\n+\n+    @Setter\n+    @Getter\n+    private boolean hasCallGraph;\n+\n+    @Setter\n+    @Getter\n+    private String projectName;\n+\n+    @Setter\n+    @Getter\n+    private boolean isAPI = false;\n+\n+    @Setter\n+    @Getter\n+    private String signature;\n+\n+    @Setter\n+    @Getter\n+    private int flags;\n+\n+    @Setter\n+    @Getter\n+    private boolean deprecated = false;\n+\n+    @Setter\n+    @Getter\n+    private boolean isInterface = false;\n+\n+    /**\n+     * @param fullyQualifiedName fullyQualifiedName\n+     * @param type               type\n+     */\n+    public Node(String fullyQualifiedName, Node.Type type) {\n+        this.fullyQualifiedName = fullyQualifiedName;\n+        this.type = type;\n+    }\n+\n+    public String getSimpleName() {\n+        int pos = fullyQualifiedName.lastIndexOf(".");\n+        if (pos != -1) {\n+            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n+                    .length());\n+        }\n+        return fullyQualifiedName;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (getSignature() != null)\n+            return getType() + "= " + getFullyQualifiedName() + getSignature();\n+        else\n+            return getType() + "= " + getFullyQualifiedName();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {\n    }\n\n    public static enum Type {\n        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n    }\n\n\n    @Getter\n    @Setter\n    private String fullyQualifiedName;\n\n    @Setter\n    @Getter\n    private Node.Type type;\n\n    @Setter\n    @Getter\n    private int[] shingles;\n\n    @Setter\n    @Getter\n    private boolean hasCallGraph;\n\n    @Setter\n    @Getter\n    private String projectName;\n\n    @Setter\n    @Getter\n    private boolean isAPI = false;\n\n    @Setter\n    @Getter\n    private String signature;\n\n    @Setter\n    @Getter\n    private int flags;\n\n    @Setter\n    @Getter\n    private boolean deprecated = false;\n\n    @Setter\n    @Getter\n    private boolean isInterface = false;\n\n    /**\n     * @param fullyQualifiedName fullyQualifiedName\n     * @param type               type\n     */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n                    .length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType() + "= " + getFullyQualifiedName() + getSignature();\n        else\n            return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "83dcc9cfbd0cd773712c1ec4e47d2efee5371374",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesStrategy.java",
            status: "added",
            additions: 9,
            deletions: 0,
            patch:
              "@@ -0,0 +1,9 @@\n+package refactoring.crawler.util;\n+\n+public interface ShinglesStrategy {\n+    int upperBoundLimitForShinglesBag(int loc, int s_base);\n+\n+    int upperBoundForClassShingles(int numMethods, int s_base);\n+\n+    int upperBoundForPackageShingles(int numClasses, int s_base);\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic interface ShinglesStrategy {\n    int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n    int upperBoundForClassShingles(int numMethods, int s_base);\n\n    int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "d6c31c95601aeca5d514d4627237ca39d3c44999",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "added",
            additions: 130,
            deletions: 0,
            patch:
              "@@ -0,0 +1,130 @@\n+package refactoring.crawler.util;\n+\n+import org.jgrapht.graph.DirectedMultigraph;\n+import org.jgrapht.traverse.BreadthFirstIterator;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+public class ShinglesUtil {\n+    private ShinglesStrategy shinglesStrategy;\n+\n+    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\n+    private DirectedMultigraph<Node, Edge> newVersionGraph;\n+\n+    private List<Node[]> similarMethods;\n+\n+    private List<Node> oldVersionPackageList;\n+    private List<Node> oldVersionClassList;\n+    private List<Node> oldVersionMethodList;\n+    private List<Node> oldVersionFieldList;\n+\n+    private List<Node> newVersionPackageList;\n+    private List<Node> newVersionClassList;\n+    private List<Node> newVersionMethodList;\n+    private List<Node> newVersionFieldList;\n+\n+    private double methodThreshold;\n+\n+    public ShinglesUtil() {\n+        this.shinglesStrategy = new FactorOf2Strategy();\n+    }\n+\n+    public int[] computeMethodShingles(String str) {\n+        return null;\n+    }\n+\n+    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n+        this.oldVersionGraph = oldVersionGraph;\n+        this.newVersionGraph = newVersionGraph;\n+\n+        this.oldVersionPackageList = new ArrayList<>();\n+        this.oldVersionClassList = new ArrayList<>();\n+        this.oldVersionMethodList = new ArrayList<>();\n+        this.oldVersionFieldList = new ArrayList<>();\n+\n+        this.newVersionPackageList = new ArrayList<>();\n+        this.newVersionClassList = new ArrayList<>();\n+        this.newVersionMethodList = new ArrayList<>();\n+        this.newVersionFieldList = new ArrayList<>();\n+\n+        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n+                oldVersionPackageList, oldVersionFieldList);\n+\n+        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n+    }\n+\n+    /**\n+     * For the passed graph, fills the respective arrays for packages, classes,\n+     * methods and fields by using a breadth first iterator.\n+     *\n+     * @param graph\n+     * @param methods\n+     * @param classes\n+     * @param packages\n+     * @param fields\n+     */\n+    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n+                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n+        // Create a BreadthFirstIterator for the graph\n+        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+        while (bfi.hasNext()) {\n+            Node n = bfi.next();\n+            if (n.getType().equals(Node.Type.CLASS)) {\n+                classes.add(n);\n+            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+                packages.add(n);\n+            } else if (n.getType().equals(Node.Type.METHOD)) {\n+                methods.add(n);\n+            } else if (n.getType().equals(Node.Type.FIELD)) {\n+                fields.add(n);\n+            }\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarMethods() {\n+        if (this.similarMethods.isEmpty()) {\n+            List<Node[]> similarMethods = new ArrayList<>();\n+            for (Node m : this.oldVersionMethodList) {\n+                if (!m.isAPI())\n+                    continue;\n+\n+                for (Node m2 : this.newVersionMethodList) {\n+                    if (!m2.isAPI())\n+                        continue;\n+\n+                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+                        Node[] arr = {m, m2};\n+                        // if (!isThisArrayInTheList(simMet, arr))\n+                        similarMethods.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarMethods = similarMethods;\n+        }\n+        return this.similarMethods;\n+    }\n+\n+    public double howMuchAlike(int[] arr1, int[] arr2) {\n+        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+        return finalGrade;\n+    }\n+\n+    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+        int[] tempArr = (int[]) arr2.clone();\n+        double grade = 0.0;\n+        for (int value : arr1) {\n+            for (int j = 0; j < tempArr.length; j++) {\n+                if (value == tempArr[j]) {\n+                    grade += 1.0 / arr1.length;\n+                    tempArr[j] = Integer.MIN_VALUE;\n+                    break;\n+                }\n+            }\n+        }\n+        return grade;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class ShinglesUtil {\n    private ShinglesStrategy shinglesStrategy;\n\n    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n    private DirectedMultigraph<Node, Edge> newVersionGraph;\n\n    private List<Node[]> similarMethods;\n\n    private List<Node> oldVersionPackageList;\n    private List<Node> oldVersionClassList;\n    private List<Node> oldVersionMethodList;\n    private List<Node> oldVersionFieldList;\n\n    private List<Node> newVersionPackageList;\n    private List<Node> newVersionClassList;\n    private List<Node> newVersionMethodList;\n    private List<Node> newVersionFieldList;\n\n    private double methodThreshold;\n\n    public ShinglesUtil() {\n        this.shinglesStrategy = new FactorOf2Strategy();\n    }\n\n    public int[] computeMethodShingles(String str) {\n        return null;\n    }\n\n    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n        this.oldVersionGraph = oldVersionGraph;\n        this.newVersionGraph = newVersionGraph;\n\n        this.oldVersionPackageList = new ArrayList<>();\n        this.oldVersionClassList = new ArrayList<>();\n        this.oldVersionMethodList = new ArrayList<>();\n        this.oldVersionFieldList = new ArrayList<>();\n\n        this.newVersionPackageList = new ArrayList<>();\n        this.newVersionClassList = new ArrayList<>();\n        this.newVersionMethodList = new ArrayList<>();\n        this.newVersionFieldList = new ArrayList<>();\n\n        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n                oldVersionPackageList, oldVersionFieldList);\n\n        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n    }\n\n    /**\n     * For the passed graph, fills the respective arrays for packages, classes,\n     * methods and fields by using a breadth first iterator.\n     *\n     * @param graph\n     * @param methods\n     * @param classes\n     * @param packages\n     * @param fields\n     */\n    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n        // Create a BreadthFirstIterator for the graph\n        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n        while (bfi.hasNext()) {\n            Node n = bfi.next();\n            if (n.getType().equals(Node.Type.CLASS)) {\n                classes.add(n);\n            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n                packages.add(n);\n            } else if (n.getType().equals(Node.Type.METHOD)) {\n                methods.add(n);\n            } else if (n.getType().equals(Node.Type.FIELD)) {\n                fields.add(n);\n            }\n        }\n    }\n\n    public List<Node[]> findSimilarMethods() {\n        if (this.similarMethods.isEmpty()) {\n            List<Node[]> similarMethods = new ArrayList<>();\n            for (Node m : this.oldVersionMethodList) {\n                if (!m.isAPI())\n                    continue;\n\n                for (Node m2 : this.newVersionMethodList) {\n                    if (!m2.isAPI())\n                        continue;\n\n                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n                        Node[] arr = {m, m2};\n                        // if (!isThisArrayInTheList(simMet, arr))\n                        similarMethods.add(arr);\n                    }\n                }\n            }\n            this.similarMethods = similarMethods;\n        }\n        return this.similarMethods;\n    }\n\n    public double howMuchAlike(int[] arr1, int[] arr2) {\n        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n        return finalGrade;\n    }\n\n    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n        int[] tempArr = (int[]) arr2.clone();\n        double grade = 0.0;\n        for (int value : arr1) {\n            for (int j = 0; j < tempArr.length; j++) {\n                if (value == tempArr[j]) {\n                    grade += 1.0 / arr1.length;\n                    tempArr[j] = Integer.MIN_VALUE;\n                    break;\n                }\n            }\n        }\n        return grade;\n    }\n}\n"
          },
          {
            sha: "685341106012f3c9808aa7cf285e282fb1cde756",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "added",
            additions: 180,
            deletions: 0,
            patch:
              '@@ -0,0 +1,180 @@\n+package refactoring.crawler.util;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.val;\n+import org.eclipse.jdt.core.Signature;\n+import refactoring.crawler.project.*;\n+\n+import javax.annotation.Nonnull;\n+\n+public class SourceNavigator {\n+\n+\t@Getter\n+\tprivate NamedDirectedMultigraph graph;\n+\n+\tprivate ShinglesUtil shinglesUtil;\n+\n+\tprivate String projectName;\n+\n+\tprivate int packageCounter = 0;\n+\n+\tprivate int allMethodsCounter = 0;\n+\n+\tprivate int allClassCounter = 0;\n+\n+\tprivate int apiClassCounter = 0;\n+\n+\tprivate int apiMethodCounter = 0;\n+\n+\tpublic static boolean useJavadocComments = false;\n+\n+\tpublic SourceNavigator() {\n+\t\tgraph = new NamedDirectedMultigraph();\n+\t}\n+\n+\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+\t\tthis.shinglesUtil = shinglesUtil;\n+\t}\n+\n+\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+\t\tthis.projectName = projectName;\n+\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n+\t\tval packages = compilationUnits.stream()\n+\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+\t\t\t.filter(p -> !p.isPresent())\n+\t\t\t.collect(Collectors.toList());\n+//        this.graph.addVertex(projectNode);\n+\t\tthis.graph.addNamedVertex(projectNode);\n+\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n+\t}\n+\n+\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n+\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n+\t\tchildrenPackages.forEach(childrenPackage -> {\n+\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n+\t\t\tpackageNode.setProjectName(this.projectName);\n+//            graph.addVertex(packageNode);\n+\t\t\tgraph.addNamedVertex(packageNode);\n+//            graph.addEdge(projectNode, packageNode);\n+\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+\t\t\tthis.packageCounter += 1;\n+\t\t});\n+\t}\n+\n+\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+\t\tval classes = pckg.getClasses();\n+\t\tclasses.forEach(clz -> {\n+\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+\t\t\tclassNode.setProjectName(this.projectName);\n+\t\t\tclassNode.setFlags(clz.getFlags());\n+//            graph.addVertex(classNode);\n+//            graph.addEdge(packageNode, classNode);\n+\t\t\tgraph.addNamedVertex(classNode);\n+\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\t\t\tthis.browseClass(clz, classNode);\n+\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+\t\t\tclassNode.setInterface(clz.getIsInterface());\n+\t\t\tthis.allClassCounter += 1;\n+\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+\t\t\t\tclassNode.setAPI(true);\n+\t\t\t\tthis.apiClassCounter += 1;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+\t\tval methods = clz.getMethods();\n+\t\tbrowseMethods(methods, classNode);\n+\t\tval fields = clz.getFields();\n+\t\tbrowseFields(fields, classNode);\n+\t}\n+\n+\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+\t\tmethods.forEach(method -> {\n+\t\t\tString statementBody = "";\n+\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+\t\t\t\tstatementBody = method.getSource().trim();\n+\t\t\t} else\n+\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+\t\t\t\t+ method.getElementName();\n+\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+\n+\t\t\tallMethodsCounter += 1;\n+\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+\t\t\t\tmethodNode.setAPI(true);\n+\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t}\n+\t\t\tif (method.getIsDeprecated())\n+\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\tmethodNode.setProjectName(projectName);\n+\t\t\tmethodNode.setShingles(shingles);\n+\t\t\tmethodNode.setFlags(method.getFlags());\n+\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+//            graph.addVertex(methodNode);\n+//            graph.addEdge(classNode, methodNode);\n+\t\t\tgraph.addNamedVertex(methodNode);\n+\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+\t\t});\n+\t}\n+\n+\n+\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\n+\t\tbuffer.append(\'(\');\n+\n+\t\tString[] types = method.getParameterTypes();\n+\t\tfor (int i = 0; i < types.length; i++) {\n+\t\t\tif (i > 0)\n+\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+\t\t\tString typeSig = Signature.toString(types[i]);\n+\t\t\tbuffer.append(typeSig);\n+\t\t}\n+\t\tbuffer.append(\')\');\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+\t\tfields.forEach(field -> {\n+\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\tfieldNode.setShingles(shingles);\n+\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+//            graph.addVertex(fieldNode);\n+//            graph.addEdge(classNode, fieldNode);\n+\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * This prunes away the javadoc comments\n+\t *\n+\t * @param source\n+\t * @return\n+\t */\n+\tprivate String statementBody(String source) {\n+\t\tint lastAtChar = source.lastIndexOf("@");\n+\t\tif (lastAtChar == -1)\n+\t\t\tlastAtChar = 0;\n+\t\tint openingBracket = source.indexOf("{", lastAtChar);\n+\t\tint closingBracket = source.lastIndexOf("}");\n+\t\tif (openingBracket != -1)\n+\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n+\t\treturn source;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tval packages = compilationUnits.stream()\n\t\t\t.map(CompilationUnit::getPackageDeclaration)\n\t\t\t.filter(p -> !p.isPresent())\n\t\t\t.collect(Collectors.toList());\n//        this.graph.addVertex(projectNode);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n\t}\n\n\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n\t\tchildrenPackages.forEach(childrenPackage -> {\n\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n\t\t\tpackageNode.setProjectName(this.projectName);\n//            graph.addVertex(packageNode);\n\t\t\tgraph.addNamedVertex(packageNode);\n//            graph.addEdge(projectNode, packageNode);\n\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n\t\t\tthis.packageCounter += 1;\n\t\t});\n\t}\n\n\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n\t\tval classes = pckg.getClasses();\n\t\tclasses.forEach(clz -> {\n\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n\t\t\tclassNode.setProjectName(this.projectName);\n\t\t\tclassNode.setFlags(clz.getFlags());\n//            graph.addVertex(classNode);\n//            graph.addEdge(packageNode, classNode);\n\t\t\tgraph.addNamedVertex(classNode);\n\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\t\t\tthis.browseClass(clz, classNode);\n\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n\t\t\tclassNode.setInterface(clz.getIsInterface());\n\t\t\tthis.allClassCounter += 1;\n\t\t\tif (clz.isProtected() || clz.isPublic()) {\n\t\t\t\tclassNode.setAPI(true);\n\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n\t\tval methods = clz.getMethods();\n\t\tbrowseMethods(methods, classNode);\n\t\tval fields = clz.getFields();\n\t\tbrowseFields(fields, classNode);\n\t}\n\n\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n\t\tmethods.forEach(method -> {\n\t\t\tString statementBody = "";\n\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\tstatementBody = method.getSource().trim();\n\t\t\t} else\n\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t+ method.getElementName();\n\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n\n\t\t\tallMethodsCounter += 1;\n\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t}\n\t\t\tif (method.getIsDeprecated())\n\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\tmethodNode.setProjectName(projectName);\n\t\t\tmethodNode.setShingles(shingles);\n\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n//            graph.addVertex(methodNode);\n//            graph.addEdge(classNode, methodNode);\n\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t});\n\t}\n\n\n\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\tbuffer.append(\'(\');\n\n\t\tString[] types = method.getParameterTypes();\n\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n\t\t\tString typeSig = Signature.toString(types[i]);\n\t\t\tbuffer.append(typeSig);\n\t\t}\n\t\tbuffer.append(\')\');\n\n\t\treturn buffer.toString();\n\t}\n\n\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n\t\tfields.forEach(field -> {\n\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\tfieldNode.setShingles(shingles);\n\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\tfieldNode.setSignature(field.getTypeSignature());\n\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n//            graph.addVertex(fieldNode);\n//            graph.addEdge(classNode, fieldNode);\n\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t});\n\t}\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          },
          {
            sha: "725ef3d6de620acbc3d0eeed586e1bc21cc5f2b6",
            filename:
              "src/main/java/refactoring/crawler/visitor/ClassVisitor.java",
            status: "added",
            additions: 8,
            deletions: 0,
            patch:
              "@@ -0,0 +1,8 @@\n+package refactoring.crawler.visitor;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+public class ClassVisitor extends VoidVisitorAdapter<Object> {\n+\n+}",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class ClassVisitor extends VoidVisitorAdapter<Object> {\n\n}\n"
          },
          {
            sha: "da212c011daa35711a7bc770b3a8647fd26e91a3",
            filename:
              "src/main/java/refactoring/crawler/visitor/MethodVisitor.java",
            status: "added",
            additions: 518,
            deletions: 0,
            patch:
              "@@ -0,0 +1,518 @@\n+package refactoring.crawler.visitor;\n+\n+import com.github.javaparser.ast.*;\n+import com.github.javaparser.ast.body.*;\n+import com.github.javaparser.ast.comments.*;\n+import com.github.javaparser.ast.expr.*;\n+import com.github.javaparser.ast.modules.*;\n+import com.github.javaparser.ast.stmt.*;\n+import com.github.javaparser.ast.type.*;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+public class MethodVisitor extends VoidVisitorAdapter<Object> {\n+\n+    public void visit(MethodDeclaration n, Object arg) {\n+        System.out.println(n.getBody());\n+        System.out.println(n.getName());\n+    }\n+\n+    @Override\n+    public void visit(AnnotationDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AnnotationMemberDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayAccessExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayCreationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayInitializerExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AssertStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AssignExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BinaryExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BlockComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BlockStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BooleanLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BreakStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CastExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CatchClause n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CharLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassOrInterfaceType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CompilationUnit n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ConditionalExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ConstructorDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ContinueStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(DoStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(DoubleLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EmptyStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnclosedExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnumConstantDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnumDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ExpressionStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(FieldAccessExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(FieldDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ForEachStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ForStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IfStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(InitializerDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(InstanceOfExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IntegerLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LabeledStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LineComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LongLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MarkerAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MemberValuePair n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MethodCallExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NameExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NormalAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NullLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ObjectCreationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(PackageDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Parameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(PrimitiveType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Name n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SimpleName n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayCreationLevel n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IntersectionType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnionType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ReturnStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(StringLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SuperExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchEntry n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SynchronizedStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ThisExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ThrowStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TryStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LocalClassDeclarationStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TypeParameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnaryExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnknownType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VariableDeclarationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VariableDeclarator n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VoidType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(WhileStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(WildcardType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LambdaExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MethodReferenceExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TypeExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NodeList n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ImportDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleRequiresDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleExportsDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleProvidesDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleUsesDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleOpensDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnparsableStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ReceiverParameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VarType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Modifier n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TextBlockLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(YieldStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocBlockTag n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocContent n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocDescription n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocInlineTag n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocSnippet n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+}\n\\ No newline at end of file",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.modules.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class MethodVisitor extends VoidVisitorAdapter<Object> {\n\n    public void visit(MethodDeclaration n, Object arg) {\n        System.out.println(n.getBody());\n        System.out.println(n.getName());\n    }\n\n    @Override\n    public void visit(AnnotationDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AnnotationMemberDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayInitializerExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssertStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssignExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BinaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BooleanLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BreakStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CastExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CatchClause n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CharLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CompilationUnit n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConditionalExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConstructorDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ContinueStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoubleLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EmptyStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnclosedExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumConstantDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExpressionStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForEachStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IfStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InitializerDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InstanceOfExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntegerLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LabeledStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LineComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LongLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MarkerAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MemberValuePair n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodCallExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NameExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NormalAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NullLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ObjectCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PackageDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Parameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PrimitiveType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Name n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SimpleName n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntersectionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReturnStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(StringLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SuperExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchEntry n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SynchronizedStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThisExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThrowStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TryStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LocalClassDeclarationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarator n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VoidType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WhileStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WildcardType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NodeList n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ImportDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleRequiresDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleExportsDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleProvidesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleUsesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleOpensDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnparsableStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReceiverParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VarType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Modifier n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TextBlockLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(YieldStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocBlockTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocContent n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocDescription n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocInlineTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocSnippet n, Object arg) {\n        super.visit(n, arg);\n    }\n}"
          },
          {
            sha: "1f2ec2d8c7de952487f2f8c7cf6e125976d6ad20",
            filename: "src/test/java/refactoring/crawler/LibraryTest.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class LibraryTest {\n+    @Test void testSomeLibraryMethod() {\n+        Library classUnderTest = new Library();\n+        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n+    }\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LibraryTest {\n    @Test void testSomeLibraryMethod() {\n        Library classUnderTest = new Library();\n        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n    }\n}\n"
          }
        ]
      }
    ],
    trees: [
      {
        subTrees: [
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "3663e804b7832ea04bf4a3ff8eafea32070498dd",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "original",
                                sha: "fe217450e9ba950dba99855d78dd89bb0f6213de"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "2dc66023a72d428c6c21fd74e2234072326a49e2",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "701f29bc236e688897a8a591086c04fde5b966e9",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "986e673462260d92feac4b036a4d2b48af19cb71",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "newVersion",
                                sha: "035ccb7d43d00146cd15659487a15ab390b263c9"
                              }
                            ],
                            type: "FOLDER",
                            path: "testPushDownMethod",
                            sha: "5d3fb22bf9533e1d01f9985765f21cbe7738af45"
                          },
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "original",
                                sha: "c71faa28699f5ec81e575876f0e2c145dc66d068"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "dd83f48f6ade0ae1135e1142522e3d14895cb000",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "e4e3a2ff422284c53ab262608b26088f45ae47e1",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "newVersion",
                                sha: "6d258ff24af96d8479adda2b4740222a9f826199"
                              }
                            ],
                            type: "FOLDER",
                            path: "testPullUpMethod",
                            sha: "b43a61966d7e6aa4a1a660bd5b8629d7ffc1ceb9"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "Array.java",
                                sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ArrayStack.java",
                                sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Stack.java",
                                sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "testMoveMethod",
                            sha: "40afa68dfbb3a131f33f7d93793faba0bb9d2ab1"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "Array.java",
                                sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ArrayStack.java",
                                sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Stack.java",
                                sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "original",
                            sha: "2a15a3a12d34a74a2027ea661a9b101a9cfdecb5"
                          },
                          {
                            type: "FILE",
                            path: "RefactoringCrawlerTest.java",
                            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
                            subTrees: []
                          },
                          {
                            type: "FILE",
                            path: "TestUtils.java",
                            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
                            subTrees: []
                          }
                        ],
                        type: "FOLDER",
                        path: "crawler",
                        sha: "98288f4e7f0e172bba7041ec831758b368b93522"
                      }
                    ],
                    type: "FOLDER",
                    path: "refactoring",
                    sha: "9ef8d49f98d995b8170df85355997b662966490b"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "c6e539a4b86cac1acfe92f4e91aa259dfc190d7b"
              }
            ],
            type: "FOLDER",
            path: "test",
            sha: "7f203f941c443c15f09bdcd85fa5ccb07f43081b"
          },
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "RefactoringCategory.java",
                                sha: "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "SourceNavigator.java",
                                sha: "15111aaeb3dee736e91cde79219e6eafa796ca62",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "util",
                            sha: "38e8428da312e0bec4049f16f56d2a589097a5d1"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "BloomFilter.java",
                                sha: "98bf2210121031f53e8caf7f8f89645f6b1dcc86",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "DefaultStrategy.java",
                                sha: "3be706f1ea9ded9a332de32c31f99eedf4652de0",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "FactorOf2Strategy.java",
                                sha: "55e796c451fb63675bae1000f41dd15b720bbb42",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ShinglesStrategy.java",
                                sha: "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ShinglesUtil.java",
                                sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "shingles",
                            sha: "56f30a8ca8fb903827e3db90ee5cfce4f85dd4d7"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "ClassNode.java",
                                sha: "66cc05cc40337a87d4835854e19c62d19d2c4067",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Edge.java",
                                sha: "7774ec8b37feef6882a868e2660021a320eeaa54",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "FieldNode.java",
                                sha: "51d845ea135825c28660aac7c258adde05243914",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "MethodNode.java",
                                sha: "e2919264f5aa7154db6f0c0501950564a730a1e3",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "NamedDirectedMultigraph.java",
                                sha: "5c0ac895baf10b75181e22675a8b7840b08fb90d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Node.java",
                                sha: "4397227e131372600696f0c613eaab9d7bf41229",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "graph",
                            sha: "cdb7155a52f9d60fb5a72d377603dd2835433ded"
                          },
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "ChangeMethodSignatureDetection.java",
                                    sha:
                                      "6f93400dab485c9315236a4fe01494f3d3b2aef8",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MethodDetection.java",
                                    sha:
                                      "9e492fa56e3b1f654735d03da1b18778ea4a3c5e",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveMethodDetection.java",
                                    sha:
                                      "76a947129555279bb0423f831c949f1899b2074a",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "PullUpMethodDetection.java",
                                    sha:
                                      "2c24f295bf40887025a35ce694a69c056b81a7a3",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "PushDownMethodDetection.java",
                                    sha:
                                      "296bce275d7968716d7f0bed80da373e18210114",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "RenameMethodDetection.java",
                                    sha:
                                      "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "methodDetection",
                                sha: "d71d6fbc9a38fa530fa48d80ee1f73e6581da619"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "FieldDetection.java",
                                    sha:
                                      "67bf6cf86456904a46c7d568fe0527ed920c971f",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveFieldDetection.java",
                                    sha:
                                      "184ff327f5f763cae4d3307e3cf0ae9b0391eb70",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "fieldDetection",
                                sha: "d2cf92424145905798c99058040596a8b5fdce12"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "ClassDetection.java",
                                    sha:
                                      "072aa07a114622cd395391b740b9a1e46b64fb70",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveClassDetection.java",
                                    sha:
                                      "e753da375cfabc5fb57d8d5440f95671d7bf42f9",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "RenameClassDetection.java",
                                    sha:
                                      "f069e44153341cbf9da6818393293f5e7e9ac108",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "classDetection",
                                sha: "9f0ced53fce008209a00bde46ea3f4a4bbc74301"
                              },
                              {
                                type: "FILE",
                                path: "RefactoringDetection.java",
                                sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "SearchHelper.java",
                                sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "detection",
                            sha: "0f9b16b7f833ff07de2f31c4765a6be1dfda06f3"
                          },
                          {
                            type: "FILE",
                            path: "RefactoringCrawler.java",
                            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
                            subTrees: []
                          }
                        ],
                        type: "FOLDER",
                        path: "crawler",
                        sha: "69f6c6e48f58bcdf616b290b9e6b24a59a184dcd"
                      }
                    ],
                    type: "FOLDER",
                    path: "refactoring",
                    sha: "275d87f15d039923db87aed2db9adaf509dfb986"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "5d2a8220cfc3d7c2f673c01a0ba4a7a9db4fbf35"
              }
            ],
            type: "FOLDER",
            path: "main",
            sha: "1b5651eecd5c551bb2843bc7bfc4f9c595ff5e06"
          }
        ],
        type: "FOLDER",
        path: "src",
        sha: "f3a6fbab422f5dd563c43cab155e7a0fc34d04eb"
      },
      {
        subTrees: [
          {
            subTrees: [
              {
                type: "FILE",
                path: "gradle-wrapper.jar",
                sha: "5c2d1cf016b3885f6930543d57b744ea8c220a1a",
                subTrees: []
              },
              {
                type: "FILE",
                path: "gradle-wrapper.properties",
                sha: "f3b4dae340056399e69926fa62aba660b3e9404e",
                subTrees: []
              }
            ],
            type: "FOLDER",
            path: "wrapper",
            sha: "51f47f1a365e3bb394f7c705f95fb406d5a30c00"
          }
        ],
        type: "FOLDER",
        path: "gradle",
        sha: "82921f678d2459e9e22ae47b07d34dfa858ec085"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "org.eclipse.buildship.core.prefs",
            sha: "e8895216fd3c0c3af4c4522334775f41b7deb42e",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".settings",
        sha: "66e551dc6b35c2e0b562f48158c0916684323c66"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "compiler.xml",
            sha: "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d",
            subTrees: []
          },
          {
            type: "FILE",
            path: "gradle.xml",
            sha: "a64b2758bd03a20260566a40b58c116679055c17",
            subTrees: []
          },
          {
            type: "FILE",
            path: "jarRepositories.xml",
            sha: "4fed64e0de33c78035aa4aa1eb052668eb85c6d4",
            subTrees: []
          },
          {
            type: "FILE",
            path: "misc.xml",
            sha: "b1662faf91f158c3fc95e7f294260c2ea0cdbc12",
            subTrees: []
          },
          {
            type: "FILE",
            path: "uiDesigner.xml",
            sha: "e96534fb27b68192f27f985d3879e173ec77adb8",
            subTrees: []
          },
          {
            type: "FILE",
            path: "workspace.xml",
            sha: "0f5826ff690d76f8961058a4fd1cf25f380882c3",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".idea",
        sha: "cd26532d3e2893606d8764f108082f9c98f2996f"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "config.yml",
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".circleci",
        sha: "ddf3d2658c7739b92c394d54f0ffd22ef945ac1d"
      },
      {
        type: "FILE",
        path: ".gitattributes",
        sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".gitignore",
        sha: "ea419d85c301b292fbadf5b1f4da2c8350a1c0f1",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".project",
        sha: "669e8aabbeb973fc803553332427c4c3309bf0b6",
        subTrees: []
      },
      {
        type: "FILE",
        path: "README.md",
        sha: "b34fbf6028059b5e0f654d1d1645aef6f2400c75",
        subTrees: []
      },
      {
        type: "FILE",
        path: "build.gradle",
        sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
        subTrees: []
      },
      {
        type: "FILE",
        path: "gradlew",
        sha: "8e25e6c19d5748190b8cc39e98c2b56e496a5717",
        subTrees: []
      },
      {
        type: "FILE",
        path: "gradlew.bat",
        sha: "9618d8d9607cd91a0efb866bcac4810064ba6fac",
        subTrees: []
      },
      {
        type: "FILE",
        path: "settings.gradle",
        sha: "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc",
        subTrees: []
      }
    ],
    branches: [
      {
        name: "circleci-project-setup",
        commitHeadSha: "2a8ff280c4626e929dec89adc0992be9af6c2c55"
      },
      {
        name: "develop",
        commitHeadSha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c"
      },
      {
        name: "master",
        commitHeadSha: "27447784904e85b61609a78983e4ecbecaf37c4f"
      }
    ],
    shaFileContentMap: {
      "3663e804b7832ea04bf4a3ff8eafea32070498dd":
        'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "6d45cd03f52a582ed4925ce83d7c0dfa088209e3":
        'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813":
        "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n",
      "2dc66023a72d428c6c21fd74e2234072326a49e2":
        'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "701f29bc236e688897a8a591086c04fde5b966e9":
        'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "986e673462260d92feac4b036a4d2b48af19cb71":
        "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n",
      "0a06f9b4447e64347de6217bb6a2a1ff9d57c920":
        'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "4b759f877b4483f21723c98d6fe5403d7f6cd4df":
        'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "7e973976b15ab8576eeb05a552ef14b85f64a6cd":
        "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n",
      dd83f48f6ade0ae1135e1142522e3d14895cb000:
        'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a":
        'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      e4e3a2ff422284c53ab262608b26088f45ae47e1:
        "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n",
      e27bc744f35db7816a16656ad51b777fb11c089b:
        'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n',
      b5111703d0e7e2b56393115af91c30d85537e93d:
        'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n',
      "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d":
        "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n",
      "3d04b5375c95bfa076ffba2211b24cb079563585":
        'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // \u009e\u0084\u0080\u0087\u0095\u008c\u0085\u0095\u0084\u009a\u0084\u0087\u008fcapacity\u009e\u0084\u0080Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // \u0097\u008f\u0082\u0095\u009a\u0084\u009e\u0084\u0080\u0087\u0095\u008c\u0098\u0095\u0084\u009a\u0084\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u009a\u0084\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // \u008e\u008f\u0096\u0095\u0084\u00ad\u009a\u0084\u0085\u0083\u0095\n  public int getSize() {\n    return size;\n  }\n\n  // \u0094\u009b\u009e\u0095\u0084\u0098\u0090\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // \u009cindex\u0095\u009a\u0084\u008d\u008f\u0092\u0085\u0080\u0096\u0085\u0083e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // \u0090\u0091\u0089\u0080\u009c\u0089\u0085\u0083\u0090\u008e\u008a\u0080\u0096\u0085\u0083\n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // \u009c\u0089\u0080\u009c\u0089\u0085\u0083\u0089\u008d\u008a\u0080\u0096\u0085\u0083\n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // \u008e\u008f\u0096index\u0095\u008d\u009a\u0084\u0085\u0083\n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // \u0094index\u0095\u008d\u009a\u0084\u0085\u0083e\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0098\u0090\u009c\u0089\u0085\u0083e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // \u009f\u0089\u0095\u0084\u00ad\u0085\u0083e\u0089\u0080\u009c\u009a\u0084\u0095\u008c\u0082\u009e\u009c\u008d\u00ad\u0098\u009c\u0085\u0083e\u008c\u0088\u0099\u0094\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099index\u008d\u009a\u0084\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u009c\u0080\u0090\u008e\u0080\u0085\u0083, \u0094\u009b\u009e\u0088\u0099\u009a\u0084\u0085\u0083\n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // \u008e\u0095\u0084\u00ad\u0088\u0099\u0085\u0083e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // \u0086\u0095\u0084\u0097\u009a\u0084\u0087\u008f\u008f\u0098\u0088\u0090newCapacity\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n',
      "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d":
        'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n',
      b3512976aa6de01f87c5d7e929b59a137bdc69a3:
        "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n",
      "95c782cd777d56e3441b65345697ee273f34fff4":
        '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n',
      "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92":
        'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n',
      "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e":
        'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n  @Getter @Setter private String name;\n\n  @Getter @Setter private List<Node[]> refactoringPairs;\n\n  public Node[][] getElements() {\n    Node[][] elements = new Node[refactoringPairs.size()][];\n    int i = 0;\n    for (Node[] pair : refactoringPairs) {\n      elements[i++] = pair;\n    }\n    return elements;\n  }\n\n  public String toString() {\n    return name + printElements(getElements());\n  }\n\n  private String printElements(Node[][] array) {\n    StringBuilder res = new StringBuilder();\n    for (Node[] nodes : array) {\n      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n    }\n    return res.toString();\n  }\n}\n',
      "15111aaeb3dee736e91cde79219e6eafa796ca62":
        'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n  @Getter private NamedDirectedMultigraph graph;\n\n  private ShinglesUtil shinglesUtil;\n\n  private String projectName;\n\n  private int packageCounter = 0;\n\n  private int allMethodsCounter = 0;\n\n  private int allClassCounter = 0;\n\n  private int apiClassCounter = 0;\n\n  private int apiMethodCounter = 0;\n\n  public static boolean useJavadocComments = false;\n\n  public SourceNavigator() {\n    graph = new NamedDirectedMultigraph();\n  }\n\n  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n    this.shinglesUtil = shinglesUtil;\n  }\n\n  public void browseProject(\n      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n    this.projectName = projectName;\n    val projectNode = new Node(projectName, Node.Type.PROJECT);\n    this.graph.addNamedVertex(projectNode);\n    compilationUnits.forEach(\n        cu -> {\n          val packageDeclaration = cu.getPackageDeclaration();\n          val importDeclarations = cu.getImports();\n\n          val classesImported = new LinkedList<String>();\n\n          importDeclarations.forEach(\n              importDeclaration -> {\n                classesImported.add(importDeclaration.getName().asString());\n              });\n\n          if (packageDeclaration.isPresent()) {\n            val packageName = packageDeclaration.get().getNameAsString();\n            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n            packageNode.setProjectName(projectName);\n            this.graph.addNamedVertex(packageNode);\n            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n            cu.getTypes()\n                .forEach(\n                    type -> {\n                      if (type.isClassOrInterfaceDeclaration()) {\n                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                        if (className.isPresent()) {\n                          val classNode = new ClassNode(className.get());\n                          classNode.setProjectName(projectName);\n\n                          List<String> extendedClasses =\n                              classOrInterfaceDeclaration\n                                  .getExtendedTypes()\n                                  .stream()\n                                  .map(extendType -> extendType.resolve().getQualifiedName())\n                                  .collect(Collectors.toList());\n\n                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                          classNode.setSuperClasses(extendedClasses);\n                          classNode.setClassesImported(classesImported);\n                          classNode.setDeprecated(\n                              classOrInterfaceDeclaration\n                                  .getAnnotationByClass(Deprecated.class)\n                                  .isPresent());\n                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                          this.allClassCounter += 1;\n                          if (classOrInterfaceDeclaration.isProtected()\n                              || classOrInterfaceDeclaration.isPublic()) {\n                            classNode.setAPI(true);\n                            this.apiClassCounter += 1;\n                          }\n                          graph.addNamedVertex(classNode);\n                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                          // methods\n                          List<MethodDeclaration> methodDeclarations =\n                              classOrInterfaceDeclaration.getMethods();\n\n                          // filed fqn -> methods fqn\n                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                          methodDeclarations.forEach(\n                              method -> {\n                                String statementBody = "";\n                                val methodBody = method.getBody();\n\n                                if (methodBody.isPresent()) {\n                                  if (classNode.isInterface() || (useJavadocComments)) {\n                                    statementBody = methodBody.get().toString().trim();\n                                  } else\n                                    statementBody =\n                                        statementBody(methodBody.get().toString()).trim();\n                                  int[] shingles =\n                                      shinglesUtil.computeMethodShingles(statementBody);\n                                  String qualifiedName =\n                                      classNode.getFullyQualifiedName()\n                                          + "."\n                                          + method.getNameAsString();\n                                  MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                  List<String> methodReferencedFields =\n                                      method\n                                          .findAll(FieldAccessExpr.class)\n                                          .stream()\n                                          .map(\n                                              fieldAccessExpr ->\n                                                  classNode.getFullyQualifiedName()\n                                                      + "."\n                                                      + fieldAccessExpr.resolve().getName())\n                                          .collect(Collectors.toList());\n\n                                  methodReferencedFields.forEach(\n                                      field -> {\n                                        if (fieldReferenceToMethods.containsKey(field)) {\n                                          List<String> methods = fieldReferenceToMethods.get(field);\n                                          methods.add(qualifiedName);\n                                          fieldReferenceToMethods.put(field, methods);\n                                        }\n                                      });\n\n                                  List<MethodNode.CalledMethod> calledMethodList =\n                                      method\n                                          .findAll(MethodCallExpr.class)\n                                          .stream()\n                                          .map(MethodCallExpr::resolve)\n                                          .map(\n                                              resolved ->\n                                                  new MethodNode.CalledMethod(\n                                                      resolved.getQualifiedName(),\n                                                      resolved.getQualifiedSignature()))\n                                          .collect(Collectors.toList());\n\n                                  methodNode.setCalledInside(calledMethodList);\n\n                                  allMethodsCounter += 1;\n                                  if (method.isPublic() || method.isProtected()) {\n                                    methodNode.setAPI(true);\n                                    this.apiMethodCounter += 1;\n                                  }\n                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                    methodNode.setDeprecated(true);\n                                  methodNode.setStatic(method.isStatic());\n                                  methodNode.setProjectName(projectName);\n                                  methodNode.setShingles(shingles);\n                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                  methodNode.setSignature(method.getSignature().toString());\n                                  graph.addNamedVertex(methodNode);\n                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                }\n                              });\n\n                          // fields\n                          List<FieldDeclaration> fieldDeclarations =\n                              classOrInterfaceDeclaration.getFields();\n                          fieldDeclarations.forEach(\n                              field -> {\n                                int[] shingles =\n                                    this.shinglesUtil.computeMethodShingles(\n                                        field.getVariables().toString());\n                                String fullyQualifiedName =\n                                    classNode.getFullyQualifiedName()\n                                        + "."\n                                        + field.getVariables().toString();\n                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                fieldNode.setFieldReferenceToMethod(\n                                    fieldReferenceToMethods.get(fullyQualifiedName));\n                                fieldNode.setProjectName(this.projectName);\n                                fieldNode.setShingles(shingles);\n                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                fieldNode.setStatic(field.isStatic());\n                                fieldNode.setSignature(field.getCommonType().asString());\n                                fieldNode.setDeprecated(\n                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n                                graph.addNamedVertex(fieldNode);\n                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                              });\n                        }\n                      }\n                    });\n          }\n        });\n\n    //\t\tval packages = compilationUnits.stream()\n    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n    //\t\t\t.filter(Optional::isPresent)\n    //\t\t\t.collect(Collectors.toList());\n    ////        this.graph.addVertex(projectNode);\n    //\t\tthis.graph.addNamedVertex(projectNode);\n    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n  }\n\n  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n  //\t\tchildrenPackages.forEach(childrenPackage -> {\n  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n  //\t\t\tpackageNode.setProjectName(this.projectName);\n  ////            graph.addVertex(packageNode);\n  //\t\t\tgraph.addNamedVertex(packageNode);\n  ////            graph.addEdge(projectNode, packageNode);\n  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n  //\t\t\tthis.packageCounter += 1;\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n  //\t\tval classes = pckg.getClasses();\n  //\t\tclasses.forEach(clz -> {\n  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n  //\t\t\tclassNode.setProjectName(this.projectName);\n  //\t\t\tclassNode.setFlags(clz.getFlags());\n  ////            graph.addVertex(classNode);\n  ////            graph.addEdge(packageNode, classNode);\n  //\t\t\tgraph.addNamedVertex(classNode);\n  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n  //\t\t\tthis.browseClass(clz, classNode);\n  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n  //\t\t\tthis.allClassCounter += 1;\n  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n  //\t\t\t\tclassNode.setAPI(true);\n  //\t\t\t\tthis.apiClassCounter += 1;\n  //\t\t\t}\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n  //\t\tval methods = clz.getMethods();\n  //\t\tbrowseMethods(methods, classNode);\n  //\t\tval fields = clz.getFields();\n  //\t\tbrowseFields(fields, classNode);\n  //\t}\n  //\n  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n  //\t\tmethods.forEach(method -> {\n  //\t\t\tString statementBody = "";\n  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n  //\t\t\t\tstatementBody = method.getSource().trim();\n  //\t\t\t} else\n  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n  //\t\t\t\t+ method.getElementName();\n  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n  //\n  //\t\t\tallMethodsCounter += 1;\n  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n  //\t\t\t\tmethodNode.setAPI(true);\n  //\t\t\t\tthis.apiMethodCounter += 1;\n  //\t\t\t}\n  //\t\t\tif (method.getIsDeprecated())\n  //\t\t\t\tmethodNode.setDeprecated(true);\n  //\t\t\tmethodNode.setProjectName(projectName);\n  //\t\t\tmethodNode.setShingles(shingles);\n  //\t\t\tmethodNode.setFlags(method.getFlags());\n  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n  ////            graph.addVertex(methodNode);\n  ////            graph.addEdge(classNode, methodNode);\n  //\t\t\tgraph.addNamedVertex(methodNode);\n  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n  //\t\t});\n  //\t}\n  //\n  //\n  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n  //\t\tStringBuilder buffer = new StringBuilder();\n  //\n  //\t\tbuffer.append(\'(\');\n  //\n  //\t\tString[] types = method.getParameterTypes();\n  //\t\tfor (int i = 0; i < types.length; i++) {\n  //\t\t\tif (i > 0)\n  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n  //\t\t\tString typeSig = Signature.toString(types[i]);\n  //\t\t\tbuffer.append(typeSig);\n  //\t\t}\n  //\t\tbuffer.append(\')\');\n  //\n  //\t\treturn buffer.toString();\n  //\t}\n  //\n  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n  //\t\tfields.forEach(field -> {\n  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n  //\t\t\tfieldNode.setProjectName(this.projectName);\n  //\t\t\tfieldNode.setShingles(shingles);\n  //\t\t\tfieldNode.setFlags(field.getFlags());\n  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n  ////            graph.addVertex(fieldNode);\n  ////            graph.addEdge(classNode, fieldNode);\n  //\t\t\tgraph.addNamedVertex(fieldNode);\n  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n  //\t\t});\n  //\t}\n  //\n\n  /**\n   * This prunes away the javadoc comments\n   *\n   * @param source\n   * @return\n   */\n  private String statementBody(String source) {\n    int lastAtChar = source.lastIndexOf("@");\n    if (lastAtChar == -1) lastAtChar = 0;\n    int openingBracket = source.indexOf("{", lastAtChar);\n    int closingBracket = source.lastIndexOf("}");\n    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n    return source;\n  }\n}\n',
      "98bf2210121031f53e8caf7f8f89645f6b1dcc86":
        'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n *\n * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n * can make a useful tool.\n *\n * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n * checkers.\n *\n * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n * vector of a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are willing to\n * put up with.\n *\n * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.\n *\n * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n * a Bloom filter.\n *\n * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n * key. We run the key through our set of hash functions, and then check to see whether the bits at\n * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n * the filter. If all of the bits are on, we know the key is probably there.\n *\n * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n * bits we check will be on, unless the key actually exists in the filter. The relationship between\n * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n * will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:\n *\n * <p><code>c = ( 1 - e(-kn/m) )k</code>\n *\n * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n * in the filter, and m is the length of the filter in bits.\n *\n * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n * our limit. The following equation will give us vector length from the error rate and number of\n * keys:\n *\n * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n *\n * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n * combinations of error rate, filter size, and number of hash functions at <a\n * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n * -- the math</a>.\n *\n * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n * the case of JDK 1.4).\n *\n * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n * even in this Java implementation the speed is reasonable.\n *\n * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a\n * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.\n *\n * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n * <code>URL</code>.\n *\n * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n *\n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n * @author Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n  /** A buffer for the Rabin fingerprinting algorithm. */\n  private byte[] buffer;\n\n  /**\n   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n   * bit is the constant coefficient.\n   *\n   * <p>For example the integer 0x00000803, in binary, is:\n   *\n   * <p><code>00000000 00000000 00001000 00000011</code>\n   *\n   * <p>Therefore it correponds to the polynomial:\n   *\n   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n   */\n  private static int POLYNOMIAL = 0x000001C7;\n\n  /** Internal values for the Rabin fingerprinting algorithm. */\n  private static int[] table32, table40, table48, table54;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int P_DEGREE = 32;\n\n  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n  private static int READ_BUFFER_SIZE = 2048;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n  /** The bit vector for the Bloom Filter. */\n  private boolean keys[];\n\n  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n  private boolean useRabin = true;\n\n  /** The number of hash functions. */\n  private int numFunctions;\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n   * length for the bit vector (1000).\n   */\n  public BloomFilter() {\n    table32 = new int[256];\n    table40 = new int[256];\n    table48 = new int[256];\n    table54 = new int[256];\n    buffer = new byte[READ_BUFFER_SIZE];\n    // We want to have mods[i] == x^(P_DEGREE+i)\n    int[] mods = new int[P_DEGREE];\n    mods[0] = POLYNOMIAL;\n    for (int i = 1; i < P_DEGREE; i++) {\n      // x^i == x(x^(i-1)) (mod P)\n      mods[i] = mods[i - 1] << 1;\n      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n      // x^P_DEGREE term that \'fell off\' the top end.\n      // Since x^P_DEGREE == P (mod P), we should add P\n      // to account for this:\n      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n        mods[i] ^= POLYNOMIAL;\n      }\n    }\n    for (int i = 0; i < 256; i++) {\n      int c = i;\n      for (int j = 0; j < 8 && c != 0; j++) {\n        if ((c & 1) != 0) {\n          table32[i] ^= mods[j];\n          table40[i] ^= mods[j + 8];\n          table48[i] ^= mods[j + 16];\n          table54[i] ^= mods[j + 24];\n        }\n        c >>>= 1;\n      }\n    }\n    mods = null;\n    this.keys = new boolean[1000];\n    this.numFunctions = 10;\n    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs a Bloom Filter from a string representation.\n   *\n   * @see #toString()\n   */\n  public BloomFilter(String filter) {\n    this();\n    int index1 = filter.indexOf(":");\n    int index2 = filter.lastIndexOf(":");\n    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n    for (int i = index2 + 1; i < filter.length(); i++) {\n      if (filter.charAt(i) == \'1\') keys[i] = true;\n      else keys[i] = false;\n    }\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n   * error rate.\n   *\n   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n   */\n  public BloomFilter(int numKeys, double errorRate) {\n    this();\n    double lowest_m = Double.MAX_VALUE;\n    int best_k = 1;\n    for (int k = 1; k <= 100; k++) {\n      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n      if (m < lowest_m) {\n        lowest_m = m;\n        best_k = k;\n      }\n    }\n    this.keys = new boolean[numKeys];\n    this.numFunctions = best_k;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n   * length for the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   */\n  public BloomFilter(int numKeys) {\n    this(numKeys, 10);\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n   * the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   * @param numHashFunctions The number of hash functions.\n   */\n  public BloomFilter(int numKeys, int numHashFunctions) {\n    this();\n    this.keys = new boolean[numKeys];\n    this.numFunctions = numHashFunctions;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Internal method for producing the hash value for a given function number.\n   *\n   * @param fnum The number of the hash function.\n   * @param original The original value for the hash of the object.\n   * @see java.lang.Object#hashCode()\n   * @return Returns the hash code value for the given function number.\n   */\n  private int getHash(int fnum, int original) {\n    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n    int hash[] = {original};\n    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n    hash[0] = hash[0] % keys.length;\n    if (hash[0] < 0) hash[0] = -hash[0];\n    return hash[0];\n  }\n\n  /**\n   * Returns true if this Bloom Filter contains the specified key.\n   *\n   * @param obj The key whose presence in this Bloom Filter is to be tested.\n   * @return true if this Bloom Filter contains a mapping for the specified key.\n   */\n  public boolean hasKey(Object obj) {\n    boolean result = true;\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions && result; i++) {\n      result &= keys[getHash(i, hashCodeObject)];\n    }\n    return result;\n  }\n\n  /**\n   * Adds the specified key in this Bloom Filter.\n   *\n   * @param obj The key to be added to this Bloom Filter.\n   */\n  public void put(Object obj) {\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions; i++) {\n      keys[getHash(i, hashCodeObject)] = true;\n    }\n  }\n\n  /**\n   * Returns a string representation of this Bloom Filter. The string representation consists of an\n   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n   * the character ":".\n   *\n   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n   * returned.\n   *\n   * @return A string representation of this Bloom Filter.\n   */\n  public String toString() {\n    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n    for (int i = 0; i < keys.length; i++) {\n      if (keys[i]) aux.append("1");\n      else aux.append("0");\n    }\n    return aux.toString();\n  }\n\n  /**\n   * Returns a copy of this Bloom Filter instance.\n   *\n   * @see java.lang.Object#clone()\n   */\n  public Object clone() {\n    return new BloomFilter(this.toString());\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @return The Rabin hash value for the array of bytes.\n   */\n  public int hashRabin(byte[] arr) {\n    return hashRabin(arr, 0, arr.length, 0);\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @param offset Index of the first byte of the array to hash.\n   * @param length Number of bytes to hash.\n   * @param ws ??\n   * @return The Rabin hash value for the array of bytes.\n   */\n  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n    int w = ws;\n    int start = length % 4;\n    for (int s = offset; s < offset + start; s++) {\n      w = (w << 8) ^ (arr[s] & 0xFF);\n    }\n    for (int s = start + offset; s < length + offset; s += 4) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ (arr[s] << 24)\n              ^ ((arr[s + 1] & 0xFF) << 16)\n              ^ ((arr[s + 2] & 0xFF) << 8)\n              ^ (arr[s + 3] & 0xFF);\n    }\n    return w;\n  }\n\n  /**\n   * Return the Rabin hash value of an array of chars.\n   *\n   * @param arr An array of chars.\n   * @return The Rabin hash value for the array of chars.\n   */\n  public int hashRabin(char[] arr) {\n    int w = 0;\n    int start = 0;\n    if (arr.length % 2 == 1) {\n      w = arr[0] & 0xFFFF;\n      start = 1;\n    }\n    for (int s = start; s < arr.length; s += 2) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ ((arr[s] & 0xFFFF) << 16)\n              ^ (arr[s + 1] & 0xFFFF);\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a <code>File</code>.\n   *\n   * @param f A <code>File</code>.\n   * @return The Rabin hash value for the contents of the File.\n   * @throws FileNotFoundException If the file cannot be found.\n   * @throws IOException If an error occurs while reading the file.\n   */\n  public int hashRabin(File f) throws FileNotFoundException, IOException {\n    FileInputStream fis = new FileInputStream(f);\n    try {\n      return hashRabin(fis);\n    } finally {\n      fis.close();\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n   *\n   * @param is An InputStream.\n   * @return The Rabin hash value for the contents read from the InputStream.\n   * @throws IOException if an error occurs while reading from the InputStream.\n   */\n  public int hashRabin(InputStream is) throws IOException {\n    int hashValue = 0;\n    int bytesRead;\n    synchronized (buffer) {\n      while ((bytesRead = is.read(buffer)) > 0) {\n        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n      }\n    }\n    return hashValue;\n  }\n\n  /**\n   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n   * the hash methods, so it should be used when possible.\n   *\n   * @param arr An array of integers.\n   * @return int The Rabin hash value for the array of integers.\n   */\n  public int hashRabin(int[] arr) {\n    int w = 0;\n    for (int s = 0; s < arr.length; s++) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ arr[s];\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of a given Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If Object serialization fails.\n   */\n  public int hashRabin(Object obj) throws IOException {\n    return hashRabin((Serializable) obj);\n  }\n\n  /**\n   * Computes the Rabin hash value of a given serializable Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If serialization fails.\n   */\n  public int hashRabin(Serializable obj) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = null;\n    try {\n      oos = new ObjectOutputStream(baos);\n      oos.writeObject(obj);\n      return hashRabin(baos.toByteArray());\n    } finally {\n      oos.close();\n      baos.close();\n      oos = null;\n      baos = null;\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of a String.\n   *\n   * @param s A <code>String</code>.\n   * @return The Rabin hash value for the String.\n   */\n  public int hashRabin(String s) {\n    return hashRabin(s.toCharArray());\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n   *\n   * @param url The URL of the document to be hashed.\n   * @return The Rabin hash value for the document.\n   * @throws IOException If an error occurs while reading the document.\n   */\n  public int hashRabin(URL url) throws IOException {\n    InputStream is = url.openStream();\n    try {\n      return hashRabin(is);\n    } finally {\n      is.close();\n    }\n  }\n}\n',
      "3be706f1ea9ded9a332de32c31f99eedf4652de0":
        "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n  /** */\n  public DefaultStrategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base;\n  }\n}\n",
      "55e796c451fb63675bae1000f41dd15b720bbb42":
        "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n  /** */\n  public FactorOf2Strategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @Override\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base + (2 * loc);\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base + (2 * numMethods);\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base + (2 * numClasses);\n  }\n}\n",
      "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9":
        "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n  int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n  int upperBoundForClassShingles(int numMethods, int s_base);\n\n  int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n",
      "088d9845fab60669cca75fe6233c0e37d1280b6d":
        'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n',
      "66cc05cc40337a87d4835854e19c62d19d2c4067":
        "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public ClassNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.CLASS);\n  }\n}\n",
      "7774ec8b37feef6882a868e2660021a320eeaa54":
        'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n  @Getter @Setter private Node.Type label;\n\n  public Edge(Node.Type label) {\n    this.label = label;\n  }\n\n  @Override\n  public String toString() {\n    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n  }\n\n  @Override\n  public Node getSource() {\n    return (Node) super.getSource();\n  }\n\n  @Override\n  public Node getTarget() {\n    return (Node) super.getTarget();\n  }\n\n  public Node oppositeVertex(Node n) {\n    Node source = this.getSource();\n    Node target = this.getTarget();\n    return n.equals(source) ? target : source;\n  }\n}\n',
      "51d845ea135825c28660aac7c258adde05243914":
        "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n  @Getter @Setter private List<String> fieldReferenceToMethod;\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public FieldNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.FIELD);\n  }\n}\n",
      e2919264f5aa7154db6f0c0501950564a730a1e3:
        "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n  @AllArgsConstructor\n  public static class CalledMethod {\n    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n    @Getter @Setter private String fullyQualifiedNameWithSignature;\n  }\n\n  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public MethodNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.METHOD);\n  }\n}\n",
      "5c0ac895baf10b75181e22675a8b7840b08fb90d":
        "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n  public NamedDirectedMultigraph() {\n    super(Edge.class);\n  }\n\n  public NamedDirectedMultigraph(\n      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n    super(vertexSupplier, edgeSupplier, weighted);\n  }\n\n  public boolean addNamedVertex(Node v) {\n    if (!addVertex(v)) return false;\n    namedVertexMap.put(v.getFullyQualifiedName(), v);\n    return true;\n  }\n\n  public Node findNamedNode(String name) {\n    return namedVertexMap.get(name);\n  }\n\n  public boolean hasNamedNode(String name) {\n    return namedVertexMap.containsKey(name);\n  }\n}\n",
      "4397227e131372600696f0c613eaab9d7bf41229":
        'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n  public boolean hasCallGraph() {\n    return false;\n  }\n\n  public void setCreatedCallGraph() {}\n\n  public static enum Type {\n    PROJECT,\n    PACKAGE,\n    CLASS,\n    METHOD,\n    FIELD,\n    METHOD_CALL,\n    IMPORT,\n    CLASS_REFERENCE,\n    FIELD_REFERENCE\n  }\n\n  @Getter @Setter private String fullyQualifiedName;\n\n  @Setter @Getter private Node.Type type;\n\n  @Setter @Getter private int[] shingles;\n\n  @Setter @Getter private boolean hasCallGraph;\n\n  @Setter @Getter private String projectName;\n\n  @Setter @Getter private boolean isAPI = false;\n\n  @Setter @Getter private String signature;\n\n  @Setter @Getter private int flags;\n\n  @Setter @Getter private boolean deprecated = false;\n\n  @Setter @Getter private boolean isInterface = false;\n\n  @Getter @Setter private boolean isStatic = false;\n\n  /**\n   * @param fullyQualifiedName fullyQualifiedName\n   * @param type type\n   */\n  public Node(String fullyQualifiedName, Node.Type type) {\n    this.fullyQualifiedName = fullyQualifiedName;\n    this.type = type;\n  }\n\n  public String getSimpleName() {\n    int pos = fullyQualifiedName.lastIndexOf(".");\n    if (pos != -1) {\n      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n    }\n    return fullyQualifiedName;\n  }\n\n  @Override\n  public String toString() {\n    if (getSignature() != null)\n      return getType()\n          + "= "\n          + getFullyQualifiedName()\n          + getSignature().substring(getSignature().indexOf("("));\n    else return getType() + "= " + getFullyQualifiedName();\n  }\n}\n',
      "6f93400dab485c9315236a4fe01494f3d3b2aef8":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n  /**\n   * @param graph\n   * @param graph2\n   */\n  public ChangeMethodSignatureDetection(\n      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We need to go from the node to the AST and get the actual method. Then we will call\n   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n   * checked, since we do not want to detect polymorphism as change method signature.\n   */\n  public double computeLikeliness(Node original, Node version) {\n    // Need to find out if in V2 there is a node with the same signature\n    // as the original\n    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n    else {\n      // This is when we have a method overload or deprecated. So when\n      // we can check deprecated methods we need to add it here\n      return analyzeIncomingEdges(original, version);\n    }\n  }\n\n  /** This will handle the same name condition, explained above. */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n      if (hasSameNameAndSignature) continue;\n\n      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n        prunedCandidates.add(pair);\n    }\n    return prunedCandidates;\n  }\n\n  private boolean hasTheSameSignatureAndName(Node[] pair) {\n    // TODO here we have to take into account the RenamigsDictionary\n    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n    boolean hasSameNameAndSignature = false;\n\n    if (n2ParentInV1 != null) {\n      // Calling the overloaded method\n      List<Edge> allMethodEdges =\n          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n      for (Edge methodEdge : allMethodEdges) {\n        Node targetMethod = methodEdge.getTarget();\n        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n            && targetMethod.getSignature().equals(pair[1].getSignature()))\n          hasSameNameAndSignature = true;\n      }\n    }\n    return hasSameNameAndSignature;\n  }\n\n  private boolean isDeprecatedOrRemoved(Node[] pair) {\n    Node source = pair[0];\n    String parentOfOriginal = extractFullyQualifiedParentName(source);\n    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n    boolean isDeprecated = false;\n    boolean isRemoved = true;\n    if (parentOfOriginalInV2 != null) {\n      List<Edge> methodEdges =\n          filterNamedEdges(\n              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n      for (Edge edge : methodEdges) {\n        Node methodNode = edge.getTarget();\n        if (methodNode.getSimpleName().equals(source.getSimpleName())\n            && methodNode.getSignature().equals(source.getSignature())) {\n          isRemoved = false;\n          isDeprecated = methodNode.isDeprecated();\n        }\n      }\n    }\n\n    return isDeprecated || isRemoved;\n  }\n\n  @Override\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n    List<Node[]> goodResults = new ArrayList<Node[]>();\n\n    for (Node[] pair : listWithFP) {\n      String signatureN1 = pair[0].getSignature();\n      String signatureN2 = pair[1].getSignature();\n      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n    }\n    return goodResults;\n  }\n\n  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n    // TODO filters out (IPluginDescriptor) with\n    // (org.eclipse.core.runtime.IPluginDescriptor)\n    // right now this is checked only for case when there is a one argument\n    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n    return simpleName1.equals(simpleName2);\n  }\n\n  private String extractSimpleName(String fqn) {\n    int lastIndex = fqn.lastIndexOf(".");\n    if (lastIndex < 0) return fqn;\n    else return fqn.substring(lastIndex + 1);\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      "9e492fa56e3b1f654735d03da1b18778ea4a3c5e":
        "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    List<String> callers;\n    if (this instanceof ChangeMethodSignatureDetection)\n      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n    for (String s : callers) {\n      Node callerNode = graph.findNamedNode(s);\n      if (callerNode != null) {\n        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n      }\n    }\n    node.setCreatedCallGraph();\n  }\n\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n",
      "76a947129555279bb0423f831c949f1899b2074a":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n  private Node targetClassInVerGraph;\n\n  private Node targetClassInOrigGraph;\n\n  private RefactoringCrawler crawler;\n\n  /**\n   * Checks for MoveMethod\n   *\n   * <p>1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   *\n   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n   */\n  public MoveMethodDetection(\n      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n    this.crawler = crawler;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    double edgeGrade = 0.0;\n\n    double referenceGrade = 0.0;\n\n    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n    // FIXME: Potential problem when we subtract 0.01 from reference grade\n    referenceGrade = referencesRemoved(original, version);\n    edgeGrade = analyzeIncomingEdges(original, version);\n    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n  }\n\n  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n    String sourceInOriginal = extractFullyQualifiedParentName(original);\n    String targetInVersion = extractFullyQualifiedParentName(version);\n    // treat case 1\n    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n  }\n\n  /**\n   * 1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   */\n  private double referencesRemoved(Node original, Node version) {\n    String targetInVersion = extractFullyQualifiedParentName(version);\n\n    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n    // treat case 2\n    if (targetClassInOrigGraph == null) {\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      Enumeration<String> keys = dictionary.keys();\n      for (; keys.hasMoreElements(); ) {\n        String aKey = keys.nextElement();\n        String aValue = dictionary.get(aKey);\n        if (targetInVersion.equals(aValue)) {\n          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n        }\n      }\n\n      // treat case 3\n      if (targetClassInOrigGraph == null) return 1.0;\n    }\n\n    // treat case 2 and 4\n    if (!targetClassInVerGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInVerGraph, graph2);\n      targetClassInVerGraph.setCreatedCallGraph();\n    }\n    if (!targetClassInOrigGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n      targetClassInOrigGraph.setCreatedCallGraph();\n    }\n\n    List<Edge> originalClassReferences =\n        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n    List<Edge> versionClassReferences =\n        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n    if (originalClassReferences.size() == 0) {\n      if (original.isStatic()) return 1.0;\n      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n      if (versionClassReferences.size() == 0) return 1.0;\n      return 0.0;\n    } else\n      return Math.abs(\n          ((originalClassReferences.size() - versionClassReferences.size())\n              / originalClassReferences.size()));\n  }\n\n  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n    List<Node> fields = new ArrayList<Node>();\n    for (Edge value : edges) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        fields.add((Node) value.getTarget());\n      }\n    }\n\n    return fields.contains(theTargetClassInOrigGraph);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n\n      // Prune toString since the SearchEngine finds all the toString()\n      // methods, even those that are called from different classes\n      if ("toString".equals(original.getSimpleName())) continue;\n\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n    return withoutFP;\n  }\n\n  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n    boolean needsOneMorePass = false;\n    List<Node[]> addToPUM = new ArrayList<>();\n    List<Node[]> addToPDM = new ArrayList<>();\n    for (Node[] pair : withoutFP) {\n      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n      if (sourceClass != null && destinationClass != null) {\n        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n      }\n    }\n\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n    RefactoringCategory pulledUpCategory = null;\n    RefactoringCategory pushedDownCategory = null;\n    // TODO this only checks whether we already have such a category\n    // created. It might be\n    // that such a category has not been created previously (because no\n    // results were found\n    // for that category. In this case, will need to create a brand new\n    // Category object.\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n    }\n\n    for (Node[] pair : addToPDM) {\n      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n\n    for (Node[] pair : addToPUM) {\n      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n    else return withoutFP;\n  }\n\n  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    List<Node[]> pairsToRemove = new ArrayList<>();\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")\n          || category.getName().equals("PushedDownMethods")) {\n        for (Node[] pair : category.getRefactoringPairs()) {\n          for (Node[] prunedPair : prunedList) {\n            // The OR below takes care about n->1 and 1->n\n            // overlappings\n            // between PullUp/PushDown and MoveMethod\n            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n          }\n        }\n      }\n    }\n    for (Node[] pair : pairsToRemove) {\n      prunedList.remove(pair);\n    }\n    return prunedList;\n  }\n}\n',
      "2c24f295bf40887025a35ce694a69c056b81a7a3":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We should now check for the same method being in the parent class, thus for the two nodes,\n   * check if the version now resides in the superclass of the original method\'s parent class.\n   */\n  // TODO: Check why we get a null pointer exception with parentclassver and\n  // parent class orig)\n  public double computeLikeliness(Node original, Node version) {\n    double incomingEdgesGrade = 0.0;\n    boolean isSuperclass = false;\n    // TODO: Think about possible different cases that this might be\n    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n    // find it.\n    // TODO: Think about the NULL case. Return 0.0 if you find null,\n    // since clearly they are not "like" each other.\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassOrig is a subclass of\n    // parentClassVer\n    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n    if (isSuperclass) {\n      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n      return incomingEdgesGrade;\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      "296bce275d7968716d7f0bed80da373e18210114":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    boolean superClassGrade = false;\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassVer is a subclass of\n    // parentClassOrig\n    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n      System.out.println("stop");\n    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n    if (superClassGrade) {\n      return (analyzeIncomingEdges(original, version));\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      ad4c2988b4aa75b00ee844d54a74c441abebf9d0:
        "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n",
      "67bf6cf86456904a46c7d568fe0527ed920c971f":
        "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n  @Override\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n    for (String result : results) {\n      //\t\t\t\tIMember resultNode = (IMember) result;\n      //\t\t\t\tString callingNode = null;\n      //\t\t\t\tif (resultNode instanceof IMethod) {\n      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n      // ASTNodes\n      //\t\t\t\t\t\t.getParent(initializer,\n      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n      //\t\t\t\t}\n\n      Node callerNode = graph.findNamedNode(result);\n      if (callerNode != null)\n        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n    }\n  }\n\n  public void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createFieldReferenceGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createFieldReferenceGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n",
      "184ff327f5f763cae4d3307e3cf0ae9b0391eb70":
        "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n  /*\n   * We already have Class - Field edges. So we need to make sure that they\n   * are different parents, and also make sure that their call graph is still\n   * the same.\n   */\n\n  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    return analyzeIncomingEdges(original, version);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedFields) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n}\n",
      "072aa07a114622cd395391b740b9a1e46b64fb70":
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * We need to find all the places that the original and version classes are instantiated. We will\n   * incorporate this into the likeliness grade.\n   */\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    createClassReferenceGraph(node, graph);\n    node.setCreatedCallGraph();\n  }\n\n  /**\n   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n   * parameter.\n   */\n  public static boolean isSuperClassOf(Node node1, Node node2) {\n    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n    for (String superClass : superClasses) {\n      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n    }\n    return false;\n  }\n}\n",
      e753da375cfabc5fb57d8d5440f95671d7bf42f9:
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n    for (Node[] pair : prePrunedClasses) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n      String parentPackageVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesInDifferentPackages.add(pair);\n      }\n    }\n    return candidatesInDifferentPackages;\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n",
      f069e44153341cbf9da6818393293f5e7e9ac108:
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n",
      "6ba49588fd9f84df7d87869b64cfedcf10d88ed0":
        'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n',
      d81bb74b671cc12037d7efe46ea3c7faacae2b31:
        "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n",
      "4eb81739758717c8ca09b89db317ccc7d09c6c46":
        'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n',
      "5c2d1cf016b3885f6930543d57b744ea8c220a1a":
        'PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MFMLK-.\rK-*R03-IM+I,\u0001\n\u0086d\u0096Z)\u0017%*\u0084\u0017%\u0016\u0014\u0016rr\u0001\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/gradle/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000org/gradle/wrapper/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000f\u0003\u0005\u0000\u0000\t\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.class\u008dV[W\u0013W\u0014\u008e\u0099d`\u001c\u0005c@\u0083\u008a\u00837\u0012.\u0089VJ \u0001-\u0001lD\u000e!\u008cNfK\u0017{\u0007O]}\t\u008b\u008b>i\u0099@\u0012\u0082,\u00993}g?\u0005p\n?(\u0088\u0082\u0082\u0001LxKE\u00052(\u0098UL+\b!`\u0006b\u0081Bv\u0007dde\u008c(\u008c\u0005\u0005g(N\u008e\u008c\\\u0007n\nwKb%\u0096\u001dxW{x_\u0086\u0081e+8\u0084\u0082\f\u00109gX\u0086;\u0010J$\u0017\u0019I@\u008caji\u0099;I\u0092h\u0018.\u0094U\u0090N1]t\u0082\u001d\\N\u0082m\u0015\u0097^ftrg\u009c!\\\u0011[\u0086c\u0089\u001d\u009e\u009e6u\u0098\u008ea\u0015}\u0089a/\u0019&\u001f\u009d"EF\u0099AC^K\u0094fc\u0086NPyr\u0003w+\u0095\u008c\u00ad\u00178\t\u0085\\H\u0018\u0097(kO!\'\u0012\fwW\u0002C_\u0083\u0082WL\u009ew\u0019i6\u0013\u001c\u0090\u0017ku{nh\u0082w\u0011W3zS\u0093B.>kVEF\u0091bX\u0085\u008c^\'Zk%CZ1\u0084Ur\u0096N\u009e\u000b9QJ)a\b\u008e8\u0087\u0019m\u0013\u0083x\u001d\u0019wU\u0098(T(@,GpQUq\u000f)e\u0099\u0094_\u0094Y\u0092\u008b\\T<C[L\u0088[R!>b\u0014_[C\u0018\u009fP\u0002\u0093]\u0082G\u0015\u009fh\u0090o\u009d\u0016yX\u0016}s|K|EhF\u0083FSC\u0088\u0012\u0091\u008a\r{3\\r\u008d\u0012(\u0010Ij\u00164v5\u0093*r]\u009a\u000fL\u000b|jWi\u0086\u0015\u0088\u000b\u0006X\n\u000f`JN=]\fCA\u009bG\rv-6J\u0017\u0088DzL\u008d7\u0017{\u0099\u0099!\u009e\u0096r\u0005\u0012+r7RE\f<Zx\u0098u\u0087[43\u0092\b"mc%\u0006GCk:\\\'\nv\u008ep\u0014\u009aR\u0091|\u0085\u0093mE_\u0005:Ma\u0005`\u001dZP\u009e7,mIhD\f\u009e}\u0097l/^4\u008b\u0092[ET1\fG[\u0006J\u001bD\u001ejj\\q.d"\u0099dB8\u008b\u0004n\u0095\u0091MIw\u008a\u0090\u009ev<$+CJ-@\u0090\u0006F\u0017\u0093<@f\u0017\u0002\u0013#\u0090c\u0096\'gxh\rWqZ#\u009ep?N\n\u0018D\u0082\u009e\u00ad\u0018"-2f\u0003\'\u0093\u008c\u000f\u008da\u0013\u0084r\u001f\u0090r\u001a5D\u0090kXC\u0098\u000e%.3.E\u001av\u008d\u0085n\u0085\u001a\u008cE\u0011F\u0082h.4L{o\u0010{,~C\u000f\u0083HN\u0092;\u0081NZ(\u0001q\u0010?\u008d~\\a,@mZ\u0013\u0091\u0015?zb7\u008c\u0011\u000f\u0010(R\u0004$B\u001b\u000b\u0091\u0005\u009cK\u00144\u00ad2\u0081\u0016>O\u0015:S?{\u0095^#I?s\n&\u0018\u0090-\u000f\u0092\u000b0e0N\u0091\u009bSgg*B\'\rG\u00ada\u007f\r\u0099\u0091\u00133R\u008ftG\u001c\u001e\u0091N\t\u0092j\u008b\u001ecD_\u001eI<\\?j\u001d\u0087\u0095VK\t\u00924\u0002=JO\f\u0016th\u001b\u0013\u0004XhMo\u00103<P\u0011z\u0086\u0098\u008c7\u0018;/5:\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQ}\u0000\u0000\u0000\u0000\u0000\u0000#\u0000\u0000\u0000org/gradle/wrapper/Download$1.class}\u008cM\n0\u0010\u0085h5*v/\u0082\u000b\u0006\u0082?B\\x\u0082\u0086\u0012\u0092\u0092T{7\u0017\u001eC\u0089)\u0019\r\u000f^\u0013\u001aC\u00060 $g{s\u0099\u0017Z\u0012[\u0018mE,]\u0010&;\u0093i\u000b\u008e\u009c!!S\\9\u0091k\u001b\'J:-V\u0084\u00186Zx/=!m\u0016F\u0094YM\u0098iH t\u009dnX\u0004\u0017\u0017~\u0084~8\\\u0012\u0018j\u00814\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.class\u0095S]O\u0013A\u0014=-l]XWmEC@v\u008b_\u0098\u0090\u001a\u0012\u0093jHP\u0012N5N3\u009dZ\u008fLD_\u0084h\u000fG\u0019\u0094\u0082\r4Eags=wn?\u0001c\u0007\u0013\u0098ub\\\n\u000enb!\u0085\u0014\u0096\u0096\u0083ev\u0090\u0080oc\u001d\u0086ga\u001c\f\t?\u0090,\u009a`X\tc#\u001b\u0013Q*\u008f\n\u001fLF\u0086\u0092{n\u0088X\u0087Ubp_P\u0088Z\u00820\u008aTx-\u0012AGfS\u0085\u0091\u0002%\u0086\u001bDHU\u001b\u00852fX\u0095\u0003\u000fb\u0083\u0092\u008d\f\u000b%Wd\u0098;\u0007l\u008a\u009e>N\u0015\u008c\u000f\u0017iL\u00929\u009e\u0018&\u001bZ7\u000bM\u0096P6( K\u009b82$\u008b6V]\u009a\u0003S\u008dG\f\u0085L\u0086\u0089S\u0089\u0099\u0091M3dz\u0088`b\u0097aEIB._\u0019\u0080h\u0015Rl\u0088\u0010?R3cdBr\u008358\u0099H2CnH\u0089\u0099\u008861O\u0085\u0012 A/\u0080N\u0001\u00ad4\u0003\u008c\u00ad\u001cJ\u001b\u000b\u0019\u008f\u0082\u001fq\tf>=\u0000<\\5\u0089,r}+\u008a\u009a\\\u0007\u0012!q>D\u001b.\u001cr"\u0011\r\'OtL\u0012\u0003#i\u00021\u0097~J\u0086\u001e\u0001:{\u001b=\fJ[z\u001e\u0097\u009a\u0081eR\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005<\u009b\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000org/gradle/wrapper/Download.class\u009dY\t|\\Y\u007fNXi;\u008e\u001d\u0089\u0013Kd\u0092\u0095v<IO][JJCJ\r%\u00844@@)\u008d&\u0004@\u0081rS(PP\u0016hZ?\u0087v\u00adH_4o\u009bo3^\f\u0080\u009d \u0082g\u009aT\r59\u0013\u0019o\r|>\u0088 ~\'\u0088\u0005\f~_5\u007fxP5\u007f\u0014\u000e\u0081/\u0018\u0093 \u0096O\u0083\b\u0082x\u001e_T_R\u009f\u009b\u008b \u008fT_\u0019u\u0010o\u0082[|E5\u007fWEi\u007fo\u001f\u0082G\u0093\u0081\u007f6z\u0010\u009b/~\u007f\u0080\u0089\u0006j;#\u0088g\u009f&KQ[5E\u009a\u0081+}G5\u009aS7T\u0086j\u009ao)\u009dn\u009aBEL0\u0010_\u0010YSJ\u0080,b\u009eI7IU\u0010]\u00124:\u0088kb\u0099RcH\u00ad"\u0099Ro2\u0003O\u0018\u0012\nrYaJ*CV\u001b\u0094)k\rYg \u0086d\u0083)\u001bME\u001b&\u0094[M\u0094l1vS\u009a6fH!M\u0002+\u0091p\u009dJ9)AM^\u009e9\u0090&\u009d\u0084\u0017\u001b+\u001b9{hWo\u000f\u0017\u009d\u0098h\u008bzn,1OP\u0099L<;\rcJHh\\Qn"\u0090JkAu\u0087EN\u001f\u0004\u001aH\n\u0093\u0013\u0013\u000e\u00adN\u0013m\u0013=\u0016w.uI\u008a18\u001c\u0097!M\u0092\tA\u009b\u009cp\u009dT;\u0096\u009c\u0084>\u0007\u0093\u0097\u0012=\u0080\u009d;\u0007\u008e%b~AG\u0012\u001a,6}1e\u0090\u0099\u001c\u0092u\u0084\u0093\u009e\u001aq\u0001{$(%G\u00908Gy\u00931\u007fR*S\u0092\u009a}7Y3\u008f&\u0013\u0089,L\r\u0006T\u0013\u000b\'\u009c5XN\u0096\u0086\tk\u001bI\u0089%\u000e\u008e\u0096`ccJ5K)+dIyDNVmZ&\u009a\u0084\t;Nn|\\V\u009bN9\u0081\t\'\u0097\fHz|\\eL\u0099\u000e\u0093HO;J\u001aNoyNb\u009bd,9\u0099L+!c"\u007f\u000eW\u008a)\u0011H8JU*P\u0099L{\u0082U\u0005szt\u001d{\u008a\u00151._Y\u0098JO\u001abH!m\u0086l7d\u0087!;o\u001ew\u0006\u0098`\u0002_o[O:$f\u001d\u0094M\u009fwxn+\u001bF\u0005G\u000bc\u0086\\9+1\u009e$\u008c)gC\u0089Q]\u00017\u0094r\u0000R?xE\t\u009bL\u0097k\u008b\\g<Nim9[\u008ef\u001a[\nO#HE]u\u000fn<V\u0016q\u0015\u0012)\u00881#\u0015\u001a2\u0004K\u008cE=\u009a\u008e\u009e3X\u00ad\u0003Rj\\B#\u009a9M/%]Z\u0013*Ng`EC\u001d\u0082\u008a6$\u0014ZWg\u00079X\\6?U\u0005\u0092,\u0080V%S\u0003(\u0093<\u0018MQG\u0095\u0018s;\u009f\u00adj\u001f\u000b\u0097j\u001e"ey\u000bi\\%\u000b\u008fI\u009bn\u009dV`47NKv#\u0082%is\u0087rd\u008f!wYW-\'w[r\u008f.Og,W#@C\u00173V\\M,b(\u009eR\u001fPM\u0087%\u009dr\u0087a\u000b/a\u008e.P\u008ah\u009f[rH\u000e[rD\u008e\\Z\u0000K\u0098%\u0090\u0013\u0096H%}J\'$c\u0012Sp=g\u0090~K2 X^B\t-#\u0097ThaR\u0096T\u000fZ2$\fy\u008b%r\u00923rV\u0000K\u0097\u0001K\u001ePa\u008a\u0013\u0092s\u0098AJ\u0011\u001bU\u0018\u001bX`VWKY2.\u0013\u0082+\u000et\u001c\u0089\f\u0098h\u0091\u0003\u0003}\u0011\u008d\u001a\u0091R\u0088$/:nNP\u00943"2\u008f\f\u0011/\u0019#s\u0084\u008b"G\u0003#c<\u0088HZF\u000e1C-KXQ\u0091tA`\u0095Y%9\u0090Z\u0006:@V=\u009dI\u000b?\u008f\u008fX\u0012SV\u009e\u0097\u000b\u0096\u0085PRlC\u0094%\ta\u0006\u0087@-\u0099\u0096\u0087rTvsaEm\u0016|\u0006\u0092Y\u0085rr\u008a!\u0010\u0092\u0094\u008a\u0083\u0003\u0087[\u0098iX\u0097_\f.\t"\u008azTu$\u0096\u0018k=h{73\u0010\u0094}}\u001a-\u009b\u0006^V\u000e\u001e\u009b\f\u0011t~~\u001eZ)h]&0\u00987DcH"ER$u\u0018\u008b\u00906C\u0088\u001c\u001b:\u0012\u0091,[2\u00ad\u0092Q\u0003\u0094\u0097=\u0015\u0096*@z1\u0007kVn\u0094\u0083pj\u009eb$S\u00adY\u0014\rWB5\u00ad\u0092j\u0092\u008a4lIm+Z<B,)S]\u0007\u000bw\u0099\rK!\u000eV|\u0086\u0088]\u008c\u008fbLH\u0014\u0017\u0017swI\u0082\fLKK\u008a\u008f$<rQW\u0096=Jo\u0086wCJf)\u0010\u008fi\u009d7%W\u0081y{\u0016\u001d\u0082);\u008c8\u0013\u007f]qXQbm\u0097\u0087\u0085/0ua,4\u000bKj\u007f\u00148x\u001a\u0016_4\ro\\j\u0096&\u008a\u0003v\u009e%\u0017\u0010\u00adw\u001eJv:\u00ade9$\u008bL-eD\u009dP[\u00863\u001djX_\u0092\u0012kU\u008fK/\u000fYzR]\u0087LOIA\u0093e\u0094!\u0087]\u0094s\u0085T\u0004En/^9iQSra:US\u009b\u00adC\'\u0010)^:E\u0011\u0089\te\u0005c\u0094Knc\u0002\u001amW\u0097TiJh<\u0099R&$::(1?\u009aLy^\u001fA0ULN\u001d\u0085\u000e\u0094M\\YL\u0096)\u001b\u0002\u001dO-\bUzMsG\u00adz\u0085NQEt[l\u0097Nx1[2MH(\u0095\u0017b\u0092\u007f\bWf\u0099Ek\u008awYX\u009dXb\u0002C\u008c\u001f\u0094qm\u0088rX\u008c~rYUB\u000em\\:G\n\u009f}7t.\u0015+\u0095}\u0092x\u009d\u0005&\u0094T\u0019\u0013r\\\u0084\u0081\u0081\u00810b8\u0005\u0000\u0015\u0088c-\u0090(\u008c\u0093\u001cO\u0017\u008d\u001fBH\u001e\u000f\u0007\u0084s_>#\r\u00922f> [$-\u0090\u00176\u008fh\n\u009b`V\u0095,#\u000fo?UiA{JT\u0085)a\u0095Z9\u0011\u008c!pc,*\u001a\u009b\u001a|\u008da5\u001b\u009b!\tc^F\u001a\rl-vb+V\u0081\u008e\u0086\rB+cA\u0097\u008d\u0005]6j3+t\u009eG*\u001fQ9\u00adz\u0096\u008a\u0090y\u001dU7P;\u0087:,KVo\u000fZ\u001cl+.\'\u009aW\u0096\u0093\u0003x\u0007EdZ\u00175gP\u0093AY\u0098\u000e\u008b;\u0091\u0092\u0082Mu\u0082\u001fC\u008b?\u008f\u0094(\u000b\u0084\u0080\u0086\u000fv\u007fug=0\u0087\u001c\u0096\u000fS\u008aY\t\u00072Xkl\nf\u009a._n\u0084}p`m\u0097v\u0006|l7h`\u009e=5a\u007f`\u008a1u\u001dd\u0010y\n+?\u0086M[3m\u000e\u009b\u0087C[fqjVV]U+u=\u0013\fm\u0094&:{I\t@H}\u009aV\u0006$\u009a\u0002h\t\u009b\u0095+2h~\u009a\u0096\fZ\u001b0\fZn\u0091\u0094/\u0086\u009a\u000fNuu|U\u007f!}/\n}\u0087\u0004\u0097\u008c\u0003\u0089\u000et=\u0088.\u001cF\u001f\u008eG1\u0018\u008e\u008e3\u009d\u0099=\fK/\u009e 8\u0089\u000f\u001f\u001f%1\u0080Wq\u008aO\u000b8\u0083/,\u008c\u0007\u0015\u009c\u0016uY\u0011< ~\u009c\u0093*baD\u008fR\u009bZ\u0082wG\u0018\u009dx\u0016\u008f3q\rJ\'\u0098.\u000f\u007f\u008c\u007fU\u009468{A|\u0004?\u0081\u009fD5u\u008cWCk^OV\u009fJ\u008c|J\u0097K))U!x\u0012C\u008b\u0089h\u0093_\'\u008dk\f73\u0006\u009e5~\u0003\u0019x@\u0081\u0013\u0010\u001fd\u008d.%\u009a\u001bIM\u0003\u008b\u0019\tQ7iM\f\u0014]\f|&\u000b~L\u001f\u0019=e-*\u001cS\u0091*Ms1\u0098Nas\u0007vN\u009eYuP\u0001B\u0011\u000el">H\u000f9\u0011\u0098\u0083\u008dM\u001a|/\u0086\u009b(+\u0083}OI|7\u00939t\u001c\u000f}\u0019\u001ch$\u0014w\u009bA\'s\u001e\u008f\u0098\u001etCtd\n\u0089s\u0011=y\u009c_\u0091\u0005\u001c\u008f\u0017\u0018`:\tw46]cv\u001bf\u008cV\u0014\u008cL&P)q\n\rpq`\u0006\u0087N4\u0087\u000egp$tXOs\u001aw8\u001e\f\u009d\u0088\u0092k\u0011d\u000f~N\fW6\u008528I\u0086W\u007f\u0095+\u0007\u0095a\u009f\u0094nah8tJ\u0001[^\u008a&\u008b$\u0083OK\u001f7Fz\u0006d\u008aa\u0092\u0093,~\u0016$KQ\u0016c,$\u001ar\u0002\u00921j\u001f\u001b\u0092KeFp\u0092>\u001ecE\t\u0012\u001fcOa\u0005_?+\b\u007f\u001c\u009f\u008eMI\u0095:7Y\nTJGo\\\u0015H$h*\u0097d0\u009b;\u009eH\u0005sGh\u0098\u0087\u0089i=7p\u000b\u0091n]._x\u001coLK6_2^-d*}R\u0097\u0001|\u0092\u008fe\u0014a\u0099LQ~\u0087e^au}[\u0004\u0092O\u00162\u001aM4k}9\u0012rz~\u0091BTb\u001f\u009f\u001av\u0087\u001e\u009eS\u0086\u001ed\u000b\u000f\u008dO 4Zo\u00003}a\u001f?0$:\u001c\bg\u0084\u0003a):\\\u001fhfcDcl\nU<\u0000\u0095!\u0096t\u0098GX}[Y}Y\u0085r\u0005\b\u009f\u0091\u0018\u0088OkB\u0004\u0080h\u0084\u0097\r!*z\u0085=?\u008d_a/@W_\u0084FU`\\_M\u0013EN"mPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L\u0000\u0000\u0000\u0000\u0000\u00001\u0000\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classu\u008d\n\u0082@\u0014E+j\u0015DE@\u0096E\u0090\bERI\u001f\u0088#3c[\u008b>\u008f\u008a4v\u0017\u00879\u009c\u0004\u0083O\u0098.r%J[\u0099M\u0016\t\u0084,]\u008a\u0082\u00ad8\u009fk\u009f_\bPU:]\u009a3aG\u00ad\u0012\u0004\\^&at"\u0012-\u009cE\u00adeY\u0016\u0014\u009b\u009b8\\3\u008eK t\u008e\u001cB\u0017Nk\u0081\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.class\u0095Ws\u001bW\u0019\u001dYu|iVMNZ*;\u0095\u0006J\u008alB\u001cNK\u009c\u008e[\u0097\u0090t-\u009d\u001bvj\u0015S\u009aB[(P`x\u000f\f3L$x\u00860\u001b\f\u007f\u0001\u008f}\u0085\u0019\u00180+9%L=sO\u001f\u0000\u001ct<\u008agZYjxNG\u0014_pNG\u001c\u0097\u0086\u000bx^mME\u009cSKA-EH\r\u0017\u009b1\u000b::`vIb3l\u001dI\u009eDIG\u001e\u008equ\u0094fxJ_\u0019~\u0002Oc\u0014\u0097u,J\f\u0004\u0096\u0015\r_5\u0081\u000b#\u000bSgGF\nt\u008e_2/\u009bYtSg9\u0002\u00adCSM\u009f1\u0014h\u00ad\u0092tDE@\u0005v\u0094];.\u009b"\u0007,\u008f\t2|\u008c@t-RmrjiNz\u009c-\u0095=`3gs\u009d\u0018\u0017,j\u008e|v3\u008b.yf,\u0095\u0082]\u00adX\u0097\u0088eBAV*\u0013cK\u008f\u008e\u0080 0\u0098\t\u000fOU\u0005)T=O:~vme{]\u0093s\u0097dW\u0095-3Qd\u0085E\u0081!C\u0085\u0005q]\t\f0\u008aE\u0095(;&f\u0017*2B5\u008f?\u0002^}\u0099\\jL\u0096C\u0087l\u009dtGuZ5["\u0018\n\u000fMn,rQ\u0096\u0087t1\u0095\u0084),,N\u0098@L5|C75|K@gd\u0088\'h\u009awLQtnk\u0011\u008e}2\u0086\u000ets\u0013\u009f&J\',VXjt\u008a\u001d%syN\u000enE>]o3\u0095;6\u0082\u008b\u0010\u0010lKq\u0014o\u001b\u001eF3VB\u008e>%l\u000fW\r\u001c!\u00038$`\u000f\u000b\u0003\u009bD\u008b3"\u0019x\t\u0011D]A\u0085E\u0003U\n\u0081W\u0081x\u0095cLQ\u00adV$\u0081Cn.\u001dO\u0017<i2]6U\u0006\u0018\u0017]/\u00ad \u009aHi\u0003\u0085\u0086~``\u0012\u0005\u001e\u001b,\u0005"\u0092\u0081\u001fG\u0006~\u008c\u009f\u0018x\u001ag4n\r)\u0090\u0098\u000egL\u0098V\u0081\u0094 M\u000f\n\u000b\u0098^2-\u009f\tL\\:l\u0006\u009e(3e:j\u0081qZ/\f\u0012WY;A\u008b}3\u0002\u0005\u0013r\u008dS#\u000e\u008c\r^L/xR\u0092X\u009d\t\u0011|:u\u0098Li\u0091\u0094YLv\u0083;\u0014\u0089\u0099\u00ad\u0012u!I=A\u0011\u008d\u0097\u0016\u0089\u0088\u009e\u000bfUyLX\u0095uc\u008d\u000e\u000fU\\ pv\u008eQ\u009fN\u001cv5|o9Lrt\u0086K\u0093\u0089Ul)\u0095;\u0093Wv\u009c\u008f74O\r\u0086\u0096+,1\u008e\n\u001cF[F\n\bf\u000e>#\u0080&\u0090A7\u0004zx\u008a \u0081N5@T3\u0084(\u0090z\u0098Y4\u0017}\r\u0088\u009e]\u001f \u00034\u0017\b?\u0016\u0088Evq\u008f\u0016\u001c\u000e<\u008f\u0016 \u001d\u008aL\u0010\u0098\u0011N\u0019\u008ap8>K.\u009a\u0089\u00191\u0002\u0089\u0015Dg\u000f\u0010[A|\u00064n\u009bkhLp\u0081SES\u001av\\c\u0016\u0012~\u001d]+\u0098\u00advvR\u00885dw\u0016\u0098\u0019=#r<\u0089\\K\u008f\u0018T8\u0082lo\u00037`.\u0096\u008a\u0090S\u001a\u001e\n\u0018W\u009a\u008aT\u008c\u000bU4]\u0089~T7\u00876\u0095\u0089\u001av\u00067\u000eBZ H\n\u0014@\'\u001dc \u009bKl\u0093\u009d31\u001a\u0099c\u001c\u0089\u000eDQDDwp>\u009ePz\u0013\u008fp}\u0094\u0004@8B \u001cgm*&\u000b_$W\u0099\n\u0002+\u001ak\u0006\u008er}\u000eF\u000eA?~\u008b\u0001(\u0082AZ\u001d8\u0089\u007f\u009f:\u0017\u008aq\u00118\u00ad\r\f\u009b\u0093"\u0089\u0085Q\u0017c\u0000?\u0085\tz5)\u000e\u0093q\u000ej\u0085\u0099sDP\u0019h\thF\u009b9\u0088\u008b\u0006\u008eu\u0011>\u008fc~\u0002iM\u0088vz5HM\u008d\u009d \u008a\u000b\u0086$?b\u0087)nI\u008eP$)S\u0083\u001a\u008a\u009dh\u0007B\u0086\u0086<\u001fq0.\u0003\u0083\u001ex\u008f\u0018d(WW\u008e\u0004w@M\u0089\u0003\u00ad5S<\u009f\r\u0092a\u0084<u.\u009f3\u0012Gh\u0085G\u0004At=\u0092dl@]\u0012\u0085\u0002ys\u008e:m\u008c\u007f\u009aO\u0095\t\r\u0091\t\u008d8\u001bx4?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.class\u008dSN@\u0010=\u000b$v\u008c\u0081\u0094K\n\u0014J)$\u0005\u000bE`@"\\\u0094@<E&Y\u0005\u0083#_\u008b\u0004H}C:\u0084K \u000faf9?~\u00020\u0083\u0005\u0005Q\u008cIx&c\\\u0004\u0012\u0012\nB\u0098\u0094\\_D\u0082)\tI\u0005\nd"\u00941-\u008c\u0084Y\u0086eceq7\u0093_M/.\u008cnH6\f\u0006-u`\u001e\u009bm:%={\u0096S0t\u009b\u0097Nom\u001b\u009d\\~1t,N7\u001d?kUN\u008dl\u008d\u001a\u009e\u001c_`h\u008d\'\fmKn\u00916t,\u0087oV\u008fc\\p\u000b\u009d5=K`\u009boU\u0018\u0012)+%,\\\u00992`[\u009a{S{X-\u0093R\u0003\u0010\u008d\'j\u0016-W_lN\u009c\u008e\u008co\u0016\u000e7r0F+\u0006y`\u0085*\u0019\u00152\u009a\u008dI\u008a~*z0qOi$JV\tO\u001f\u0012^x\u00839\u0006@-o\u009f\u008aw\u0098S\u0000\u001aC\u008fjE1Dx\u000f2+`\u0015H}n\u001d\u0082\u00005B\'\u0015\u009f\u001f1\u0097d?a\u0018\u008f8\u0089fw\u0019\u0091nB\u0098q\u0098\nqhN\u0091a^-N\u00853\u00940d6\u009e\u0088\u001bjEL\u001c\u001bU1tS&>-\u0001sc-\u0011gO\u0088N\u0099Q\u000eM\u009e\u0081}\u000b(1\u008a\u0000#\u008aj\u008d\u0080\u0001\fR\u008e`\b\u008f\u009b\u0004\u0080i\u00ad\u001cmP/\u0010QWM:\u0087\b\u0089;"+\u0006)\tQ\u001cg<D\u0087)\u008e`\u001cW\u0083%L\u0012&|\r\u0007[[\u0088\u0006\u0099_\u009a\u0098%7p\u0001%w\u0086vM%9:)\u009c\u0007"\u001aa\u00ad\u0097h`\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000org/gradle/wrapper/GradleWrapperMain.class\u009dX\u0007x\u0014\u0015\u0007\u009d"\u0013h>c@\'Q\u0084)\u0006\u008bf!\tIp @\u0002"p\u0080H\u0007wbo\u008f\u00928=N%\u0089\u0013;\u001dRN\u0015 8C\u0012?\u0095\u0005\u009d7oW\u0019\u001ey+\u0000V\u0089\u0005\n\u009eb3\u009eBl9\u00ad9**$\u0002U<\u0005\u0005~P\u0012x\u0011^Kx\u0082{TJZ\\\u0090\u008b/SrB+UtRj+a\u0093kZ\u0015u\n^\u001bx\n\u00817)x\u008a\u0085x\u008b\u008a\u0005x\u0082X,\u0001\u0003\n\u001e*x\u0087\u008aw]rx\u008f\u001cE?.*>\u0080\u000f`X\b\u001eR0F\u0015|He\u0015qE]\u0087\u0086\u008fQ\u0005\u001f\u0093\u009f\u001f\u0097\u008b\u009fPI|\n\u009fg\u0014<"9?+!I\u001c>/\u0087/"\u008a\u0082\u008e\t\u0016i?}\u0091\u009dGwvu\u0012\bDN\u009e\u001ch\u00adXr`\u0083V3\u0099_\u008f\r\u0081P\u0096H{[\u000e.g_W{o\u008e:\u0080Zbc,\u00197\u000b\u0094\u0085\u001b\u000bZ~J\u0089\u0092t\u0098a\u0086T\u008c\u0015\u0093,g\u000fR\u0002K"54`q\u008c\u000f\r\u0019VS\u00873=v$\u008d%+03|dGn\r\u0010cY@"o-\u0081j\u0097#f6m\u008b\rV\u000fY&\u0017\u0098\u0091\u0092\u0014\u00012M-F\u008a!J\u0019X\u0098g4\u001ekj5\u0013\t=/\u008d\u00102j&O\u0013HnX[\\6\u0012s\u0000Z\u0011C1\u0087\u0018!\u0091\u009f\u008fREt\u0091k_\u008e\u009bN\u0017k\u001f\u00954\u0013"n\u000e\fHezE!,r_M\u0096~\u0088m\u0093\u008b\u000f\u0014rI\u009f\u008d\u001a9\nn\u0010)\\\u0018\u0090\u0099\u008c\u00adJr\u0095^PP\u001cB2\u0085Kqf-\u0097\u0011In\u008bk\u0082r\u0017\u0010{%ml\u001e\u0084\u0012m\u0097\u001aS663\u009do,=\u001e=S\u001frr^7\u0004V\u0085\'\u008ej\u0089[&F!T{\u00155\u009eYrVH\u0081L\u0003\u000f\u00886L2n\u001aG\u0013\u0091`#(DB7-P2\u0087&s\u0019\nNs\u0096\t|\u0090Y\u008e\u0082j\u001eO\u009eS\u00021\u0016X\u007f\u001c;\r?\u000f5\b?V\u0013\r\u008fC\u0006\u0019D\r?\u0015B/+\r1<E\u0010Ni8\u0081*\u0086\u0002s<\u00928\u001ev\u0017P\u0095+\u0018n\u001elI\u008c\u0004\u0092|\u0097\u001f\u0004=\u0098VlN\u0098pA\u007f\u009f\u0004<I\u0015NY_4\u0015\u007fw\u0019\u007f\u009a\u0086\u007f\u001a\u009d\u000bk\u0091@U\u0096\u007frc\nqW !\u0014E\u0094i\'\u0015Q\tE\u0099O78AxNM\'X-\u0012_TjB\u0095Z\u008eSyMT\tM`s\u009eL\u009av\u0091\t\u00860\u0014\u0095n\u0088\n\u001d7\u00adP\'!qL\u0084lI\u0094\u0011_\u009c_Q\u0090\u0087N\u0018Q[\u0013SE\u0014W\u0088i\u009a\u0015\u0001Eib:47>\u009a\u0098\u0081k\u008a\u0098\u0089Yb63R\u0004\u00151G\u0013s%q\u009e\u000fB\u0004{(,\u00892\\;Nx</y2=\u001f\u0016\u0085\u001b&\u0094*,:y\u0003\u0088\\\u009b\u0088\u0087)2Z\u0081tH\u0013\u0096\u0095xl m19\u0017\u0097Rcd/(w:d\u00adl\u0099y\u009cB=`bX(mJ\u000bl\u009dDUCa\u0005P4\u0017\u0098%F;v\u008b\u0018\u0081p1\u0004}pK\u001bx \u000e\u0014wB\u0010)i\u0093j\u0085\u0006\u0017\u0098`xj\u008be\u0093v\u0086^\u0005u+y\u0016\u0094OG\u0080b8VC^i)\u00ad\u009ek^%\u0091s\u008bU\u0005\u008d\u001e\u0090m\u0093\u0019\u0014\u0097W:wrRZx\u001c\u0098WL.%+d;\u0096f\u0019Cq]\u0017\u0014\u0087\'\u0015]/mWjN\u00aduM64E\u009b\u0000\u0016\u008e)\u009fbH\u00ad\u0098}\u0098gX.\u0087\u001e^qE|\u0094\u008e\u0012oX\u0088\u0014]%s\u0017MxG6\u0014\u0016\b\u000b\u0098m:E\u0088S^;g;w2{\u001d\u0019\u009e\\\u008dSi=N\u0007w\u0086\u0086\u0083dO\f\u001e?+r3<JM\u008e\u0095d\u001c6R6`8u1\u000b\u0099\t\u001d(Ri\u009cL\u0095SR_\u0017\u009d\u001e1\u008b>au%\u0093\u008b\u0082\u008ag\u009f^\u0017\u008e\u0082W4O\u0087x\t\u001fl\u008f\u009b!\u0097\u0004!\u0088\bvB`\u0017gSPyw\\|w\u0086=yi\u009b7u\u008e4Wq\u0018S.9,8V8\u0010s\\\u0006\u001c\u0013[\u0089>\u001c$\u00177\u008b{T\u0015iWGP\u0016Y:\u0002N\u000eFQ7\f\u0017e?\u0010\u0095_Fe_Y\u0017z2\u0098\u009aA8F\u0092I\u0081Qrg<X.\u0005}\u008d\u0019Lo\u0018\u008cf%\u0090Z1\u008a\u0099d\u0099\u0095\f\u0082Ai\u0007G0WN5W.\u001bf56\u008ebA_r\u0014\u0082c@h\u00187\u008fba_?\u008c[\u0086h\u0014\u008b\t$\u0083q#\u009e^\u000e\u0006Tc)fa\u0019c9`\u0005:\u0092\u0095\u008eXZ\u0018\rg\u001eOC3F\u009cg\u008c.`\u000bq\u0090\u001e\u001c\u009dNF<:LwV"\u0083#\u009aB\t\u0097\u0088t\u0018e\u0094 t\u001c#\u001e$\u0011E?]~\u0094\\\u0006\u008e3\u001c\u0006\u009d>\u0080A(\u0094u\u0007\u008e\u0087\u0019\u0004N\u0012\u0002\u008b#p$\u001d9\u0002&F9J)2:r\u0014@0\u001aG\u0094>\u0092\u0096\u0091\u001dRM\u0080mC\u0007\u0096|iL\u0017\n\u0016\u0095\u0080u1J\u0095/b\u0096.\u0016%\u008er\u0002B9\u0088\u0096,,G\f\u0096oE)2\u0083[\u0087\u0018;\u000fnV\u000e\u008e,t\u009d7f:\u00835\u0019\u001d\u000f`jd\u0014\u0096\u000e\u0014\u001c\u00900[\u0012\u0003\u009b|\u0097g\u0004[\u0086qU:!l\u0015\u00186\u008c\u008b\u000er\r\u0093g\u001d6[\u001d\f\u007f\u0099\u0012\u0006\u0007a\u0004a\u001dO<\u009e0\u0089uPN\u0006Ypi\u009c\u008e;\u001cUg$~cO_-|{\u0015{\f\u0095\n\nu)\u0014Gg>\'\u000f\u0080\u0005\u008d\u0081\f\u008bn9S=\u0082.PS\u00819qw.pr\u0015Z\u00061\u0087b\u008aY\u009f\u0015S=\u008aDa(\u008e<,\u009c`*K\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0018\u0000\u0000\u0000\u0000\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/IDownload.classE\u008d\n0\f\u0086\u0014\u0011\n^b*\f\u0004A{(l\u001e|\u0000\u001fJTf $_u\u007f\u0000X! \u0089\u0094<!L\u009b\u009c_9Sd\u0087]\u0014~)l\u009dI\u0011\u008e\u0084`u\u008bEQfZ\u009d=,\u0013\u0006g5\u000f\tcmR\u0096\u001a\u009eH*\u008bB\u0018h\b\u008f*eS.\u00920\u008f\u009aO\u001d\u0002A\u001d\u0012Zp--c\u0003\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@c\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/Install$1.class\u009dW\u007f\u001ce\u001d~1\u0084\u0081\u0006\u0097\u0010\u0096d{\u0007-I+\u0091MZ\u0092&(\u0093f\u009a:;\u0003\u000f<V\u0014/\b\'EE)lS\u0080\u0088\n\u001d~>\u0002n6\u009bmla{<}w\u007f"\u0080Mxk\u0019\u001bC6Ge\u0093\u0093lL\u001c\u008ba3\u0014X1\u0098V`\u0010\u0094\u009c8r\u0094W\u0011r \u001bO6E\u001c\u008f!\u0083\u00131\u009c)\u0015\u0095\u008f\u0095\u008fTD\f\u0093rS4>#\u0005\u009760>\u008cq|^6_PE\u0018\u008cpt\u0096We\u0080\u0082\u008a\u0007U|C7cx\u0080\u0087\u0014<`F#\u0002\u00aduk\u00addtk7-C\u008a1\u009e2\u009d\u0094\u009c\u0010h\u00962Y\u0099\u0095\u0095\u0099kN\u0014=G\\d\u001b^jd\u009fJ+X\u008f\u009aK9\u0081R9WZF\u0084\u0086\u009b\u001a\u000bZQ\fO\u009bl\u001d.N\u000b\u0005,\u0086)`\u0010&\r\u0002\u001by\u000b\u009enYRni\u009bn\u0081\u0013K\t.\u0084FY/P\u008bQw\u008e\n\u0084{\u009d,o}y\u008d\u0084\u001e\'d\u001c2,kyy1,O)6[z`pz\u0012\'Y\u0091\u0087\u000e\u0012\u009a\u000fn\u009bWC\u001f\b\u000b\u008eVV\u000f;\u00991uwp\u0003\u00160\u0085>\u0084m9z\u0096\u008aGA?jC\u009c|8nX\u0010\u0006o\u0094\u0095\b]\u0004\u0017\u001eTr\u008e:\u0095\u009d\u000b\u000f\u009b&Z\u0086==35}\u0015\u0005\u008f*xL\u0004]=AA\u0013\u0002WU\u008f\u0081\u0089cFFBX6ll+tw@\r\u0000:St]RX\u0001\u009eSt3FpWZ9\u001cR\u008cgg,@\u0012\f\u0018\u0093U\u0086{\u001av\u0016\r[U6\u001f5`\u0087\u0086\u009da\u000fO[4\u0000\u0002W\u0093ie\rW\u000f#\rO4LixZ\u001a~\u0082\u009fjxF6?\u0093k?\nhx\u000e\u000bDi\u0085>\u008bYz\u00ad\u0004\u009a;\u0092\u0082s\u001ap^\u000b\u0097\u001a~\u0085\u00175\u0084\u00975\u001a\n~w\u009b3,\u0093\u0019qO\u0007\u0005\u007f\u001auY_W\n7  \u0099\u0014\u00adl\u0087x\u001dE^3Atx\u000e;-\u000e\u0019z{h\ry77\r\u007f\u0097o\u0093wz,\u0090\u000bY2\u0095H\u0094+\u0001B\u008e2\u0087\u0017=\u0083uq+\'\u009c\u009a\u008b\u0083#\u00952{~^\tloX\u001a\u0096\u009cE\u001eJ\u009a\u00923\u0083<K@N\u0085A}O\u008d*mLD\u0083*h=*\u009e\u0013,\t\\\u009fhTEaY\u0090\u0087\u009a\u00125\u000b\u0001wXE8{\u0093\u0018=\u00931\n\u001bX\u0097]\u001b\u001ccV506_\u0014YF\\\u00937A\u007f\u000bY{c\u001eF\u0089q\u0018+h\u001b\u0095i\'\u0097uA\u0018i0/j\u008cwl9\u008cF\u0081\u001d\u009d\u0087IBy\u0090+7"7\u007fj:J\u0017\u0086FR^2\u0090O\u008d:bIT`o\u0094\u0017?MYMD~%)L\u0085A$3l]\u0005\u0012@\u0000 u\u0097\u0098AF5o<*XH,w\\\u0002\u0096Z\u0012\\JV\u001cl\u0095\u000evU)\u001eh\u0080\\MlK\u0094E.\u0099\u0083\t\u0084\u000e~n\u0086\u0088\u0007\u0016`\u00ad\u0099{~\u001a/A\u0088=K[9\u001aG\u0013\u00147&B$o\u009aESk\u0016d<<\u008bp2\u001e\u0099E$\u0019\u008f"\u009a<\u00079J6\u0097m\u0094\u0006m\u001a-`\u001f>\u0000#\u0089\u0098|G?Mo#"\u0088.@=\u009c<\u008b\u0012\u0096]@94\u00073\u00ad\u0084\u0096+\u0094\u001c?\u001a*a\f/m\u0006\\\u0010r1r\u000eW\u009d\t4\u001e\u0081\u0012>\u008dph\u00179\u001c\\=\u0083%W\u0084\u0012\u001e\u0093\u009eh[\u009c\u0002]%\\C\u0012V\u0005\u009bx<\u0084\u0010\u000f\u0007\u001d\u009au=.\u009f\u009eH<r\u001e\u0015\u0098.9z\u009fP{uN\u0093x\u0094g\t\u0094\u001dsX;v?/\u0095-GJ\u001f\u007f\\Wh\n&N\u009e\u009eH\u009d$M\u0006\b4T\u009ea\u008dZ\u0097DD\u0087U\u0081x\u0082#\u001by\u0081xd\u000e)\u009a0\u0016\u008f\u009c\u0081\u0010bH\u008cYg\u0087\u008dU\u009f\u0004Y\u009d,M\u0093\u009bG,99IV>HN>DV\u009e%S^%W GAw\'`\u009fX\u0087"\u0089D/n\u0017C8Hi1\u0086\u0001\u0000\u00068 \u009e\u0090x\u0005u\u001c\u0012obg\u0011,[AfA\u0098\u0096v\u008e\u008b\u0007?\u0084x\u0006\u0083\u00158"N\u0000\u000e\u0092Y\u0091\u001dD\u001b"\u0092\u007fb\b\b\n\u001c\\\u0004#(\u001f\u008d\u0018Wn\u0080\u000e\n\u0096=]xB\u009db\u0082\n\u0085c\n:&(\u001a\u0096Z2%\u000eR\u0002)?E*a\u0099\u0086\u0099\u0005\u0002eU3l?\u007f\u0018\u008e\t\u007f/\u001bQ\u008cR\u009b\\\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000org/gradle/wrapper/Install.class\u009dY\t|T?\'\u0002!\f\u0088\u0004\u0087\u001d\t\u0088\u0084$H4\tHX\u008c\u0014e%\u0019\u0099%!\tj-Vk\u00ad[-ZhUP\u0012 \u008akZ\u00adM\u009f\u0016\u008ad\u0092\f\u0002#w\u0097s?\u0017\u0007\u000f\u0011\u001cMy4#\u0019)(iFg\u0091f\u008c|\u008euS!*<Fcnrs\u009e\u008c\u008d\u0097\t<Q\u009aIn\u009eSt\u0003O\u0095In\u001ad\nOwq\u009b\u001e\u0019\nt\u0004.p\u001e.\u0094\u009e"i\u008a\u0015.qTus)\u0097\u0092s\u00964\u00993\u008c\u000e\\\u0085x\u000bdB7S\u007f\u0091\u008b+X]"c)\u008f\u00974y.J^*v\u00adF\u0015nZ\u00880v4+\u0015\ng\b\u00853]\\\'=\n7(]|\u0096tq2n\u0094f\u00ad\u009b^u\nWx\u0083\u009eZnrJ>G\u008dn\u0017+k.$\u001fJ3Gnj-\nknnf\u009f4~7\u00ad\u0093\u001eMM\u009c\u0016yJ3m\u001cpy.*l\u00079a\u0011.vy\u009e/<E\u0015\u008eU\u00140\u0098lSMA\u0095S&v)]|\u0099\u0017\u0082o\u0088\u0017\u0013H>/\u0092\u008b4\u0017)M&6\u001cUA-\u0016cL\u009e\u009a\u0015\u0095nm\\v\u001a6\\\u0092)<m\u009bV\u001e\u00ad\u008dF4\u0010n]4*\u0012\u008e\u0019ZX\u0005\u008b/ar\u0006#\u00ad\u00adz\u0094ib]$Z\u001aA#:s\u0010+]HG8\u0018LS2M\u00adN\u008c.\u009aV\t\u0016CA<-\u0082sh\u0082\u000bc\u0081m\u008a@PX^\u000bk&o\u0099(\u001cu\u00019\u0097\u0004\u0001c)\u0005_"\u0097Krl\u000b3"~\u009did] 7Czt\u00ad\u0086A@\u0005k\u0080|\':F[\u0000\u0096\u009b\u0094qgM0\b\u0019zu f0-(\u0006\t\u0083\u0004ZQ\bD\u008b\u000b-\u0007"\u00131\u0085/}\u009cIA"?\u008f\u0006\u009a.\u001ad\u001aa\u0091\u000fF5\u0098\u0092\u009b>M\u009b3\u007fAc<4:(W\r*-t\rf\u009awL-O\u001f\n;+su \u009ab_f\u009c@|C\u0097\u0089.b\n\u0080Y0\u008b\u00074\u0086\u0015\fR\u0098{lmz\'\u0013\u0007W\u000bK\u0098Bp\u0089\u0098\u008bG\u0003FWy=\b V\u0007Z\u0098!+[=jq\u0003tu-\u0084Q\u0086\u001a\u009c\u0096\u0016\u0081z.X_34lljq4~\bWUbFCm\u00adM\u009c)|V> \u00adU7*z4\u00955\u0091\b5k\u0090C\u001e\u0082tW1_4n\u000fD!(k\u0005\u0083u\u0001S\u0001\u0006BW{\u001f\u0083.\u0019\n_\u0086,\u0013\u009eYn\u000b\u00862|L\u0081J\u0010\u008c\u00164Q\u0090\u001d\u008b>0]\u0019\u001cq\u0005-A:ofK \u0018h\rkF<\u000f\u0015Cd\u0086cQ\t8\u0019z4\u0014\u0088\u0004p N\u0096k|B\u0085_k~+\u001a\f\u007f$n hn"\u0012\ri\u0086aN\u0007\u0011@\u0019\u00918Me\u0011\u0089\u0081E\u0089\u0099\f\u009d #\u0000\u0084J\u0094\u0095\u0015al\u0019\u008dCSV\bX\u0019\t\u0081p*\u0012\nia\u0097\u008a\u0015\u0091h\u0014\u000e\u001b\u0088m\b\u0084\u0091\u0094 \u00ad\u001c\u0018\u00895h8\u0007u\t\u009e\fD%\u00167\u0093\u0005X\u0097\u0006:;fcF\u0007\u0015z\u008b\u0011\u000fo\u000f@\u0019]&\u001c\u000e=lDR\u00161\u008d\u0088I52"A\nH\u0000\u008f$\u0091Ui\u0012\u0084T@\u0092}^\u001a\u009ap<\u0002d%[(\u0093\u0081/o&\u0087\n_w\u0015\u0012!\u0017iJ\u000bFLe\u0005\u0019\u0083Tf,As6\u0013\\h\u00ad\u0099\u009d>k,\u008c+\u0099N8du\u0092f4s\u009a-[eN\u0093\u00ad2&Tu\u0093$4G\b-9qBO\u0092c:F 5Oh\u0095\u009e\b\u00ads\u0017\u0097g\u001d\u0013\rY\u009dswY ,>asM\u0092\u0013\u0096V\u00167\u009a\u0082\u009a\u0098W&Tz\u009a\u009eQ\u001dzW^zX\u001fTz\u009c\u009eP\u0012\u0096J\u00177Uz\u0090\u001eRr\n\u001b\u009fP)\u008b2\u0095v\u0010U\u0001_\u00ad5|\u00ad*\u0090oPG|\u0003\u0085\u009a>[\u0088TF\t"K\bn\\YY\u008ajE\u001f4G\u0005\u0005\u00ad*|\u0007\u0004%s\u009d*w\u008bQ^4\u009bUg\u0006rA5\u0011\b\u0098tS\u000eoz=\u009d\u0099\u001f\u009bG\u00987\u001c1(?\r-\u0010j.L\u008b"F$\u009a\u0095yk\u0012kD-\b^\u0013\u00898\u009d\u009d\u009aU\u0086R\u007fU[\u009f\u0007T0m:*\u0013\u0089c"\r}5\u000eT\u000ft+COnh\u0085j*3\u00037C\u008b\u0006O\u000f\u0087\u009b\u0000\u008csBZ\u0097M{\u009bu=5PmoGh+\u000f\u009b\u0005y454\u0003\u008d\u009d\u0099\u009em\u008fFB]\u0097\u0005\u0004\u0012\u0010+E7\u0010\u0083r"#\f\u0097%^-\n\u0012A\f\u00001K,D#!5\u0098*\u0092D0ozAET\u008f\u0087\u0093+U\u009f\fY)\u008d\u0012[\u0085i(\u0090V\u009aE\u0090\u0001\u0095{\u008d|\u0080\u000f*bG\u0010u\u007f\u008cF.\t\u0099*?Jo\u0018?\u0013$lF\u000b\u0092\u0081p\u0004>O!;\u001f\u00ad\u0019\u0000d\u0085"(El\u000bW\u0017\u0010PyZgY\u0095\u007f)H\u001c\u00971=CFT~\u008e\u007f%\u0084\u000eK\u0000R\u0099/B\u0081\u008bi\u0003,\u0095_\u0092iSRe\u0095\u007f\u0004\u0091!\u0082H<7\u009d\u0018(\u009c#Y\u008czQoK$Z\u0095\u001b\u0085\u007fk\u0000\u0012\u0004N^9\u008ap@\u008b\t\u000e-l\u00881G`\u0096p\u008cuw%\u0012+\u000b\u008aSu~C{\u0083\u007f?a*T~\u0093R6\n\u008c%\u008eJ;*+\b\u000b5i\u009a!u\u0098I\u009bc`\u00ad\u001aP\u008dO\u000fCb\u008e\u007fW\u009f/\u0095?T\u0090oG<zG\u0089\u009b\u0011\u009fFy7\u008fI\u001c\u0098K\u008b\u00130\u009a\u008e\u009do\u0003!2@i5)L\u0000~E#\u001d\u0019\u0010\u0014\u0005\u009cy\u009c7\u0014`\u0011G\u0081\u0018UP8\u008abIi\u0087\u0005\u0019\u008fcY\u0082i\u0089\\|\u008d\u009cAl\u009b\u0099\u0094xFqc^cW.\u0006j\u0085\\\u0017:2ID\u000b\u00923\u0089c\u0097Q^\u0005\u0004\b\u0003.]l\u000f\u0001\u0087A@S\u0082\u000f\u0012p/<\u008b\u001d\u000b6./\u0005wvfHI\u0085\u000e\u000brN\u007f7\u0005\u0085r2z`\f5 \u0087\u0019\u0091\u009571\u0005\u0019\u0011h31-{\u0089\u0000;jM4eD\u0092|(\u0081XMYb\u000b\u001c4\u0084\u009a~n&F\u008e3\u0016.\u008e\n[\f\u0091=e)~>|l\u0010\u0095vrB\u000e\u0096V6"\u008b+\fL]2\u009d6\u001b\u0085\\<&C7._A\u008a;\u0003A-\u0003\u008cr\u008f#X4/R\n\u0087a\u0081Xu\u0003\u000b\u009a\u001f;Wdb\u0014d\u00910%\u0082\f\u0017\nf\u0003\u009c&\u0015\u007f\u0095th\u0001\u0003\u001faD\u007fZ\u0004K\u000b\u0001\u0003o\u0011g>~c\u0087\u0012WB\u00123}\u0096\u009c\u0010f\u0086\u001eI\u0010O^\u0099\u00121t\tWO~\u000f\fVbI\u0016,\\"y/9^%"\u00adV Y\u009d(\u0094\u0099f\u001c\u0017Iq(qZn5~_I\u001bXl\u0006\u0089H\u0007$\u009f=dCAawj9\u008a\u0003\u009as1\u000b0\u0019<\u0005\u0019x;4M\u008bGzMP\u000f\u0006\u0000i$>\u0007\u001b#\ne9C[\u00ad{]O?\u008c\u0086\\\u0003\u0095:hxu\u0082\u0011\u0092\u0003Q[\u0093h;\u0015\u0012\u0091\u0083<t\u0001}\u0083\u0098.W\u0016]D9rB{\u008e\u001c\'\u000e\u0013n<`\u001dWbP9\u0087\u008bz\u00943l4=C>\u001a^T\u008f\u0094\u0092},*G#\u0098;|\u0017\u0004r\u009d\u0086\u0095^\u001aK\'\u0083\u00874\u00856\u0083H\u0091E\u0093\u0011\u0099o\u0013\u009boU\u0096&|}\u0001z\u0084\u009b&\u00054\u001e\u0086\u0087h\u0004^FW=npcL\u0085\u0013=^\u001aTqz\u001c%=\u0094M\u001e\u0007\u0006Y\b\u0019\u008b@\u0004\u0096D*\u0003L>WZ\\JW5A\u008bZ\u000eT4\u008f\u0087~mX[D?\u009d\u0090l"\u0091ni4\u0089~\u008c7\'\u008cv\u0005kp\u000b9\u0093\u0097&4\u0015\u0006\u0002Q\u0091k\u0095&\u0095z\u001c4i\u0081=~K\'%\u001e\u0087-\u0017BNnI7M\u0080\u0094S\u009bz[\u0016r]\u001e;hh8s]s/O\'Ud{i\u009a6\u001aQF\u00937x\u0014\u009aa\u0087\u008bwQ)_b3\u0082F\u0004\u0091\u0019\u0002\u0013j4\u0095\u009ai&(?\u009dB\u00adPG\u0080Nh\rm\u008c Bt>E\u000b}\u0017QTa\u000b\u0004\u0094CIt\u0006;\'\u0012Sj\u0094\u0084\u0092\u001aXu\u0017\r\u008cm\u008b\u0001?9\u0014{\u000e\u001aA)\u0007.s)\u008c~\u000e3\u000f:4B\u0015S\u0001\u0085B{\u0089|AT>B3\u0014\u008c\u0086\u000f\u0083P\u0002c\u00021AgC\u0011Lh(=@3\u0018f\u001dK3\u009br\n\u008fPa\u0093\u00adq?!\u008a\u001fh\t\u00ad\u0089\u0003T\u0096E\t0\u0081\u0013bv\u0001_\u0007.*xho4\u0094`b\u0089}Pb\u0016Vn\u0081rW5\u0015\'=\u0007#j#4]\u0083S\u0006\u0088K\u000f\'D|\t:\u0014&jJ\u009f\u0092\u001e*\u0097\u008a\u0091\u0002R7QLI\u008a\u001b\u009b\u0098(mlrz"Y\u0085c/\u0013D\u0005{R)2|\t6A`\u0088(\u001e\u0094\u0019x\u009e\u0002Y\u0006\u0086\u009f\\iz\u0093\u0013}*=\u0002\u001cX\u0088\u000eMII_C\u008f\u009aK\u0093L\u008f\u008coo\u0010L\u0097qz"!x\u008a\u0003WB8)\u00121\u0016xT4\u0094\u001eZ`-p oicN\u0085;I-8\u000f\u0092,\u0001xzSL\u0082;\u0001\u001ba\u009b\u0000\\\u008b~\u001a@\u009e`\u0001\\N}J\u009a\u0084-]\u0098/\u0016JY9\u0080\u001e\u0091j"\u0080|P\'\u0019J\u0098)\u0004~\f_\u008c\u0015\u0086cl\u001f\u0006NE\fKyM9K{zneMG\u0096\u001c\u0006\u00829a\u001e\nM\u0018\u009d\u0097V6Rm\u0093|\u009fCgP\u009dD\u0098z(B\u0011\r\u00adjp=My\u001e%g\u0085w\u008f\u009b\u0080x$\u0081dM.\u009ad\u0091]\u008bWD\u009b6H\r\u0080\\!bKMxNn\u009a \f\u008fnM`f\u0081\u0084\u0080h>u\t\u009dKyh\u0082)\u0086A\u00173\u0003vS\u0005rD\u0084\rP\u0016\u0083\u0017Q!\u0005nh\u0007p\u0005\b\u0007`\u008e\u00830\bps\b\u0098iv\u0000r\u0003\u001cY%t\u0005934d:\f\u001az\u009e^\u0080+Lz+0e5\u0087Y_WL8\u001fN\u000100)\u0000\u0018\u0083\u009d\u007fc9\u00176\u0005\u001ar+iyTh\u0099B)Rz#4\u0005}}\u0092\u0097\'\u0011-W\f\u0085\r/\u0004\u008dD\u0006o\u0097x\u0084\u009c-IK+w\u0093\u009eu\'9mS\u001e\u009cc$X\u007f\u008a\u0001b\u00010Q8\u008bBB\f\u0095FL\u0014\u0096]\u0084\u0090:^8\u0092\u009f\u0002\u0012\u0087"\u001cx.,6=\f\u008f\u0096z%M\'\u0015\u0099,\u0099<\u0007!\u001ba&\u0086Y\u009af\nal<\u0082\u000b\u008bp\u0097\u0090\u0087\u009e9\u009e8\u000fc\u001fO\u0010b\u0004\u0019\u001b7-S\u0080\u0085);,?\u009bv\u0010\u0001\u0086\u0093s\u001a<3\u0010\u0092\u009f6\u0012el.nuM/Jfn`\u001d\u0090p\u009ed\u0085\u0000^2 \u0013\u001c(\u0093D\u0012\bCn\u008a/^v8M\u0003z(C1\u0094*\u001et\u0019\u001eg\u000f\u0096m(\u008fN6\u0090N\u0097q=\u0007BnB\u009a\u008d\u0082(\u0019\rK\u0005w\u0019R\nl\u0000\b\u0096qC5\n\u000f\u00941\u009d\u0086S!2z\u000f\u0094\u0007\u00ad\u000f\u0090?\u0004\u000f\u0090\u0095>DF\b>F,\u0004>\u0086>A\u000fSk\u0097t6\u0085\n\u008dmBa\u001e\r\u0016\u001f\u0085>\u001d;Cg)e_\u0003\u008aV\u0006\u0006t\u0005W\u009a\u0086S~D\u0005i\u0014\u001a)\u009f(\u0085>V\b\u0095+\u0014\\F\u00ad\u0080\u0019d\u007f|FY}#5\u0005\u001f\u00adP\u001f,\u0018\u0012[$3E#\'+\u0091)nF\u009f5\u007f\u001deWCq)\u00ad\u0005\u009bhDIYlu\bB\u009f\\h\u000fST{F\u008bK\u009f@\t)Mc=&\u007f1S\u0006\u009a\u0085\u008f!\u0087#=B(\u0017v4t\rV\u0089\u0095bpW\u007fY4\u0098hg\t\u0016\u0014\u00841\u00140+D*w\u0082\u00110n9p9\u009e2!83i\u009a`\u0091//bq-|N,H\u0004,Y\u0080e^m\u0005$gJ*%\u0015d-\u0013\u001d\u0013cgGB\u001d\t\u008b.\u0019\u0087\b\u009e\u008c\u0094\u0095\u0002%pqAVb\u00194\n2\u009a3+6_n\u009b\tp63)\u00833>\u008a2(\u008b\u0087|VQJ\u008eB\u0010\u0093G\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000:o\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000org/gradle/wrapper/Logger.class\u0085\u0093ko`\u0014\u000f\u0097Unc\u008c@&s*\u0017]7\u008b11$KH\u0092`w\u0093\u0014\u008d_OFg\u000b?\u0080\u001fx\u009eR\u0019\u008e5Krw.??\u007f\u0001h\u0019G\fb\u00821TP\u008d\u00864w+\u0002U\u008e\u0082]\u0086\u0010.\u0003;`XxfX\u0086\u009c!R9\u0082!1,j<8\u0014>?4dckq\u0090{0\u001e\u0019#\u0086bvtUwx\u0014\u0007\u0087\u000f\u0087Q;\u000b\u00106m\u009d!W\u001c\\5]1,)\u0081@\u008cF\\\bs\u000e\fw/\'.Hq3:NW\u009c\u008c\u0085\u0089fu\u0085-Ce"\u0084!\u001f\u0014\bl\u0003U#\u0097;\u009bm"x\u0015*\u00ad@ob\u0088w\u0089=C\u0016\u0095\u0098j[$\u0091B#\u0089\u0004\u0092\n%q\u001f\u000f\u0014<L\u0011rI\u0014X\u009a\'<%N`\u0019\u0096\u000f\u008f\u0085F\t\\\u0094\u0012\\\u0091c\u0098~\u001cb@\u0017\u0098r\u0093J\f[}C#qi0\u0082\u000f\u0090\u00054\u0099\u0016\u0083z|\u0014w/\\L~sW(\u0010\u00035\u009aeNSNa\u0091l\u009av{\b\u0003k?j\b}]\bKd\u0017\u0011&{\u0015\u0011\u0092J\u001e\u0019oy\u0093Z\u0016VR\u0095\u0089\u0015|}_3]\u0086\'"\\?ED\n\u0087g\u0084\u008bPP\u008cpz*\u009c\u0093U\u0012{QL[5\u009f\t\u0099\t!1!D>\u009fc\u0094\u0089I![3\u008c\u0094\u0091\u001cJg\u008cX\u0019&\u001dovHIFi\u0014\u000b\u0094\nQV(I\u0094\u0092)r\u008e\r/\u0087,*\u008f\u009c\u008aP*qw(\u0011P&n_\u00967\u009b\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.class\u0095R[K\u001bA\u0014fVK>ER\b\u008aP\bC&\u0090L\\wd\u0014\fB\u001f\u0003JLB1V\b}\u00983\u009d\u009b\'\u0080}l\u0088\u0017%xX3Kc^xBj\u0090\u007fW}B\'EH%t4j\u0096t\'hNd|E/uE` \u009a\u0089\u008c>T\u001f\tih\u0084\u001edmIXlT\u001e\u000f\u009aR\u007f\u0013\f$\u0084\u008d%\u0092\u0013\u0095\u0089\'I\b%,!9U\u0096\u0012\u0082Oi*A"\u0098\u009a[\u0094\u0010~[\u0091\u0094]Ou\u007fw%\u00ad\u009a\u0088\u0083P8\bH\f.@\t\u008f\u0002\u0004\u0006\u0098\\\u0000\u001fs>\t\u0091X)\u0089H;fOrBfVY\u00995\rU\u0019\u001e\u0099\u0002B\u0081\b\u0002e#Vx\u0093xv\u0081.\u001c|D#Pt\u000b\'\u0019\u0010\u008e^s\u009daz\u0014O1\u0014HPL4b\u0089\u000fg8z\u0086\u009eaXWd\u001am\u008a\r\nW\u007fi<\u009bvt0n\u0098\u008c&<}\u0010\u0007_>\u0000v\u001b\u0090\u009aD\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/wrapper/PathAssembler.class\u0095Vic\u001bW\u0015=cK\u001aY\u001e\u008eb\'c\u00171\u00ad,\u0016\t4@\u00065Qk[q\u001d[\u0013y\u0012y\u008eF\u0089\re)\u0090\u0096})P(\u0094C]hP\u0003ob;wf,L\u000fz9wy??\u0000\u009c#\u001cr-\u0088c=\u0002\u0013#\u0094n\u0090\u0097aC\u0085%\u0005Y\u0014U<\u001dA\u00049E*\u0085\\\u008e@M%\u008a\u00ad\b\u008e\u0013\u0011|R\u008b\u00990>\u0015\u0099\bt|VgU|NGp\u0012_\u0090\u008aT<\u001f\u0017#\u0088Ka|Y\u0094"WD\u008ao\u0084M\u0011\u0015\u000ba|;\u0082\u0082b\u0018\u000brE\u0015/)8:]X\u0093fc\u0016,\u0005Z\f{"\u0097JFI\u0089\u008bsc\u0093S+\u008bSs+\u0097f3S+\u000bs\u0099\u008b\n\u009bz*[<\rXQ\u0005m\u0013\u0005\u0096\u0086\u0082#\u0097f\u001f\u0099\u009aX\u009d:\u0092lX,\u0019\u0086hxfBa3oDA2\u009d\u000b\n\u009a\u0083K\n\u0002\u0013\u0085,M\u0098)o\u001a\u0082\u009a7\u0004_/)k\u007f3\u009bd?]s)\u000f*u\u008bEN]\u009d1zAM\u009b@G\u0005\u00ad=g8\u0012od1o\\EwtmQ\u0007\u0012p\u0089^+\n\u001a\u009ai\b \u0097\u008c\u0019]\u0002\u0019\'\u0085\u0002\u0095*\u007fpKW\u0082[.l\u0090yl/uJ\u008c\'\u0000\rTs\u00993J\u008e\u0082>Od\u0095mJeM\u0096#tu\\\u0081B\u001fX\u009d\\3\u008a~|B%\u0017\u0082\b\u008ev#\u0017Bi\u008d\u008dMcj1\u0092\u001b\u0080FKat\u00944cW\u0082\u0017~\u0013pR\u008bsCB ]"@\u000f\u0014Dhw\u009cIs\u0013\u007fx\u0080\u0017" 9B^3d\u0093F\u0084\u0086Q<8\u0087\u001a&\u0086\u0084\u0086\u008fcVC\u001a{-k\u0011^\u008a5\u0083,f>k\u001a~,:?O\u0019\u0094\u0094\u0086\u009fj\u0014?\u000b\u0091~\u0089W\u0014\u009c}E/6~\u001af0\u008b\u009e\u0099|@\u001a~\u0083j\u001d~\u000f\u0082N\u0097\u0006m\\r\u008c\u009cP\u0093(\u008cb[X\u0083+\u0095-0;Q(1Y1*\u0096\u009d\u0098W*#bt\u0097_\u0086;h\u008aw\u0004.v*835_Y\u001f~3]-\u008ddM[\u001b\u001av$A\u001bU*|\u008c\u00173Ku*"\u008e3\u008d5g_\u0083\u0005z@\u001bwk3\u000f*\u008b$/PVV;~\u0089I\u0013s\n>\u009c>\u0093\u001b\u0018Z\u0010\u0098_x\u001c\u001av\u009d\u00117@\u001b\u001a\u0005\'O+D}\u009e\u001f\u0010v\u0016\u0088\u000fJC\u000b\u0095\u008bY`0\ne}P<t\r3\u0093h;\u000bv\u00964@V>$\u009f56g\u0089\u0006\u007fKE\u008f\u008dqU`<]\u0003\u001d\u001drJ\u008e\u0005]`\u009c\u00adC\u0088,\u0014\u0092\u008b\u0019x\u0000\u0083\\5a\u0090\u000fY\'c\u0013\u001c\u001e{"\u0087z?g\u0085s0Q\u0085\u009az\u0081c\u00843\u0087\u0000G(i\u009e\u0012>\u008a1b`705E7"\u0006\u0012;h[9BZwU\u00804[Z:i\u0096D\u0012ZBb\u0002\u0093\u0012I|;\u0091\u008a@&1TEp&1\u009c"t>\u0003uY\nW\u0083r\u0015\u00ad\\i\u0015E\u008fp\u000ep\u008a\u008e]tt]i~(\u0083c\u0089`w\u008a\u009a;=\bq\u008c\u0095A#\u0081\u0013\u008c\u0004\u0086\u0089aK\u001e\u009ak1V\f.2\u0017M<u\u0093Z\u0018\u0096\u0013\u009cch&\u0018G\u0018\u0082 QJ!je\u0083Q*y A\u0086\u0015tUq|\u0089G~#} \u0081g\u0098.\u0084gm\u0094\u009bD\r rk\u0092\u0007G\u007f\u0095H]\u0093!`\u0010zvpr9@FUu\fTpvf\u0007)fM)=W\u008f\u0018q\u000e&\u009f\u0089->@Ce|\u008c\u00ad\u008c\u001cy4\u0005,\u008c\u008f`e\u0018\u0010\u0094U\u00958M\u0094^g2z\u0082\u0081\u0087z_F0\u009dl\u00adm\u0011NQG\u0099id\u0018Y\u0097K;[C\u008bR\n\u0012\u0017%\u0013><)6{\u00182C\u0092\u009a\u0081\u000b}\u0004\u001f\u001e\u000b<Uu\u00181H4zA\u009f\u009e\u00ad\u009e\u001a\u0083\u001e<\u0089\u0015b\u0004\u0085Jx\u0084K\u0005\u0011U\u000b\u001d~t^\u0019\td2:XA%\u0084\u0013i;\u0019M\u000e\u001b\u0018bd[\u0097U4rrk}\u0097\u009b\u0007\u0088?N\'HIj\u0085E\u00935\u0093\u0012E.G\u00165\\\u0094&\u0014\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007f\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.class\u008dVS\u001bU\u0014]\u0092!,-\u0002\r\u0016\u008b-3\u00ad\u008aTR\u0096\u0006\u0089%A(.a\u009b,\u0084\u0094W~\u0093L}\u0019\u0099\u0092\u000e2cW&\r$\u000f9s~s\u007f\u009b?\u0004"\u000b\u0013Q\u0005\u0013\u0001 \u001a\u0018P0\u0019\u0080O\u001ac\u0001(xSN\u0092\u0094\u0082i\u00053\nf\u0003h@\u008f99-\u0014\u0000T,H;XR=.\u008a\u0014r\u0091\u0082~\u001b{x_\u008a\u000f&\u001fc\u0014\u009a\u0082\u0015\u0081r|!:}mn~v\u008e":\u0011B\u009avC\u000b53\u0019\u008e;a&#\u0002\r\u0096\u0099u4Y9]\u0082a\u001a\u0098\u0080\'(\u001dVi=<e\u0098LncE\u0017\u0095.\u0093Y\t-\u0086\u009c\u0017\u008d^\'ed\u0005,;\u0019NjZ\u000foZ&V7l\u008b\u0013\u0093\u009aI\u0012\u008e$u+p2T(\u0013FZ\u008f\u00149H\u0087\f\u0086m\u0086@\f\u001b339"L\u0096\u0092?6\u001b\u00993\u008ea\u0099y-&dnC7\u009dr\u008efW\u0084CL.\u0099\u009e\u0086\u0004\u008b\u0088-V&,5\u0090}\u001dG\u008c\u00adc^\u0087\u0013^8\u0083\u00961%\u0019Q\u0090P\u0080u\u0081\u009145\'g3\u007f\\?z\u0081\u0095\u0013z\u0081\u008e\'t|P\u0086x\u0001\u0005\u009a\u0099)"\u0089\u0094j\u0014\t=2\u009db\r*2\u0091*\u0016hz>g:\u0086VK9#\u0002]Q\u0094nv-m\u0095\u0086v^g-*6`Ja#Y\u0090\u00ad"\u000bGAN\rl\u0089\u0094\u008a-|,\u0083g+[\f*DL\u000b|+|\u00ad\u001b|+Xyvy\u0002\u001a)\'1MnB6\u008bw{/(X,(\u001e~>\fW##\u001f\u000bI\u008e=\u009b(\u0011DWF$v t$\u001c0\u0015;\u0011\u0017/~*\u0098xB\u0007\u0081DV`\n-n|/#\u008e\u0014)\u008d\u0012y\u00ade2FIi\u0019&^\u001d,=A\u008d\u00955\u009d\u0092T\u0091mMfR\u0002\u0018/}6\u0092-\u0084bU\t$eg\u0087Re\u001evX|\u00153%\b_\r~\u008ac\u0017g5hOW\u0082\f-a\u008e\u0082\u001e.\u009b5\u0006\u0011T\u000b\u0000\u0097c\u001dO\u0014\u0083_\u0012\t\u008b\u009a{L\u0011P;\u000be\u0099\u00993\u0003y\u0017\u0086:\u0095J{\u007f\u001b\u009d3P\u0097w@y42ES\u001e\u0003p~\u007f\u001eGw"03\u0083V\u0081;LM`\u001bq=\u008f4\u0088/\u0013Z\u0082>u\u0082\u001d\u009c`iN]xG7\u0006Y c\u0010\u0018A=#7?\u008f\u0094\t\u001cI4lv14$ nq\u0098\u0011R\u0013!9K\u0018\u0080M-z\u009b\u0099\u007f9B\u0018r\u0089\u009cW)\u00105\u001a" ,9z|\u008c~\u0085_=/\u000e\u0092!\u008e~L0\u009b\u00108\u008fWIH-\u0005_\u0084\u0005{\u0010M\nF\u001f1W\u0018U\u0005>\u0085\n\u0005=\u0080\u0092\u0082\u008e\u0087Sp\u001fL<`\u0096_b\u0086qW\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000=\u000f\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/WrapperConfiguration.class\u008d\u0093mO\u0013A\u0010gJK\u009f\u0004|\u0002\u0015i\u000f\n\n"\tHUL\u0015C\u0005\u0012\u0090-\u009cH\u0092&~*M$&\u0003\u008c3w\u000b\u0094e\u009b\u0098&33\u009f_\u0001\u0002:a\u0002\u0092`@E\u0083G\txL<\u0099\u00052O<%\u0092\u0006\u0018\u0018\u0007\u008e\u001fxN\u00138m\u0097P\u0088\u007f\u0096k\u0007\u000635\fQO\u008bM\u008e5)!\u0083Bw~+\u000b1\u0003s\u0012M(\u008d/;\u00130/\u0095w\u0018^\u000f\u009e9s\u000f\nn\u000e\u001cZ\u008bd,8t|\u0006ZkZM\u008f\u001fl\u008bONl\u008d\u008biv<N,\u0088\u009bn\u0093gJei_n\u001a.]!\u009c4*:ZlkBjjttW\u008c(;"v]\u0088s~"DEE,\u008eotGU\u0017<K1\b\u0018\u008c+\u001e\u0085}\u008cZ]U\u00ad\u009bo\u0006d`\u0098\u0098B\u0001o\u00182\u0095\u0006da\u0080<\u0099\u0002\u0099!H\u001b\u0090)SU #l6\u008e\u0000&\u0092W\u001ch"F}\u0084\u00169\u0017B\u009f\u0002FG;\u0082]37\u009fl)l\u00140N\u0084q{(\u001fE[\u0084\u0001y\u0088a\u0090\ff\u008b0\u0086?@p\u0010\\\u0087\u001b\u0019F&\u0016z\r\u0098?@v>,.\u0004\u0017\u0081sm\u0018\u0017\u0015ns\u0014\u000b\u0014=NN8\u0018u\u0089\t\u0014\u0013q\u0015$&\u0083L*A=\u0015HL\u0006)\u0001B\u000fC\u001bO*A4\u0019dF\tr_\r s\u0000\n\u0090)%\f2\u0004)A\u0006e\u0090E,\u0000\t\u0090\u0012$!\u0083<W\u0082\u0098j\u0090\u0084\f\u008a\u009a\u001e y\u00012\u00ad\u0004I U%\u00035HR\u0006@\u009b\u001e \u0005\u00012\u0013jf\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000G\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000org/gradle/wrapper/WrapperExecutor.class\u0095W\u007f\u0013\u0019\u009e-X2\u0006l\f\u0011\u0080\u0090l\f\u0004\b+\u0098Cl\u0088!\u00ad9Kg@)\u0013\u0014\u009at+m\u009a\u0090t\u0099\u0098\u0016l\u001a7\u0013tgy;\u00938(Az\u009e=\u0017_\u0006\u0005\u0092\u0088\u008cGCxLA\u0015*m\n\u00828@q\u0019\b\u009d2\f\u00ad\u0016O(\u0098\u0087s2`!\u0012{yx\u001f\u000f\u008b\u001fI~0\u0084\u000f\u0014\u009f|\u0098WO\u0087\fyx6\u0084\u008fQ&\u007f\u008cW\u001f\u000f\u0013<\u007f\u0092\u0087O\u0085\u001c\u009f32>\u001bX\u0081\u000by\u0005w\u000b\u0017y%^}9\u00843\u000b2y~\u009eO`;)H\u0012\u0083^V0\u0083Y\u0005W\u0010^\u0094;98147243\u0092\u0018Ot\r\f\u000eK\b\u001cNj\u0019-;\u009e-#;[N3\u009b}H\u0014t\t\u008de\u0000\u001d\u0092]\u001e\u0084rbbA\u000fqy\u00191yp\u0096mG\u0092C\u0012\u0096\u001dN\u008c$\u0007\u0007*\u0011=\u0094\n8%g\u00999\r=/az62\u00899u\u0090\u000b\u001cNl=q\u00981.aC\u008fi\u008d\u008f[Z:\u009f\u001ck?\u009d\u0082`iafR\u0098i\u0091\u009czoX4\u009a\u0094\u0084\u00adr!v\u009dS\u0005F`\u0081N3M\u009a-1z_arT\u0006Q5c!2x\u001e\\)\u0002&*\f\u009d\u009f\u0089^-cd\r{\u0084\u0015Zn!\t\u0012]$E\u0094\u009es=\u0010\'\fr|\u009d\u00994g9\u001byJ\u0002\u0083\fY\u0086\u0084E\r\u008e\u0080n\u000f\rts@fJ\u0095BU(E\u00052DK\u0002\u001c2t!cj\u0084\'-BF\u0096\u0012Y&\u008bv\u0090\\v\u008ew\u0086\u008c\u0097dL\u001fmz\u001b\u009d\u0094\u0005^B<d\u0089\u000b\u000f\u0090)GGo..?n.L\u0097a\u009a6z5Kl\u0012q\nh8Y[#\u0083\u00940\u001cH\tM\u0013(a\u000f-W\u0015\n\u0090v\u009c$\u009b\u0091`Pm\u008b\u0006?}Ub4FsN\u0091\u0098V\\;\b\u0088/T\u001f,P(\u008eH\b\u009edH\u0019W)(M5yb-$E\u0016;"6\b\tv\noJ\u0088V;6wT\f\u009b$\u0099-\u001e\u0086T|\u001b]y\u0090\u008dIXj\u0012Z]\u009d"%\u0018)\u0013Y6>\u00926i\u009b5\u0088~\u009ag#\u0095M\t\u007f\u0094;\u0095\u008a{,\u001a5\u009f;\u001e\u0015U\u001ckU\u001cD\n\u008du=\u0082*$$)\u000e-\u0001^Q\u0091I\u0015?dIe\u001c\t\u009eP#1\u0013\u0084F/Q0\'\u000ei\u0015?e6!#\u0097(\u008e\u0084\u009f1e\u0004\u0007\u0017L%\u0013|%y,dK"|\u001cj\u0099\u0093\u001bSRq\u008cm5\u0003\u0006U;^\u001eGQ\u009ah\u0086\u0015&\u001f\u009f\u0085}#Y\u008eI7w<}\u008fEA\u001f\'\u0015\u007fL\u0018Q\u0019\u007fQWMU\u0003\u0094\u008c\u0088D\u008f\u009c2\u0089\t}\u0089x>\u008c1COG\u008c)7r\u0083\u0092a\u0085WTN{R\u0093|88a\u0099\u009cAXTY\u0012oe\u0082zfu\u0094\u001a\u0091ytR{\u0085:\u0089v:\u001dZ\u0098|`\u0016G_8x\u00868\u008a~\u0095\u0010\u009c7:+x\u008b@-I\n:b\u001cqJq(\u000eKq6b\u0085\u0017j\t&\u0099\u009a\u0005\u0098\b};dm\u0003\u0016?\u0019JpE\u0093\u009b)@a\f\u0083\u0095\u001ffhr%\u0092\u0095Q\u000f\u0003\b2&xg\u0093lL\u0011->lDM6uFg\u0096\u0016\u008f\u008a\nC\u009a!\u007fBh^G\n\u009bh_F\u000e~\u0005;=U7_\u008b0kZ\u0087c\u008b\u0099z8Iv\u000fz\u0089\u008fv\u009d\u00150\u0007ix\u000eUp,\u0002s\b\u000ef\u0016\u0080a\\\u0087\u0004\u008ds\to\u0010\u0018(\u0002\u008eC\u0016\fBb\u001cj\u0087J%\u001b\u008e%@\u009d,,V.ZX@3\u0010#\u008c8\u009a\u0091\u009a\u0091\u0014R\u0013M`:BB\u0080NcX@\u000b\txe,\u008e^F8\u0016\u008c8is\u001eO[`I\u0012QfQ?\u0083b\u0019^\f\u0096a\u0006\u008d\nI\u009c\u00adtV9gw\u0091\u0087"3X\u001c6;\u0087k\u0004c\u008bs9[\'_@c\u009fp\u0006\rqvC,bW/\u0092\u0011<\u0085g\u0010u\u001d\u0081E4n"kXB\u0099\u001b\u000fe\u0004(\u0089r\u000f}\u0007NLb\u0017\u001en\u0097\u0010<\u000b\u0014\u0084pa\u0080Kq\b\u0087\u0085K0 VHI8C\u0084K\u0097?\u0004RM\u0093Q%V\u009at<\u008d\u001cZ\u008b0hn!{\u00ad9o(g.n\u0006mt\u0091rg\u0006RH"2\u009d\u0084\u001f\tL\u0013\u008eDr\n.<\u00807\u0092^M\bh\u00967.@#}\u0003\f"\u0004\u0019l\u000e%\u00164\u008b-\u0087pXn\u009d%\u0015PG\n\u00942k\u0082\u009bYu\u001e\u0099\n\u007f2\u009f&"[r\u000e\u0087\u0003[g\u0083~;/@M\u0004\u0096d\u0017T\u00adP, Ia\u0092UOs#M\\#"t[f880\u008c\u0004HyCT!Hs\u0088\u009ac/\u0007\u000e\u0085\u009cTUY<\u001e\b\u001e\u00900\u0001\u000f\u009e8*C\u0006\u00059\u00ad\u008e\u0002m\u0006\u008c=\u0017\u008bHN@N\u0090\u008f3XL\u0088[\u009d[\\\r\u0013mRH\t#\u000bSdL\u00189<Hw\u0015R"\u0087\u0005\u008a\u000e\u0088\u0012\u009d>\\\u0003\u001a\u008a\u0000\u0015l\r9O\u0016\u0086\u008a\u0012C(\u0088.H\']\u0003\u0084T !\u009e \u008cS\u0012\u0098]h\u0017\u0014D\u0019L\u0085yW!p\r5\r\u0081k\bN<\u008fX\u009c\u0012zZ*%q3a\u00810\u0014LQwx\u0088|q\u0086,8\u008bx\u0098\u0092\u0011?cKQ\u0097\u0096.-.\u009a"\u0004c#Lg\u0001\u0091d\n_EX\u0099`-q\u009d-z3Ai\u009aD#76\u0000\u008d^\u0097=\u001en*"-\u0082\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000e\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000gradle-wrapper-classpath.properties+(JM.)M/JLIM**+M\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000gradle-wrapper-parameter-names.properties\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000org/gradle/cli/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.class\u0095T]o\u0012A\u0014=\u0003\u000b\u008b"~C?\u0094\u008fR*O\u0010\u0012h4!\u00ad\u0011aYm`\u0097\fC\u007f/4\u001f\u008f2\u001d\u0090P\u0096a9{s?\u007f\u007f\u0006PF@\u0002;:v\rDc@{\u0011xY\u001d9\u001dy\u001d\u0005\u0086x\\Yc\u0088fs\f\u0091\u0019V\u001bg\u001f\u000f{m[xKH[{\u0085\u001b\'&?\u0003\u0086b\u0017N\u0011KV-\u0003)%\u008f^\u008f{\u009d\u0080m!mQa\u009f|\u0013jU\u0011\u009bn\u008d\u0011\u0086l\u008c\u009fR\u0097{N\u001d\u0085\u0004\u0095\u0019}f[\u0092\u000bC\u0085\u000b\u0087-k\u0092\u0096=,\u008d\u0018\u0082ak^\u0018\u008a^t\f\u0094\u001c-J\u001a\u0019\u008c_,/]\u001bct\u001d\u008f+;X\u009a\u008dr\u008aCu\u0018VQ\u000bCW\u0088\tuhCao\u008f\u0099\u001f1a6C2Q\u0089\u0012\u000eLK\u0086\r&\u0084!9\u0089a{\tQ23Qu\f{\'M\u0086\b~r\u001d\u00903\u0010|i153\f\u0016\u000emn\u009eDevf\u0086J\u0085\u0096\u009a~-C\u007f\u0085\u0004H\b;"d9\u009a\u0093edc\u000b\u001fDq\u0087\u0002SX\u001c\u0007`\u0015Iw/!)\u008c:Fy\u00017\u001a_\u0088|@8_\u001cA\u0017\u000b#F\u0088\u007f\u009fVX!\u000bK`\u009d\u001bR~\u009c;\u0014x\u0086)>=\u0011\u008aN\u0001\u001eRnp\u008e\u009c\u009cc\u001ch\u001a\u0098\u009f\u0090\u0011\u0014\u00944=c/\u0083-e\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0083X\u0004\u0000\u0000\n\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.class\u00adV[W\u001bU\u0014N20\u0012\tH\u0015\u0084KKIQJ\u008d\u0086\u008b\u0082\u001a;L\u00860\u0010f\u0004OZZ_t\u00adA\u0097}N.\u0010\u0012i2Y9};vO\u007f\u00016Q0\u008ce|`\b|`\u0001w\u0015,\u001e\'?\nH`\t=\u0098\n\u001fV\u0089\u0002\u001f>B\u0007\u0083x\u0089&c\u009d\u007f.cC\u0017\f\u0094i\u0099\u001c\u0083?\u0012]c\u0090\u0016\u00971-ci8\u000f"qB\u0019[\u008ak\u009acr\u0094me\u0099\u009dBh\u0091\u008bfb~\u001cMV\u001dd8\u009ei\u000b\u009ef\u0005\'$\u0019\u0006\nF]p\u00990\u0018\u0089fv}-QB"9U \u0091\u0016\u0086\u0099E#0f\u001df[\u00ad-Pv\bT4\u0013V5%\\\u0011\u0092X3LX\u009eQgIW\u0091\u0091W]p\u0005\u008d0\u0099?\u0095:\u0099\u0092VJFO\u0014\u0092MA`i\nq\u0015A1\\W@\n\\\u0005A\u008a\u0080A)5"\u00934\u00828,\u0013Fh\u0015J+g\u008e\f^z\u009aK\u001a\u008e\u008c\u0087\u0004a@7e<f\u0082y"\u001b;D\u0012=\'\u001d\u0003\u0012\u009a+\u009b;\u0086%\u00ad,\u0086\u007f\u0015W\u0092J\u009d\u000b/Gd\u001bL\u001eXg\u0005<mx\u0015#\fx\r*&0.K\u0015o \'+\u0015\u008fA\u001a\u0093|g\u0013\u008c<\u0000o(`[\u0086b\u0007*\u008aSa\u00ad\u0084\u0019\u0081C\u0099\u000f\u0094%M\u0097U\u00114z\u0011%LEu|t\u009a\u0018\u009ag1qBu)\u0094\fk$1\u008b\n5xE;i1g\u0018Yu[sD:2KZMu6?Al\u0010\u0086T\'[\u001a\'\\L\u0092z\t\u001fo\u0092\u001fB\u0091\u0093E\u009f1]^\u0084\u001c\u0086.\u0011&\u0085z6\u001eKZ6\u000e<S+Y\u0082h~\u001au.\u009bV8Xb\bu\u009a2\u001bi\u0095te\u009ed\u008fNH;4A\u007f\u001a\u0086?2\u0018/y\u001a/\u0012\u0095\u0099j\u0013\u0081\u009f~\u0085\u000f4\u0006\u00053\u008c1\u0015\u0002\u0084\u0080$ \u0089<g\u0092y\u001dWjFK$j,\f\rt\u0005\u0086D\u0093\u0094\u00ad \u0014 \u0014\'Rk\u0010$\u001aG\t\u0018}/a\u008aN\b\bj\u008a~\u008cDH\u009bAR \u0018?\u0082\n\u0094#0,_;\u0082\u001d\u0016iq\u00819|\u0011)[Al \u001c\u001e\u0003q"\u008f0\u000f\u0018%\u001f\u000eT\u0010\u001a\u0091\u0001q\u00059\u0084N\u0090\u0004R\u00907\u00133\u0085w\u000f\u0084o\u0083\u0090="\\\u0006\t\fb\u008dj\u008akD\u001aQ0\u0014-\u0013#Kusu\u0010Q\u0091\u0080\u008c\u0090\u0090cc\u000f)\u0000Q\u0082=[tx\u0092V\u0017\u0005\u0000p2\u001d\u008b?`\u0005\'g\u0004[\u0081:YM\u0098\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000org/gradle/cli/CommandLineArgumentException.class\u0095\u0091J\u00031\u0014\u0085O3Zm+U\u0007V\n"\n\u0096i\u0098Ff\u0012\u0007$-U\bfq\u0093{rwO\u001b\u008034K(`\u0084m\u0017u\u0017\r\u0002\u009c\u000b\u009e\b\u0087=}^DESE=\u001a\u0012\u0014.\u0098\u0011T}.m\u0016\u008f\u0098\u001aQ\u0095\u009a/\u0003\u001a\r&\u009f\u008b\u0085t\u0013\u0082\u0013_\u000b\u0015\u001dG\u000b"]8bl \u0017*b&\u0080=\\\u008a.\u0081\u001b$rA^\u009b2\u0098(d[\u0080f\u0089&\u0097V\u0010\u00942S\u0001o/c\u0006PF\u0011\u008e\t\u0015\u0082?^E5.\u0013)\u008f\u0012-/\u0098\u0095\u00031\u0013ttuyNN3\u0005y+:\u0096\u0095;XJk\u0096\u008cu0\u009cug;S~t\u0085\u001d\u00160w\u000e3*6M]\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000org/gradle/cli/CommandLineConverter.class\u008dQMK@\u0010}\'"4\nF<6 EQ\b($x%vS<\u0003Q6\u0085\u0012L\n]Xv\u0086\u0099\u009fo\u00008wupJp\u0092L-6\u0084~/\u009c\u0005S\u0084bf\u0094\u0007%u<\u0089\t*D<.\u0013id\u000e\bn$\u0085b&\u009cpW\'<(a\u0091R\u0089`\u0018qKx\u0085\u0099\u0016l\u0092r?I\u009cOFl$\u0094jw\u0090v\u001a\u001fR\u0014m_U\u0088%J\u0003\u009d\u001bvJQ\u0096\u0084?_\u0094F%p}b\u0011.;o\u0012-\b7\u0089\u000fZ3fSm\u0002\u0081i\bMlg\u0096pl~Qqk*\u001d[9a\u0011\u0091#\u001c\u0017\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\n\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineOption.class\u009dV[w\u0013U\u0018\u0093\u009d4\u0099^\u0088i\\"iB\u001b\u00adZ.^\u0016\u008a\bdL\u0007\u00990\u0099p\u0011w\u0007 .\u0081UY\u0093\u000f\u0017\u0019.\u0097d:\u0099\u0087\u009c\u009dsN\u007f~\u0005&\u008cm8\'|\u0018\u0001\u009ckE\u001f\u0096Zq\u0001o\u000b\u0018\u0089\u0010.E\n.\u008bA\u0095\u001cA\u001a\u0019\u0019\u009a\u008cwh/\niEHz\bW\u009c\u008a\u0085\u00118\u0089\u0014C^&\u0006KFA\u0086-A6n\n\u0012:T\u008d\u009cf\u008fJh\u009d9.Z\u009a\u0084\u0095c9sV[y^\u001a7B\u0081*\u009b\u0012f$\u0015\u00968#!Z\u000b/!eJ\u0082D\u0096Y/\u008a\u0084jL+\u009bZjRiCO\u008d\u009bj.3Y\u0088o8--\u00adZFB\u0098\u009e\u0012bq\u009fI[eC\u001b_\u0090\u0010\u001c73\u009aH\u0015af\u008a\u009a5/\u0084fZ5\u0016TK\u0017kwt\t+:3NU-\u0000\u001ak\u0083j\u009aw(.!a\u0004\u0091\u0081pVg))_C\u009a{\r\u009c\u0089\u0085c.[$\fk\u0091l\u001d\'{\u001bRS|~2v?x+bi\u0085zkN\u008f\u0017u#Y j>2ZfYTR\u00ad\u0011Q\u008e\u0096\u0012\u0002xu\u001d\u009d\u000eWx8R\u008b\fE\u001910o\u0013\u0014gm\u008e\u0019\u009e74\u009f\u008a\u0081r_q9\\\u0085WO\u0095\u001bw\u0096/\u001bjh\u008az"\u001d#\u0081z,Zi.ZFkP*\u008f\u001b$}iB+\nc\u0087\u008c\u009b\nna\u0082]b\u000e\u0005\u00821\u0003|(\f2>R1>aSz\u0081\u00895 \u0082\u0082xA$>U\u0090D\u009cP~.*8\u0085\n\u0095\u000e%\u000f>\u0084\u0082\u0085\u0082\u0082;g+Z\u009aEk\u008cM\'\ng6-\u00870\u000b\u0001:\u000bNV\u0004\u009f=!!{\u008a\u0015LX\u0007`e2zFI\u009c3U\\%N\u0015e5CC]Z]A\u0081mYCYb\u0019Z.+&%b\u000b`)s4\f"(({j^<\u0005Q*>\\\u0005\u001f\u0010{#\u0013\u001c\u0099\u001c\u0015\u009c\u0013%\u009dN\u0000\u0083\\\u0081&\u00049\u009fI<\u0086\u0094x\u0082hz\u0088`G4?DKyGN!$az\u001aZ%V\na\t"2\u0093\t\u00815(\u0001,{\u0003\u0005\u0091\u000b!\u008e\u008a\u0003=V\u0003$IjH\u008d\u009da\u0014\u0011D\u009b\u0084/\u0016\u001a\u0002\u001ci;\u000ea\n\b\u0083\u0094\u0010x\u0090\u009ad8$\u008b\b\u007f\u0011\u0014T\u001a\u0098\u001bf\u008a+qY\u0083\u0090r*6:^\u0094\u009b]%\u0090w\u0018G\\\u009078\u00078\u0089H\u008d\u0080ir`v?/\'\u001c\u0092\u009a\u0017\u0086\u0096\u001c\u0086\u0015c\u0018Gaf\u0084;B\'\u0094\u0088F\u0004|v\u0006vr#x=\u008cz\u0018C8P\u0017c\u001c\u0013.\u001d\u0016}\u0082vrc\u008a\rJR\u008fi1!h\u0088]n\u008aG\u0088\u0095S\u0085\u0086\u00100\u0019 \u0083.j5\u001f"GO\u0090\u001b\u0086 \u008d\u001e\u0099\u001f\u0001\u008enJ0.b4-\u009d\u008f\u0098\u001c\u0010n=\u008cw"`<A\u0082F\b\u001b%H\u000f)$\f\'J ^\u008dz]B\u009a$\u0002\u008etA\u0087\u0081h3_\u0094\u0011?\u001d:kR<M3\r :U\u0010r\u009a\u001a%\u0013n:\u0099\u0016w\u0090\u0083\u0010l\u0005S\u009bu\u0088\u0007\u001d\u0006\u008f\nY\u000fr\u0085\u0010\u0090\u001b .\u0010;*\u0011\u001ca\u0017QN\u0004\u001f"Z\u0013\u0012\\\u001e\u0087\u0081D\u0088u!zq{9z\u00973uzYbU}ye\u0091z\u0088\\\u008a\u0018\r_\u00919q\u0098wA4\u009761\u0001Gu\u000b\u009fM!&\u0095b\u0099c\u0098\'s\u0091B\u0096\u008fJ1\u0098P~YN{YH\u008b\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u008a\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/gradle/cli/CommandLineParser$1.class\u0085\u008cA\n0\u0010Eh\nv\u0088k\u0083^(\b\u008a\u0082\'\u0088P[\u0004\u0092\\x\u0000\u000f%t\f\u0087\u000f\u00048D\u0018bD\u0088fsV\u008a\t4\u008d|\u0092].\t\u008d\u0095q\u0095.\u000f^M\u0011"&\u008d-EieX\u0012?\u008a0i6S9v\u0084\u0013JR\u001c/5-!W\u0093 \u009d_x\u0017`\u007f\u0080_\u0019\u0080$\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099\u00adN\u0003\u0000\u0000\t\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classVN\u0013Q\u0010N[8e[TA#V\u0084\u000b" \u0088\u0016\u0094\u008b\u0014\nAIu\u0092"\u0082\u000b`A%13Q|\u0006c\u009c[X`\u000b!9sf|s\u0099o\u0000\u0098\u0097\u0080D\u001d-I\t\u008dHHH!\u001d@/qq\u0017\u0092\u0001\t\u001c\u0083\u001c\u000f8\u0086%\u00040"A#\u008e\u001c\u0019\u0086ZV\u008c$\u0019\u0086\u0099OMy&\u0094\u0082\u0096\u00183e}%\u009cl\u0016Us\u0088\u00875]F\u0018&:+ezC]\u008b\f1cEeh\u0014\u008ce|./\u0017\u0088\u0013\u001a\u008a\\X\u0094MM\u009cKL\u009fp\u0097b\u0095\u009a\u009aY\u00166\u0097K\u0090\f)]W\u0082\\,c(\u001c\u008a3\u001ch\u001e\u0091\u009aH\u0018\r}\u0092M+ai\u00861\u008e)\u0012Z\u00843*\u0091\u0013\u0005Y\'\u0016,SC\u0095\u009c.w+\u0007lE*\u0019>9U\u0016Z;;:"@\u001bxv.U\u001ek\u0014XRbI3D -\u0018\u009b\u008ek|Z*tzD\u0082\bB\u0010!4q<\rb\u001c\u0013\u001c\u0093AL\u0019C\u009b[j\u0018\u0006]\u001dy\u0096~D=\u001e\'\n*\tf\u0090]\rL\u001f\u0003r\u009c\u0002s\n\u0088Z(\u009a\u0015K\u008eL=VML\u008e\u0096l\u0087c:N\u0090>}PW\u0089E(Q\u009d\u008a\u0016\u008b\u0091\u0081$Uio\u0015\u008d\u0015\u0012U\u000e1\u009dQ>1rb-gq:\u0014f9cy\u009a{:9OR/\u008d\u0095iPFFz\u001cPH\f4\u0088\u0006mi\u0092^\u0083\'x\u000e\u001fA3\u00ad\rB&P&\u0011`Sh!^\u000bH\u001f\u0097p\u0005)\u009aLcN\u001cG{&\u0011\u009e\u0083\u009d\u0081.R\u008c$(A.%\u008bR,N`\u009e~vX\u0012\u0016\u0080l\u0006Ml\u0016,\u0087\b\u009b\u0089:\u0086\u0016\rA&CA\'\u0011\u001d \u001f7"\u001c!\u0081Yr8GR\u0081\f\u0083\f\n(6^f\u008a\u009b"pfSQ;\u0007\u0082\u008a!neGl\u0003=Z\u0089s\u0083\u009b>\tw\u0005DO7R\u0087x\u00850D\u0000\u000f!o)\u008c<\u0098=\u0093\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019D\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.class\u00ad\u0095mO\u0013A\u0010{-r- >W\u0004\u0081+p\u0080\u008a"D!$\u0015M\u0090Fxag9\u0099\u0011.\u0090D%\u000f\u00872^r\u0092\u0003c\u009affwn\u001f\u0000fq\u0080\u008eQ\u0003i\u008cu\u00934h \u0089I\u0003StL\u0098aTz\u009d\u008bj\u00116P\u00935&y\u00ad\u008aXOl}\u009f\u0005\u0086\u001dG8]\u0086\u0091x2Cr\u0012<\f+M[>\u009b.YN\u0094\nw\\:J\u000f\u008dI\u007fi0dm\u008dxBBr\u008d\u0086Mu0r$f\u0090\u0084\u001c\u008eu~^\u009bF\u0086+\u0096[.\u00175k\u0097\u008e-\u008co0$\u0016\u0019z<\u0011A\u0098ekS\r\u001b\u001d\u001db\u0017V\u0085g<\u0089?d`Sm\u0091t\\cX>\u001dcg\u0082>v@]7|\u0094-\f-+CG@\u009b\u00940\u008b\fj\u009eE7\f\u001d7\u0018ck\u0089\u000eW7x\u0092\u008a1f\u001600y\u0006d\u009883\u001e5\u008d?U\u0086\u001b=\nq~\f\u001f:5\u007fh\u0098h\u001fkmq\u0083\u001d_2wC^\u00802\n\\\rG@\u0014I]T\u009f\u0091\u0087Gi4gL\u0007,~Ab\u0097T\r4"A;\u009f\u008b\u00ad`\u001b\u0091m\u008e<N\u0002\u0081\u008c~\u001fBhV^Zc\u008b\u0095"\u001b\u008b\bCk14\u009c\u000e\u0018\u00838\u00172\u001e\u000e\u008a\u008ew$\u008bg$T\u0086]\u009f\u000e\u0000+\u0001tm\u0001s!PIIH\u0080K!z1PW}V\u0016\u0089jF\u0093\u009cW\u0085_\u000eyGO\u0099=\u0003\u0019E2L8)\f\u0005+\u0018\u000e2\u001a\tv^\u009b\u0002L\'\u009d>:C3q\u0091\u0082\u0002\u0007hb\u0002oPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classVRF\u0014\u0016#\u008b\u0098\u0084\u000e5\u0001|\u0092`\u009b$\u0005\u009a[qpZ\'&Bq\u0015l9#M^\u008fHg!):C;=+9`b\u0083L&3=\u009co?\u009d=:\u007f\u000b\u0000sx c\b\u008b\'\u0091\u0091\u0011"GN\u0086\u0084%\u0019Y\\\u000e\nr|$\u0016\u001c+\u0002\f\u00198\u0007p\u0083\u008c[D\u000082X(pa3\u001a\u0019\u0086|+\u0096UZHk5\u001b~G\u001a\u0095#\u0092a\u001a\u0015\u0086\u001b\u0093\u0011\u008ey\r\u0097\u009b`\u0090V[:)aXouW-W\u00125Z\u0086X\u008c\u0092\u0010Y\u001f-a5b2MZ\u00ad\u008d\u0086NEO\u0092\u008eAm\u001fE\u009c0\f\u00adZv\u0091mM\u008e\u0018\u0006\u001b\u008b6m9\u0099\u007f~YI\u0017m0+N\u00947\u000eZ\u0015!]\u0087?vu\u0007O"\u0013w\u0083\u0096\u0085\u0003t\u0081\u001c\u000fIUh8*\u009b\\\u008c\u0010\u008cXkG(2l\u0095>\u0093{\'31+\u001es\f^c\u0090\u008bQ\u0088\u0084\u001cL\u000b\u0015\u009c\u0088\u0082a\u009c\u0090:\u0096{\n69\u0017\nJd\u0088z>dxFgn\u009bf\u0097<s\u0096\u0082s\u0018\u0013aH\u001c\u001e`4ki_{\u00ad<8r\u0019mHJ\u009b\u0080\u00894Ch?Y\u000b\u0087fs|@EYD\u0018.y\u001ei\u0090\u0003\rw\u0010~X\\|\u000b!7c\u000f\u0012:lc\u009d.\u0099w\u001e\u00998.\u0088a\u00ad\u008a\u0092UM\u001b\u008d\f]\u001e\u0094\u001bi\u001b4\u0015\u0003Q\u0018\u000e\u0018Ut\u009b|;M7S^ng\u0090\u0011\f{aAz\u0006\u000fC7UBi/j\u001az\u009d\t\u0095sJ\u009aJd\u007fR{;]\u00117(\u001e\t\u001f%n8^\u0011*BM\u0019\u000b\u0085Dy\u0099\u001f>Q.\u00adnO\u0012O\u0002_<\u0091\u0081\'Z\u001e=O\u008a=6\u008f>\u0080 \u00806L{\u0084(\u00863jK6\u0086\u000fq/\u0004G\u000b\u0094H\u001d\u00ad\u007f\u0086\u0019\u0093}\u001d\u00814"\u0081Y|G\u0084w!\u0097\u0012\f\t<@)|R\rJT\u0019B;\u0018|\u008bpI\u0091\u001a\u0091^!y\u001cJ=\u000bNt3D5\u008bQ\u0096\u0018[B\u0092]F\u008e]q\u0012c\u0002\u0093D[hC\u0010\u009b\u0088#I>GI\u009e\u0014uM;\u0007\u0083\u001c\u0087\u0011\u0018\n\u0081D\u009cm\u001d@X\u0089F\u0017\u008e\u009c\u00138B\u0002sj\u0094O;\u00819\u001d\u0005l\u0001\u0017\u009c/tq\t\u001fBj\u000eQ|\u0096,1\u001a%Mg\u0091yF\n\u0005 U\u0088^9\u008b\u0084\u008bW4~-\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000*ZM\u0002\u0000\u0000\u0004\u0000\u0000F\u0000\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classS]O\u0013A\u0014=wPR\u0087\u008a"\u0088UhA\u0016x1\u0084ML\u009a\u008f\u0084\u001dv\u0097n\u0089\u007f\u008b/\u0098`|\u001f\u0019\u0006\u0083EkC9{Ng?\u007f\u0011&6\u000bQ)`,95=\u001bK&lfc*!|\u0015m\u00132]B\u0011t%a||\u0093zGy\u009c)\u0082\u008ev\u0085V\u009c&+\u0015\u0012\u001b"\u0094M?\u0094~"u$\u0091V~\u0011\u000f\u0085\u0016Q\tNnx"\f%\u0017<i\u0005zxel_]\u0095\u0011\u0094u\u0082\u0089O<r@\u001c\t\u0013~M\u0090L5a\u0002\u007f\u0019\u0002\u009c]o\'\u0010\u0014\u0091~&\u000eS;\u0090\u009d>\u009c6m\u008f#n\u008d\u009buB_\u0084"\u001a\u0018[\u007f\u009af\u0010)m*\u0083\u0081H\u009b\u0019jf\u008a\u001c\u0014p\u001a\\\u0007p\t\u001cLb\u0006\u007fs\u0089 E\u008a\b\u008b"Ld\'h@K\u009f0}\u009b1/d\fMX\u0018En\u0085q\u0015\u007fsYX\'>9|r9\u0012\\=wP5o\u0092\u0005\u0097y$\u0000L\u0091\u008c\u0085ift\u0096cye\u0004\u0099\u001d\u009b}\u0098\u0099\u0098l\u0010\u0015y:E\u0081\u001f1k-LYn\u001a3q2\u0019\u001c\\u\u0099M&:c\u007f#\u00802\u001c\u008b\u0095O\u00ad\u0004\u0088(&J`\u0007R\u0092\u0087\u001c\u00ad\u0001\u0081\u0099\u0004p6k\u000e0\u0019,X\u008c\u001d\\\u0089*w\u0099M\u0003/\u008d\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u00062\t\u0004\u0007\u0000\u0000\u0011\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classXw\u0014\u001dd\u0093l\u0006\b\u0081\u0004\u0013\u0014FMHy\u0012\u0081b\u0098\u0082\u00046\u000b6\u0018\u001a;n\u000663qf6\tZmQj\u0000\u0081\u0016\u0094ji\u0005k\u0012RU\u008f\u00ad\u0087\u007fOn\u0092]\u001f~u\u007f\u001b\u0080NL\u0087\u0004\u008c\u0096!\u0084\u0011\u0093\u0010\u000f!\u0000\u008d1\u008f\u0092e\u0088\u0017\u009d\u0097\u0003L\u007fPB2\u0088a\tF\b\fA\bC\u008f\u0007a\u0095\u0086D\u0010\u001a01\t\u0087BX\u0085\'\u0083x*\u0084\u0016<\u001d3x\u0096O\u009e\u000ba7~\u0084?\u000b\u008cy\u001c\u000f\u0017 E>%\u001f\u001c\u0012^b\u0097%"U\u0001\u001cqtw,HHx\u009d0;gahk\u0018\u009a\u0093Tm[\u0005#\u0095hOXj<\u0092z{\u008f9<\u001a\u0088nhTw\u000b\u0094z\u001a\u0004n\u000eC,2\u000f\u008b">\u008b\u0091XJlGu4\to\u0010gB?#\u0004\n:\u008b\u009eM\u001dU\u0093)eE\u0080:\u001c=\u001em\u0087\u0084:)\u008b\u0004;\u0093\u0091h\u009c!=\u000b\u0098znN\u0097\u0097\u008d\u0085\u0017\u0019\u0085\u009e/9i@ c[\u0098$\u009a\u001aYITF\u0098\u009a\u001cP-\u009d>2\u0012a\u0098c\u0086g\u009chn*l@~Vm4\u00adDjX3\u001c\u0081{\u001bsT\t\u0019y\u0095\u0004\u0096\u0010a`\u009f:n)B\u009c6\u0090)\u0002\u001d\u008d\u008b49T;{\u0093\u0007\u0011HRc/\u0095)L\u0095`:C\u009a/=y\rgz\u009b\u0093`9B\u009b\u0012\u0092\u000fYY\u0098z\u009bE\u001d\u0093\u0097\rl6.\u0005\u0088\u009b)+m994m\u009c52\u0003\u0019\u009bq\u000fC\u0011X\u0091,\u0096\u001eG\u0087e\u0089M2\u009a.\u0003e\u001a<\u001bdl\u001d2\u0010\u0015hM\u00842\u001e\f\u001f&\\:Po7(qS\u0015t\u0014G=)\u0013\u008db6w?\u001d6oB\u0011\u001c\u0015m(\u0088s(\u008c2b\u0099z\\\u008b+\u008f\u0099\u0096\u0012\u00866\td\u008b2v""\u00042N"*w\u0002\u0017ty\u009fn\u0094U^\u0095Q\u0095\u00176\u009eFb\u008cS8-=\u0019\u008c\u008c?\u008c\u000f\u008c?r$RIGz\u0088\u00951\u0016,,$|\u008fpn\u008e\u0091q\u009e\u001d1"\u0013\u0001P\u0019\u0098\u0094\u001d\u007f\nt.0-\u0083k]T\u0083\u0010hYLu\u000b[X[\u0096\u009d\u00ad^GThJ\u0017j\u0081\u0086m!\u009ci-X\u000f7\u0099:{#\u000b\u008a\u0006Q\u009eaR\u0095obf$\u009c!WW/\u0087\u0012B<\u001a\u009a\u001b\u00954N\u0093Is,3QhJ\u0085iS`\u0002\u009c\u0091;\u008e\u0017r5\u0016ln\u000e=\u000b\u0095\u0019y<9R9\u0019B\u000f=rZ:O\u001eS+g_k\u009f`\u009d\u0014\u008a\u0001Y\u0094*\\f,grz\u000es:I\u00804 \u0095\u0086Y\u0094\u009b\u0016x<\u0090I}\u0096\u0099\u001as\u009a-\u009f#_c\u0086%s\u0010bih\u0017\u0006\u009d0\u009a*E%\u008f8\u0082*y_\u001at\u0097f\u009d9\b\u0081\b.\u0015\u0015<<]"\u009etC\u001dF1a\u0080\u0096p$\u008ab\u001a\u008b\b\fNd\u0012\u0096IHI\u00045\u0081I\u0094\u0085k\b\u001b:Ju\r$@\u001cAH\u0083*q\u0014\u0018\u008awQ/\u008eY\u009cD\u0011%,\u001f=\u0002\u0010]Bly\u000b\u0001\u0017bK\u00ad$iahx\nG"%\u0081X:X\u001c\u0004R\u0005,\u009bF\u009b<}\\\u0099{Lpi\fV\u0014a\u000f\tZy\u008e$\u0016e\u000f\u0088S\u0090i}\u0013g%>@A=s\u0083(\u0097lNp\u0000Ek\u0010\u0003\u0011}\u0084\u0013\u00ad\'})TM\u00865Z`\u0002K.b \u0086ss\u008dX\u008e\u0010\u001f\u00119(cW\t\u0015owi\u0085BHz:DA_LlJ\u0019O\u008a\u0082\u0082 \u0006\u008f_[\u0015\u0004\u001af\u00999&#x\u007f\u0001\u009e\u0011\u008fFz]M&\u0017\u00178\u009dv\u009atP\u000f\f]\u0018}-3\u0099V\u0011p\u008b5:\u00853\u0013S?C\u0091\u0090k\u0088ADx\u009b\u0010\u0018:\u0093n\u000eq\t+eO)\u009fQ9\u0017T\u0007&\u00978&\u0085KB|\u0085\u007f\u008a+\u0093)\u000bwQ\u009c\u008bq\u0089<w\u009fW|\u001fvU\u0018~\u0016\u008a\u001d\u0012v_E\u0099\u0084\u0007\u008f\u0090]\n&\u0087H\u001c\u0090psKkMd\u001a\u0090\u009a$\u009d\u008c\u009fP\n\u0017\u001a\u000bH\u0083Y2\u0005$!\u0080\u0018z\u0018\u008fa\u001f\\\u0097\u0094R\u0091\u008d\u0015!F\u0003\u00078~D\u0014\u0003"\u0088U\u007f\u0002\u001f8^\u000b\u0084\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$\u0002\u0000\u0000\u0006\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.class\u009d\u0095mOP\u0014w\u001b\u0015\u0019*\u0088\u008fLD\u0003\r\u0091!\t\u0087\u0018\'\u009a`0W\u0017\u009a\u0016o;\u008doB\u0012\u0085\u0017~\u0000?\u0094\u0001K\u0006\u0092\u009cs~\u009f~\u0003\u0098\u0092\u008e\u0004r:\u0092\'I*(uZG\n7\u008c\u0092\u008aq\u0094\u0098e\u009c-rD\u001c\u0018\u0086_K.]Sz3\u0019\u008cB\u0098js5]\u0086\u009a#\u001b\u0086u,nV4\u009b\\k\u00960\u0003#\u0090%\u008ar\u0012\u0096w\u009f\u0092\u0007\u0090[c\u0088U\u009d:3\fWZ\rS\u001b6\u009d\u009c9\u009b^Rzx\u0018Z\u0094su-\b\u0090\u0011V;\u008b\u009eTJ?n\u0098I/GQw|\u009b\u0017m.\u001aUO\u0092Rn\u009d!eCw&#\u000e  @~\u0011+\u008e\u000f\u0095:0\u0007r\u001d`\u0080#:L\u001e\u0089:\u009e\u00ad1\u0089)[\u0011PR\u00972q\\\u0018U%7\u0096\u0092#63\u0019\u0006\u0086\u0090V\u0097\u0006t\u009c20\u008f1\u0003\u0015,\u0018\u0088K\u0006`<\u008eE\u0086\u0096\u0088a$e\u0098=y\u0003\u0019&z\u0083a\u0018\t\u001a\u009d\u0005io\nS\u009ex[t\u0015\u00ad)<\u0086L/gd\u0095\u001a=Ij\u001a$i\u0088\t0iOH\u008b\u007f*\u0010\u0017~"Cj\u0084AQ\u0000{\u000f\u009dI\u009c\u001cgI\u0082/),9\u008c\u0085\u0010\u000b\u0088}k4\u000f\u001c\rq\u0096\u0084\u009cg\u0014\u009f2`\u0007\u0018(LB~\be\u00026n0)I\')Be\u008c\u0087{a\u0082I\u0005\u001c\u0087\u009f;rLv\u008e\u0019\\\rQ\u0015_\u000fQ\u0094\u0095;\u0082\u0004\u008c0AS\u0016B\u001e\u0092e4h\u001ed\u009a\u001d\u0015v6lo\u0092\u0086_\u0094\u0099\u009a\u0081\th8%\u00181\u0005+a\u0004U\u0015\'\u0014 \u009d\u0007PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>\u0002\u0000\u0000\u0006\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.class\u00adUn@\u0010=\u009bq$\u00946\\%)MK@)p)\u0015E\u0015 \u0005E*o\u001b\u0004\u000e\u0085O\u000bx\u0001$\n\u0088J|\u0000\u001f\u0085\u0098M\u0092*A.\u0015/\u009d\u0099\u008cgf\u009f\u0000P8\u00120*wTz\u008cc\\\u0085\u008e\t\u0005\u0093*\u0014L+(\u0088cVAQu\u0086\u00844\u009b\u0095,d\u0096\u001cQ/\u00055\u0082\nOp\u001f\u0012C{i\u0099\u001e\u000e\\\u0090e;\f\u000f`\nCdQIh5x\r\f\u0094\u001c\u00837*\\X\u009d\u0011\u0099.Cg9\u000e\u0017Z\u001eu6j\u0083I\u0085,s\u0099]SMj\u0092%}\fP\u008a\u0085\u0006\u0085\',4\u009c!E]&\u0015\u00968\u0086c\u001f\u0010$\u008e${\u0017]pG\u008d\u0098o\u0015RNK\u0018\u009a%\u008dti!\u0089\u0094\u0086\u0098\u008fS\u001anbX\u0086[XPa\t\fs\u0081\u0099Lf\t+~\u0098a\u0097[f\u0098:\u001e~\u0081Z)9hOS\u0086\u007f\u00ad\u0082\fcs\u009e\u009bmqr\u000f\u009c\t\u001a|\u001a\u001e\u0004FdU0L-\u001e=\u0094\u0013_qkvrl0.\u0092F\u001f\u0010\u0006|\u0003\u0094\u009cx\u0084\u0011!\u001a\u0000\u0019J\u0084\b\u009a\'vt\u0015!}r\u0017OYY\u008a,T6\u0082$a\u0088|i\u008a\u0019Z\u0003\u009d\b\u0011\u0005\f\u008bdKTT\u009f\u0082\u0087C(\u001d<C\u009e(.\u0012\u0019.#\u008d*\u009f\u0011&>Z7D!\u0007eSZ2B\u0099#\u0087o\u001fo+5U\u0010c\u001dC{\u0095\nB\u008f\u0014*^\bv#8GNi$y6\u0012\u0098\u008e+\u00111E\u00888\u00ad3$r]\u008boPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%\u0002\u0000\u0000\u0006\u0000\u00007\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.class\u0095TmOP\u0014~Q:\u001c\n\u0080\f\n\u00832@\u0010\u008a\b.,Yd\u0086\u008fe4kI\u0011\u007f\u0086?\u0084/~\u0001#\u0089_\u008d\rN6).]}s=~\u000b\u0080E\u0094%d0#\u009f0+bN\u0082\u0000U\u0002J"\u0016E,IHs;\u008d\'"V8|US\u0011k"\u0019z6L7\u0019\u0092\u0005e\u008fA(;\u0007\u0006\u00adi\u001b;\u00ad-\fV\u009dn)L\u008f!{\u009b\u008e]v\u009aG\u008e Wlp\u0096y\u0006!\u0096\u008eP\u001b~`\u0019j2U6u\u0080y\u00ad\u009eN_\u0018z`QW\u0085k\bH-\u001eT\u0088\t\u0012T|%|\u00914y`P?UK\u001bjwM\u0085k\u0004\u0017\u0016w\u000f\u008duz\u0094\u008a\b-\u0000\u009e$/0L\u0004[3\u001bxM7-O7\u000bIRiu;?\u0091~\u009eSb@\u0006\u009e\u0089\u0099ZaBh\u0005\u009f\u0013\\\u0016i\u0082a+6eY\u008c\u008a\u0019g\u0099{"\u0006!c\f/\u0018&q\f\u001e\u000e\u0016v\u008ea[h\u008a\u0082Z00\t}\u008b\u0003\u0005m\fj\u0086]{\u0096\u0090\u0085a=e\u009eB$>\u0095P}4s2|=Q*teK\u008a.@\u0001\t>rd\r\u0092\u0092d$S3gH|$%\u0081!zp\'\u0086a\u0010\u0080\u0011!x\u008b\u000fD\u0096"2{\u008a9\u0084\fO\u0080Sp\u00ad\u000bHswnL8\u0085tr\u0099\u00ad\u001fI"\u008e!\u0003y3\u001c2GYv\u0017\u0082\u009d>i<2\u0087\u0007\u0098<\u001dl\u00924!M{\u0018n\u0095V\u0088\u0017\u0099\u0099\u000b\u0015\u007f\n\u009a#fdY"\u00925\u0092\u0089>{}FCNS\u0098#ZOq\u0080\u0010H\u0005INQ2(R8S<i\u0092\u0018\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000fC\u0098\u0001\u0000\u0000\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.class\u0095\u0092J\u001bA\u0014Y\u001a4\u0001\u0014JoJP\u0003\u0085\u0085H.\u009b$:\u0099\u0095\u0089\n}\u001c\u0004/\u0000}3\u009b\u0080\u0088\u00854\u0017\u0099\u001d\u009c\u0017\u0080#B\u0014\u0011F\u0080\u0000UBXie?\u0013\n\u000eo}IXl)-O\u0087\u00834\u009bpf\u0095D\u0011F8K\u0095\u0011\u0096\u00adJ\u000fa2iVXT4Dd\u0099dVj(6\u009f\u0097\u0099\u000e\u0006B]\u009fQ]\u0019AXH5\u0087\u009e[\u0001\bO\u001c&\u009fBT3k8\u0090\u0012N\u00ad+q#D8j[t\u0098\u009a\u0010KMd\u008fT\u008b\u0011W^\'\u0000\u0084d\u0087\u0086[\u0083w{H\u008f\u009bms+a\u0006\u0000;\u0084@(?^YJx\\\u0011a{(\u0084$\u0093_\u0087{\u008aL \u0004|\u008aX\u0089uf\u001e\u001d\u0007\u001efs\u0013\'\'8.\u008d\f\b\u0002ygXu\u0019+e\u0015\u0097/;\u0018\u0089\u001b0\u0082:^eor[n\u000f\u0014}\u0087y?"k\u0099\u0095\u0097g\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000E\u0002\u0000\u0000\u0005\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.class\u0095TN\u0013A\u0010zq\u0094Z\u0004DQ\u0011\u008bGQ\u009f \u001akL\u008c\b&(\u0006[\u0097rxk\u000e\u008f\u0013/$\u0002\u0089&>\u0080qv[\u0010l\u0093B\u0093|\'\u00809<E?L\u009d\u008e4\u008aB-0\u001a,\r:4\u0014\u0085(\u000b1\u0097m;\u0086{\f\t\u001e\u0018#<8t\u0002CO\u0088\u0012TRXgP+Aa\u0018Xv}ge\u0084o\u0088L\u0081u\u001eBo\u0019x\u008d\u0018\u008cU\u0099\tC\u000bw\u008aSk9\bkV-Ul*AH\u009a\u0087\u0091\u0013NS\u0001\u009a\u0013?s\u0086?:\u0098/t*\u007f-\u0087W!h\u0090\u008a\u0083\u0086\u0007\f/Tww~e\u001b\u0010e!\u0018rg\u0089cDQ<?K\u00959p}-\tm+\u00860\u00860#B\f\\@@\u0016\u0083B<40\u0080\f1/\u0095\f,`\u0091a\u007f;WuB\u0003\u008fd:\u0018\u00189_\u0098\u0086\fsf_v\u0094k{\u000fE(a\u001cs-\u0086\u000e\u0093-+\u001b\r\u0012N\u000emVnD0N/MOWvR/i\u0097\u0015-5)m\u0083\u008bJ\u0006i\tZ\u0007C$}fq\u001flO\u0086\u000e0\u0015`z\u0098\u0082^\u0096@\u009a\u0018&x3\f#\f\u009dHN$RhOh\u0089\u000e,\u009af\u0093\u0007\u0082\u001f6\u000e\u0091\u0012j/\u0019-\u0007b.\'$\u001e\u00814hx\\\u0006e\u00adF\u001f&&E\u008b\u0080EpL\u009a\u00070v\u008fk"\u0019\'\u0090\u0092M\u008cF+x\u0095\u0002\u009c.\u001eB;\u001d\u008e2l\u001c7DD!\u001an\u0086\u0088]\u000e\u0093HdR\u00856fTnG#f\u0013\u0012ZA^\u0002F|\u0014\u001a\u001d\\\u0082N3_&\u0017PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.class\u009dTO\u0013A\u0014fv\u0085e\u000b\u0015*Z@Rd) \u0084\u0094\u0010H\u0013\u0092&ULjH6\u0094MY\\v\u0096\u009b\u0097^@\u0089\u007f\u00931(\u0016\u00ady?\u009buf|{\u0011"VtcF\u0087.\u0017\ry\r:T\u0091\u0086yM\u0090\\];`P\u0085]\u0006[\fC5\u009e\u008e,s(3\\\u001a\u0015-8\u0086\u0007v\u00909\u000em\u00ad\u00876+E\fFu-\u0088 \bVc\u0099\r6\t{$}\u0099\u0003]_5\u0088\u009ak\u0087D\u0098\u008ep\u009bf\u0007Y\u0014t\u008b\u0095$."\u0089\u0010\u001cx~H8G@T=\u0014\u008dWOq<\u0095;{\u0087V#,wg\nU\r\u008b\u0011\u0094\u009c^`\u000b\u009an7]\u0011\u000e\u007fb\nm)z\u001bTJ{-amrLWyy\u0080\u0081\u0094\u0081%,kx\u0093cE\u0004V\r,7C\u0011\u0013=\u0010\u0081Qd\u0018fX\u000btXG,\u0086\u0091b\u0098O%q,\u0019\u001eD\u0086nd3Xw\u0083a\u0080^\n.\u0085h\u0090"\u0093,#\u009b\u0098\u0000\u007fG\u000e\u0010\u00adI\u0099\n\u001b\u001d\u0000n`\u0084,\u0093\u0087?C<U<\u0087\u0081\u0085l\u001a\u00adS\u0019\u0012\u009d=\u0093)\u0012j\u0003\u0017\u0002\u0089"\u0093m*D\u008d\u0001\u009e O"5L>\u008e\u0012\u001f\u0012OE\u0084\u0096;McB\u0085\u0011-!\u008f\u0013%\u008c."\u0087{\u0081N\'\u008dM\u0015\u0006zz\u008b\u0019\u008fY%B65[\u0004m\u008e~kE\u0093T\u0087BZ\u0093q\u00915<\u0016\u0094]/h\u0003\u009f}L\u0082\u0007\u0011>\u0087\u0087\u0091\u009dMc\u0094G\u0001MHx\u008f)\u0088PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000\u0004\u0000\u00002\u0000\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.class\u0095SoP\u0014N)\u0014\u000bs\u00809\u0015\u00117\u0018\u001b\u0019\u008c&\u0012MLf\u0082..vF\'_|\u0007\u0000(-\u009b A\u009aG\u009d\u009c\u0017\u0080\u0003mdQ\u0091C-\u008f6xbaB\u0083\u0090{I/zI4\u009a\u0004\u001b\u008c\\j\u0093d\u000fbs\u000b\u0086?\u00164iF^H(\u0017*tU?\u0012\u0011\'\u008btU\u0017av/Pcgw\u009d9`2\u0011r;$uTy\u0087P\u009a\u0088/\u0003\u0097#\u0015\u001d}\u008c@\u0012\u001b3I8\u0090c\u001f)O\u008e;\u0013B\u000b/ \u0019Z\f\u008e\u0012\u0014\u009b\u0085&\u009cWt\u009fi2qfYC!\u0090\u0087\u0081\u0010z<K)\u0090)\u001b9Ki,yGm|~J\u000f\u009a`\u0083s5tz7f0m=M\u0011\u0016\u0004*l[\u0016ZEla\u009fl<\u001c\raD8X~\u00844K\u008e\u0082g\u0098\u0088hx"\u0006V\u000e`\u0015\u0080p\u0083#\u0087-\u0080\u008d\u001d\u00036?s:I%\u0014/&\u0000\u0080JP\u008e\u0089*l\u0013\u0092\u000eW\u0019\u009aU|\u0087\u001aZL\u0091@\u0012\u009a\u00855\u0010\u0013NL|\u0017\u009b\u009c\'T\u008ac+J)\u0084)O\u000b\u009f5c\u0014\u0097Rz\u0097zx\u0080\u0087qY5?M\u009b\u009bm\u00986Wl6-\r/\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pX\r\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUR\u0013Q\u0010=w\u0092I0@\b\u0010\u0085\u0088(I\b\u0084\u0097\u000f\u0004\u0090*\n\u00adBY$Sqt2CM&//.\u008aG\u0095\u000b?\u0095\u001b_\u000b7n/XvOB\u0084P!.to&\u007f}\u0007`\n5\u0090\u00866Z\u008d\u0099\u0083I\u008dR\u001a5\u0001I\u0088\u0086@#\u0096\rw\u0095\u0003\u0002\u00036%K\u0096FY`|q\u008b+\u000b\u0096\u0091[fn)\u0095]X6m\u008a\u001b\u0083\t\u0084[\u0014H,?\u0093/d\u0092v1]\u0001V`0S\'HdMoAH\u001delNZ5\u0081\u0092S8eR0r2FN^Zk5y\u001f\u0004S\u0093D\u007fb?\u009d\u0097Mt<A\u000b\u0081\u009dE/\u008bnR2l\u008fM)\u0094z+\u0096rO\u00adIs\u0003;\rm\u00991&k|DN\u009b\u0096OlV\u007f\u0098^I\u007f\u0004\u009bI6Sl\u0005\u0086O\u0002k\u00ad:\u00157o3y#9|G\u001d=esSG\u0017:\u0091S\u0010\u0006\u00981\u008f[Q\u009b\u009e!0\u0014\u0000 \u0096mEd6\u0017J`$ua\f6{\u0004\u0002\u001dPrMZ\u00155z\r\u008e\u0094 }\u0005K\u0019B\u0082\u0007B\u0004\u008f4%\u0011(<>P\u0015\u0095h\u0017&\u0097\u0011P2\be\bgvn\u0081\u0082$$T@|\u0084*>A\u0013\u009f%W|):T\t\u008f3\u0080\u0082_qI_q3!\u008a\u009et\u0096<g):\u0011\u008e\u0088o>^=\rx\u0005c @\u0002\u009aC!:Z\u0003_ eYq\u001f>8YMHEF\u0082\u009fw@@9\\"\u009e!v\u0010C\u0094\u009cz1\u008b\u0089vx\u0095\u0095&\u0083\u0080k\u009d\u0014$}\u0011\u008cf!\u000fuTsj]p99\u0086+\u00811\u008c:*\u00854*4\u001ff\u001bE\u0007!\u008a\u0013\u0093\u001e\u0019\u009c./1Y\u009c\u009f\f\u0087?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009b\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineParser.class\u009dYi`\\\u0091J\u009a\u00997zze=`l\u0003\u00961S>\u0000\u0019K6\u0096\u0091\u000fXz\u0092F\u001e\u0088\u0099\u00118B\u0011\u008e\u0010\u008e`\u0013\u0002\u0081`\u0087\u0004\u0082d\u000b\u0081M\u0012\u0012a\u0083=\u0080\r!l\u0000~\u009b\u0019\u0089PwOwUuUuO\u001d{\u0010\u0080YT\u001e:jW5\u0016\u009fh\u0083\u000e/>)s3\rO\r>\u000b\u001dyRa\u001d#|\u001c|1\u001c\u0084\u0014W\u008b%G\u0018cxS5\u0015E\u009e\u008e]%_\u0018\u0019fFe\u0014u\u0091\u0002\u008cPt|\u009de\u008c&cu\u0094\u0013\u0014\u0097q\u00198&&\u0004\u009c\u009e\u009a\u0089JO\u008b\u0094|</\u0093&\u0093uH&\u0098+S4\u00994\u001de\u008eZ9MQDbzAJu\u0095\u001a)\\r%m\u0099\u0097\nzE*J\u0095_.3Us.\f5\u009a\u00ad\u009c|\u0096\u001a\u009c\\5\u009c|\u0002,T\u0017iXG3\u0005\u0012\u001cHx\u0004f\u0019R,Sv-UVY~9[y\u001c]e.*4P\u0013\u009e\u00874Z<V\u0093&\u0081Q\u001f\u0089\u0098e`<n\u0005Vw%BHS"\u0016\u008a/\u008b\n\u0082\u0089hL\u0093u\u0082\u0082q>\u00127#P"t\u0089\u0099M$(\u0017L8?=\u0012\u0019\u0017\u0004cq3\u0094\b&LMssOA0e\u0002AQC(\u001ej]Z-um\t3f5i\u0016\u008cf\n\u0089mkG0J\u0001Kh\u009adc\u0001u;\u008313cM\u0082\u008c\u00890[\u00821_a5u\u00adX(\b\f^\u0012N\u00841U&\u0098V\u0091\u0082QQ[=I\u0019\u001b\u0082]k\nG\u0082\u0089\u0018-\\\u0091\u0019\u000eFm\u0001WEc`kn\t\u0087\u001dV\u0085"\u00adE\u00949:\u0018\u000eGw6\u0084v\u0099\u00ad\u008e\u00041|yqe4\u0015\u001d1P<-l\u0089\u0005H(H\u0090[Rs,\u008b\u009aJ\u007fc\u009b\u0019[\b\u0005\u0085-`,~;\u0093\u009eDG\u0088\u0092|\u0085K\u008d\u0004g\u0096l\u001aloi\u0004\u008b\u00ad5M\u000e%\f9.b\u0088I+v\u0098"\u0098[\u0092FUR\u008a\u000fo;R`\u0090FN\u001b\u0014\u00943#\u00ad\u008cm\u001eL=\u0083 \u009a\u008c4P\u0017%$l\u001bu\r*\tcLa\u0014te+r"n\u0006\u0016\u0093uUC\u009b\u0097i\u0080J\u0006\u0085\u009b]B\\\u0005\b\nk\u0014X5Pj:\u0003)B\u0088p\u0002(^\u0017\u0019H\u0098i%\u0083\u0004\u0085n\tZk\u001bn\f\u0089\u0019\u0092\u009d_\u009d>N\u0082\n\u0017\u000e\u0012\u0011\u0004\u009c&3A\u008632g\u0016\f\u0007R4d\u008a\fZ\u00948?\u001ely\u0006O\u008b\u0001m\'\u0011\u0088f@h\u008c%s\u009eUu6\b\u00923\u0005i\u00ad\n\u0095\u001e%p77\u009a\u0091DL^aE\u0099\u00909\u009aV\\\u0084\u008aEW\r\u0099p vX8\u009d)4iFf(Ma\u0084}\u008e.l?F,\u0083N@6\f7w\u009e3E\u009a\u00045F\u008c\u0086\u0018p\u000bJ\u0004-\u008b\u0086f\u008b\u0015\u0000n1\u0002R^:t\u0004[\u00ad\u0093B\u0014Y\u008b\u0099d3\u0089\u009bR\u00ad\u00adM\u001d\u0084A\u001b-Vvm\u0082\u0081\u0007\u0004.(S\u009eYn\u0091Z\u001cQ_;S\u0099\u0007[Zx|\u009c\u00993\u0005K\u0086F\u0081R^9f\u000epU\u009cg\f\u0087sPY\u0091\u00141O\u0089/ \u009b}\u009bMX\u000bk#\u0085\u0006IRr\f\u008a[\f\u0080\u001b\rFD\u0081-\t;\u008d&-\u0086\u008ai{OP<\u0014\u000e\u00921M\u0083t\u0086\\\u0090\u008dku;5nHXv\u0018\u0012\u0091!]r1\u0011%\f\u0089\t0\u0090\u0084t\u000b*\u00871T\u001b]B\u00adt-\u0086\u0094!\u0090K2C.\u0097+\b\u001d%\u008b\u000e2C!W*o\u001ar\u0095\\MxZm\u0085U\u008c3W\u008cq\u009f\u0006\\lE,\u0016\u008d\u0019r\u008dRz\b\u0085[U\bV3[r!7(G(W\u0018r\u0093|\u0090\u009bjCn\u0086*\u0019\u001d%*\u0006!wYX\u008a\u008d\u00172u]4y\u0082\u0087Y\u0016\r<\'\u0094kP\u009d\u0086%w\'\u008dt3lu\u0002\u008fY9L\u008f\u0018C\'d\u0098R\u0017\u008b\u0005{\u001423$*\u008a\r\u0083\u007f0d\\/\u0080!{^C/hr\u009f\u00817\u0007\u0086\u009f\u009e\u0002kC\u001eP\u0099\u001e\u009f\u001e\u0088:\u001b\u0001\r\\l\u0083\u0010\u0099n\u001d\u008f\u0018Eb`*c\u009d&{\u0015>V\u0004i%\u0010=\u0018f\t\u0083wbeic\u009b^<cz|Fq(^\u001c\f`kOq+\u0088Zr#\u0086DB`$\u0012M\u0014\u0007[[\u008biAF\u00923-6M<\u0011\u008c%\u008aw\u0086\u0012\u001d3*gT\u0019\u0016\u0086<*\u008fi3\u0095\u000eQaJ,\u008eF=-H"\u0018\u008aP\u008e`\u0084B--\u001d<\u0016\u0086X\u009c\u00ad32`qC+E&\u0096l^|\u0094{r\u0096RC\u009e\u0090\'!c\u0089%\u0092!\u0089\u0086|>\u001bR\u0089^\u0089ww`\u007f\u009d\f\u0007\u0084OF\u009f3<,\u001dd\u001fn>g?\u0005\u0015_y2\u001c|\u0097\u009f\u0098%\n\u0007\u0080zX>"Nd1V\u0093f\u0090Y\u001072pLb\u0000h1s}6=Jq\u008a*9DuX\u0004U?\u009b}\u0018e\u000f\u001f\u009b[\u0015\u000e\u0082eN(q\u0019%B=\u0097:\u0082FsWz\u0013~\u008c-)u+Z\u000bv\u0004{\u0097p,\u0091|\u0094\u0015\u0095\u0094\u0083\u001b{`8\u009eE\u0090<\t\u0012\u000fr_nC\u009dc^{[\u0089\u0092z\u0012v\u0084\n4\u00136\u0098\u0097<[]k\u008ct6SNo\u001c;:\u0013\u0082\u0016\u008a\u009a\u0083C\u0093q\u009b[c`|\u009d(~zv\u0082V\u0086\u00127\\e\u009f\b\u0018\u007f"\u009az\u0096>L\u009e\u0019P_kp\u00176#\u0089\u000e+L\u0080h1\u001aI\u001e`\u0081E\u00994c\u0085/]Ain\u0016\u0099\u0019<hw\u0086\u00900=\u0097\u0002\u0015g3\u0086Nj\'"@#yYk>nV\u0017\u000e\u007f\u00050=t\u001a\u0090zi\u008fH_\u0085r3\u0012\u000b%?~u\'\\\u0017\u0093\u0087\u0004vB\u0091\u0003\u008b\rA\f\u008a7o}mh~\r\u001d\u001dW\u0084\u0081\u0087s\t\u000f\u0001_\u001a&%@,y\u008e\u0091<\u0080\fM<k\u009a\u0019\u0013\u00ad0nGRZ\u009eA<\u0005[1Q; h\u0019K&\u0019i13|d7L]$7$\u008dJ\u0093Ah5\u0098\u009az=\u0004\u0082\u009e_\u0091.\u009fq*:\u0016\u0080\u0017\'\u0097\u001cF\u0086&kml\u008doU}\u0004\u0011\u001b\u009awk\u0011r9r\u0001xm>\u00003y\u0083\u00ad\u001e\u0098\u0003\u000fN\u008e\f\u009b\u001ewnW}\u000f)\u0094\u0085\u0015m^YAhO\tYL+,\u0001l"G\u0080\u001a\u001e\u00877<\u00157hb>x\u0091\u000fi!_p\u0000\u0001\u008ch\n9\u0080Q\u008d}(\u000b\u0013a`F\u0085\u0082\u0098Zoe\u008b\u0080\u0017v\u001f\u009b\u0015\u0084}r\u001f\u00038i7N"eK\u0093{1\u0017\u0014\u0012\\N\u0082I\u0016AU[\u0017\u0093k|6e\u0011)\u008a\u0015\u00ad\u0016\u0002=\u0095Lg\u0093i\u008atE:\u0014\u001bRt\u0093\u009f=("4RA~?(N{\u0081,$)\u0003>)Y>gGK;,J\u001f%\u0014TZX\u008brE\\\u008b\nO\u0007\u008d\u0080?i.UMj[\u0093W\u0094\\V *Rv\u0015\u0099"uG\u009e\u0012Yxm\u009e;>,.\u0092\u000f\u0087K\u0011\u0091lwlfe/NoE\u0088\u008a\'Q<L`\u0012LE\u0013\u000e+q>\bb\u0003\u0002\u0019Wb#`\u0013cm3\u001e\u0016<\u008d\u000b\u008a_"K\r\u009f\u0005*#`x)h\u0097btH):Ll\u0097&\u0084e\u0013vH\'\u0085.\u0002\u0017M\u0088^Q~\u0006;9T7C\\)\u007f5\u0019\u0093?z9\u0086\u001bsr\u0098\u0096*\u001fh\u000fp?0\u0019\u000f\u0087\u001c=\u008cQ\u009cF\f{\u0095t\u001aw\u009b\u0082\u0007\u0010t\u0089c1~D\u008e<jZs<gT\u008aW)!r|i9\u001fY)\u0099}\u001c\u008f\u0099q\u0013#<\u0082\u009f07)5ct~\u009cY\u0080\u0082c(\u0090j\r\u008f`\u008e\u00861g\u008c?\u0082\u0012\u008e\u008e\u009e\u00ad\u0086]Ga,:h\u0012\u001c\u0086\u008f,\u0081\t\u008e\u009fS\u000e\u001c\u008cB\n\u00ad\frg\u00adT4\u0014\u001c3\u0084+"d\u0090\u0088;(N\u0017\u0011W16\u009eE\u0088\u0097k\u009c\u0000f5\u00947V\u001ex\u008bE\u009e\u0007\u0099EY\u008adN\u009e\u0091\u0083>\u0086k\u008cUa\u008e\u0006!\u008ct0F!SE/w\u0083\u0081X\u009eS\u0002\'Md_8\u008f\u0081\u0091g\u009dM\'9K\f(=SX\u0019\u0007-,3\u0013,-N\u009e=\u0019u\u0086S9Pi\u009c\u0086\n\u0005\u001dQ\u000fc"\u0099\u000e\u0005%p;\u001fs\u009b\u000f`\u001eq\u0096x<\u0099\u0000\u00166V\u0080\u000f\u008b\u008b~,\u0096z*-w\u0012\u001c\u0087F\u008eG|\u0098:%f)X\u0010JX\u0096\u0014\u009cBV\u0010\u00124[J^ \u0091^\u008d\u001cl\u0015T{\u001e\u0094\u0080\r\u009cp\u0016\u0085\u0081\u0006\u0085g\u001f9\u0085*+/#\u0092\u0007ZJNx\u0002y\u0001\u000f*\u0099\u008c\buR6+|*\u001a,&\u0091\u009dVUV}\u0010\r5^\u0087bi\u001c\u0095bY\u00ad\u00875\u0016\u0015\u0085y\u009e\\$h:\u001a4"i4\u0088hp\u0083m\u00947\u0083H\u0019\u008f8\u0089T\f^R\u0094x\t0K\u0019%\u001fk\u0098\u009fAg\u0084\u0093\u0019r7s~!o\u0019_\u008c\u0001\u009e\u009c9`9\u0086\u009f\u008b\u008e_\u0010K_\u0094\u0002$,+\fJ;~);\u009a\u0086%!My\u009dxw\u0095#){9%qG\u00882\u0007wR\u009f\u0017\u008c\u000f0\r/r5\u008f{\u009d\u0082\u0097,5\u001cq\u001fBH\u008d\\\u0088\u0097\u0089\u0083\u009a\nd^pKP\u0093\u00177x\u009dY\u0010\u0090+b\u0096\u008b7X:yx\u0093YF\u009b\u00adS\u009a-18gO{zSe\r\u0018y\u001cNva\u0095`aZ\u0081x\u0002\u0005\r5m\u008b\b\u0016\u0012C\u000fd"QLtLq:\u009b\n\u001cec%,3w\u0084\u0085]}\u0018s\u0014\u0013S\u009e}~e?\u009a\u00192\u001b\u001b<\u008b_\u0081p>lJ\u009b0\u009bjA^\u0005i\u0086\nu\u0017oQE\u008ep\u0000\u00148~?\u009eoSw\b/-Ow\u0089g\u0012K/\u0014\u009eU\u001aGy\u0095^}B\u0095\u008c\u0087,ZJ,;\u0096\u0090\u0096;\u007f\u009f\u0004x\u008eb\u0086f9\u0002r\u0002\u009dKa2J|\u008b\u007fs=S\u009e8TPqhQn\u008ds\u0083YQ\u0099U@\u0094O\u0081~lm.I=oA\u0004\u000f`\u001b\u008b2\u0005/-\'a*o}\u008fC\u0091Ms\u00ad\u0087w\u008diV\u0001\u0084\u001a*,K:&U@cHb{V5\u0094ky\u0086E=!#&\u001fP==\tkO\u0086?r]\u008d?1>g\u008e\u007fA\u0092y{8u\nca*^\u008eH*\u0087R!V\u0095g-y\u0087h.\u008e#f\u0080N>\u008c_{\u0014EV43$\u0016\u000fff\u000eN8\u009c;ldO\u0097\u000bsN\u009d]w\u0096a\u009f\u0013i\u0089\u0002\u0004\n;{\u009d\u0017\u0081g\u001f<Oaja v<\u0005s[\u0080G%.X"\u009c"\bQ\u000bkG\u0011OaXg\\\u0017\u009fp\u0017\u008f\u009f>>\u009b.a\u0093\u009cxtv2\u008fg\u007f9+\u007f\u0083#_\u009b;q\re\u007f\u001dV\u0013)^?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008b>\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/ParsedCommandLine.class\u0095Wiw\u001bg\u0015~F\u008b%v\u0093TMc[\u0096\u0018\u0092\u0000R\u008e\u009b\u00908S)-L\u0089T(\u0091\u0013\u0094.Phli7\u0003\t\u0090\u0014\u0092`rX;\u009f\u009c\u009c\u0098}g$K1G}\u009f.3?\u0019\u0001.\u0082v\u0098*\u0011`!\u0089\u008b*\b\u0082 .\u008ab\u0004u\u008ef\u001e\u0013T\u008f\u0093,.+*\u009eWB\u0004M0#h\'".T=^a\b}:\u0082\u0016|Fk\u0011t\f0^\u00177\u0084/\u008b$\u0096_\u0012\u0000_V\u00950\u001aA\u0017V\u008fMa\rq[\n\u001a\u009d1s\u0085#+3\u0095\u0099/\u0003E;\u0093\u001d\u0098\nf2\u009cn\u0017-C#2\u0003\u000ei\u0007\u0096\u009e\u001a\u0003\u000b\u0093U0R\u0092\u009eKMfr)y(\u0091\u001b\u0096Q0r*T\u001f>c4yZq\u0004\u008c%sH\u0095\u0081\u001a\u008c\u008fY\u0012h\u0099\u0014\u0004M-C#\u0099\\\u001eU\u001e08a\u001b\u0096~.k\f*\b\u008c\u009b)Cx\u008bK\f)LAt\\\u0095\u0011kWYp#\u0084A\u0099\n\tFA|\u0094Ww\u001e/\u0080\u0098)xV5Kx\u00ad:\u0095|)\u001e#wOPc\u0017\u009ec\u009dI(\u0015V\u001d\u0005^y\u0016U6K\u0012b\u008d\\j\b3Tp\u0091UG(\u0088\u008c\u0014|VQH1\u0093M\u0019\u0096 7S8\u0096\nR\u008a|{\u0085Y\u009b#nQ/\u00945^kKo\u009a\u0016u\u0012O;=F\u0082m,R\u0011hq3\u009b5\u0016$bwcLO\u001aF\u0099m\n\u0012\u009e\u000f\bLn"\u00149mG7M\u0094hz*gJw\u008dr\u008b\u0000v\u0094D\u009cEc\u000bYey\u001dK\u0084?a{?\u009cqZ:f\u0002y\u008cY\u0016\u008cc\u0019m5\u0085\u001a\u000e\n\t ^Xd\u008bk\u009a\u0007\u001c\u001a\u008f\u0003\u001a\u000e\u0080\u0082\u00076\u009e\u008eY\u0096"\b\u0001|P[x[w=\r\u000f\u00141s=>4\u0010?RcfUDO3\u0005\u00078\u0014*$c/\u001fGW\u0086\u0012*S.\u00845\u009c\u0093\u001a~\u008eUn\u0098\u0017\n|\u0098\u0086_\u0097\u001c\u0017=\u001a0\u00ada\f4\nWU\\0\u008f\u001a~\u008dpWL\u0007HZ\u0096:zypy\u0014*r\u001dK\u0019\u0019}j\u0015c\u00ad\u0086\u0006\u009e\u000e\u0092[\u001cv.\u0095\u00942}Ri\u009b\u008c\u001f\u0097c9SVUPP\u008cI\u009dir+\u00039\u001e\u000e\u0091\u008egS\nQZ\u001ey\u0088\u009c\u0087\u001aO\u000fBMkI\'G> \u001b\u0014=\u009f7r\u008d\u0091W=~\u0084\u0017\u009c\u00adgD\u00ad\u001e1\b\u0002[f(\u0003O\u000b:6y\u0085P=\u009fJ8\u009eJ\u008de\u0014\u009c2m\u0087s\u0000QP0\u0095\u000f\u009a-^^\u001f5[\u0010y?\u008cAC\u00802\u000e?TjH\u0086\u0092\u0003mo"@1H1t\u0013\u0086\u0018XG1r\u0013}k\u0014L%C\u0015\u009ch\u009c\u0083&4\u000f\u0005o!\u0086\u0007\u0014\f\u0005;\u0082]LHe(\u0094=\u0002\u001d\u008e\u001aZ\u0098[];7d\u0090?\u0082k\'W\u00ado\u009d\fA\u0013\u0085\u0019\u0086\u008d=x\u0015\u000f5:I\u001a\u008eC\u000fa\u0001\u008fb\u0014!Z\u001dcx\u009c(\u0013D\u001d\u0011\u0006p1\u008e\'\u0000)\u001d1a\u001a\u008e8\u0013\u0094!N*\u0092*&T=thT\u007f_\u0012P;=\u009c\'\u0092X\u009c\u0002\u00ad/\u0016\u0013\tF\u0099\u0080\u0010\u0018\u0014bX\u0088\u007f@u\t#Bwvp\u001c\\\u0087}b9\u0087x?}\u0007\u009dd\u0093\u0095\u0080T}HH.o!\u0092\u008c\u0085s\u001ey\bV\u007fOCI/\u0017a$\u0010\u0017qa\u0092\u0015x\u0090A\u000f1\u0015cx\u0082\u009a)R_J@\u001c{\u0011& (+\u0093}\u009a?Av\u00983x\u008aG\ff\u0099\u0094\u008d\u0004\b97\u0001\u00adCTEB"]t\u008c\u007f\u0094F\u009c.\'\u009c\u0085\u009c\u009bt<2\u0011i 1i\u009b_3\u0019%\u009c\u0082\u00036\r;A\u0093\u0081\u0018\u009eq\u00936\u0001A-V4Rg\u0091Z\u0013lG \u0018orN$g\u0010dy\u008eE:\u008f\u001e+\u008e\u008e\u0091N:$\u000e\u0095\u009cxU\u000b\'\\\u009e5B%6\nZ3\u001b]\u001e^\u009c\u0090\u0088k>\u001f\u009dl\u009aJ\r;k>\u001d\u0090e\'*6z\u0092\u0014E\u0097\u000eGe)A<\u009d],;[S\u0003;\\O\u0016\u0086r\u0017=l8>Y \u008a\u0080\u0013\b\u008a^9\u008a\tNL\u0006\u0091vcz\u00ad&@\u0018S\u0087\u001b\u009b\u009ag\u0007\\HVvWc\u0018\u008c\f.\u008897\u00ad{X\u009a\u0016\u0098\u0094\u0097Go )\u0010\u0091,I8\bsQHI\f0\u001f\u00ad\u009b$Abs\u008c9\u008a{`_i\u0096*^QUt\u007f\r\t\u001f\r\u009a\u0089\u001b\u008c9%<\'\u000btEB^Krvs\u000e?\u0096`A^EAEXP\tQP\n\u0096d\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0005t\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000org/gradle/cli/ParsedCommandLineOption.class\u008dS]O@\u0014=G\u0081eP\u0004a\u0015\u0084eQ\u0001"\u0088hHV1Y\u0083awR\u0006\u0012l\u008b\u000f\u0098\u0004Ig\u007f\u0094N[`Y$\u0099{=?\u007f\u0000\u0098\u00934(\u0098H#\u0082b\n\u001d\u009e\u0086\u008a$4\u0012\u0099-L%q[+r\u008a\u0007\n\u0012[lpWA\u0098\u0084\u0097\u0084(H\u0095\u0085a1p\u0005#-\u009fg\u0083,C/{\u008e\u008c\u00999*I\nKxs\n\u0085U\u0005EJ\u001d%a\u0097\u008d:w^u\u0093"\u0092]a*s\u0084<\u0087\u0098!\u0088Id;\u0086n8jrb\n\u0015s\\^]k5fU%J\u0013E\u0092\u0006V\u0000\u0005\u0085\u0094\u0014\u0095=Vy\u0082\u001e\nj\u0094;*i\u0016=z&x\u008e\fV\u0017\u001cQ\u0096p6K:\u0090d)\u007fKn07T@\u0096U\u0090.\r\u009f\tv\u001c\u0093\u0012IC\u000fz\u0015t\u009d]p\u001c-)kDN(\u0014\f\u009dt]6Mn0\u0093,\n(#\u0000Wm-o-\u009egv\u001c\u0093\u008a\u0087\u001af0?L\'ZDAK\u008f@*\u0018\u001a\u0016$\u001b)\u0094\u0095M^!\u000fO\u008f\u0086\u008c+v\u0002\u0096iQ,7_\u0085\u0094\u008eZ\u0006\u0015~\u0093]m\\\u007f(K?\u0018\rLH.:E\u008d8rZ/Pd\u000eQ\u0001>\u0094!"k\u0088~E\u009f}\u0091V_\u0082*bTG;-%\u0003\u001cb\u0084Xo\u0088\u0010\u0089\u009c\u008f\u0017\u000e\u0090"\u001fp(\u001c=@&\u0082_2w%\u008e^*$APPS =1D:\u009a!\u0089If%\u0090\u0084\u001f\u001cn\u0082\u0089\u00870\u00815W(v\u0095\u0007b\u009eRD\n$\u0001"xj\u00182D\u0086xr7\u0082k>\r!\u0090V.p].G\u0080D\u0013\\\u00938"y\tR\u0089\u008c\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.class\u009d\u0092KO@\u0014\u0085\u0005\u0004D|?P\u0004\u009a\u0018u#Q\u008c+$\u0018C;\u00961m\u0087\f\u0003\tJW&.\u0001(\u00141D,\u009c9vo/\u0000[@\u0016\u001byl\u0095G)\u0087\u001cv\b\u0013\u0011\n}FHWkw\u0084LS\u009c\u0012!\u001e\u0006]nY7ZK:cJD\u009e\u0018\u0010\u008eZRy\u0098s\u0085V\u0081;H\u009f+-)\u0083\u0080\u0085nkS\u0086#cruLXgh|B\u0086\u0084\u008dj\u00adFY\u001d\u00adD\u0099\u008f%L%\u0094\u0013\u0006\u008e\u0012\u008e\u0085\u008e\u001c*\u0087_\u0089?\u0088:("\u0087<\u0081\u0084b\u007fJ\u008d\t\u0017\u001d\u00ad\u008atf^*K\u001d\n\rXU\u001aV\u001d\u008ci0\u001e1\u007fk\r\u007f\u000e\u008dp8\u0083\u009dw\u0007Z8T0g?\u001a\u0019Pa\u009b\u0099m\u0094\u008c=\u0083\u009eC\n\u0005S\u0013s\u001d\u000b\u0016\u0001\u008b\u0013|\t1\\\u008fZq\u0006-}C_J\u0002\u009a\u009eE\u0089j\u0002\u009a\u0099E+\tw\'\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\n8=|\u0001\u0000\u0000\u0002\u0000\u00009\u0000\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.class\u009d\u0092J@\u0014\u0086mjE5B\u0013P\u0085\u0017\u0090\u0016\u0017R/P~\u009a\u001e\u0091$\u0013&BJW\u0082\u000b\u001f\u0087\u0012\'i\u0010AY\u009c3\u009c\u007f\u0001\u0001l\u0097 \u000f\u008d"l\u0014Y\u0084\u0002l\u0015E \u007f<&\td\u0090@Hg\u001eL\u0011\u008a{:r\u0094Rs\u008b:C*X4N\u009c\u0080Q\u009f\u000b\u0005\u001d;hZ\u000e3\u0007a \u0013G!\u0019\u0006]\u001bG\u008bv7S"\u008a\u0013\u00025\u001beb\no}G\u008ftFM\u0087z9\u0090\u0082y~X{()spL`7e.\u0004KV,\rTXx\u008a\u0094fD\u0005T\u0000E\u0002G\u001cPW\u0014\u0081\u0001Jmh~\u00ad\u001f49Ajx\u00ad\r\u00adsh\rg\u0099n\u001085].F\u0081\u0014\u0092s\u00079Q\u0002\u0089\u001a\u0099*\u0013\u0095s/@\u009eUg\tJ*c\u000ee\u0015+s\u0083+1\n\u0004$p\u00806\u0099/t-\u0005,;h-\u0005.Z\n>kZ\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000gradle-cli-classpath.properties+(JM.)**+M\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000gradle-cli-parameter-names.properties\u0003\u0000PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081)\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u009b\u0000\u0000\u0000org/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000org/gradle/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A\u0000\u0000\u0000org/gradle/wrapper/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000f\u0003\u0005\u0000\u0000\t\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u001d\u0001\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQ}\u0000\u0000\u0000\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081k\u0006\u0000\u0000org/gradle/wrapper/Download$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081N\u0007\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005<\u009b\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\t\u0000\u0000org/gradle/wrapper/Download.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L\u0000\u0000\u0000\u0000\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0018\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0019\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081 \u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081u#\u0000\u0000org/gradle/wrapper/GradleWrapperMain.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0018\u0000\u0000\u0000\u0000\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081d-\u0000\u0000org/gradle/wrapper/IDownload.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@c\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081N.\u0000\u0000org/gradle/wrapper/Install$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00815\u0000\u0000org/gradle/wrapper/Install.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000:o\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\\J\u0000\u0000org/gradle/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\bM\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0014O\u0000\u0000org/gradle/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007f\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081nV\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000=\u000f\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081~[\u0000\u0000org/gradle/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000G\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081y^\u0000\u0000org/gradle/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000e\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081g\u0000\u0000gradle-wrapper-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00814h\u0000\u0000gradle-wrapper-parameter-names.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000A}h\u0000\u0000org/gradle/cli/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081h\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0083X\u0004\u0000\u0000\n\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00817k\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081o\u0000\u0000org/gradle/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081~q\u0000\u0000org/gradle/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\n\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081r\u0000\u0000org/gradle/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u008a\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081$y\u0000\u0000org/gradle/cli/CommandLineParser$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099\u00adN\u0003\u0000\u0000\t\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u000fz\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0019D\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081}\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0080\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000*ZM\u0002\u0000\u0000\u0004\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0004\u0085\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u00062\t\u0004\u0007\u0000\u0000\u0011\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0087\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$\u0002\u0000\u0000\u0006\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0014\u008f\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>\u0002\u0000\u0000\u0006\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0013\u0092\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%\u0002\u0000\u0000\u0006\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0018\u0095\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000fC\u0098\u0001\u0000\u0000\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081(\u0098\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000E\u0002\u0000\u0000\u0005\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081%\u009a\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081!\u009d\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000\u0004\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0010\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pX\r\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081d\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009b\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u009e\u0000\u0000org/gradle/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008b>\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000org/gradle/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0005t\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0005\u0000\u0000org/gradle/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081)\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\n8=|\u0001\u0000\u0000\u0002\u0000\u00009\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000?\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081\u0000\u0000gradle-cli-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0081"\u0000\u0000gradle-cli-parameter-names.propertiesPK\u0005\u0006\u0000\u0000\u0000\u00003\u00003\u0000\u0011\u0000\u0000g\u0000\u0000\u0000\u0000',
      f3b4dae340056399e69926fa62aba660b3e9404e:
        "#Mon Mar 23 21:48:17 CST 2020\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStorePath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\n",
      e8895216fd3c0c3af4c4522334775f41b7deb42e:
        "connection.project.dir=\neclipse.preferences.version=1\n",
      "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="CompilerConfiguration">\n    <annotationProcessing>\n      <profile name="Gradle Imported" enabled="true">\n        <outputRelativeToContentRoot value="true" />\n        <processorPath useClasspath="false">\n          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n        </processorPath>\n        <module name="refactoring-crawler.main" />\n      </profile>\n    </annotationProcessing>\n  </component>\n</project>',
      a64b2758bd03a20260566a40b58c116679055c17:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="GradleMigrationSettings" migrationVersion="1" />\n  <component name="GradleSettings">\n    <option name="linkedExternalProjectsSettings">\n      <GradleProjectSettings>\n        <option name="distributionType" value="DEFAULT_WRAPPED" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n        <option name="gradleJvm" value="1.8" />\n        <option name="modules">\n          <set>\n            <option value="$PROJECT_DIR$" />\n          </set>\n        </option>\n        <option name="useQualifiedModuleNames" value="true" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>',
      "4fed64e0de33c78035aa4aa1eb052668eb85c6d4":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="RemoteRepositoriesConfiguration">\n    <remote-repository>\n      <option name="id" value="central" />\n      <option name="name" value="Maven Central repository" />\n      <option name="url" value="https://repo1.maven.org/maven2" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="jboss.community" />\n      <option name="name" value="JBoss Community repository" />\n      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="BintrayJCenter" />\n      <option name="name" value="BintrayJCenter" />\n      <option name="url" value="https://jcenter.bintray.com/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="MavenRepo" />\n      <option name="name" value="MavenRepo" />\n      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="maven" />\n      <option name="name" value="maven" />\n      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n    </remote-repository>\n  </component>\n</project>',
      b1662faf91f158c3fc95e7f294260c2ea0cdbc12:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ExternalStorageConfigurationManager" enabled="true" />\n  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n</project>',
      e96534fb27b68192f27f985d3879e173ec77adb8:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="Palette2">\n    <group name="Swing">\n      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n      </item>\n      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n        <initial-values>\n          <property name="text" value="Button" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="RadioButton" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="CheckBox" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="Label" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n          <preferred-size width="-1" height="20" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n      </item>\n    </group>\n  </component>\n</project>',
      "0f5826ff690d76f8961058a4fd1cf25f380882c3":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ChangeListManager">\n    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n    <option name="SHOW_DIALOG" value="false" />\n    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n    <option name="LAST_RESOLUTION" value="IGNORE" />\n  </component>\n  <component name="ExternalProjectsData">\n    <projectState path="$PROJECT_DIR$">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name="ExternalProjectsManager">\n    <system id="GRADLE">\n      <state>\n        <projects_view />\n      </state>\n    </system>\n  </component>\n  <component name="FileTemplateManagerImpl">\n    <option name="RECENT_TEMPLATES">\n      <list>\n        <option value="Interface" />\n        <option value="Class" />\n      </list>\n    </option>\n  </component>\n  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n  <component name="ProjectViewState">\n    <option name="hideEmptyMiddlePackages" value="true" />\n    <option name="showExcludedFiles" value="true" />\n    <option name="showLibraryContents" value="true" />\n  </component>\n  <component name="PropertiesComponent">\n    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n    <property name="WebServerToolWindowFactoryState" value="false" />\n    <property name="aspect.path.notification.shown" value="true" />\n    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n    <property name="show.unlinked.gradle.project.popup" value="true" />\n  </component>\n  <component name="RunManager" selected="Application.RefactoringCrawler">\n    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n      <module name="refactoring-crawler.main" />\n      <extension name="coverage">\n        <pattern>\n          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n          <option name="ENABLED" value="true" />\n        </pattern>\n      </extension>\n      <method v="2">\n        <option name="Make" enabled="true" />\n      </method>\n    </configuration>\n    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n      <ExternalSystemSettings>\n        <option name="executionName" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="externalSystemIdString" value="GRADLE" />\n        <option name="scriptParameters" />\n        <option name="taskDescriptions">\n          <list />\n        </option>\n        <option name="taskNames">\n          <list>\n            <option value="dependencies" />\n          </list>\n        </option>\n        <option name="vmOptions" />\n      </ExternalSystemSettings>\n      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n      <method v="2" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue="Application.RefactoringCrawler" />\n        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name="SvnConfiguration">\n    <configuration />\n  </component>\n  <component name="TaskManager">\n    <task active="true" id="Default" summary="Default task">\n      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n      <created>1584971244282</created>\n      <option name="number" value="Default" />\n      <option name="presentableId" value="Default" />\n      <updated>1584971244282</updated>\n      <workItem from="1584971249949" duration="21487000" />\n      <workItem from="1585056855574" duration="4355000" />\n    </task>\n    <servers />\n  </component>\n  <component name="TypeScriptGeneratedFilesManager">\n    <option name="version" value="1" />\n  </component>\n  <component name="WindowStateProjectService">\n    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n  </component>\n</project>',
      d45b35fe7e96659467ab36d569bede38ef6d8956:
        '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test',
      dfe0770424b2a19faf507a501ebfc23be8f54e7b:
        "# Auto detect text files and perform LF normalization\n* text=auto\n",
      ea419d85c301b292fbadf5b1f4da2c8350a1c0f1:
        ".gradle\n/build/\n/.idea/\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n",
      "669e8aabbeb973fc803553332427c4c3309bf0b6":
        '<?xml version="1.0" encoding="UTF-8"?>\n<projectDescription>\n\t<name>refactoring-crawler</name>\n\t<comment>Project refactoring-crawler created by Buildship.</comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n\t</natures>\n</projectDescription>\n',
      b34fbf6028059b5e0f654d1d1645aef6f2400c75:
        "# refactoring-crawler\nJava tool for detecting refactor\n",
      "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750":
        "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n",
      "8e25e6c19d5748190b8cc39e98c2b56e496a5717":
        '#!/usr/bin/env sh\n\n#\n# Copyright 2015 the original author or authors.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG="$0"\n# Need this for relative symlinks.\nwhile [ -h "$PRG" ] ; do\n    ls=`ls -ld "$PRG"`\n    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n    if expr "$link" : \'/.*\' > /dev/null; then\n        PRG="$link"\n    else\n        PRG=`dirname "$PRG"`"/$link"\n    fi\ndone\nSAVED="`pwd`"\ncd "`dirname \\"$PRG\\"`/" >/dev/null\nAPP_HOME="`pwd -P`"\ncd "$SAVED" >/dev/null\n\nAPP_NAME="Gradle"\nAPP_BASE_NAME=`basename "$0"`\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD="maximum"\n\nwarn () {\n    echo "$*"\n}\n\ndie () {\n    echo\n    echo "$*"\n    echo\n    exit 1\n}\n\n# OS specific support (must be \'true\' or \'false\').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase "`uname`" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\n  NONSTOP* )\n    nonstop=true\n    ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n "$JAVA_HOME" ] ; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n        # IBM\'s JDK on AIX uses strange locations for the executables\n        JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n        JAVACMD="$JAVA_HOME/bin/java"\n    fi\n    if [ ! -x "$JAVACMD" ] ; then\n        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\n    fi\nelse\n    JAVACMD="java"\n    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n            MAX_FD="$MAX_FD_LIMIT"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn "Could not set maximum file descriptor limit: $MAX_FD"\n        fi\n    else\n        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n    JAVACMD=`cygpath --unix "$JAVACMD"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=""\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS="$ROOTDIRS$SEP$dir"\n        SEP="|"\n    done\n    OURCYGPATTERN="(^($ROOTDIRS))"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in "$@" ; do\n        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n        else\n            eval `echo args$i`="\\"$arg\\""\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- "$args0" ;;\n        (2) set -- "$args0" "$args1" ;;\n        (3) set -- "$args0" "$args1" "$args2" ;;\n        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n    esac\nfi\n\n# Escape application args\nsave () {\n    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n    echo " "\n}\nAPP_ARGS=$(save "$@")\n\n# Collect all arguments for the java command, following the shell quoting and substitution rules\neval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n\n# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\nif [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n  cd "$(dirname "$0")"\nfi\n\nexec "$JAVACMD" "$@"\n',
      "9618d8d9607cd91a0efb866bcac4810064ba6fac":
        '@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the "License");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an "AS IS" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if "%DEBUG%" == "" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif "%OS%"=="Windows_NT" setlocal\n\nset DIRNAME=%~dp0\nif "%DIRNAME%" == "" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif "%ERRORLEVEL%" == "0" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist "%JAVA_EXE%" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windows variants\n\nif not "%OS%" == "Windows_NT" goto win9xME_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif "x%~1" == "x" goto execute\n\nset CMD_LINE_ARGS=%*\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif "%ERRORLEVEL%"=="0" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\nexit /b 1\n\n:mainEnd\nif "%OS%"=="Windows_NT" endlocal\n\n:omega\n',
      "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc":
        "/*\n * This file was generated by the Gradle 'init' task.\n *\n * The settings file is used to specify which projects to include in your build.\n *\n * Detailed information about configuring a multi-project build in Gradle can be found\n * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n */\n\nrootProject.name = 'refactoring-crawler'\n"
    },
    language: "Java",
    description: "Java tool for detecting refactor"
  },
  {
    name: "backend",
    language: "Java",
    description: "djakldfjklajsdlkfajsdlkfjaldsf",
    lastUpdateAt: new Date().getTime(),
    currentBranch: "master",
    ownerId: "PatrickLai7528",
    commits: [
      {
        sha: "d452a08ee6b7772f30b876395b09ce7a15f8a58c",
        message: "chore(*): update lai's mysql settings",
        stats: {
          total: 4,
          additions: 2,
          deletions: 2
        },
        author: null,
        committer: { id: "PatrickLai7528" },
        parents: [
          {
            sha: "1327329a38f6f97ee8caef9e6f99b28c5b721b29"
          }
        ],
        committedAt: 1584511342000,
        changedFiles: [
          {
            sha: "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6",
            filename: "src/main/resources/application.properties",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              "@@ -1,4 +1,4 @@\n-spring.datasource.url=jdbc:mysql://localhost:3306/myDb\n+spring.datasource.url=jdbc:mysql://localhost:3306/tle\n spring.datasource.username=root\n-spring.datasource.password=admin\n+spring.datasource.password=\n spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\\ No newline at end of file",
            rawContent:
              "spring.datasource.url=jdbc:mysql://localhost:3306/tle\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver"
          }
        ]
      },
      {
        sha: "1327329a38f6f97ee8caef9e6f99b28c5b721b29",
        message: "Initial commit",
        stats: {
          total: 753,
          additions: 753,
          deletions: 0
        },
        author: null,
        committer: { id: "PatrickLai7528" },
        parents: [],
        committedAt: 1584510539000,
        changedFiles: [
          {
            sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
            filename: ".gitattributes",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# Auto detect text files and perform LF normalization\n+* text=auto",
            rawContent:
              "# Auto detect text files and perform LF normalization\n* text=auto\n"
          },
          {
            sha: "a2a3040aa86debfd8826d9c2b5c816314c17d9fe",
            filename: ".gitignore",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+HELP.md\n+target/\n+!.mvn/wrapper/maven-wrapper.jar\n+!**/src/main/**\n+!**/src/test/**\n+\n+### STS ###\n+.apt_generated\n+.classpath\n+.factorypath\n+.project\n+.settings\n+.springBeans\n+.sts4-cache\n+\n+### IntelliJ IDEA ###\n+.idea\n+*.iws\n+*.iml\n+*.ipr\n+\n+### NetBeans ###\n+/nbproject/private/\n+/nbbuild/\n+/dist/\n+/nbdist/\n+/.nb-gradle/\n+build/\n+\n+### VS Code ###\n+.vscode/",
            rawContent:
              "HELP.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**\n!**/src/test/**\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n\n### VS Code ###\n.vscode/\n"
          },
          {
            sha: "a45eb6ba269cd38f8965cef786729790945d9537",
            filename: ".mvn/wrapper/MavenWrapperDownloader.java",
            status: "added",
            additions: 118,
            deletions: 0,
            patch:
              '@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2007-present the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.channels.*;\n+import java.util.Properties;\n+\n+public class MavenWrapperDownloader {\n+\n+    private static final String WRAPPER_VERSION = "0.5.6";\n+    /**\n+     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n+     */\n+    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n+            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n+\n+    /**\n+     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n+     * use instead of the default one.\n+     */\n+    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n+            ".mvn/wrapper/maven-wrapper.properties";\n+\n+    /**\n+     * Path where the maven-wrapper.jar will be saved to.\n+     */\n+    private static final String MAVEN_WRAPPER_JAR_PATH =\n+            ".mvn/wrapper/maven-wrapper.jar";\n+\n+    /**\n+     * Name of the property which should be used to override the default download url for the wrapper.\n+     */\n+    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n+\n+    public static void main(String args[]) {\n+        System.out.println("- Downloader started");\n+        File baseDirectory = new File(args[0]);\n+        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n+\n+        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n+        // wrapperUrl parameter.\n+        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n+        String url = DEFAULT_DOWNLOAD_URL;\n+        if (mavenWrapperPropertyFile.exists()) {\n+            FileInputStream mavenWrapperPropertyFileInputStream = null;\n+            try {\n+                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n+                Properties mavenWrapperProperties = new Properties();\n+                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n+                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n+            } catch (IOException e) {\n+                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n+            } finally {\n+                try {\n+                    if (mavenWrapperPropertyFileInputStream != null) {\n+                        mavenWrapperPropertyFileInputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // Ignore ...\n+                }\n+            }\n+        }\n+        System.out.println("- Downloading from: " + url);\n+\n+        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n+        if (!outputFile.getParentFile().exists()) {\n+            if (!outputFile.getParentFile().mkdirs()) {\n+                System.out.println(\n+                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n+            }\n+        }\n+        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n+        try {\n+            downloadFileFromURL(url, outputFile);\n+            System.out.println("Done");\n+            System.exit(0);\n+        } catch (Throwable e) {\n+            System.out.println("- Error downloading");\n+            e.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n+        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n+            String username = System.getenv("MVNW_USERNAME");\n+            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n+            Authenticator.setDefault(new Authenticator() {\n+                @Override\n+                protected PasswordAuthentication getPasswordAuthentication() {\n+                    return new PasswordAuthentication(username, password);\n+                }\n+            });\n+        }\n+        URL website = new URL(urlString);\n+        ReadableByteChannel rbc;\n+        rbc = Channels.newChannel(website.openStream());\n+        FileOutputStream fos = new FileOutputStream(destination);\n+        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n+        fos.close();\n+        rbc.close();\n+    }\n+\n+}',
            rawContent:
              '/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = "0.5.6";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            ".mvn/wrapper/maven-wrapper.properties";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            ".mvn/wrapper/maven-wrapper.jar";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n\n    public static void main(String args[]) {\n        System.out.println("- Downloader started");\n        File baseDirectory = new File(args[0]);\n        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if (mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n            } finally {\n                try {\n                    if (mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println("- Downloading from: " + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n        if (!outputFile.getParentFile().exists()) {\n            if (!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n            }\n        }\n        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println("Done");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println("- Error downloading");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n            String username = System.getenv("MVNW_USERNAME");\n            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n'
          },
          {
            sha: "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054",
            filename: ".mvn/wrapper/maven-wrapper.jar",
            status: "added",
            additions: 0,
            deletions: 0,
            rawContent:
              "PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MF\u0095\u008fA\n0\u0010E\u0081!\u0017H\u0015E*\b\u0082\u00ad\u0084d\u008aC$LcVT+w{\u0083vXA\u0017\u0019C2P\tgE\u001b\u001ahE\u001d\u0087P\u0096\u0018\u001bD{pN:\u0004\u009f\u000f!Q+lK\u008a=8\u0092q8,a\u0013e\u0018\"\u009c\u009d\u0002\u0018v\u0093,l&kM\u008e@G\u0013\u009c2Q8^R+\u001enTrI\u0097;_\u0013PK\u0007\bK1\u0000\u0000\u0000+\u0001\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000META-INF/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000META-INF/maven/io.takari/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00005\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.properties+K-*533J//-L+IN,J,*LKL.\u0001\n&\u0096\u0096\u0017%\u0016\u0014\u0016q\u0001\u0000PK\u0007\bL@\u0005:\u0000\u0000\u00009\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/apache/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000org/apache/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000org/apache/maven/wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.class\u0095Vv\u0013G\u0014\u0085\u0086\u0016\u0099\u0004\u0006`#b\u0092\u0007up\b\u0001\u008b\u0098\u0081 \"\u001bc\u0083A\u0098\f-l\u0091\u0095\u00923'\u0090y^d\u0099Ua#\u0084\u0013\u008f/\u0092jlI\u0096sNzUu\u009f\u007f\u0014I`\u001be/hzE\u0017V\u0097=J\u0085%\u0012\u008e\u0084n\u00983B\u0005\u0015\u0019,KV\u0005zn\u0091\u0005C\u009ca\u001ab\u008c\u0017O2\u00ad\u0002\u000f\u0087*\u0002\b2\u0018&\u009f\u0096sJ\u009c!\u0092ziV\r9\u008c~Q4\u001c\u0006-\u0082J1\u0004\u001ce8\u0016\u009flD7#l\\H-\u0086]1J<%\u000b_^\u008a0,Q\u0010ag}&\f\u0086*p\u0080\u009f7BF\u009a\u0014\u0090}M\u0019zm\u00adC\u0005\u0087\u0018\u000e&\u0093\u000btf;N\u000b2\u0089\fjd\u0018\u0087a`T\u001cA\u008c\tt\u009a\u001ewSa<\u008bc\nZ*\u008e\u0084-i[\u00861 )>\u0015\u0083\u0018\"\u000b\\8\u0082\u0097\u009b\u0018\rm.nR\u0085&7oSM\u0011A\u009c\u00942\u0018aH4\u008e\u0011\u0016H\u00890N\u0082\u0017ZvhsE\u009ca\u0099\u0012np[[S\u0012fTE\n\u0088e\n,Z\bu\u008c\"\u0004\u0092I\u0012c2O\u0082.U'Y)ejr\u0003.\u0015\u009cd\u0013F\u0010I\u0082\u008a\u008bD\u0089(\u0011\u0098\u008bp<Y\u009c\u009b\u0092\u0099\neR+d*s)\u008e+*^U\u0012\"bJUtQl\u0081\u0086q\r\u0019\u0005d~\u0096*&0\u0083\u00921e[TRb\u0085L\u0087;T\u0014\u0014hNF2C\u0098&Ij9#Er)Ep\u008b\u00adt:8L5 Kr`\u008e\u008aC\u0087q\u0007x\u001do%8E\"q\\@pnS\u009b\t|DW\u009bVG `\u001dy\u00059\u0086C[\u00adQQ\u0000aA\\SlE3%6\u009b\u0088n/\u0090`*J\"`\u009a5\u0086\u0090;F\u0091|\u0007]G3[?)\u00170=U\u0094\u0007W~\u0086H^ia8z\u008fT\u001awvs\u0003c\u0017r%.\u0015QU\u0084\u0007F\fGHV2\u009axb\u0095\\m\u007f\u0085tR/\u00108$N\u0015>>TAk\u0001#|LHe]P\u00ad\u0092NUyW#11]5\u0085QC\b\u009f2\u008c\u008f[R!fZ\"V4\b\u001e\u0013E\u001e\u009b\u0090\u0012k\nk\u0017c\u0086Y\u000b6rU\t\u0011?'e\u009f\u0002_\u0092v-\u009bjN\u0007vz\u0005<\u0082\u0099|\u009e\ryB\u0019j\u0015w\u0010&v\u001c\u0097\u0007Q\u008fs*4e\u0006\u0006V\u0011zL\u009dm\b7\u001a\u0083j}\u0001;%\u0011c7\u00adC}?\u008dJ\u0018v\u0084vH8g`h\u0015&\u009f`;Yp\rptf\r5\fQ\u001a\u009e\u008fk8\u001bG^h 2>T5oG?P*f<S4\u0010\u0099%;Y_.\u008d\u0006AF\u0006_7H7o?v9G)4\u0090\u0082zq\u0088\u009e^!FQzF0\u0086c\u0081\u0013\u001f%zLjm\fD)xDeo\u001es.y\u0007\u000b(\u0012 0#),>\u0014\u0013R\u0099\u0012\u0094'&,ZUV\u009f{\u008b?!^\u007fo\u0090$;\u0018]\";\u001axz\u001b\u0005hgd\u0082r\u001cy\u0086~B`G>\u009f\u009ea6I#\u0001kl\u0015_~n\u0007\u00150L\u0093H\u000eR\u0014F\\z1W\u0000uzi\u0097\u0014\u00adK\u008f;\u0017\u007f\u0001PK\u0007\bB\u0005\u0000\u0000`\n\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00002\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.class\u0095SmO\u0013A\u0010~\u0096\u001e\u009c\u0087j\u008b\u0006J`\u008f\u001aa\u0005B\u0015b`\u0096vi\\w\u009b-\u0084\u007f\u001f\u0014\u0089?\u001fe\u009cT\u0083@\"\\rss<dfo?\u0000T\u0018\u0092]\u009f\u000fx'>?\u0010?|0\u0010\u008b}>\fM]\u001dP\u008e\u008a\u0083$C\u0003?\u0014\u000eMOH\u0013Q\u009a!ezA\u0094_&IW(y \u0003\u0017.\u0093XfHTGL\u0080\u0087+HH`\u0083\u0083k\f\u0089\u0082\u0005L5\u0002)\u0087=P0d\u001am\u0003{\u001e\u0005\u0093t\u0086%\u0015*}+&\u008fC;'\u0011(0_(6|\u008a\u0083\u001c\u007fP0^y^m\u008d\u000e0\u0090:\u008a\u008c{\u0087\u0010[\u0099VT9bX(4N\u008c\u000edwx64\u008e?J\u009bVkgc!\u000eU\u008a\u001e\u001ea\u0081\u0094\u008cjI)Y(\\dQs(2L\u009f#[q[jU`'\u0090;M\tv\"Jk\nS\u001d\u0007e\u0086at[;\u009cR\n]\u000b\"\u001c-S\u0082\u0007KF\u00917F\u0083q\u008aO\u0090\u008c6\u0096\u0016?\u00939\u0086)L\u0091M\u0011\u0006XE\u009a\u0017.#C$n\u0088\u0005\u009dwdeb&3K\u000b\u001e\u001cSd/O\u0090eGd\t\u0094b\"\u0096b':[1\u0016\rPK\u0007\b5C\u0012\u0002\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000S\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.class\u00ad\u0094]o\u0012A\u0014\u0086\u0003K\"*XZ.*^\u0099`L\b\u008d\u0089\t*\u0089\u0014FX\u0090\u008f27\u001f\u008f2\u0000*$E793s\u00999\u001f\u0000\u001e\u0089\u0083\u0004\u0095T\u00ad\u0080uY\u0083\u000e;\"+r\u0015l\u000f\u0017-\u0017\u0091dMw\u0007\u009d\u001d%\u008d[\u0087<6O\u0083JOa\u0083i\u001c\b\u008f\u0080\u0005\u0082\u0084\u008f0,\u0014~NHz~\u009d\u0090&w\u0091\\\u00063\u0098%,B_:\\e\u0011'j:S\u001d\u008f'S\u001d\u0084\u0085\u0097\tK-wX\u001cjNB)\bk\u009e_Ae\u0007\u0097\tgDq\u0085[Z\u0088w1W. O\u000eWGL\u0082\u0011r\u0006D\u0098h#\u0001aMi\u0015\u008aV?=\u0095Ms\u0084R\u0001J6\u00016\u0095_!<\u009d\"x\u0014.V`$\u0097\u00066\r\u00966S\u0015\u0098!Oy^E\u0016\u009e\u00adO(LW\u008dw\u0005.\bs\u0004wWT\u0083\bm\u009f*Y B\u0010\\U#sh<v\u0088P<?\u000fal\"\u0018\u009e$\u0093D~\u0003f\u0098Q`\u0010f\u008aGH\u007f1\u009d\u0084\u0016\u0086n3M\u009b\u0019\u0005\u0018{\u0014\u00168^\\1W\u008e\\\u0018Ws7r\u008eq+\u001e\u007fr\u0087\u0013r\u0085\u0091\\\n\u0017r\u001b&,$\u0086\u0083a\u0010%e7\u0010\u0098\u008c\u001bPK\u0007\b\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00000\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.class\u0095X\u0007`\u001b\u0019\u009e-0\u008e\u009c8QB\u0089\b\t\u0090\u00ad\u009a\u0091\u0010\u009b@\u0001\u0083\u0004v\u0004H>\u0090ut\u000e\u0085\u0086B\u0007e\u0094RZF[\u0092\u0016d\u0093M{\u009edY\u0015\n\t\u007f~{Q\u0000m\u0005\u001a*\u0004\u009a\u001cw4jN\u00981+:nNZ\u0094kNLXnt\u00875bfS\u000eg*\u009dra\u0013\u009c4)3=\u001a5t\u0099\u00954T\t\u009crl.\u00025c\u008bu\u009f?w\u0080\u00168~\u0093xf\u001b4SY\u0012;\u0002u\u000e\u0015\u001fU\tl\u00158\u0081Rvl'g\u008e[\u0002\u009ey]\u009ekG;XB6h\u0019~\u0004w\u008e\u0086g\u00964\u000e\n;V\u0000\u0095Xn\u0016+\u0004*\u001b\u001a\u0007!\u0091\u0090\u0081\u0013P\u0013h\u008d\u0081\u0013%\u0089I'=b\u008ff]k\u001c\u0098\u0096WF\u0012\u009ed`\u00ad$\\Y$\\HC3{\u0097\u001d\u001f~s(t\u0092fjtm9/,1;#\u0010y\u00811\u0018\u0089\t@r\u0003\u0088F\r\r\u000b\u0002\u001b\u009fx\u0081&43\u0014\u0096Gk\u009b\u00168\u008c\u0003\u001b\u0097.ih\u0011}\u00ad\u008b,\u00adb94\u0082\u008c\u0005b\rg\u009b\u0011\u000f4\u009ct\u0081zeM\u000bh\f\u009c\u0089M\u0002\u0081\u008c\u0015D0\u0005o,!&C\u001dg\u0011\u0083}{\u000fb}zt-\u0016\u008f\u0015lF9\u0018\u0016@\u0007\u0091~8W \\`\u00ad\u000f\u0017\u0002kK\u0094\u001f\u0088u\u0017v;\u0094\u0088\u0003]\u0007\u0092\u0084eF\u000e\u00818\u0017w\u0002\u00895\u009c'`\u0094\u009e7\u008d\u000b\u0098x\u0001;eT\u0095=\u0006zG/HT\u0099.\u001d&\u0089\u0086\u0085%n\u0003\u0017).\u0097\u000fnF&P@?\u0091~\u008egi3%\u0099\u0095\u009a\u0085\u0086\u0011V\u0085\u0014Y,i/.o\u00821\u0003\u0097R\u0001\fzJ\u0014o\u0010/bq\u008e\u008cX5+Md=f\u0081e\u008ek\u0018\u0012XU*t7\u0000\u00132\u008e~Yb\u0007\u001frw\u008cuf~\u0094\u0081\f)\r\u0097/T\u009d>\u001e\u0087\u0093\u0080OY\u0095\u00170!};a\nL\u0091\u009dfN.M\u008de\u0011\u0094\u0099TL3\u0090$\u0017W2\u009b2=K\u0016\u009cm(Lq\u0080\u0093T-\u008a,\u0080\u0017\u001a^R\u009a\u0093\u000b$\u0019x\u0019\u0096Q\u0002s2f]\u0091e\u0090*\u0095<r\u0003+\u0007b\u00ad;]\u001bo\tJ6:\u0090\u007fx\u0001\u009a\u0097Sk\u0000\u001aa\u001c3z\u009cQ\u008bu8lG\u001c\u0081\u0015\u008a$}zA4\\8\r\u00117\u0010oS\u0011\u0012ZnyMx\u008b\u00867eB\u0095\r\u00157Q.h?4vY\u0000\u00ad\u0006n\u0093\u008d?\u0099r2\u0096\u0094\u007f+3!EV\u0099\u0018U\u008a\u00ad@\u0085\u0015e\u001dHY7(\u0001{\\\u0093\u009d\u000b\u0099C*am_'\u008dMgc\u0084\u0013x3\u008d,def3\f\u0017hx\u007fJj\u008f\u0007\r\u008fCL\u0005(VqX\be!aG\u0089\u0019Y\u0007\u001e4\u0090\u0093\u0098\u00ad&d\f86\u008b\u001a\u001eZxA\u0006\u008eaY\u009a\u001fG\u001d\u008d{u<*p\u009em\u0003\u0019\u001e\f\u009f;R,0\u0086tNg$\u009f\u0007da\tU0\u000f\u0085{%\u0010,=\u0094\u0095$\u00ad)S\u0019\u009b5?\u009c-\u008b+8?n#\nS\u009b1Vb\u0081/V\nh8c\u009dY;En:\u009ey\u0003x\u0002\u009f\u0094\u0005\u008c\r|F>\u0016\u008c!JtFW:^OOs\u0006\u009eyJfK\u009a\u0001nyV\u000f\u0088\u0082\u000e\u008b\u0006$c{N~\u00935\"YRl!5\u0003_7\u0000nO\u00996[Pj\"~\u000bm\u0002n\u0096\u0081{\u009a=\u0085kh)\u0097\u009eg\u000f\nhe\u0010R\u00ad\u009d\u0005\u0001\b?c1\u0003?\b4\u0019\u0082\u001b\u008fk\u0005\u001d@Nv)2k&\u000f^\u008b_P\u0086%JH\u008aN\u008d9P\nW]\u000bbu\u0081^\u0010\u0018\r\u0006gU_.2\u008c\r\r\u007f'\"s9K\u00962iL&-]O&@\u0096d\u009a\u007f|;=\u008b.\u00ad/}\u009d:\nr@\u0081T\u0090\u009d\u001enaz7=a1\tY{th\u0004\u000fyy;\u0084p56h<\u0018\u000b\u0095=n\u0015\u0092.\u0010]<\u00924Q3)\u001b{\u0086:`gi\u000bg\u0013\u0013\u000eu\u0019\u000esm\u000b\u0006{[\u0003R=Q\u0099;\u009a1\u0099\u0092-\u0083zUub+\u008f\u0081e\u0002y\u001eYsHZ}l\u008c0\u0010\u0098SwawV\u0088\u0017\u0001#v\u0099n\u0096T+J\u008a\u001edzn\u0014\rB\u0096\u0094**d'\u0019`\u0010D\u0088B&%kdQ;R\u0006(\u0005\u0087\u008c\bhO\u0089\u0013dkLf8\u0010ke\u0091\u008d]\u008b.\u009a>\tmq\u0087u\u009e*O\u0018a\u00879 \u0082@uP4\u00ad\u0093\u008bM4J~\u008809)n7M79\u000b<k6d\u001b2\u0086\r\u0099\u000e_cP:4C\u009c.F\u001cw\u0016U\u0099\u0002plwQ\u0013\u0096b\u001c\u0090\u0004\u0083\u0082\u00ade[\u0093Ntq\u001b-!8Q\u009c%MJdHu\n\u00992\u008d\u0016\u000e'3+\u000f\u001fVC\u0083q5\u009fs\u0015|\n\u00adq%s\u0003As\u001c\u0094\r<\u009b2\u00069IS\u001955?\u0088\u0083Xj{!$o\u0094\u0002\u009fO\u0016mdu\u001a\u0019\u009c\u008ez\u009cAu@\u001a\u0006p\u008azYTb\u0085\u001aI\u0015{\"V\u0014T\u0003\u0083gqQ\u001cA$!f:\u008by\u00995\u008af\u009as\u0016\u0018s\u00059\u0015\u007f1\u0014x\u000e\u0016x\u000fnV<O\nnQz%I)#A\u0096\u0091\u0015p\u000e9(\u0091 \u0083\u000b\u0091\u0093c\u001fg\u00954\u008b\u0094\u0091\u001cn\u0086\u0010\u0017kOSsd\u0006y\u0001\u0090O\u0018i\u0005}\u000fz\u008f\u0001\u009a\u0091w\u001eP9\u00ad\u007fpS<\u009e+\u0087E\u009fh7\u0090h:\u0082\u0089#0\u0013\u0094\u009e\u009cH_*\u0007\u001c\u0099v-\u000bN\u0085\u001cC\u001cl/XWo\u000e\u0083H}`E@}`9^5^Q\u001bj\u0016Qsks%W\u0090?pcbSu\u001dO\u007f\u001em7\u0082o#a\u007f\u0014z\u009f--G\u00901v\u000e)\u0086\u007ft%C\t,\u009d~x\u0000k\u008duD#}\u0011E\u00820\u008bs\u008f\u0084=~R\u0088/1\u0084\u0014\u007f\\\u007f5Fp\rF\u0004\u008cFb&\\\u008e[\u000eq'}\\?\u0007\u0010\u001c\u0015\u008fU\u0086\u001c.p1\u001e\u0087\u008b\u0098SI\u009aa\u0081w2*w2\u0087H\u009b\u001fN\u008bp\u0000]L\u009f(u\u009b\u00124\u0095:K<[\u008d\u0097T~M\u0017#\n\u0096D>\u0005\u009bT31\u009a\u009ag\u0081\u0096'\u0089\u0087\u0088\u0082\u0007r\u0098\u0005z\u0091Y<\u0016\t~\b\u009eH\u0004\u008f\u0013M-3T\u000e\u009f\u000b\u008c<4O*\u0080*d(\u0093\u0004\u0014t\u001a\u009bTJ\u00974E\u0015]\u00922M\u00ad6|EQ\u0085|\u0018QD[V\u008c\u0083M9|5\u0087oF\u0082\u0087\u009fW>\u0082oHr{\u001f\u0089\u001f\\l\bWv\u007f\u0017s2Q\u001cG\u000e\"\u009f\u001e{\"yN\u0088}-\u001cq\u0011Q\u0099\u0013\u0096\u0019=F\u0005u\"\"fQ\u008c\u0095\u001dDAlmW Zq\u001d\u0010=\u0017\u0011\u00111c\u008172FoRN\u0089\u0091\u0092\u0015\u009drP9\u0080$^-\u00028r]\u0085-\u0010)\u00ad8Ep#U\u0004Q\u008d^\u00adU\u0092!\u0096\u0089r\u001e{B)\u0096s6\u00962QB&\"G\u0096F\u008652+\u0019\u009cX\u0092\u008f9\u0017\u0095\u009d\u009b\u0019\u0083[Xne\r\u0011Bw>mEDX\u008ao\u0090\u0093U\u00ad6A+4KT3yJ\u009a\u001e`\\'Na]\u00ad\u0013\u001b\u0013\u001bi\u0089F\u0089f\u00ad\u0013-\u0089h\u00ad\u0002\u00849\u009e\u0087DU*\u009eBZ<G\u0089\u0016PgE5\u0094;).\u0006w8C%{%\u0081\u0019+XGR\u009c\u0002cbIYV\u0087\u0001YY\u0006,\u008e|\u0012[8\u0093VQ\u00159\u009e):TV\u0088\u001eb8G]\u0015@O\u0004B\u009c\u008b\u0000PK\u0007\bC5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000org/apache/maven/wrapper/Downloader.classE\u008e\u000e@\u0010\u0086\u0094\u0092\u0090x\u0000\u0007\u0017.6\"\u0091H$\u0084j'fU\u001c<\u0080\u0087\u0012[\u0084I&3\u007fo&y\u0003\u0098B\u0018hs\u00102\u0095\u0091IDad\u009a\u0011S]D\u0090\u008d\u000b\u0087\u008de.E\"A1\u0007\u0019\u0011~\u0011B\u007f|\u008a3]/\u008f\u008a\u0098G\t\u001d\u009b]\u0003NH\u008b&s,\u0017\u0013pyE#\u008cKN TQ\u0016D5\u00adv\u00adrl^A\u0005PK\u0007\b\u0084q\u0012\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/apache/maven/wrapper/Installer.class\u009dXy`\u001cu=iY\u00ad\u0097\u008cl\u008b,\u0006\u0090u`\u001bd\u0090\u008d!\u0019D$YX\u0096`3\u008e;\u001e\u0096d\u0080m\u0012\b\bI\u0086p;\u0001\u0004\u0011`Z\u0002iS4E4mi\u009a-7{hW\u0092\u0013\u001fZ}3~}\u009f\u0016\u0080\u0015r@\u0089`\u0091\u0013\u001fjb\u001e)bMq+\u0016MD\n\u0087\u0001\u008f`->)lE\u0087\u009a\u001eH\njZ6og\u008dtZAU\u0004}O2\u001e\u008a\u000e\u00ad\u0011(h\nl/**'-\u0018J$\u0013\u0002o\u0019\u008e\u0086\u001d+(8j\u00adY\";\\cVr\u0086D\u008e\u0082g>]HkCPr\u009d\u001c*\u0010v\u009c\u0097\t<\u009b\u009cC)L\\Ae}\u0015\u0010T\u009bRWM\u0098\u0098!\u0098\u0011\u008a]n;\"\u0003u\u009f3`\u0085xH\u009f/==!\u00923k\u0091\u000f\u0019m\rm+i\u0082\u007f\u008e}\u0099\u008c`h(\u0015\u0092!'fY&~!is(l+\u0091\u0001;{\t\u0003~\u0089wX$0;wmm\u0087K@mQ\u008c&\u0092v\u0012,e\b\u0086\u001d'Xtj,\u009b\u0087:\u001bX^3\u0080F\u0081\u0011JEbQ\r\\J\u009d\\\u009dln`%]?T(\u0010+L\\\u008ef2iep\u0092n\u0099\u009f^\u0015B}%<\u009d9}^\u0095\u0084W\u0099X\u0087\u0000~\u0094pV\u000e\u008b\r\u0082uS\u0082\u009ayh<jln\\U};\u0014m\u001f\u008a\u001a\u009bL\u008d\u0085\u0097t2\u0002\u0004,\u009d&\\\u0005K{y+#6\u0090\u0083H\u0019P\u0089Fh/\u009b~\u001fC\u0087\u0081O\t.<cu8CCvD\u0013\u008a\u000e:>l\u0006\u0093\u008f\u0095&\u0087\u0094\u008f\u0087v5S%gQ6\u0005^\\e>\u007fr1V|?\u0018w\"~N\u0006\u0086I9c\u0002bo7Cqv(!<l\u008d&rt&\u0013;usfn7J\u001bp3v\u001b\u0098pg\u00074j\u0080`\u007f\u0089\u000bC\u0085m6\u0086\f(<LA\u0088\u00880m\u000f\u0014_\n\"\u0094C\u001c\u001f\"b \u009c+{\u0013Qu\\=B\u0089b&nUv3\u008a3\u0094Nw\u0012&\u0092\u009a\u0006w\b\u001b\u000ea1f\u0093=\u0095J\u0094xiVo3q+;h\u0087Y\u0001^I\nS\u0012\u009f=\u0006&h&\u0005\u000e.\u0096\u0016gf.\u0019\u0087L\u008bFi\u001d\bLRzv\r}&W_TM\u0080\u0010\u0081M\u0080\u0089A\ts\u008fL\u0093d\u001ey*A5\u0095xX\u0011&k\u008en<j\u008b\u0012\u0019\u0086\u00926Sa\u009d\u0090E{=<\u0086\u0006\u001enSwM\u001c\u0013=\u0092\u009c\f?b9\u00adyuu0\u0014[\u0087y3\u001ah-\r\u0013N8\u00955\u0007L<D\u008dV*GM|\u0015{D\u0017zU&do\u0094\u0018S^|\u009d\u0093\u008e_yh%I)D\u008a3f\"f\u0006^\u0011\u009c;aT4\u0019\u008a\u0005}U\f\u0004\u000b_R\u009bX\u000f:v\u001fu\u0092\u0001'\u009aBQ\u0015\u001d\u001b\u001c\u0013\u008d\u0091X\u0006\u0080`(\u001a#@2<_1\u0098Fd2\u001aLA'\u001e+1;}\u0013WhO\u009ax\u001dltiN{[8%X\u0090\u0093m#@*\u001d\u008eGB\u0089\u0084\u008e\u0011$q\u009f\n\u0015\u0013\u008awDh6v/\u0015x&\u0087e\u0094;\u001c\u007f\u0093y\u008b1P\b\u0091\u0082\u008f\u0089LBz\u0084\u0099-\u008c\u008b\u000eocNf*\f\u009c\f\u0013R\u0082\u008e@\u001f\u0085'\u00937\f;s\u0097\u009bm*KFbyR#\u0098\u0081\r\u0086&\u0082`h\u0005u\u007f^:\u001a\u008dI'\u0016K_G\u000e\u0015=\u0095LI~/@)\rqn4u\u00896R#T)V\u0089?\u0087\u0014\u0018<\\cj\u0089\u0089P\u008c\f%Zsy\u0097&\n\u007fMS\u00ad`p\u009c\u0097+\u001f\u00863v!\u0099{eS\u0011J3\u009c\u0084\u0017Hgrhb6\u0018'\u0004\u008b3`'\u0012Q\u008b\u007f!\f\u00898A/\u008d2W_~\u001f&S\u0011o6\u008bp\u0093\u0015u!;\u0003y\u001f\u008fB\u008e{G?\u0013?i}!\u0096qa\u0015guX\u0013\u0091RCxK\u009c3e\u0014\u008f\u00161l\u0085\u0092\u009b\u009dW\u0019\u001e;?6Q~\"P\u008b\u0010/yzcjp\u008e\u00adCC|RT\u0092*V$\u00ad\u0098\u0090\u0099YZ]@i`z(\u0001\u00152\u009b\u00909iI\u000f1d\u0012\u009d\u0099 \u0088U4\u0097yE9T\u008d*0\u0089(\u001f<\u0002\u009c/Xp\u0098\u001aUh)\u0017c9\u0095\fP\u0085m\"\u0090\u008bs-[m\u0094Z=sU'#d\r\u00125k\u0084(\u0085S1BDG\u0092:A&'\u0015\u000e\u00ad'\u000b\u0002^MipGa+N\u0006M\u0082\u0015aJ`~*\u0016x\u001d\u001d\u0087\u0006N?p\u008a4.liY\u008bk\u009d\bt\u009b\u009c\b\u000fL\bJbUin&|7\u009d&\u008fyV/\u000b:<\u0010\u0090H\u0006\u009d\u0094\u0016\u0011\u0091a\u0080\u0012<I\u008c>^\u0095,\u0018'C\u001co\u0094Mz\u00075\ni\u0093k\f\u009cfN6Zi-=+\u0005z3\u0096O\u0099!\u009d\u0098t:\u009ca(\u0086cZH=M\u008b\u0016-\fH)M*=z\u008e\u0006\u0011\bO{NN5j\u0099/7\u001eKd\u0090e\u001a\u0014bb\u000fa82d\u0012\bX5H\u00064\u008a\u0086\"\t;8\u00895e[\u0093Ov\u008awJW\u0003\u00045N\u0006\u0002:\u0001\u0010U\u008afh*bg\u009bv\fI\u0090=E\u009c\u000b\bLE'J\u009dL^n\r\t0P\u008f6\n\u001b\t\u0086Db^\u0018\"{_n\tE0z0\"\u0085\u001cL\u000fd\u0086r\u0092JI\f\u0019\u0091l\u0013+X>Im\ntKr\n r)w9\f8\"m\u009c\u001eEL{\u008f)\u0007\r8kw:q;G\u001f\u0087LW\u008d\u0095\r\u0084\u001dRw\u0004mM\u009dg\b\u001aC?7\u0093\u009f\u001cS\u001fWTO!y\u0090\u0087y\u0098N{S \u008f\u0092p\u009c\u0097\u001b\u008a\\cc{v\u008b/c\u0086R!\u0004G\u000b\u000e=.\u0087i\u00806v=qH\u0085\u001dR\u001c\u008a\u0016\u0001H\u0081\u000bi\u008b@%h\u001bv2\u0091a-\u001d_\u008f\u0093\u008a\u000fQ.QY\u0010@Qb@@c\u0094q\u0010\u0017q@)\u0005W\u00832\u0094S\t\u008f\u0094\\W'Jro&fw6\u009f\u0002s0nk85;\u001e^\u001e\u0091M<\u0082\"\u0000\u007f\u0018y\u0080R1TP\t\u0002_w\u001e>]\u0002K\u0017P1!?\u0004.jx\u000f\u001bXv\u0004W\u008e)0\u008e\u0015\u0081\u0086\u0013X5\u0086U-i\u00adZ\u009f46\u008easU]\u009d\u0086\u0013h?\u000642[U\u009fF_f\u008b\u0003\u001e\\V-jWKyMy\u001a\u0016[9\u0082\u001a#\u008d[\u008e\u0086q\rQF\u0088guH\u000fTT\u0015uG\u0091(?$+~OWe}b\f\u009fkU{\u008f\bfN!a\u001c\u0017x\r0\u008f<\t&R\ny\u0092Bj*x*on]M\u0018\u009eW\u0017\u0004GN\u007f;tF\u0086kQE\u000b\u000f\u0019\u001b9=\u0017\u008c\u009b\u0081\u009e7Q\u001a(\u00ad9\u0081_\u001e\u001a_I\u009c(QE\u0086R:x:KI\u00059 .Lfj\u0098\u008aV\\\u0089k\u0082\u000e.\\\u0005\u001b8G\n\u001bq;6.R<\u00806\u001cf\u008c\u0091\u0016\u008fv\u0018qq\u009br>*H\u000b\u00ad\u0095=\u0093\u0018e\u00047=\bc!_Mr\u001c;=\u0083\\f]._z\u000faV<\u001a~\u009dyA\u0004}/5D\u001bx\u009fW\u0086\u009b\\\u0095!%7=.}m|\u009f\u0019}\u0097\u0007RK;|WA\u008d\u0006>\u0087=Z\u000b\u0007|W\u0089\u000f\u0084I\u0099\u001fzJ\u009b\u000e\u007f\u00ad?rU\u0090\u008fG\u00811\u0093i|a?\t\u0094\\V9\u0086j=+X\u0018\u007f~\u0018\u0095\r'\u0012\u001fH?\u009f\u0088B\u0097_\u0090\u009aAb\b\u0083^\u0087:k{k\u0007[=v\u0094,Z}\u0091!JsA\u0006^\u0003z\u0082\u0014\u001f\u0010^0<\u0096W\u0003\u000bSQM\u0005J'\u009e@\u0019{_-\u009e\u001aO\u001aRVS\u0096f\u0002R\u0096\n q1\u0002R\u0011P1\u00995&U-R\u001d\u0018\u0093-1T\u0018seA&qk=i9\u009f)\u0017\u0004Z9S\u0096\u008e\u008ea\u009e+Q.2\\]V,W\u0096\u0095F\u001ex\u0006\"$\u008b\u009b;1\u009f1zV&\u0081H\u0092b\u001fVa\u0098U0\u001f%\u008d\u008d\u0014su'`\u0015<Gp7y\u001dQ\u001c8\u0084Wp/\u0088%x\u001d3\u0083\u001ep\u009f\u009eoq@.u4\u0017\nTwd\u009b\u0010\u0091Ur\u0019#\u0082A\\\u009a\u0099IV\u0015\u008fr%\u000eU\u0086ox\f\u0015QVZ\u008ag_qW*p\u0089F\u001d8\u007f\\}B6*\u00adi\u0083.JKw\u000b(X\u008e\u0010|~\u0084?Z3/#k\f\u0092mn#+~YI\u0084z\u0003\u0097<-\u009d\u008eaa\u009d\u009bY\u0017dj\u0011$\u009b=\ne/\u001e,\u0095\u000bz\u0087<\u007fB\u0089E4\u000b4ta\u0011{\u0002K$\u0096y%\u009es\u0095,#.n#a\u0001Nn39\u0090\u001bE0\b\r%\u0006.\u0098\u001cZ\f\u0095,r90.;\u0003L\u009af\u0005\u001bN\neo&#\u00871_\r\u0087(MJ\u008b\u007f\fW\u0015\u0083j<&>.)\u0096p\u0088fLFd\u007fZ\u0080g\u001cV\u0091\u0007'J7\u0087FA%_bL_b\"jO\u000b^#\u0099/17N\u001e\u009ct\u001d.cJ1\u00073ctY7f#>:\u0087Q_>GW,$R? \u009fSE\u0007.=kx\u0086WK\u009a\u001a?!-_dG\u007fG\f\u0091<1aD\u0006J\b7o3\u009a\u0098HpH6.\u0005\n\u0015\u0095'\u0094<\u00ad\u008f\u000b\u0019y\u0096\nW+1\u001e\u009e4\u0012y^\u000br\u0094\u0083\u0090\u008d\u009bf\u0001PK\u0007\b[\u0007\u000f\u0000\u0000\u0088\u001f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000org/apache/maven/wrapper/Logger.class\u0085SmOP\u0018=w\u001bkWP2\u0010m*%\u000b\u0018\t&&\u0005\u008c3%\u008bR\u001d3\u0004\u008d\u001f\u0001(s\u0086\u0017\u0087I{os\u009e\u009c~\t\u0011\u009eh(04#Y|\u0003aP\u0084\u0091\u0083\u0081\u0090\u0096\u001dy\u009e\u0090\u001aJ\f3\u0087|\u00ad\u0080\u0087\u009e;\u0014n9[o^v\u0018>\u0083\u0006~'\u0018\u008a\u00adP\u008c\u000b\u001d\u0093KdJ)\u0006s{\u0097\u0019\u0098\u0015\r3\u0017\u009fDM0PD\"!j>GI\u001fzq@\u001d4]Tj&c\u009ep1A\u000b#)6y,\u0018\u0097iWp\u0004\f\u001f\u008a\u009d\u0013-\u0005S#\u0097\u0007\u000e\u0097F6\u0081\"\u0016M,@W\u0093\u001f1\u0092\u009f\u0088\u0089\u0087\u001f\u007fq*\u0014\u0089hQQJG4?^\u0013'!}\n\u0083\u001a1^R6\u0000+\u0006\n\nB\u0092\u009e\u001af\u0089d\u0088Kb\u0018(\u0095x\u0001'Gf\u0014\u001dK\u0014P\u0091\"\u0086\u0086J\u0089v%d\u001a\nPGf\u009eW4\u0010RM\u0096\u0089\u0007V\u0086(\u009d\u0085^\u008bVU\u009d|C\u0096zb\u008e\bd6\u00ad\u0015,c%o~NlU\u001e\u00191tN>SfI\u00ad\u0081)Bd\u001e\u009e=1\u001d#\u0091\u0017i\u0006K1\u001f\u0001PK\u0007\b\u0084'+\u0001\u0000\u0000m\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000/\u0000\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.class\u0095X\u0007|\u001bW\u0019d:\u00893\u001a%e[h4I\u0087l+u\\\u00adTSN\u008c\u000e\n@Ye2\nP6i\u000biSV\u000beQ#@\u0081\u0002\u0085\u0093,\u001b%{O?0\u0080b\u008f\u000b\u000b\u0004\u001a\fs<&\u0084\u0016\u008c'5=xT\u0013\t\fv\u0090R\u000b\u0095\u0002\u008e'`L\u0083=\u008ek\u0011K`e[@pHWh0=r?7r+,S[fT\u001f'\u0084l770<\u0011\u001e\u0016XjIK\u00adA5\u0096\b,\n\u0092\u009a\u0019\u00980\u001aE\u0096\bw\u000fn,&\f=\u0094\u0091p_KO\u007f\u008d%\u0094bH\u0092P\u0017\u0096Mo\u0086\u0087zN\u009f\u000b\u001ct\u0002\u0081E\u0091\u008c{X%pg`w`\u0080[~\r\r\u001ctc\u008d3\u009c,\u009a\u009d\u0085}hj>\u0016\u00037D\u0013d?\u0012\u008bQr\u0081\u008a\u0086A\u0081VcTsGK}\u0092\u008aF5\u008d\u008d\u00029'y\t[\\\\\u00143IK\u008b+\u008az2YZg\u0004\fV-\u000fhr\u0098\u00adMA3\u0002\u0002\u00932p=c%,\u001d\u0094g\u001e\u0014l\u000e\u0081Yk3tE0\u0010!\u000fVp\t\u0090\u0084>*</\u001bU\u000fop>\n\\P_Fj0\n\u0016\u008a\u008cZw*~L3\u0007c1M\u0088A\u008cA\u0005ZQ5\u0011M\n4v;\u0098&\u0095q>\u0005V\u001f-\b\u0001OtDKXQf\u008b\u000b\u00025y\u0017\u000fP\u0089.ge\u001dRMn\u0011<\u0010\u008di$e\u008f\u0082^\\%<K\u0099FT\u0017\u0017\u00979`@\u001ew\u0099\u0086aEM7`HwI\u0096f&\u0097\u001bL\u0001zzg\u001a(u\u001a\u0081z\u0018\u001fL\u0005ITF1C\u0082\u0099\nT\u001cc\u001eamj\u0094\u0015\u008d\u0005_lG\u0015h T%T39\u0091'9`\u001a\u00909N&\u009b\u0086\u0080o\u0097\u009a \t\u001cw!J\f\u0095\u0013z\u0088D\n\u00ad/90(U\u0015\u0018`\tQGGK\u0015bpJ\u00031XM\u008c$X\u008a+\u008c\u0014\u007fks$\u009a\u001av'q\u0085S\u0002z6\u001b\u0085i-\u0092\fr=\u0083\u001b1\u001c*\u0084\u0094.[N\u0081\u0093BvR\\+q\u009f\u000b7\tl\u009c\u0095]\r\u0098f,\u0001tm\u0098\u009a\u008aYm)=fvu|\u0093)\u000fn\u00ad23\u009f+L(\u0097n.<\u008flVi5\u0011J&8\u008dq\u0002\u0005[l\u001dfM>h\u0097\")9\u008dx\u0089|{ov\"/c)\u009c\u0095\u0085\u0099\u0090\u0085RMK|\u0007Z$@^Ux5\u0093X\u0003\bG!\u007fver\u0001\u009a\u0083\u009c\u0006vMTd)#\u00915\u0018iH\u0094\u0080qYrF(\u009f,\u008a\u0081G0\u001fgjL\u008a=4\u008f\u007f>8\u009c\u007f@hV=\u0013\u0004KKB\u0011\u008f\u00939\u009d\u009cp\u0085\u0016\u0017.\u0010\u0098\u0093W^Yxn\u0089\u0083N\u0005]3bcq\u009ds\u0000,7\u008d(x/'\u000bZ,f\u009c:_\u0013=%~\u008eP\u009e\u00add\u0001\u0005\u001fY_v\u0016\b\u0097\u000f\u009c\u009cmv\u0005IW\u0000>\u0014\u00888\u0014h\u001f\u00860q!zP\u0004\nN\u0004Z\u00162\u009f\u0013\u0098#\u0012:\u0085\u008f-L77\u001ef~9}x><\u0098#\u008c}Lo\u0082\\\u0019\u0013\u0094\u000b\u009fJjTjA\u0016\u0093x\u008c\u0018>R\\_;)\u0098\u0019\u0005\u008f%Y\u0007\u0096$\u0095_>I}\u0091_T%n\u001a\u0007\u009aq>\u00179\u008fo(&E\u0099Z\"F\u0003Q3I\u0099\u0015S-\u009e\u00ad\u001e<\u0081]\u0016<AkLM\u009b>~8\u0084\b1S\u009bt\u008d\u001b{\u009e$+\u0096\u0019\u0004KiG\u0089\u000b?fo77\u0082\u009fg\u008e\fo\b\u0013n\f\u0011d\u000b\u0085_w\u0098\u008dF\u001bg\b\u0091\u0094W\u0097\u009a\u0015EF\u001f\\4\u001c\n\u0088?1-p_\u008cc\u0004\u009f\u0005V=\u0097\u00adh\\+h\u008c\u0012O\u0003\u0013qY\u0088)\u0017Q,]?OJd\u009bW\u0098\u008d&?\b\bAh'Rj,Y2LOAG\u0082\u0013E\u0086\u001b\u0098q\u009f/\"C\u009b\u0085c\u0084\u008f=o\u008c/B\u001dS\u0093\u009ao\u0000\u0089\u0085\u008a\u0012.\u008a#}\\%.-\u0083e4(\u0007F\u0085G\u0011\u008b/\u009b\u000b\u0089m.yM#\u0096z:S\u000eQ\\ \u0097\u0014\u0083.!duq|\u009f[p\u001d\n\u000f\u0084\u009a\u000fdB\bX\u009c\u009bD\u0088\u0017\u0013b\u0085\"V\u008aUNFiI\u001bd\n4>\u001ajl}[&v\r\u009f-\u0097\u0017\u0090\u0080yGN\u0088u\u008aPge\u0087\u0096Q\t;\u000e\u00adb\u0083\u009c\u008a\u009dG\u009e\u0016\u009bh*Ed7}=M\u0092\t-\u0012\u001d\u008bj;&T\u009fEh(\u0011[DKl\u009d\u009e\u008a)AN\u009c\u000b#1#\u0005M\u00adF\u008a|\u008aa6\r|t^43\u001f\u0004w\u00050C\u0098y\fO\u0096u_q\nvm\u0001<\u000e8\u0089\u008b\u0015K\u0089\u008a\u0093\u009c^\u009dyr@\u00066\u0015\u0000Q'\u0007u'\u0081\u0005\u0082\u0092\u0082R\u0097\u0015\u0097s-Xp}A\u0096\u0015\u0005\u0095\\\u0015WX\u009d\u000bs\u0085\u00ad\u001df\n\u0087\u001b2(\u0083\u0086I\u0004;\u0095\u000f\u0083W'#\u0093f\\i\u0082l\u0098\u0005\u0014|.O\"\u0094?Veo\u008f(\u000e\u0001Zf{%\u008c\u0003z\u0006+)j3\u0096\f\u009d\u0095\u009aWSJG\f\u008ed0waB\u007f\u0006\u00914\u009b3\u00887\u008f\u0013\u0019VUp\u0014n\u001eRW9\u0089L\f\u009e?\u0089\u0017NScx\u0012/O\u0015ym\u0003\u008c\u0007\u008dl~;\u0018\u008d\u008b]\u008aK\u0084=|\u008bK\u001f-\u008cU\u0007\u001d}\u001ad\u0002\u009dx\u001dF\u0004\u0002r\u000e\u0003| a\f'\u0095v%\u0080;\u008d\u00167M\u009foy\u008b\u008f\u0014O(m\u009d]Tm\u009dS\u009b{\u001a\u009bx\u0007{\u009f\u0011|l\u0094\u0015d\r\u0084\u0016\u0082\u0095hc>\u0087eVe73\u0089\fU^F|\u0004\u000f\u0092\u0083G\u008e\u001e%'\u0019\u0006z\nS\u0083\u0087&q.\u0083\u008fM\u007fV\u009fKlA\u0014~\b(@A\u0083\u0011\t\u0001\\\u0095\u0015+\u000bE=\u000e\u0090\u000bX,\u001d-YX\u0084t+m\u009d,\u007feW$]\u0080\u001cNteJ\u001f\u008a4\u0093\u000fy\u001a\u0017\u008b\u0019\u0088\u008d\u00939\u008a\u009b_i<}'f\u008dXP\u0010*\u0086+\u0019Q9)\u001ceDP\u0096+\u0016g5YmW\u00867L|\u001ca~^C_]Kt\u008d\u0082\u0014\u0015bXZ\u0004o5\u0016\u0085!bIbK\u0006\u0088W\u0088\u009a?\u0086%\u008eZu\u008e.\u0013\u0093bMg#\u0015ZX#|i)Gs\u0091i[\u009b*vg\u000e?)\u009aQ\u001f\u001f5?`\u008eV c\u0091\u0004\u001c0\f\u0098\u0088^\u009c863g\u009a\u0099)\u0011\u0006iO\tV\u0081\u0013\u0087I.I\u0006-\u0096j\u0089fYlg\b\u0013\u001b\u0005T\u0083\u001dvnE\u0086i\u001dG\u0011\u0090*\u0019spK\u008f((g{\u0003Fjp\u0013+\u0082[r\u0090B#\u0085J:!v\u0093\u0092\u0002PK\u0007\b\u0011ps]\u000b\u0000\u0000\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000>\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.class\u008dR]O\u0013Q\u0010=-PWX\u0003?A\bi\u0017t(1!\u0010\u008dI&\u009a>`r^lw\u009b[[\u009a\u0098\u000fG\u0011^\u001ab\u0081\u0087\u0099\u00993g\u009e\u009e\u0007`\u000f\u009b\u001e\u001cLb1\u0012\u009d\u008c\u0087D\u000f-F#\u001f\u001c\u0013\u009aYG$G*/j\u008f\u000b\u0095\u001e\u0084` ND\u009c\u0088\u0017\u007fj\u000fd x]\u001eF\u0084,~\u0012f:R\u009a\u0016}\u0095o$\u009b3W*\u0012M\u009a=`\u00165Z\u0084a\u0095KS},b\u0082\u0012\u0002\u001f\u0015\u0012JFt><&c\u0001.aRq<lKU\f!\u0084V\u0006O\u008beD9on0?9\u0092.7\u001a[9 \u0006_\u000b\u0010\u00880<\u0082!M>L\u0004s\u000f\u001b\u0084\u008e$^;\u0013\u001bM\u0089\u0012Bc\u0010g\f\b\u0002cU_\u009fw8(sE;\u0013\u008e`%\u009d \u008c\u009eOPu\u0007w\u000e3e2\u008eQE\u000fnj\u008f5fF\u0099Q7Z\u000fp\u0015s$\u008e\u000bo\u0084?/\u00978\u000b\u008b\u0081B\u001b\u0006\u0083\u0004O9V,}\u001d@PK\u0007\b\u001coI\u0001\u0000\u0000t\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler.class\u009dV\u007f\u0013\u0011}kK\u0096,\u0016\u0002\n\u0098`*\u0092-\u0085&\u0004\u0003\u0089/Rv}\u0081q\u001b\u0096\u0016yAUvW\u0006i\u009b\u001e$mNKz&\u0092\u001b7\u000fY\u0092mD>?Hyf6\u0080\u0093W\u0000M\nNXv.\u0015\u0082\u009e\\\u0096t3y\n\u0005N\u008ekB\u009f\u008by\u000e`umIK53\u0097\u001c\u009bg\\\u0005m\u0099\u0093C\u0013W\u0087CW'&R\u0017\u0015\u0084G\u0093m\u0098^\u0005;\u0007,q5\u009dE=\u0088V\u0005\u000fmq`SC\u0003SUWA\n\u0002gt\u0081\u009cvt{Zi]\u0089cX\u000bF^g\u008c\u0096\u0086i\u00154Gf\u0014\u0006\u001eB3\u001eV\u0010v3\u0088ay\u009e\u0098\u009a@2Z~F\r>\u000b\u0086 :=~\u0018xOt3\u0094\u0099V(P\u0013\u00186\u0083\u0086C&\u008ba\u0099\nn\u0083K\u0095+f\u008a&;z\u0089\u0098\u0097`!\u001cB$\u0080w+y\u0098*\u000e0\u000b\u001ffnrz\"E\u007f\n\u008e8\u0086\nvT3\u001b\u001eG\u009b-\u0081l~\u008f\u008a(H\u008b\u00ad/ZK-W7\u001d\u008f\u0096\u0013{wI\\E7z\u0088,B+\b\u001b8x`\u0010@R\u0081I\u0015\n\u001eR~!\u0092\u0000?}x\u0082\u0010\u0089)\u0099k\u0090\u0002x\\\u00adVE#\u009fml#<\u008f\u0010\u0000\u009e\u0015\u000f*.[\u0092\u001c\b\u0095^o\\\u0084\u0018\u0094bk\u0004\u007f&\b\u0002%)\u0086)\u0015O\u0003lP!R\u008at5;/VZ\u0017t\u00ad\u0010\u0012\u0018\u0017\u0000\u001f\u001e_#8\u008a)q\"_1\n<\u009eQqica,\u0080Y\u0005\u000b2\u0004\u0087\u0014\\\u001ci\u0094C}pe6*UA\u0001M\u0099qU\u0082Z\u0006d[\u0091\u0081\u0010H\u0007_\nfAWJgO\rkB\u0010\u0015\u008f;\u008e\b-b\u0011\u0084r\u00175~(\u001eoPm\u0089\u008c\u0088\u008av\u0012Y\u008e\u0010\u001c\u0014\u0003\u0003\u009eg\u008a.'h9SNw\\\u0015KY\u0099O)\u0093a.'/^z%\u009de\u0015\u001fGI\u00984\u008bv\u000b\u0090\u008f8>T\u008b\u00852\u0084?:5\u0013'9\u0001<$`!oRQ\u001d|ZgaK\u000b\u0012xA\"\u001fES_\u001e}N\u0092VH</\u0013E5\u00169K3zAj\u001d\u0017\u0015\u001c\u001c\u008al\u0002)\u008c\u0018fF\u001cC\"\u0084\u0097e\t\u0015\u0005FcdjnWR\u001aGL]-\"W<wz#\u0089\n:\u0091c\u00926_i\u008e\u0083H!\u008bF\u001a\u0004\r\u000e_'&S}\u0080k\u000e\u000b\u009coj8\u0086Rb#\u0015?O\u0014:u\u0094mT#fY]\n_J:\u0097*~%!@\u0005O\u0088\u0097\u001d3mk\u0091\u008f\u001f\u0014\u0003H\u0082g\u008bZ\u0002t]W\u0082x\u0083*+x\u0093\u001aTJ\u0019\u007f\n`u^v\\}Q\u009b\u0081\"qb\u009b2\f\u0007\u0083x\u008bAd\u009d\u0089\u0004q\u0097\u0016\u0011\u0089\u0014\u001bu\u0094z\u000f\u0012y\nMZE;h!h\u0018JH86~49@H#s\u008caN\u0083f\u001e'\u009b\u000e?Zx\u0017]\u0013\u0082\u000fm\u001fA\\\u0007\u008c\u00071*ce\u0084_L?+\u0087#\u0095Z1B\u001b*\u000eUup\u0081\u0096b\u001b\u0012\u0007\u001bh{A;F/\u008a\u0013\u009e\u008au\u0093\u0004\u0096\u00808\u0080\u0083U\u009f%p\u0081};\u0016/\u008c#Xw\u0019'Fc=2bg|kHGxl\rg<\u008ase\f\u0084/\u00940_\t#e\u008c\u009dNmz\u00965\\\u009e\u008d[RK\u0083\u0013O+zH@\u0082\t$1\u0080Gp\u008b\u0087yIm\u0002\u0096m|\u0018O3V<\u0087]Kx\u0086fZ\u0098Bj\u0006\u000f\u008d\u0014g'\u0012K\u009ed\\\u001b\u001f\u0087bDYB\u008cka\u0016\u009ag\u009b\u0093\u009eUXRS\u0090#\u008e\u008aUvP\u001d\u0010(J52\fC$\u009f\u0095j;';\u0013*4y5Sskx~G,\u009f*H\t\u009f]I\u0017X/<\u001fl\u0089^\u009f\nQy\t\u001c\u0093\u001e\u0098\u001f%u\u000f_\u000b\r|~|\u000b&\\\u0082x\u0092\u008b\u0090>7\"wKx;W\u0007Ka\u009d\u0097\u0097\u0010kt\u0081^.\u0092\u0094\u0017?R[\u008b\u0017?\u00adN\f?b\u009c]\u008deZt\u0090\u008f_E9\u009ed\u0095N3%\u001e,Qr<\u0089bbCU:jQ;[\u008e1|{O\u0001*\u0095 *<V\u0085/\u001e\u000e\u0096\n\u0082\u0012\u000fv\u008bT\u008a\u0094E4\u001f3\u001e\u0017.\u0002s\u00862\u0090\u0097\th\u0096\tm\u001a>#\t\u007f\u001d$p\u009f\u0082\u007fB\u001fPK\u0007\b\u0087|+\u009f?\u0007\u0000\u0000\u000e\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00006\u0000\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.class\u009dUY[\u0013W\u0018~\u008f\u0004\u0006AE\u0010\bQ\u0011\u0004ib\r\u008b\u0086P\f\u0098\f&3d\"Uo<\b<O\u008fj\u009e$\u0090\u0004b8g\u009d{\u00018\u008d4l\u00138e\u0089\u0018\f\u008d\n\u0086H7\u001c[x2=<x\\3\u0094t5\u0004v\u0019\u008dp\u0012\u00999\u0019\u0004\u0006L\u0006\u0005j::'\u0005|WYG\r\u001atN`gh6=#\tc&%\u0005\u009avHM\u001aEK\u009a\u0019\u00813WD`OBz\u009b\u0002G:yoM;|LHg\u0098Txp\u00103\u0013\u0096e]?\u0003R15\u00adDd+e0a\u008f\u00925#\u0093\u001fMhc\u001f\u000eh/\u0097#\u0080\u0016hf)\u000f\u0086C\u0002{KfJaq\u0010\r\u001a\u008e\b/72l9Y\u008f^H#G+\u008e*\u008f\u0093AM*t\u0004!O\u0081\u0092P\u0099\u0099l+:tt,SvFj\u0012h)}#kyfZ\u000e-\u0099!X\u0019.\u0097fjV\b\u000b\u001c\u001fr]m\u009bOJM]Ov\u009b\u0011]\u001dzy\u008fn\u009cV\u0011\u009c\u0011h\n\u001bgu\u001c\u0081Sa1\u008ePh:\u0099\u00882qA\u0017\u0002\u0093wlUl\u0010\u0003\u008b\u0002*\u000e\u0095Q&\u0092=*\u009a^\u0005vLf0ot\u0004;\u0084+\u001a.\u0003\u0095O+\u0013r!<nx\u009et-\u001d/aH@\u008bi'_\u0012j D\u009f\u001dQ)~Y5\f\u0013\u009cr1&=U\t\n$E\u001a*F4D\u0005W0t\u008cb\u008c\u0098\u00984fx+BwH\u0081\u0088i\u00861\u0081Xb\u0096\\6Z\u008d\u001a\u0012\u0017\u0014\u001atLa\u009a\u0001\r\u008fm\u001b{\u0003\u00924\u0098\u0097\u0095V\\V\t{Ds\u00867Z\u0014\u00964\u001d\u009aU\u0086\u008e\u0019Y\t:\u0086&_\"N+t$a\u0012\u0094\u0012^2\n:RH\u009cP\u009f\u0087,\u0092\u001aa\u009e\u0006\"\u001f\u009c\u001d:\\p\u009a3\u0005.T/\u00ad_GV}\u0005\u0080\u009642\u008b\u0086\u0005\u008d\u001fhc\u0081\u001d\u009e,L\u001d\u0095\u0083D(H\u0017\u0090<[N(W.\u008820n\u0004\u0002\u00157\u0094O\"\u0001A\u000f\u009aU<%Os\nuaJK\"Md\u0005\u009djuED\u0095jP\u0081U<e\u008bs\u009e\u000f\u0016n\\\u0016@?\u008c'G(\u001a\u008d\u007f|kj<\u0085\u000b\u0015\u0094g\u0089\u00adh\u0017\u0004o\u0080\u001dI]y\u0088xBn=?ij\u0005{\u001c\u009a\u001fky\r\u0007I8<\u0086)6\u001d\u0012~\u001f\u007fN\u0006|O\u0084k\bN\u00ad{g\u0005\u009b\n\"O\u009b\u0006\u007f\u008b9\\]+\u0002K\u0014]8}\u0080/\u0087\u001cn\u0005rx\u0011\u0003u$\u0005\u001cf\u009f+u+9\nM>s\u00adk\u00991\u001c\u000e\u0000\u001f\u0084I!0\u0089fG\u00191{\u009c\u0091S$O\u009d\\\u0083|\u0010p\u008ak/\b!\u0082\u001eN\u0098\u0019#=\u009c|t\u001e\u001c\u000f/SJ!z\u009b(\u0012-,\u001d\u0011R\u009eu\u0085Gx\u001f\u001f}j\u0003|H_\"~\u0084\u008f7\u008d[\u00846kh\u000f\u009fs\u00158\u0082z\u0088\u0016|\u0089\u0098\u008f\u008b9+&\u009f\u0087l}\u0017PK\u0007\b{\u0002`-\u0004\u0000\u0000\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.class\u0095\u0094S\u001bU\u0014\u0017B\u0012\u0085\u0084\u0004\u0088j\u0086-BZ\u008a\rI*mC\u0012I\u00030\u0017X\u009bT%\u001ftF\u008e\u000f\u0003\u001c@<!{~\u009f{y\u000b`\u0005\u0018\u0018\u0096x\u0097\u001f\u009d)?Mnk{,YFgs\u0018\"\fW\u008ck\u001dn+e\u0098)V\u008a?4\u000fZFReHW\u009am\u0098G\fSqNO\u008fc\u0092aa[\u001d\u0014\u001b\u008dP'\u0086L`\u0097{jX\u0016P\u0018nIi\f\n\u009cNw\u0085\u00813Lunv,~L9\u0086Cd\u0087=n\u0014\u0089MZ;\u008865\u0018\u008e\u001er5{\u0010Aa\u001a\u0006\u009a\u0088\u0094c=\u0081q|&KC|\u0014\u00adlv\\Tm|Lm3\u0086{k^w%p\u0007\u009fp\u0097Fq\u0015\u008eM\u0005\u009f\u001el\u0097\u008e\u001e\u0018d\u008d'*\u0098r\n\u0092\u0098\u008e>CV\u0093z]\u0011e\u0005iDx@so\u008d\u001eG\u0004?W\u0090AThk\nf}\u000b\u0005s\u0088Ran\u0087\u001d],\u008bu;6\u0084\u001d8#\u00890hwQ17)\u0086FMs\r\u0098qt7\u001c\u0089bD\u009a$/s/=4\u0094\u0088,+Hao0\u009c>\u000eg\u008bs3&\u0092!S#K\u0096\u008eR_p\u000f\u009b\u001e'\u009cA\u008f\u0004iz\u0091\u0010\u009a\u0097bYpa\u0091.e\u009cs&1\u008f\tD\u008a\u00915\u00868\u0089\u0001\u0006h<=\u0019HIOy2\u0013@y2I=dF~F\u0090\u001bt\r\u0016`\u0002K\u008d\u009e?@>\u0097.\u009e^k%=\u0010 \ba@m-B],7F\u0087\u0094\u0087+|M\u0092\u0011\u0003\u0010\u008d\u0088MBQ\u000e\u0014O\\\u0016?FPAc\";@WX\t{\u009fj^\u0087\u009b~VAhHA\u0096 \u000f O Ka\u00905)\u008c\u0000\u0099\n@\u008a\u0094\u0080\u0094\b\u0081<\u0094\u0082T\u001a\b\u008d\u0014\u0006Y\u009a#@\u0016\u0089\u0083\u0096\u0004$\u001f\u0006y\"\u0005y\u00862\u0090|\u0018L5\u0095\u0011 i\u0004\u0086\u0017R\u0090\u00950\u0096\u0014*\u0007Y\t\u0083Tf{\u0004H&\u0000\u0096\u0082\u0086A\u001aR\u0090\u009a\u001cd5\f\u0092jZ#@f\u0003\u0090\u0014\u0010\u0006^\n\u0090\u0083\u0014 ?RO#@\u0002\u0090\u009a\u009d\u0001PK\u0007\b\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.\u0000\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.class\u0095W\t{\u0013\u0015=\u0003r$\u008ba\u00136`\u0096Ta\t$e\u00007V,cb\bcil\u000f\u00915h\u00841Im\u0092\u0096[&mhZ`\t]I\u009b{\u007fM\u009ef$\u008d\u0000i{ss^{\u0003v7\u0088E\nb5\u0099ZzJOLkg\\byJ\u001cs\u009e}gt6\u00ad \u0002\nV\u009ch\u0089\u0096\u009bL\f\u008d\u009f\u0082\u0096p\u007f\u0091SG\u0087\u0007N%\u0087\u0087\u0092}#c\n\"\u0003U\u0094m\u0019=\n\u0096\u0098\u0082\u00adQ-[ChT<c\u0014zh\u001bf\u0095UjwWb6\u0004\u0095\u0081x5\u0082`p_r\u00059#\u009fb\u0016#[k>5r#\u001e3\u009f\u001au\u001e\u008el8o\u0099\u00846\u0082\u0082\u000e\b4\u0095M$+\u0004bYU\u0091eT\u001cIL\u0088\u0080jFrDmh\u008bv\u0094\u008beq)xOM\u0018\u0093\n\u0012\u0003wg\u008f\u0094,Z\u009aH\u008d&L\u008ba\u0089b\u001a\u0016\u007fMkVA2V\u001b\u008b;z+\u0087\u008e\u0002=fF\u000fb\u0013\u009a\u000ea\u008b\u0082k\u0095uVa\n>b\u001bbLy\u00913\n6:T\u0097s\u00adA\u00154!\u008cV\u000b\u0093\u001d\n\u0016ZG \u0088bN\u0005|-\u0017\u0016\u008c\u0092\u0003FN\u001f,N\u008f\u00888\u0014\raf\u0019b\u001e\n+Xr%k!r\u007fH\u0093g\u0082\u008cx\u0010Ij\u0010\u009cmL}gz^8\u0084\n]\u009b*\u0098\tZ\u008dnZ\u0016\u0098L;*v\u0086\u001f\t@M;XB7\u0003`\u0094\u001a\u0019+v3'\u0006\u0004\u0089r\u0093T\u0018+\u0080ScE\u0094b1\u00838H\u001d!7\u008e\u000f\u0080\u008dbuDj\u0011!\u0015k\"V\u008fX\u0087)\u0015#8\u009aZ&imo\u008b\u0000\u000ei\u008ex\u0014\u009cy\u0096\u009e,f\u00192\u0090=\"\u0013*\u001eIR^\r\u0005+c!\u009cR~hZyg5|\u0081V\u0090V\u0091\u0001\u0005\u0096P\u008d\u009cM\u0007v\u009fB\u0099<\u0004RaJnUH*\u001e\u008bTLH~ZEO>\u0003B?LFl\u0016jB\u0019\u00153\u001e\u0091Y\u0015<8\u0084\u000f\u001dzb6#)/j\u001e\u009d\u000e\u009c\u0096)\u0098\u0084`\u0093\n\u0087ld2g\u000f\u0090\u001c\u0085\u0094Azf|*,_\u0080\u008f9\u000bW6\u0085 \u009eU\u009clV$\u0004\u001d\u009eW\t\u0096e$&a\\\u0083Ty@*>#\u0090m$)\u0006:-'T|\u001e_\u0005A(=g;\u009f\n-#\u008c~I\u0097\u0085\u0089\u008a\u0089T^O\u001b\u0013F\u009a0\u0082\u008a\u0017E@\rI\u008f\u009c/\u0005h\u009fje\u009b74\u0088WU&5-\u0088Q(P\u0012A|\\2?T\u0001-\u0088\u0006M?/2]t\u0018\u0097=\u008fW\u009cVP\u008fc]\u0090\u008d3*1#e/A\u001bDU@\u0015\u0095jHgM!#\u009cWxQg\u008fSDKLEI@\u0082j\u0082;\u007f\u000fA]R\u0094\u0018\u0013>qK{\u0012\u0098mdMfZ\u0088&\u0092%Y(.`\u008e_\u0006\u000b\u0005\u009bl^kH\u009a\u0098r*+8\u0010<o\"of\u00107ne\u008b]{V \n\"V\u001fF&9-V\b\u0013\u007fI\u0094\u000eF\u008c\u0004v\u008bo\u00158\u0010as\u009aW9;mF\u009f\u008aY\u0086|87\u007f)\u001a4r\u0017\u009d1s\u0003)8\u0003AD\u008d\u009c4.U:Y\u0094\u001c\u000ei\u009b\u0094\u009d\u0002#N\u0014\u008d_N#Z\u0080{\u000br\b!\u009e\u0012\u0097z_~\u0095g\u0084\u0088Hp\u001d\u0011\b%B>yS{\u000ejD\u001b\">-@\u0019[}c\u0012.u\u0084\u0012:\u0015^e\u000fw\u0085wI\u001fb%\u0010s6\u0018\u0093\u0090\u0088\u0017v\u0001\"{\u0002cx\u001a\u0095s]\u008d[&\u0001z\u0090F\u001eb;=n;q\u000bq\u001fv*;\u0093\u008b\u0012\u000e!\u009a\u008ab v\u0015\u0083\u008eH1\u0017d[5\fu\t8.\u0097\u0091%1\u008f\u00950>\u008f\tlsfs93\u0099\u009c59gEyv\u00126\u000e;\u0099\u0089[\u0002%|eF\u0015\u001fxy?\u0096w\u000f\u0002j/\u008f\u0099g\u000eP\u000bqt\u0013\u0091\u001e\u0017'\u000bA\u001f8\u008cWh\u0087\u0093=>\u0082%F\u0017%Z\u008a\\\tj,\u0092+\u0081b\u00ad3\u0010)/\u0087\u0018\u0006(qY\u008c|\u0003l!:\r\u0010O\u0089\u0016I\u0093+\u0018\u009cgyEe\u001e_\u0099kV.B-A\u00ad\u0006\f\u0091n\u008f`\u0013R\u009emq#k Q\u008a\"\u0098\\\u0003\u009bk \u0012\u009aK7r\u0001\u0017HP\t(\u00959xLw(\u008e1g'k1\u000e\u008b\u0004Dho\\1&#m%\u0084\u0007\u009c.~/K\u0092_4\u009e\fC\u0099\u0004QI>*\u008d\u0012R\u0013b\u009e\u0096\u0014s\u001b\u0001>E!\u0087I[0I)5,\tWA+\u0017=\r\u0015\u009fu\u000f\u001eOI3Y\u0006-\u0014iwxcw\u00ad%0\u008f\\kY\"z\u008e\u0090\u009c\u00100R!`\u0004o\u000f_\u0004\u007f\u009f$\t\"3B0\u0013+A\u00114M`\u000f\b`Ma\u001b\u0084\u0087M\u008a\u009b &\u000bCkh\u0086;Q\u0082C$K\u0083\u001d718\u0007uT\u00075Rr\u008adlsa1Uqu(V\u007f\u0097s\u0091y\u0083+\u0011\u0095l\u0092\u001c ?\u001b10\u0016\u0010MT\u009e\u0083u)^q\u0083Q\u007f\u000fPK\u0007\b9\u0091\b\u0000\u0000,\u0013\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000org/apache/maven/wrapper/cli/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.class\u009dUN\u001aA\u0018=#\u008bJ\u0015\u0011mWXZ*\u009a\u0098Pk\"!\u000e\u0014B\u0096EKY\u001fL\u000f\u0087j.E\u0094-?v.|s\f??~\u0001XF\b}\fk\u0015*7\u000e\u0085^Ol^\u00ad\n[7JY967\u009c\u00adJ\u00ad\u0083i\u0089\u00ad\u008au,lG!(\fG\u0098%n\u0015\u008f\u0085#a8!3,w\u0005\u0003c\u0098\u0096l0\u0004\u0089<\u0083U9\u0010*\u0002\u0018\n#\u0084\u0001\u0086\u0011\u0099[/\u0017\u0084\u009d\u0085\u0092`\u0018V\f^s\u0094fPq\u000e\u001aC:{\f\u007foo\u000f\u009b\u001b\u0084\u001d2\bC<\u009epo\u0087R$G:\u0091j)mR\u007f5D1+V-\u0084uFi\u0017ea9\u00ad\f\u0083fNzR~\u00122m}6\u00ad\"\tO\u0090\u0010\u0019\u0016{vM*0\u0082A\u00183\u0098%z\u008bYtW@K'\u0012p>\u008c\u0087x\u0010(\u007f\u009c\n\"\u001eQ'a\u008c)ku=8\u0085E\u008e\u0011?}t]t\u0097n\u0003\u009e^O\u008eaiK7\u00160d\u0089\u0093\u001dp #q\u009fZesi\nC\u0084\u009dxv^S'.\u0095g\u00970i\u001a\u009dCG.\u001c<\u0000\u0006\u009c`U+u\u0010|[\u001e\u008b\u0012\u008bs&\t\u0019>]y\u009f\u0094y:\u0000}A\u008f\bROo/\u00834\u009ev\u000e;\r\u0002\bS\u0006q\u0087\u0097\u0080a\u008cP?z)2F=\u0099\u0082/Bc\u0085f\u0013\u0098Q\u001fb.)\u00ad\u0004\u009f\u0089OAK6p_K.40\u0016\u009b\u0016!e\u0013D\u001bu\u00adMj9z\u00868Q\f<\u0001\u008dH\u009c(^X+k\u00ad\u008b~>\u0092=Z\u0091TmAk \u0095]\r\u001e\u0012\u000bZ0Bm3b\u0087\u008dV\u0014cM#v\u00944\"%\u008dH^b\u009c\u0098*gI\u009cBT\u009aN+&\u0096\u0001R$=\t<b-ObMO5)\u008a|\u0004(i\\/\u008e2\u009bPK\u0007\bdQv\u0002\u0000\u0000T\b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.class\u00adVk[\u001bE\u0014~\u0087l$l\u0010\u0081\u008a\"\u0085Zjn\u0090\u0016\u008dP\u0014\u0081p -j\u0097e\tK\u0093uw\u000f~/\u0083>g\u007f\u0083E=\t\u0081d@,y\u0098\u0099\u009d9\u009e9g\u0000\\\u008f\"\u0018f\f+\u009f\u0092MYRSEyGS\u0096l\u009a\u0095R\nZjzv,Yq\u0096,\u0083\u001cMg\u008cbQ7\u009a\u0018\u000eM\u0096\b\u0081\f5Sgh\u009ft\u0099bEc9\u0006aPC!(\u008fv\u0086\u000b\\~T\\W\u00adGzAe\u0088d\rE.dKIl\u0086\u001b\u0094f\u0087B\u008b\u0019:CW4\u0096\u0096wTAe<\u0089zDgUG\n\u0006C_\u00935[b\u009bZd\u0011\u0081\u007fC?\u0006tIlB\u0019\u0089f\b7b\n\u0081\u0084G\u0012|.\u00130r]$\u0012\u009d\u0092Q\u0085<\u0017}uB+NH\u00870\u0088E\\>\u0003\u009c\u008a\u0084+\u0018b\u0090d{\u0097\u008a\u008fF[@\u0081\u0084N\u009aA$\u0091`8OvNh6\u0006\u0092L\u0099\fzgQm\u0019vd]<\u008c\u0092\u0015RI\u0012e-\u008e\u001by\u001a'\u009c3Si\u0011dHlo\u0091v\bc\b2\u0088J%\u009d\u0018\u0096N\u0088l\u00971\u001e\u0006^=Eu\"&N\u0080\u008e\u0099>\f\u009a\u009a>\t\u0094j!\u0087\"NJ\u0014\u000fH\u009e\u001f1<8{zL2c\u008a\u0098a\u0018oE_\u001cQ\u008d\u0098\u0093\u000b%\u00956R\u0017xYv\u001d\u008f\u0007\"2\u0094\u008a+\u0012>E\u0096!,;\u0006RO\u009dv:O\u0016\u0016$b\u0091{W%|\u0086\u0087T,tui\u0017UI\u0007\u0088\u0081\r\u000b9\t+\u0082BY7M\u0086f\u0004\u0098\u0001\u001dXW\"d8Ww\u0012S*of\u0089\u001d\u009di\u0002\u008bY\u0097\u0080J.:F\u009bs/d2M\u0012\u0017y\u000e\u0099\u0004\u0093&a\u001b\u0088 ]{\u000bK\b\u0013\u0017r'^>4k\u0095W\u008d<S\u0000\u00983-\u001c\u008c4+> \u000b\u008cb\u009b\u0087UFKI\u0090k1O<$\u0086=\t7q\u008b\u008f\u0095\u00905rQ\u0014\u009e\u0011'N\u0004\u0019\u0019=g\u009aY\u0098l5Sia\u0090\u008247\u0018\"}0\u0087?\u0012\u0081_h\u0086\u0010d\u000f\u0085? U\u0004?\u0007\b\u0002\u007f\u0082}w\u009ed\"xj$i\u0084wt\u00ade,\n\\;2\u0006\u0093y\u008c\u0011\b\".\u000f\u0003\u0018\"\u0011\fTU\u0010$\u0086{\u0088v\bi\u000bP\u001auQ\u008c\u0088#\u000f\u0086\u0097s\u0003+\u0005\u0019?f6\u008d\u0005S\u0098v-:\u000eXKpFeL\u00961}\u0080O\u0018&\u0084\u0017\u0098\u0015\u000e0\u001a]\u000b\u0011M\u007f9\u0001\u009e\u0002a_\fy/<-C\u00ad,p-\u0086\u009f~\u0095(}.\u0084\n\u0088\u0012\u0018qb\u009c lILh\u0089f\u001e\u0013c`\u009cP\u0011\u009awP@e\u0006\u001d\u0006\u001f I\u0013\u0090(,s\u0012}\u0087\u008fsq\u000f\u0013X+c\u008fE\u0006\u0084g\u0014\u001eVc`\u0016Xe\n\u007fW\u001d?PK\u0007\bj F\u0004\u0000\u0000\f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.class\u009d\u0090AO0\u0014Et \nF\u0012\u008d\u0004\u008c\u008bG\u0083!1D\u0013\u0093\u0083\u0010e4f\u0096n\u0003\u0096'\u0012\u000f~\u0000?\u0094\u001d\u0004\u008d\u0012\u000f_?^\u0000\\D\u008e*\u0094\u009eM#N\u0098\u001d)\u0013L(bv}n bpn\u0097\u0006L$.\u008b\u0012\u001e\n\u0013y\u0082\u0013\u009dR\u001fS\u0091\u0080\u00ad\t\u008ck.x%\u009e9_~\":!A\u0017\u008e\u0099\u0085\rl\u0015Q\u0080AP\u009d\u001e`\u0080\u008e|FPqB\u0097C*\u0097|21A\u000e\u0081\u00198^\u0097;\u0082\u001a*\u0083\u0089\fg\u008d\u001aDOP\u0013\u0094\t\n.Mc\u0012X0\u0095.z\u008e_\u0016/4\u0000\r\u0010E+\"Ij7UUyN\u009dF=KvoGJY\u008aj\u000b\u0015\u008a(\u0006vQR\f*/Y\u0083as\u0084\u001dG'\u0019t![%LG8,VOPK\u0007\bm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.class\u0095R]O0\u0014\u009d\u0004;\u0003\u0095\u0010\u0013e\u0084&&K4\u0081^u\u0096lR\u000fG\u0019K1H\u0087g\u009cs\u000e\u0000u8\"P\u008fe@Yg\u0011P\u0017\u0092\u0004%CN;q\u001411N,2\u0094)J\u001b\n\u0004#\u00961\u001a2\u0011\u0087\b\u0094\u0080 Py?ja\u0083\u0010]\u0012\u0098<\u0016c\u001b\u0004\u0096$B\u0091\t\u0094<\u0010,\u009dH$pjZuSE]S>\u009aF\u008e\u008dC\u009c\u0016SZ3\u009b\u009a\u008fL\u008eq0Ybu\u001a-_/U\\L<\u0092\u0013\u000f5Y \u008cu*Lx\"}81eljY\u0005k.o/\u0097J\u0004\b+\u0017\u0004\u0016TPu\u009d\u0005\u001b\u001a4 [\u001a6 ;\u001a\u001a\u0090]\u0085\u001f\u001b9\u0002PK\u0007\b=8\u009f\u0094L\u0001\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.class\u009dU[W\u0013W\u0014\u000e\u0017'\u0084ITXXDC\"V@\u0095\u0012\u0016\u0004A\u000ei\u0018LfKK\u0087Y_|h\n.Z]}kgod\u009djW\u0099s9_\u007f\u0003p\u0006hh\u0011\u0018\u009dL\u001bM\u0099\u0019\u008f\u0095x\u0018t\u0012\u0099\u0098s9J'MK]4\tto\u0019\u008f\u008dD2\u0089\u008d-\u0099r\u00054.\bt%kf\u0013\u000b\u001d\u0013X03\u0096\u0016\u001d)0X;\u009e@-\u008eieC7\u009cL1'-wY\u009eN&F@\u0093\u0003k1\u0099\u0096\u0085\u0094cz\bD\u001a\u0005\u0082\u0085F\u008b\u0016i\u0099wdP\u0086c\u0084\u0016\u0095*npMMq2\u0002*iW:FV\u008e\r/\t\u009b4&\f\u0015:\"\u0013h\u008d\u000e/i8D\u00956\n\u009bQ\u0010\u0080\u0007:\u0003GqL\u0080@\u0002d\u009bi\u001d\u001f\"H\u0095;7\u0095q\u001d\u001d\bv\u0004\u001aN\u0092jc~:\u0086\u0011\u0013\b\u0098j\u008e@OtCX'NaT.J\u008e\u0004N3%\u009fR\t\u0007v\u00111l\u008dlJy\\pA T\n\u001d\u0097p\u009951h#J\u008a\u008e1\u008cS{\u009bFa\u008b**\u0005Rs\u0086t\u0016\u0015K\u0003;ed\u0097\fTs\u007f4w;\u0001u+\u008b\u0080*}\u0086\u0086\u0090Y#`Fgj\u007fMWJj~m\u000fNV\u007f\u009c\u0004\u009dU\u0010\u0005\r]y\u0091\u0093f\u0081!PujUTyGG\u0018!\u008a!g\u000b\u008bvT\u007fd\u0095\u0001Ljr\u001fh\u00ad\u000fqhf\tn\u0094\u00ad\u0011R:\u001e`\u008d}U\u0014H\u0004\u0000~\u0004f@\u008a`YieMOjC(_\n\u001c\u008eN\u008d\u0015\u0000=w/+\u0099\u001e\u0018\u0019\b`\u008b\u009a\n\u0093\u008d\u0001P{:\u001c\u000fk\u00970\u0099\u0083#\u000b,g@Fcj.SVz6k?hAPyq\u0096\u0088f>+6\u0083\u0095|y\u008ef4l\u0017\u0093\u0092Lu@z\u001a\u001a:21\u0092l>\u0096\u000398kA\u0080\u000f/\u0093\u000f}\u0087\u001fY!\u008e!F\u001e%\u008f\u00038\u00058^\u008bBO\rW^m\u001c\u008e\u008c#\u0018\u008c\u0090\u000b\u008dF\\w\u009c\u0099\u008d\u0082^\\\u000b\u0096\u0091w\u0013!Z1\u0011\u000f~\u0090L\u001f=8\u008e\u0018\u0086p\u0081U\u009c\u0003\fx\u00941}:\u008b\u0091\r&\u0082I\\)MK&n\u0095\u0093K>\u00ad\u0003*\u001f\u008d\tVj1\u0085*\u0081\u0004nc\u009ao|\u0091j/\u0010\u008b\u009c!X?\u0011\u0018%N\n#P\u0019L3\u008cs8\u0014c\u0016s>F5\u0089z\u0012\u0097\u009b\u0092\f\u009fh\u00ad\u0002i6\u001b\u008fi\u0083)\u0099\u0095KaS\u0084b9\u0093?}0\u0006w)\u0083$3\u0016z\\\u008d;X]\u0016\u000e\u001e~\u008f`{`\u0007x$\u0094\u00111}G6\u0099z\u0085\u0082\u0005\u001f`>v({}\u0082]\u001ea\u0013\u0098\nf\u009e#y\u0006\u000fIBM\u0002X\u0083\u0083\u0082Gm^{\ruZf\u009dQ'S\u0091,\u0081]\u001e&A\u009e\u0093ho{u\u000fZ\u0017.q\u0019\u0092\u008f\u0012R(\u0091\u0099\u001f\u009a\u0082<\u0002\t\u0095A\u009e4+M^r\u000f^]>\u009a/\u0019im<j\u00003\tU\u0095\u008fViS1\u008bj*g\u009e\u0002PK\u0007\b6WK\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classV[O\u0013Q\u0010-,,UxU.-]\u008aH-I\u0095\u0084\u0096v.K\u000f>bA%1\u0099\u008cs\u0002\u0016a\u0011\u0013\u001f9g|3sf\u0000\fbFA\u0080\u0090p\u0094.X3\u008c4m}\u0015F\u0013N&#96_\n7g\u001bt',7%7V\u008ab\u0005!OC\u008bYr\u0096p\u008b\u009c'<\u0093P\u00adY\u0000a`\u009f\u0018\u000e[\u008d\u0010\u008cn\u007f>\u009f?Z\u0015Y\"\u0084\u0012Y\u000bB\u009d\u0086*T\b^\u0083\u0082\u001aB<\u0091Y1Wb%Z\u001cC\u0097\u0084k}\u0091\u0019\u0092`9v>\u00ad\u0098\u0005_g\u001c\u009e<1\u0080\u0098\b\u008eipBr\bksbSiaZv*V~|Ic*qIA\u0007\u009f-\r\u0097q\u0085P#\f\u0083\u0084\u0014 mxVZ\u009f\u0017X\u001d\u0086\u0082\u001c\u008f#\u0002\r7q\u008b\u0010L\u0099\u001e44\u008b+\u001b*e)\u0003S!0\n\u0012&}v\u0082\u000b*\u0091\u0019!UJr\u009b|=\u000e\u001dC\u0005lEk\n\t3\u0015s!\u0086*0 Cuzs\u007f\u0096TDq_~\u0001Q\u009c\u009b\t\u001f?rA.\u0090oAd.\u001c\u008f\u001b&\u009b\u008d\u0019_\u0010u.sFV\u001dF\u0082\u009at6\\\u009c(k+\u0097!#hm\u0089L\u009eu\u0017+d)`A\u0087\u0082\u0082\u0004ao\u000e\u0002O+\u00ads\u0005\u0093\u0084\"O#\u008eZ\u0019\u000f\u00176~\u009aQS\u0093|N*\u0088\u0080|N0\u0096wS\u0097r-\u0012\u00045\u0012\u0081\u0081\u00014\u007f\u0083\u0094Q\u0002U4\u0086:\u001aG#X\u0084f 1<\u0002Z\u008bV\u0010x#h\u0082\u0001|\u0085\u001fhEx9\u0092\b{{\u0017eyn\u0017}^f}{\u0007H\u00834\u008df\u009aA+\"Lyw\"\u0085\u000f\u001d\u0013C<b71\u0002\u001f\u0013<E\t\f|b\u0017C\u0093\u009aJ\u001es\u0010sTf\u008dy\u008e\r\u009fa\u0084\u0010\u009b ~W<gN\u0094( x(\u0080\u0017LB]c\u001c*&\u0098N\u0085\u0084l4_PK\u0007\bk-\u0003\u0000\u0000%\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.class\u0095mO\u0013A\u0010s-\u00ad\\\u000b\u0005\u0015\u0004\u001f\u0011\u0011i+\u001c\u0088B|&JL*\u0092\u0000M\u008dY\u009c{\u0000N\u0090D%\u000f\u00872\u009d\u00024\u0097vfvv\u0000p/\t\u0083\u0015KEiKZ5#\u0095\u008az]Vj[\u008bN\u00ad&T`+\"\u0086t'\u009e\u008ej$\u0011'<\u0088\b\b\u009aUOx\u0092\u0090*\u001d\u0013f\u000b'|r\u000bq\u0081\u0090xh+{L\u0098\u009f\u008aj\u009c-\u0012\u008bNY\u009a\u0088!\u0095F\u0012i\u0093S0'^\u0010A\u0082\u0090ZM\u0089*\u0007x\u0094D(\\[\u008fCa\u001b\u0084GQ\u0017n\t@M|\u0094\u0087\u0005BT\u0083\u0011VU\u008a,d7\b1V3m\u0093\u0084>G\u001dAlu@t\u0080F=.\u0089\u008b\u0084\u0088\u0098uQ9\u008dfb\u0014\u0097\u008e^!\u001ct\u008a btS\u0013Qm\u008f\u008b\u0084\u0013KQ\u008eK+\u009d6\u001bM\u008cc\"\u0089\u001b\u0084\u0099hJ&&\u008cD\u0093\u008anc*\u0091G>]\u009d\u0092l\u0099\u0095q\u0086`:nI)\u001cn3\u009d\u001e\u0013\u0094\u0092bU4\u001a\u0092o\u0099RaKs\u008eB\u0018 K\u001d\u0019\u008d\u001cWJ\u0018,\u0011K@_U\u0081\u0093\u0092^\u001e-6\u0095}\u0098w@\u0086\u0094C0\u0088\u0001\u0096\r\u0007\u0018d \u009e\u0012\u007fp>\u0084Vk\u0019/M\u0096\u0001m0\u008c&\u00104\u0002FBk\u008eg~am>\r}K_\u0003\u0081c\u0081j\u0013\u0098\t\u0081w_\u008ep\u0085F?\u000fc655\u0003s\u0087TSP\u0099\u008bFj6f@$n\u0085I'r}L\u009a\t\u0002<ns;\u008e8Ob,wu\u009a|\\i\u000b/PK\u0007\b\u001b\u001b['\u0093\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classVS\u0013g\u0010mrpx9%BE\u001b-\n$\u0084#\u008a/\u0010b\u0004k\u008d@\u001b\u008de\u008ei8\u009b1\u0097\u008b_\u009fov\u001dl\u0099Vu/\u008f:'9$\u0098S93\u0090=v{v\u009f\u009f\u0000rVE\u008cp*\u0086aZ\u0099\u000f\u0085clz\u0086\fj\u001b\u0005V3\u009d\u0088e\u000bo\u009a\u0082Rc5\u0090P\b\u0011=-mm\u009a^)/\b]\u001f\u009e$L\u0016yeY\u00825\u001aM6\nA)k\u0010\b\t\u001d]\u0010a\u001d*z\bRiQ[\u0015\u001dsy\u0015]\u0098\u009e-\u0001S\u0091\u0012\u0016\"F\u001b^\u0006\u0006 a\u0016\b\u0087]\u0087\u00ad\u0010G\u008b\u000f\u0087Q5\u009d\u008aQ=;9cQoo{^{\u0084\u0081\u00820\u0080A\u0089\u0084}E}wR^0\u0084\u0013*\u008e\u0013&9!R\u0084\u001eD>\u009c#EnV:\r\u001a\u008d|\u00020#\u001e\u0081\u008e8C\u0088W\u0084O8\u000e\u0003a;\u008eY*F#BE\u0082\u0091\u0091nbg\t'vO\u0004FuwM9\u000fh\u008fs\u0084ga\u0011[\u0089=\u001eeq\u00178O\u00989\t\u009f\u0012Mg=H8\u0019O\u0005G)\u0090\u001a9]\u001f\u0099P1MH)\u001a\u001eQ\u000bN\u001d\u0098/dj&t\b_\u008d\u0081\u0096\u0086)]#\u0087x\u0091\u0010\\\u008f>~n\u0085\u0002\u0080\u0005\u001bD<C^sepp\u009b33nz\u00159\f;\u0006CGw\u0080!\\y#\\\tG\u00ad\u0017\u008b\\\u0004p\u0013~w\u008a\u0005c\u0080\u0095\u0086g\\n\u001a\u0003\u001d\u0013\u0004\fM\u0011^j\u0082W\u0091Pl\u001f^S\u0016\u0084/r*$\\}\u0080\u008b\u0017\u000b+\u009b\u009b\u0097=c/l\u0091bX;S2)=~\u008a#&=\u001f'|\u0096r=\u009d\u0015Z:3\u0005g>p\u0084\u008fH\u0019\u0019I$(\u0087^\r\u008c\u0091Q\u0083\u008ay\u0084w\u001fx\u009bw1\u0015\u0018(gi\u000b\u0016@{\u008c\u000f\u007f\u0018\u009ebdF\u0019TB\u001e\u0011}\u00963|4\u009f{\u008dr\u0005\u000f\\*\u0098'(\u0094EvP\u009c\u007f<\u0013\u009c\u0018<\u0087z\u0081W\u009c\u008b8E\u0097xO#Oy,l3V`\u0017\fM\u000e[>}O1$p\u000fP\u008f6\u0016$\u009e\u0097\u0082FX0U\u009bh--0ZM\u008e}\u001c%3\u0082x\u009c\u0002LLW\u0094\u0018`ZV68/p\u009f\u008a\u009cC\u0006PK\u0007\b\u0014\u0003\u0000\u0000\u0000\r\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000T\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.class\u00adS[O\u0013A\u0014ftl\u0080\u008aVPQz\u0083\u0015_K\u009a\u0098&&M\u001a$)P\u00862d;no?\u0017L|0>\u009f\u009c@\u0018c999?~}\u0006`\u000f;\u000e,\u0086\u0083@\u000f=>\u00833\u008dT(\u0097^;\u0018\u008d:J%\u000e\u000e\u0085jPtT(T(#9\u0015HK51<\n\u0083\fC\u009cOs5>\u001c\u009f\u008bA \u0012{'\u0091x\u0086T2j1\u0095j\u009f!\u000eND\u000e6\u0096\\8l\u008a\u001fLFB\u001fc_0\u0014\u0080}Sg&:\u0093!an4\u0019\u009cAlQ\u008dJ\u008aY\u0012\u009cT;9\u0094`$\u0092[\u0017kxPJ1\u008f\u0082P\u0005Z\u0098.\u0018VoO\u001eX7y\u008b\u0097yW0\u008ed@.hN)\u0003`\u0090915\u0019^(\u0001Cr3\u00ad\r\u0012C\u0017L@\u0097f\u0083ks@3\"\u0093C\u0089YG\u001d\u0084n<\fE\u007f\u00186\u000eo\u0088\u009bMg\u0081\f,\u008aZ$#H. \u0099\u0014\u000b.}~\"O\u009b\u0004>\u0096I2\u00814\u00943$\u008b\u0005\u008a\u00ad',\u0094gF\u007f4D*\u009a\b\u001bY\u000bZv\u008cZK2ST=R\u0011e,3l.\u009a\u009bi\u001d\"b\u0093Qjc\u000f\u0011\u0097i+\u0092Vuv@v,+\u0092\u0083\u0081?PK\u0007\bG*\u0002\u0000\u0000\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classXw\u0014U\u0016C5\u0003c#\u0080K\u0001\u0092\u0088b0C\u0004h\b`\u0098d\u00823hL\n;UmUu\u0002\u008e,*nq!8c`L\u0087\u0018q\u008e\u009e\u0007?\u001f@ts\u0013?z8tw\u0097\u007fz\u0003\u0000k\u00822\u0081\u00ad\u0096\u0017Z_\u008f\u000fh\u0083\u0019\u001ftZ\u0089\u0094\u0011l\r\fhf0\u009d\u009av\u008d5dH\u0086e#\u009d\nB\u0002\u009bJ\u0084*@\u0011\u0090\u00967\u0086'pM\u009c \u0002\u000b|8\u00815\u001aG\u008b\u0012S\u0083g\u0004'\u0010@\u0085T#16\fj\u008c\bT\u0006x5Rvqinagjn&157\u0094f\u0003BZ\u00187\u009c\u009a5P{7\u001a\b!kK</G\u0096R}5\u001f\u0007u\t\u00846[I}!\u0004\u00958\u001b\bQ-\u0014)Je0+H\u0084\u0082\u0005\u0096N\u0003\bVB\u0016u\u0091@ym]\u0017+qb,\u0012\u0015X\u00ad\u0095\u0012\nZ-\u0010\u0011nI,\u0082\u00148\u008b\u0085wd\u0006zu{\u009bP\u008a[\t-\u0006\u0083\u0010\u0007\u008eR)^0(\u009a\"\u0096je\u0006t\u0015Y[\u0018uK\u0084,\\+q\u0019.\u0017Xk\u00944j\u008f\u0082+\u00046Z\t['t\u00960\u0014<X\u0098%_l+\u009dj\u001d\\nUT\u0000I\u0006)cw\u0013f\\`\u008c)\u009f\u0007\u0089\u0016\u0081\u00926\u001eH\rE}6 W*\u0082uhhV`Y1X\u008d-\u0012[q\u001d\tLf\u009f\u0016TZMU\u001fH\u0007C\u009amkHI\u00954T\u0013ai\u0011n@\u0082\u001b\u001d3\u000b\u0095vt\u0090\u0014-\u0099\u009cV\u0092=\u009d\u0012p\u0093\u00176z:smm\u009dW\u0090\b\u0084|PD\u000b\t!]\biw)\u0006\"F\u008f\u0082?\t4\u0095V\u0093$p$F)\u0012[S)k(\u001f\u008c\u000eg\u0089b8[\u0099_\u0005\bl)\u0086\u0090<\u0082L\u008c`/4vy#A-*\u0015R\u0014ha\u0090wXs\u0089\bnC\u0002\u001f4T\u00910\u008f\u0003 \u0091\u001df\u00ad9\u0093/WE\u0012.\u0005S\u0099H\u0092\u0090\u009drbGp\u00859X$aK=\u0018\u0090,\u0005j\u00048Dm\t\u0087B1\u000eRTe0`P`\\\u0000%\u0000YG\u0015\\nu7\u009ckwJ\u0089<\u009f73)O\u0018P\u001d\rQ\u0087t[/6'WO\u0001a\u00ad\u0096-P5C`\u009cx\u0010\u000f+x\u0088.\u009c\u0095\u001bN4\u0099T0\u0004\u00ad+g?%\u001e2\u0088<\u009c3\u0085q\u001f\u00938U\u0082~\u009a$<!$\u009eH$l\u009eXn6[L!\u001b\n\u009e)RA-\u001c\u009e\u009f\u000be[@\u001f\u008a$en\u009b9mV0BW\u009a^\u009b1RI\u000e\b_W#8\u008cVyY\u0015J\u0007\u0011\u008b2^4\u0016;\u001c\nL\u000f\u0000\u009bx]\u009c\u009f\rGM\u0006Q44zR\u0002\u0098\u0085{l\u007fK.\t\u0096?\u0019\u007f_\u0005oi3M\u0097\u001f;[IPd\u008eJ\u001cg\u0084Lo\u0010\u009a\u0011\u001fc\n\u0015z\u009aD\u0016q\n-\\\u0090i/\u0017ss\u0004\u009e#Bt\u0004\u0098\u0099x\u009a\u001b1\u0004\u001ctZ\u0019;_g\u0000\u0089\u008cf\u009a99\u000eWT:\u008a\u009e\u0002g\u0017{\u0083O'\u009eh$T\u001c\u0002DiA\u00ad(?,/=+/=*/=BhY.Cee%\u008c\u009del ,\u0084(\r1T8\u008bMbE8.\u0018\u0083\u001ak\u0018%1CcX\u0015\u0018Cq\u000f1F\u0017\u0092l\u0088\u0011DX&^\u0011z\b\u0088\u0095%\u008b\u0097QOk\u0091\u009e\u0084O\u001a\u0001U-k!W\u0090vM\u0088uT\u001d,\u008c`$D\u0087N\u009e$\u001e\u000f\u009c\u009bV8Mm~\u0002me&\u001dy+\u00963\u0003u((i\u0006V\u0089ch\u0011oMYPK[\u0081N&\u0004\u0088\u009b\u0002\u001dI{A\u0095$&\u008bfy\u0013YPZ<\u0089=L\u00ad3E/a;\u0012P\tO\u009c\u0081\u0002q\u0082_P\u0081\u0090<@8\u0010v\u001eg\u0001\u008f\u0013p~\u009c\u0092b/\u0011$D\u001ei\u001a%\u008a\u008a'Roo!@\u0084^\u009c\u0007s\u001e\u0007&p@1D\u001b'\u0080Gh^\u0090??0\u008f\u007f\u00818NI\u001c\u00890\u008e\u0017\u0019*\u008b\u0097eq4XE\u00ad,\u008ee\u0096\u007f\u000bDU\u001b81)SR@\u008f\u0014\u0005G\u008f\t\u0086g8$>=\"3+|'\u001b xUP1\u0005'0\u008e\u0093!\n\t\n\u0088JPb\u0017\u0081|7b\r\u008d\u008aqL\u001e\u009f\u0011\u000f\u007f\u0000\u001f7%0\u0091SF\u0087a|\f\u008b0>\t{\u0018\u009f\u0082\u008fa|\u0016\u008a\u0002PK\u0007\bF{)6N\u0007\u0000\u0000M\u0014\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.class\u00ad\u0095[O\u0013A\u0014\u0096\u0096.[.\n(\u008a\n\u000b5\u0001E\u0011\u0018+\u0090`jL\u009afv\u0081\u0098~\u0015\u001f$QH|\u0003\u008cgv\u0097Z/MI\u009d9\u0093s~si\u001b\u001c\u001ef\u0090`x\u001b-,\u0097\ni)h\be\u001cZ\\\u0097\u00ad-\u0006WP\u0093ole}\u0011\u009e\\R\u0080\u0007\"\u0083\u0014|\u0087h\t\u0019^\bdx^\u0010\u0013)i\u0081-\u0010-`\u0091a%=PaH-{[@\u0012}&20\u0019\u009ev\f>\u008e\u0082D\u000f\f\u0003km\u00ad\n\u0096W\u001dWN\u0085+[a*}\u0086N/n[1J?V\u0005Y*X\u008f\u0093?\u0092/\u007fr[\u009b\u0081\u0085{\u0083\u008e\u009a\u0080a\u0086^?rNrUROE0<y\u008c\u0086ke`\u001c2[\u0096\u0089\t\\g0<I\rG.]w$n\u009a\u0018e\u0086>Oy(A\u001b\u0012Ue\"\u008f\u0015;\u0090\u0001U=|\u009f\u0015E\u0085\u0016z\u0006r6\u00adY\u008e\u00ad'\u00ad\u0097oz;&Vm=\u0003\u0018:o\f+)\u0085Zv\u000b?\u0083\f\u009dio\u0086a{RZ,\u0013!0\u0081]\u001a\t-\u009eNd$+Ak_\u0091\u001d(\u0096~\"Of\u0002\u0003A\u000fsa0\u0089A:\u001b\u008d1D@\u0084;\u008de9\u008f\u0018:\u001fC\u0001F5y\u000fLpMN\u001a\u0017q)P\u000b\u009ct\u0016\u009f+@\u0000WJ3\u0007\u0004n/MD\u008eM\\.]\u000f\u0012\u009fT\f~\u0012\u000bj0i\u009c>\t1\u0084f\u009b\u001a\u000b(G\u001dH3t8L\u008d%\u0099\u0091c\u0084\u0083\fJ1d\u009a<\u0093Q\u000e1\u007fB\u008c\u0013F'lp\u00871\u008aagy\u000fzp?\u0087x\u000e\u000fR?PK\u0007\b\n\u0081\u009a\u0002\u0000\u0000I\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classU]O\u0013A\u0014=\u0016\u0096\u0095\u0016\u0004/@BKeIQC\u001a0&\r\u00924\u0081v,Kfv\u000bS\u0005\u0083&F\u0012\u007f\u0080?x,I;\u009es\u009cw\u0097\u0000\u0096 \u0086\u0010\u0086#\u0006opsO\u0018u~ lPFCHYF])X\u00152Y\u008e~S'b\u00880\u00063\f\u0099?\fK\u0085r\u0090\u0095\u000e\u001cCR_lW\u001d\nf\u0096\u0090\u009c\u000f\n\u000eZh\u0010;\u00151\b\u0086:b\u0018\u0010F\\ \u0012\f\u008f\u0082\u0016\"\u0091+Q\u001dg\u0010e\u0088\u00adf,3^\u0091\u0005\u0012\u0097\u0096\u0088\u0012\u008eq;\u0081L Kz'1\f\u0085}~\u008d\u001aF\u0093\u0096]v5*\u008eK\u0098d\u00180\u0097UUk\u0017\u0082\u001c4p\u0017*0\u0018Zu$q\u009d\u0093W*\u001b/<K\u00148vI\u001cR1U\u008e4\u0016H*n\u009amJ~Mp\u0093!\u001fP\u009e\u0090\u009b\u0096tb5d`B\tz*&c2\u0084\\\u008d\u009e[\u0019\u001a}N\u008fNgn\u001dZiJSlZjt'\u0000\u008b\u0018'-d]Wl\u008f\u0012\u0083:\u0089\u00adDuX\u0091\u0019\u001a0\u0081\u00840\u009e\u0019 \u0091P\u008f\u0018\u0084\u0011!YP\u000f\u0091U\b\u0015\u0097H/\u001cAOO\u0018Ng\u008e0\u0085=Gi\f\u0001\u0013#\f\u000b\u00ad/\u0095#D\u009c13\u0092\u00ad\u0085\u008f\u0017%?X\u0083'\u00892\u0090\u009fa\n>>ql\u0003F\u0088j\u0086V3n12;R\u001e|5X\u0095w\u009c\u009ab`)\ftGl;o\u001b\u009d\u0016.:KJe\u0015O;T\u009bC.4\u009bZD\u0001PK\u0007\b=\u0086\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000E\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classT[O\u0013Q\u0010-\u0094r- \u0005\u0015j[.]\u008a\u0088J\u0091\u008bU\u0093\u009a\u0006LjHPN\u0092v\u0087\u000b\u0018I\f\u001f\u0018l7 -\n\u00873gvfw9_\u007f}\u0002 \u008dg\u001a\u0002\u0084\u0015.*\u008a;R\u0088=imQ\u00adJ[/\u0096\r=kU*\u001b|-lG\u0013\u001bULW\u0085-\\\u0010\"\u008a=\u0097\u0085Y7veN\u00185(\u0084%4eB0\u0091$\u0084\f#\u0088\b4\\#k\u0095-i\u0011[eI[EQ\u00141\u0018\u000ea-\u009f\rd\bZqby2\u00ad'saD1a\u0080\u0090j-6\u0082!\\'\u0084K\u00ad\u001bD2\u007f\nsA\u0019\r#\u0084\u0017W\u0002\u0086Y:\u0085&\u008caPr\u00933g&\u0019m0F\u0018\u0093!2\u0013Gu\u0015]czT\f\u0093\u009a\u009f\u0094\u009fG\u008c\u000f\u001fLd<&\u0010^\u0090\u0086\u0084\u0016;\nGLG\u009a\u008e\u001a{\u0019\u0018\u0012\n$2\\\u0017$p\u008ba*\u0082^L\u0013\u0089|cK\u0099fK2{H\u0013f[I\u001c\u008f\u001bFZ\u008db!\u007fs\r57[\u0000\u0010\u001e>\bH\u0006`\b\u009d<\u0018\u0005f\u0017KC=\u000fCM\u0091)U\n`\u0094L[\rZj\u0015eF%\u00923Migqa\u0085y\u0017L\u0018\u0080\u0014LF8\u0007\u000f\u008cR\u0090W\u001b!\u0004c\u000e,\u0089e!\u001fY\t veob=Rw@7zX\u0092<?\u0003'S)\u0017\u000e\u007f\u0084t\u0088Ou\u008c&b\b1\u008f\u008c\u0084\u000e0\u007frZ7\u0017\u0007\u008e(@\u009c~z3*m\u0006)\u0092\u0005.:\u0091Q\u008csci\u008e\u008d\u001ck5\u0081_\f\u009a\u009c:Ft\u009a\u0001p\u001c\u0087X\u0006|T\u001e\u009d\u008f\u008a\u001dcO{\u0082EOfr\u00941<\nkr\u009505\u008c\u0006PK\u0007\bK\u0002\u0096\u0017\u0002\u0000\u0000\u0081\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000F\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classRMo@\u0010}I\u00864M|\u001e@Jz\u0095V\u0015\u0010\u0081@\u008aJA9p#w+{m\u00ad7\u0085?\u000f\t\u0089\u0003?\u0080\u001fU1F*\u0088^JV}Fow\u009e\u008f\u009f\u0000^b\u0085\u0080iJ\u0095\u009cr\u009cs6\u0017\u0092m\u009cd:\u001e\u0016yH\u001b>Vbt0Wd\u0094\u0016BBL\u009d8S&\u008d\u008fg\u009c8Bs_\u001b\u000e\b\u008d`B\b\u0087\tGh`\u008d%4\tk^p\u0096O~R\u008c\tQ\u0091l|\u009e\f\boG\u008bs\u008f)\u008c\u0084\u001dW\u0084\u0083\u007f+F\u0085\u0011YF:>\u008fm\u0018;M~'eAUo\u0088\u0099\u009fgf\u0099\u0013\u0087\u0017f0\u0089@X\u0011q1\t\u007f\u0006\t\u008f\u001dfj1av_ 0H\b.\u001f,\u0096\u0086\u001a\u0089\u008f\u009c\u0096X\u0090\u0004\u0097vcB\u0082\u0000Q]$I\u0086U\u0089W\u0005\u0082w\u0083\u001aX\u0087\u008d\u001a|W\u009b\u008b\u0010\f\u009b7\u008b\u0007_\u009f\u000fP'\u0011\u0011\u009e\u0084\u0011\u009e\nn\u0085oPK\u0007\b\n\u0095\u0094\u0001\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classS]O\u0013Q\u0010=SZk\u0005\n\u0089\n.+~G\u00071&&\u00044\u0098\u001a|)K\u0082\u000b|\u0095DJ\u0089?dDnW\u0004\u008a\u0089\u0086\u0087\u009d{f\u0099o{\u009f\u0002\u0098CMC\u008aP\u0083%^\u0097VKlIz\u001b\u0088v[\u0006\u0096:\u0082j\tx\bB\u0019L.#V\u009a\u001a\u0084\u0086\u0012\u0096+!\u0088'\u0082&\u008d\u0011\u0098\u0003sG\u0084Ro\\/R\u0013\u000b~C\u0083a \u008b\\T\u000f\u00800h \u0083~e\u009d1\u009f\u0011xi&\u0083\u0097b\u0095J\u008do\u000b.\u0002G\u00130\u001d\u00ad;!\t\u0086M\u009a2z\u0084mW[\u0012-;\\*\u00908!U8\u0087\u000b\u001a\u001f\u001a]7E\\\"a$\u0082(|D\u0084\u0091cS~\u00ad2a6dc\u0002W\u008c&B\u0088k\u0006Q\u0097P\u009dz\rB\u001e(QS)L\u00033\u0018%d#B n\u0091`\u0019(*_\u009fD/!P\u001d\u000f\u0018a2\f'\b/J'{\u0006+f`\u008eZbO\u0086\u0010\u008cg\u009e'\u0083\u0005W\u0084\f5#TO\t8\u0085\u0087\u0014\nj*Uo\u00861n\u009c:V\u0006]\u009c2gv\u00903gw\u0090N\u008a\u0096\u0007\u009f{L\u0089\u001c\u0001C\u008cLti\u0018\b\u0010[\f\u0096*\u0094b\u009b\u001f4)\u0086\u0095o\u0084\\a\u00831\u0005\u0013\u0085]\\a0T\u0007\u000f(!\u009a\u0002\n\u008cnD\u0001JYU\u008cA(9{\u0080\u009c\u0092\u0089\\O,U\u00993bn0\u009d'1\u0014#gq\u0013\u0012~E\u0016}\"v|\u000e\u007f\u0098t\u0017\u0002PK\u0007\b\u0016\u0018v\u0002\u0000\u0000f\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.class\u00adTMO\u0013A\u0018~feeY(\"ZPAh)v\u0005\u008c\u0097\u0012\u0012i\u0086DoC\u0099K\u0016\u007f\u000b\u009cy\u0017/\u0090hb<\u008cl+\b\u0085\u0090&f3;<~\u0000X\t\u000fj\u008eh\u008aj]:\rq$\u00951\u0010\f\u009c:E\u0010*V\u0004\f\u0016w\u009b\u0091J\u0014F\bD\u0007&\f\u0086Cq$\u001cO\u009a\u007f(\u0091\u0089\u0001\u00868\u008a\\g\u0018t\u0095\u001bm1$2=\u0006\u001fH\u000b\t\f0q\u0087!i5eN{\u0092aW\u0085'\u0002W\u0011\u0090u(0\u0098\u0099\u0005Ne7\u0092-Y\u0098\u0094\u0089K\u0002t6q\u0097zRzd\u001eN\u009fp\u008b\"\u0094%\u0015J\u0015\u0091{$0\u0083Z\u0007\f\u0095LZ\u0090l\u008cb\u008c\u0004c\u0081q\u009e^'a\u000f\"c\u001f:WT\\\u0093BoD0o67\u009c&0`UVP\u0095\\}}{5\u0016\u0086\u008a[S\"j\u008by\u0013+\u0097zW\u008f-R.)%\u0083'P\u0086&\u001c\u0086|\u007f\u0094\u0018o9\"\"r=m<#\t\u001aI\rpm\u00917H\u009eC39r\u0006+\u0019\u001c6\u0007t\u0090\u009b\u0018&\u0014`\u0004)\u009a\u0099>/T\u009db\u0004\f#H\u001f\u009a2N\u0090\u00896\u008f\u009141\u009e\u009da6Gs\u0084\r|\u0010#B\u009a\u000fa\u0089\u0011\u00146X\fyg. ma\fr\u001b\u008f\u0094c,\u00104\u0016Y\u00801M\u009ft\u0081?L\u0082\u0095OL8R2{\u001aq\u0084\u0011R\u0082w\u0005\\/\u0098N'\u0090\u008d\u00ad\u0015y\u0095\u0004\u009aA\u009ec\u0096\u009d\u0003PK\u0007\b7y\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000@\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.class\u0093n@\u0014\u0085M:uS\u0092\u0006\u001a\u007f\u007fI#b%\u0015 E !EmTY\u009b8\u0095=\u008en\u0011\u0086\rH,x\u0000\u001e\nq\u000e\u00904\u0094X\u009as{?\u009f3\u009a\u000f\u0000/pd#Gx\u0019+\u001bI7\u0014WR\u001f\u0018\u008fvwQ\u0018\n5J\u009e\t\u001dK\u0097\u0085n\"\u0012i\"\u0094/\u0095p\u0003\u0086iBz\taW~\u008a\u0090{\u0004\u001d\r\u0083<\u008aX*dp'\u0097a_s\u000f$\u0089<\u0011\u0084M>yi%#?&\u001cw_a\u008b\u0085S_r\u0093qG\u008aU\u0013M\u0086\u00ad\u0007B\u008f\u0092\u0002*,y\u000e6flf\u001dEE\u0089`\u0087\"aa3/8\u0099C\u00136\"5#`@\u0002I75\u009egG$R\u007f~|\u0092\u001b\u0092j@x][\u0006Y9 \u0011\u009cnt=7\u0087:4N\bJI\u000eD\u001c>f\u0090\u0019\u00859\u009f\u001d\u0095\u0087y\u0099\u009b\u0099\u00918\u001c}C\u000b/rpx6\u009fAE\u0098\u0015p\u0080tPJAe\u008e\u0019]9\u0083nT6k\u0098r\u008af%\u0019&]m\u001e\u0088\u0081 \u0005?#~OxW]#y\\W=\u008c2dh|2i\u0098\u009bYl+\u0097\u008e\f\u001c+\u0001j\u00969\u0004\u0007[oPK\u0007\btS\u0083\u0001\u0000\u0000\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000M\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classU[O\u0013Q\u0010WX\u0016(H+\r\u0015]\n\u000b/\u0084H\b*\tA\u0012\u000f\u001d\u00936-A\u0012.\u0089\u000f\u0000\u0001^\u001e|\u0017\u00039\rT\n\u009a\u008a\u0089\u000f\u0099s739\u001d\u0080q\u0089#DxESTD~Y\u009ae\"ms\u0015\u0095\u008at|2\u009drY\u00859\u0096\u000b\u00adJw\u0099vV'\u0015r'<\u0019G\u0084E&\u0014BZ\u0097\u0013s-b5'\u0084\u0085[$\u0010+,\th.ze\u0017#K\u0018}\u001c\u001f\u0010\u008d\u0001b\u0013\u0096my\u0093\u0084WfV\u008eSf&G\u0088L;\u0005!\u008cn\u001d\u001dH\u0010f\u00adB6u\u0081\u0081\u0088Mi}:)-#\u008a\u0018[K}*\u0096JRqE)'\\K\u00ad\u0083\u0088lU\t\u00adt\u00941]E=\u0016)X+KV3y\u009a7z?\u0099\u001c\u0087[\u008d\u008b\u001dq\u0001\b\u009acq$`b?!\u0013p\u00846\u0011k\u0082t\u001cW\t\u00ad\u0094\u008e\f\fB(\u0014f<WD\u0089'\u000f\u0095'h?O?\u009b\u008dLN5mD\u0003\u009d|h9L5\u008c\u009a\tmKw$UY\u008d\u009fn!\u001c\u0016${J\u008de\u007fT\u0018\u0082\u009a\u0087%k\u0092o,\u0018B\u008a\u000fU\u0099W\u0011\u0096I\u0083e\fon\u00841\u0089:\u001f\u0084p\u0092)\u0006\u0003\"J\u0007tG'\u0099Q\u0007)\f\u0000\u0002\u0092\u0090!_S\u0084y4\u0004,\u0095U(z/NLg\u001fW\u009f\u0006\u00848\u0017x\u009a\u0081g7\u0007\u009c48G\u009c/R|\u0097e(snWQ\u0014C~En\u007f\u000036*D`6\u0085,\u0092\u0088~\r\u001d!D\u001d5\u0001np\u0080\u0095f\u0006\u0099_\u0019\u0091md\u000fd\u008751r\u0080\u0019\r\u001f\u0088\u0086\u001b,oE\u008f6\u009fPK\u0007\bO<\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classZ\u000b|T\u0099\u007fd\n!\u0098 H\u0004\"!(I\u0000C\u0000\u008d\u0090\u0080\u008dB\u0003\u0082$7d&L\u0080~*P\u00ad\u0015\u00826Z\u0015\u0095\u0084\u0098\n\u0096Z+vn]Gn\u00ad}\u0085\u009f;w^ \f\u0099s9||\u000eo\u001e{ \u0080\u008bd\u0086,AE0Qit\u001b\u00ad\u009dfe\u0097\fTn\u000e\u0019f\u000bvu\u0019\u0081e\u0080\b\u0085\u0090\u0006\u0087 o\u0083\u001b\u0081\u008e-\u001b\u0088`l;\u000b\u0006\u000b{\u009b\"!_\u00833,\u009e\u0088_`tW\u000bM\u008e\u0080\u0011\t\u0099\u0082\u009ae\t\u0091Q\u0001N\u00960\u0083\u009b\u001b|[lX \u0005\u00ad\u0002\u001b\u0003\u0081J~\u009b\u001d2[\r\u0082:#fHP\u0010\u0017V\u0085|\u009c\u008d0X\u0017F\u008bl\u0013jhL\u0017\u0099/.\u0099R\u000b\u0099\u001e\u008cG\u0081\u0086\u0019\u0084\u0084[u~\nQ\u0088s\u0004\u0085mf\u00172jc\"\u009b\"\u008cK\u0012\r\u0081W\u0018xT\u0010`cOW\u008b\u0019V\u0082\u00ad\u0086\u007f\u0011w{Yc\u0019<\u0098{\"=\u0011F4nQ\u0084\u001aOp1\r?\u0013\u0019\u0015\u0083\u0088j\u000f&\u0002\u001d\u00930\u0083\u0095,KzJ\u000f\u00ad\u009fJ\u0019\u0004\u0095\u001dG+D\u0091N\u001f]\u009478\u009ay\u009f\u008d\n%9O\u0085D\u0002]e\u0084;\u0099D\u001eTBEb\u001d9pj\u0098C\u0013\u0007\u0097`L\u0087\u008e\u0018\u008d\u0091f\nr\u0095R\u00925Ss\u0017\u009bn\u0096\u0000y\u0016oi5\u0089\u0081r:_\u001b2\u0003\u00918\u0007W`\u0086&Z\u0011\r\u0085\u008c^fW\u001d\u00161\u001b\u008c2_\u0098X\u009cb|Ti|\u0082M\u0091U\u001d[\nWr,Ibg(T~\u009d\u008e\u00ad\u0089WB\u009a \nVS\u0096\u0006\tgn\u0080\u0086e'\u0083QL\u001a\u001aGeU\u0093\u0019\n|I5\u0082R KG\u0013e7\u0019\u001e\u0093<$9uA\u009fVA\u0003V]\u0095\u009b\u00914n\u0096YQ\u0011I\u000b+5\\/X\u0094YL_h\u0007C\u0012_(\u001cii=X\u0083uJ\r\u0082J2\u00adLw#CM0\u0085(8:>:Ts\u00026\"ABya\u008e\u0080OCgLJ\u008e\rH\u008c\n\u0098[X@g$$\u0017\u0090\u0086T\u0000\u0083 n-N\u0000\u0010\u0002S)m19\u0013\u008aD\u000f+BrI\u001a\u0018ZB\u008f \u0003?6\u0082^&yc\u008f\u000f\u008f`\u0089\u0015j\r7\u000b34\u009dM\u000fn\u00ad*un\u0013t\u009f$u<\u0015\u009253\u0003\\C\u0095\u0097Y7o,]:V!\u008c\be\u0086=:}7=-a\u001b)(\u009f9:\u0082j\u009fm\u009d\u0089\u0088w\u0089xGh\u0087\u0093\u009cFlN\r;\u0004W\u009c,\u001d_\u0083\u00821+\u008dLb\u009e\u001f\u0082%\u0019\u0099l\u000b_\tfG}^E\n7t<\u0082]\f/fnY\u009aa\u0088R\u009f\u008a\u001eU\u007f\u0083\u001d\u008f&\u001e` v\tV3\t\u0002\u0082e6\u00adv/TYWTw\b\tuNlq(\u0014d\u0087mT(=UT<\u0002\u0011\u0017\b/5{5|\u009f\u0010=\u0085=>\u007f\u009b\u0019r\u0019\u009c,*\u0092NP+\u0015>\u001d/Eu`\u0000\u00118\u0081j%b\u008e\u0001\fH0x\u0082VR\u0087t1\u001df\u0084\u0087[,j\u0087:^Q\u0099`HfT;yH\u0011\r\u009b\u0081\u008eH\u009f:rQ\u0013\u001d\u009d\r\u0006\u001a\u0083vo\u00ad\u0010\r\u001dG\u00942\u00ad\b<T\u007f\u0090G|6nt'\u001e\u008f\u0091\br1me\u0089\u0092BPs&)\u0010\u001854z\u0018\u0082,<slPp\u001ehjX\u0012Ek\u0087\u008b8#Eh\u0007\u008b.~\u001d#\u009cr%\u0098\u0092F;pm q\u009a\u009d1T9\u00ad5\u009en\u008d_\u00176:DO\u0014\u00adC\u0012:x\u0090^\u0012\f\u0011\u00ad\u000e=\u0087*w5\u009f]\u001b2M6m\u001a>\u0014,8\u00ad7^\u0083\u000f;#v]\u00996IY5[A\tN0\u0089*\u0017\u001f\u0013\r\u0095p'\u001d\u008dQ`V\u007fA/31\u0084F-~KTa\u0093\fQ\u007f4\u001cB\u0011M\u001e\u0013a4$Kpi\u0086wL+\u009f\u008bC\u0097\u001cq2\u0088t\u009c\u001d\u0097\u000e2\u009aRE;\u0091G4Hr,Mt\u0002f\u008dI\u00971LF\u0084p\u0096UV;\u00942^xwl\bX5'\u009eSAjD.(hWp\f\u0086|\u0096'.\n\u0088+\\]&d\u001a\u00ad.\u0097iNxK\u009eRR\u0002h22\u001e\u0099*5\u0099\u0016s\"o0\"\u009d\u0014\u0005el\u001dY\u009d\u008aD\u0097\u0099\u008a$\u0004h2+%\u008bZ\u0094J.\u0015v\u0095\u0012\u001d\u0080Z\u009e\u00adje\u001eu\u0099\\\u0094S\u0016\u0002$\u0082\u009b\u001c\u0093uQ\u0092i\u0090\u0096j\u001eR#\u0098\u0094?\u008c\u001d.\u008d]\u000b\u0017\u0015)\u0013\u0095=WR\u000e\u009cv\u007fOS\u0081nZ\u0004#2\u008c0Fuk!*Ib5vD\u009aR\u008f\u009f\u0089\u009f7\u0013\u0018\u000f\u0014Q\u0094\u008e\u0090n\u0001|l&ow\u0001\u009eg$&:\u0093\u0083X\u0017^\u008e^\u0015f2zqn9'J\u0098\u0000\u009b6RwZ#<>\u0001Yu:\u0007O\u0094\u0005at!\u0081&_f~\u008dv\u001e\u0083J\u001aB\\\u00adN\u00884N%9oe^*J~]3\u009a$\u00851ML\u001b\u0082IbI`\u007f}\"r\u009e%9\u009f\u008b\u0097'\tCwz\u001fF'\u0099&OMj\u008c\u008f\u0092 (S\u008c\u008c\"_\u0087L\u00ad\u008d\u0095\u00140*1\u008d\n\u0019\u0001T\n\u008b\u001f*Q=lRW[OX|\u0091N\u0097\u0010v\u008c@ \u0018)S\u0014LE\u0081Lk\u0094b-L\u00193hh\u008ew\u008f\u00942Z[px:\u008c?\u0003\\\u009d\u0010N6s\u0001~\"\u0088\u0089\u009b\u009dxXpJ\u001e\u0015\u0014\t\u009aK|#.\u001cW\u0088{\u0081\u0080\u0019>+*^\u0093\u0004ub\u0087,\u0016ji=c\u0007\u00815g0M\u001e\u00104fhF\u009d\u00116\u0003a3\u0010E|\u009b\u0091]\u0013S$\u0014\u009a[\u009a%N_n6aZ\u001a\u0015U\u0014\u009d\u001bn6Bf\u0017'Z\u001bL\u009e?-O9\u008e\u001d1o)jrPmf)N8\u0012m/\u001b@\u000eo1|\u0096\u0005\u0017\u0015z|\u001b\f\u00907A1\u0019\u008b<r\u008cS?SrT\u008d\u0097\u0001\u0081\u0087#ELg\u0089\u0098N\u008b\nZ38<8\u0098\u0002\fx\u0010%\tf\u008f\u0088Z\u0017[\u0002(9f\u0016Uj\u008b\u009e\u0014A\u0094S\\e .\u008f|y \t\u0006jJ\u008a-\u0085Q\u0019|rj\u0093\u000eTs\u00ad\u0086syY\u0016t\u0001,\u0018Gx\u0094$\u001d\u0017z\u008bQ\u0087\u0090\u0010\u001a\u0084\u0095\u009d\u0098\\0\u00966\u000f%\u001er \u001b\u0097\u001b\u0086L\u0006q\u0010SZN\u0019BU\u001c^\u0000\u0002}\u001d#?2\u0080M}\u001bM\u008a\u0096~y\u0098\u000f>L$\u00913\u0080\u00ad\u0003V:\u0007\u0000\t$x\":\r(e\u0001)v+Zy\u001d\u0005Nz\u008bQ2',-Z%v-p\n_\u0084=( ^RA0={\u0010YHTTz\u009dCn\u0016Pd9m\u008d\u0096u-J(5\u009ba<\u009c ~(\u009f\u001fKjV\u0006p\u000f^WW\u0081\u001djz1g\u009fR\u001c\u0005\u0002fw\u0095'I\u0090\u0016\u0089\u000b\u001an\u0096\u0002\u008a\u0012Zq8P\u009b\u001fe_h\u0091X;Z\u009f\n\u001c)\u001f\u009be*\u009d\u00adt:\u0088J]\u0087\t\u0001\u009e\u0089c\u000e-h@+VM\u0082\u0010\u0005\u001d\u0007\u009d\u0001\u001f\u001e\u0006\u0000\u001b28\u0082.\u0012\u0001\u0085 \u0080n|\u008a\u001b\u0089\u0090\u0083)DD\u0091,\u0017b\u008b|\rn\u0092Y\u0016i\u00adyn\u0093^.\u000f\u000e'q|\u000f[9+CO\u000ea\u009b\u001c\u000e\u001e\u0090xPC!s\u0013<\"\u007f.\f\u009eQi-\u009f\u0080OWgL\t.\u001a\u007f\u009f&o[\\%w\u0005\"R{OS\u000f\u0015\u009f\u001eg9\u008d~x\u009f\u0002N\u0014!#4t\u00835n\u001d\u009b%>\u0096\u0094\u008fS\u000e9<\u0018XvU\u0082\u007ff\u000e\u00adU\u0005\u0095:\u0089\u008f\u0002\u0092\u0000K\u008b\u0003Vnz\u0011\u0087G\u0089x\u0082\"\u0015\u001b\u001b\u0015\u0091=\u008b\u001e(\u008882\u008c\u0014;1\u008a\u000f\u009aY9\u00887\u0096Ac\b\u007fa|\u001a_B\u0010>#b8\u0013Uc\u0016b|^\u0095\u0013?F~\u00053;g@mn\u009a\u0007\u009e~4x=qq{\u0006\u0013\u0098u%R\u001dM!PD?&k\u0091QkJ\u0092y]e\u0001\u0019G\u0089^Pz^G\u0083{\t\u009cqxd\u0090\u0089dt\u008c\u0097f:\u0086<2PX@gA\u008e\u0083\u0007|\u0012j6Q2#\u0089+\"\n\u0086bO*\u001b/\u0095\u008eW\u0090\u009c\u00adVX7\r%2x\u008c~\u00152/]N\nu\u0096h\u008dY6 \u000b\u000b.\u0014\u0099O\u0099R\u009e\u008dgyn<\u0087x\u009ee\u008fe\u0002E<\u0088\u0097H\u009f\u0014\u0003x\u009ds?g\u008da\u001c\u000f\u0011^48\u009e\u00157\u000e\u008b\u008e\u001fL&s8.r=\u0086\u0085#r\u000f\u0094\u00979\u001a~&o$U\u0004\u008b\u0017\u0011\u0016B\u009f[^\u0095:YTX\u0096KdJ:h\u0000\u0092\u0098sU;jYa\u001b2\u0016\u0099\u009bV\u0016K\u0083t\u0014I*<Z\u008a\u0014\u0018shn\u0015\u0093V\u0093\u0082UY^BQ\u00ad\u00975)Z\u0096v\u0094:rz?k\u009d_qbf778)4&!/\u0093xb}V9&\u0081l\u0080]UF\u0096){~\f\u008f-4\u0012\u0098]j\u0093h\"\u0092y\u00884c\u00885\u000b\u0088ItB:SEd\u0012k4GZj\u0015\u0096J\u001b\u0003\u0016$\u0012gQR\u00adt@/@t\u0012\u001c\t87p\u0093\u0018E\t\u0019O\u0097\u0095\u0093}\u009ar\u000eudWU\u009b3yv\u0083\u0002\u00872\u000e\u008b\u009f\u001b\u0088vY\u0001\u001e\u0094\u0007$\u0012_<bykL.p=0>oVM6\u0094Y\u0080j\u0089D\u0016\u0097]~\u008dJ_y\u0099]\u000e;j)K@_4d\u000fp\u001e>d8~#Q#\u000f?\u008f\u009d.|\u0092\u0014xw'7Y8,\u000e\u0084,r]dec\u0016y\u0019\u0095\u009d\u0092\u009b\u0016\u001b\u0089\u008b-pg3L~\u0088\u0016n^q%\u00adr[\u001a\u0096#$\u0096j9<R\u0082$\u0096;4,\u0097\u008eR\u001bX\u0095c\bc\u0014+\u001e[\u00856+PD\u009fvL\u0094\u001d\u001c\u00079~\u009d\u00150G\u001cY\u008c.q#}\u001c\u001f%1\u008e\u008fq>\u009b\u009c\u007f\u009c\u0013?PK\u0007\b5\u0010\u0000\u0000(\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.class\u00adVi{\u0013\u0015~\u0016\u0083\u008e1(\tF`\u0090-\u0090`\u001b\u0083\u0083\u0017\u008a]\u0013d\u0090\u0006y\u0088\u0011\u0091\u0083Mk\u0097,t_\u0007>$S\u0094>O\u001f\u009ao\u0019i{g$K8\t4_4w9=G_\u009fo\u0000\u000e\u008f\u0011\u0004\u0004-;\u0097\u008bzfH/F!\u0094\u00ad\u0017\u008b\u0086\u009d).\u00191kiI/d'\u0082\u0011AH`E}YOB.=s\u0091q\u00046YE\n\u0095Y6\u000b9L*cSzqP`\u0099+N6\u0004\u0016w\u0087&W]\u000e\u0006'\f\u008c\u007fp\u0098\u0016md\u0014\u001cwT\u000feph]srd\\vl}\u0095\u0097\u008e\u008e6\u001c\u009b4K5Kj\u001a2\u000b3,5Qc0\u0018~>o\f\tL\f}6\r~\u0004H_1+kD\u0011D\u0087\u0086M\"\u0010LEUm\u0015\tHD\u0006\b!\u008c\bo\"EQZ\u0001\bv\nj5b\u008a\u008c?\u008ak[\u0083\u0086\u008d-\u008bD\u0004=\u0002\u008diER\u0094s\u0005:\u00135|Nx\u0083-H?\u0082\u008a\u0097]\rig\u0005fKF\u009e\u0083\u0011\u001c<70\u0019a\u0081w#(\u000e#\n{PC8*\u0010\u0019bl\u000bQ\u0005\u0083\u0092!\u0081\u008du\u001b\u0011\f\u009a+\u0016|\u0015\u0011\u008cY3\u008d\u001a0\u0013],\u0093\u0085\u0087\u0012\u008d$40%\u0099\u001e\bN\bD\u0016\"\u00959+\u0088!N\u0097\u0097\u001b\u0019\u0099>fc96[\f9\u008b&\u007f\u0087\u0005\"\u0089X\u0015\u0092:\u008a\u0084U\u001a|\u0010\u008a\u0019\u0091/b.\u0006&CPp=)+\n1_N}`\u001ceah\u0006#s \u0094\u008aw2\u0016e\u008d\u009e\u0018En.\u0095-\u0018)dOZ&I\u008b8\u0086'48\\%\u009db9\u009ah4|Wn\u0007T\u009f\u0011\u0090\u00adk\u0097Gf>kQd\u008cE\u0081@*.'\u00175<\u0089<qK\u000bY\u0081>\u001f\u008dx1\u0089\u0012=\u0013Ko\u001e|K$uZvT\u001d=Os4n%Z\te\u000b3@)@+z\u0087L3\u001afI\ndz^\u001d\u008a1c\u0015\u001c\u0094U\u0011Ha\u00025\u0096i\u0080cV>O;U\u009aKl\u000b~ ;\u008b\u0003S2\u00975\\\n\u009bWM\u001aF\u0088;Q\b$8\u0004\u008c&b\u0093d\u0097\u0017\u0081?;\u0002j2krzR/g\f\u0085\u0019?\u0012b\u008e)\u000b\u0096\u0013\u001a\u0017\u0098\u008cl\u007f\u0014o'\u001fu\u0004@\u001ba\u001d_\u008ei\u000f^2{\u001b\u0016\u0091F=\u009bU\u001e|h\u008b\b~Ri\r\u0094\bZ ,m)Y*:x\u0007\u009dC{ \u001b@6;\u0092g'\u0088Ze;c\u008c\u009bYw6\u001c\u0097`\u0093\u009a\n\u001cD|-q\u0016,\u0080f.[8:o.\u0098\u001c+m\u0080\u0090\u008f49\u007f>y\u0013$os&]G\u008c8~\u001d]\u001c9u\u001dna\u008fU\u009c\u0085}\u0002\u00818\u0007\u0006B\u001b8r\u000b\u0003\u0002\u0003MW=Y\u001c\u001b\b'\u0084X,\u001c\u000bW\u0082\u0098\u0097;\u0005>op#\u0015\u0004\u007f\u0089\u001c\u008c2&l\u0081=\u0085(v\u001cg\u0017u\u001c\u00128Id\u0082\u0011k\u0098\u0004h\n\u008c(Y\u009e):\u008a\u0083:N921\u008b3<\rZjr8\u0012\u008f\u0097o\u0093\u008b/\u0084\u008aB0 n\u0085\u0090\u001cv\u009f\u0087\u008aK\u0089O)D\u0087( g\u0094p\u0092\u000bSa\u0097\u0081U\u001c\u0088\u0085\u0085_A4\u009e\u0001s>>P,8,\u00ad\u0015\u008ff\n\u000fp\u009f8@e\u001c$\u0087ab<\u0083\u0018p\u0084,\u008dqo\u008a\\\u00adryi\\R\\6sF\u00898Ac'sL.C5\\J\u0014\u0097l{\u001e\u0097\u0013<\u0015-\u0006\u009e\u009e\u0097D2\u0002V%/\f\u008e\u0093\u0092q\u0005=P\u0085D\u009eQn\u008b\u0017T~O\u007f\u0085\u0010t}\u00ad\u0015u\u001e\u009bJ\u0092\u0092\u0097>@8t\u00ad\"O\u0082\fuhO\u0083\u009f8a4'Ud\u009dV!W\t\u0083`%\u0098@Mr5\u0005\u008f\u007fu^%\u0082T\u001e\t\u0000\u0001\u001d\u009aJ\u0013n\u0085\u001f\u0086\u0094I\u0015\u008f\u009eZ\u0095R\u008aqJ\t\u008euB\u0003e\u0095\"\u001d=_\u0003\u0005$\u00ad\u0080\u0001\f5Wp\u0015E\u0097;M\u001ef\u0014?\r`5i{\u0092:M+\u0005\u00105~y,xeZ \u0015}8[U\u0016E\u0092'zjZ\u0091[\u00adt\u0092\u0092 W|]\u001fPK\u0007\b\u0088!@\u0006\u0000\u0000z\u0010\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000:\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.class\u009dS]O\u0013A\u0014=\u0096n)K\u0081\u0002U\bB[+\u008a\u0015E\u0084\u0011\u0093\u009a\u001ax\u001bIdm[\u0014\u0089>\u009b\u0083&*A\u0012\u001fe\u0085\u0086\u0017_vv{g'\u0080\u0015+1\u00ad\u008a\u001bT\u0015Z\u008d\u001f\bS{mFCXZ\u0017j\u008aFVf9\u009bbauSA\u0080ax\u009f\u001fpfE\u0017%\u009b!x\u008d\u0096hY9l\u009de/\u0015\u0093-K0,\u009c;;X\u0005Jv\u008dJ\u008295\u0006\u007f\"Yd\bl\"\f?\u0006U#`\u0088a\u0003nYP\u0085\u0011`?\u0018*\u0010d\u0018\u0092\u009fj{z\f\"\u0010K(rK\u0097{/\u0018:qG\u0012\u001b\b(\u0005`\u0018K${G\n\u0013I\u0015S\u0098*oz4\u0082+\f\u009d\u008a-\u0010\u0015n\u0014ln\u008b7%\b!NInx.\u009aqn0}:\u008c\u0019\\\u00953\u008c'zI$\u008b\u0003\u0086%\u0005\u008b\f\u0091\"\u0081$BXf\u0098:\u0012x\u00adez\u0010nfZbP\u0091\u0086F\u00054=\u008c\u0082\u00953\u0086q\u0090)N%#\u009auf'x\u0081W\u0006xnUZ5a\u0092]\u0015p\u009fXQ\u009c\u0012\u001e.]\u0003J%zp%C\u0015k\u0014Yk\u0087\fBe\u00953]zf\u0002;%\u0018\b]:\u0091V\u0085v>\u0084h\u0087;@\u0091'\u0094h\u001dN\u001dAM\u009d s\u0084o\u0018d\u008f7\u008c#\u0080\u0018\u0086h\u001d\u009d.\u0084\u001e^c=\u0006O0\u0013\u009d=W\u008c\u001cc\u0081n\u0083\u0017N\u009d\u0086o\u001a#\u009e\u0004\u009e\bq\u0085\u0095lWL-*wU\u0087\u0085FQ\u0099';A'8\u0005\u0006Cqw\u0084\u0094\u0093\u0019x\u0018\u0019\u001f^u\b;gK\u0094\u0099ppbn\u0087#\u001e !<:QW\u0083\u001c;(\u008f\b\u0004>\u009d-z\u000fPK\u0007\b=!C\u0002\u0000\u0000@\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000H\u0000\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.class\u0091MO\"A\u0010\u0086\u0012\u0004DB]ua\u0081\tL<\u0091(fOd%xo\u0086rh33=i\u001a\fJO&\u001e\u0001(c\u0080\u0093]\u0093C\u0095Nu=\u00008\"\u0016\b\u0017J\u0088\u00857`7\u0014c\u008e{-\u0098\u0005hu\u009eb+FPD\u008c-.\"OhyohW#BDF\u009c\u0011r\r!R}.#\u0087\n\u0016Q %Z\u0002&T\u0013\u008d2\u008ay3\u0090Ce\u0087;&la\u009a\\F\u0088UX\u0081\u0088|k\u008c\u00126\b!A\\\u00112~\t[\u0084J<}a5&g\u0087\u009e\u0096iZ\u008e]R\u0097\u008d3\u0083\u0012M\u00ad\u00ad\u008e\u0019\u001bL\tM4:$\u009d\u0086\u0093\bF\\o\u0012]5\u001e\u0092\u000f\u001d~kf2\"\u000e`\u0081mf`c\\du\tG\u009b,lc!-nb`u%W6\u0083\u001b38W]\u007f\u0098CwO\u009a\u0081n\u0099v\u0006c\u001e=@\tk\u001dPK\u0007\bBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000G\u0000\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.class\u0091N\u001b1\u0014\u0086CB\u0012\u0002-\u0090r\u008b.\u0094\u008cbEB\u0089Xp\u0091ReLN'f#\u008f\u0013\u0094*+$\u0016<@\u001f\n\u0019\u0002B\b!\u008bs\u001d\u007f\u001f\u001f\u0000^\u0019\u000b\u0084S}W\u001b\u001b\u008a\tG\u008d\u0016q\u0002\u0089Z+[0\u0092\u0093\nC\u0011\r2\u008a&\u008c\"n\u009bAb\u008d\b#\u0019IsB(\u001b}B\u00ad\u0086\\E\u0001K+XD\u0089\u009a/\u0080O1\b\u0098P*O\u0004}e\u009a\u008aE3\u0092\u0089Sg;$rUl\u008a\b\u001bF\u0098\b7\u0010\u0091\u008c\u0096\u0091\u007fX:\u0081:\u0084\u007f\u0088\u000e\u001b!\u0003\u001eVAXN\u0083\u009b\u0095\u0010\u0088\u0013O,`\u009bpc<3N<S:\u0097cF\u009c/\u009c:\u0096\u0084t8\u009cND0F\u008bPL\u008f\u00adt*|\u0083\u0001h#\u0096mZO/~C\u0006\u000bZ[\u008a5,[,S\u0086\u007f\fnBm\u001c\u0006-\u001c<\u009f\u008bn[\u0093\u0083\u0012v2\u0013PK\u0007\bv\u0089\u0001\u0000\u0000&\u0003\u0000\u0000PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000K1\u0000\u0000\u0000+\u0001\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000#\u0001\u0000\u0000META-INF/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000b\u0001\u0000\u0000META-INF/maven/io.takari/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000META-INF/maven/io.takari/maven-wrapper/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000L@\u0005:\u0000\u0000\u00009\u0000\u0000\u00005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0002\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.propertiesPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u009f\u0002\u0000\u0000org/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000org/apache/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000e\u0003\u0000\u0000org/apache/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000O\u0003\u0000\u0000org/apache/maven/wrapper/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000B\u0005\u0000\u0000`\n\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0098\u0003\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005C\u0012\u0002\u0000\u0000\u0003\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001;\t\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000S\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u00ad\u000b\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000C5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00017\u000e\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084q\u0012\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u001b\u0000\u0000org/apache/maven/wrapper/Downloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000[\u0007\u000f\u0000\u0000\u0088\u001f\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\f\u001c\u0000\u0000org/apache/maven/wrapper/Installer.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084'+\u0001\u0000\u0000m\u0003\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001>,\u0000\u0000org/apache/maven/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0011ps]\u000b\u0000\u0000\u0018\u0000\u0000/\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008d.\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001coI\u0001\u0000\u0000t\u0003\u0000\u0000>\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001G:\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0087|+\u009f?\u0007\u0000\u0000\u000e\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001n<\u0000\u0000org/apache/maven/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000{\u0002`-\u0004\u0000\u0000\t\u0000\u00006\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0007D\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001SI\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00009\u0091\b\u0000\u0000,\u0013\u0000\u0000.\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001LM\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009V\u0000\u0000org/apache/maven/wrapper/cli/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000dQv\u0002\u0000\u0000T\b\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0086V\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000j F\u0004\u0000\u0000\f\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001Y\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000m6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0015_\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=8\u009f\u0094L\u0001\u0000\u0000\u0003\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001`\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00006WK\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0087b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000k-\u0003\u0000\u0000%\u000b\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001g\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b\u001b['\u0093\u0002\u0000\u0000\u0007\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u009ek\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0014\u0003\u0000\u0000\u0000\r\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001n\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000G*\u0002\u0000\u0000\u0004\u0000\u0000T\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001r\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000F{)6N\u0007\u0000\u0000M\u0014\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001u\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0081\u009a\u0002\u0000\u0000I\u0007\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001h}\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=\u0086\u0002\u0000\u0000\u0007\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001z\u0080\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000K\u0002\u0096\u0017\u0002\u0000\u0000\u0081\u0007\u0000\u0000E\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u009d\u0083\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0095\u0094\u0001\u0000\u0000\u0003\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0086\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0016\u0018v\u0002\u0000\u0000f\u0005\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0088\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00007y\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000tS\u0083\u0001\u0000\u0000\u0004\u0000\u0000@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008e\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000O<\u0002\u0000\u0000\u0007\u0000\u0000M\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u001c\u0091\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005\u0010\u0000\u0000(\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001^\u0094\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0088!@\u0006\u0000\u0000z\u0010\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001r\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=!C\u0002\u0000\u0000@\u0005\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000Bm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000H\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000v\u0089\u0001\u0000\u0000&\u0003\u0000\u0000G\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.classPK\u0005\u0006\u0000\u0000\u0000\u0000/\u0000/\u0000\u0006\u0012\u0000\u0000\u0000\u0000\u0000\u0000"
          },
          {
            sha: "642d572ce90e5085986bdd9c9204b9404f028084",
            filename: ".mvn/wrapper/maven-wrapper.properties",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\n+wrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar",
            rawContent:
              "distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n"
          },
          {
            sha: "3c8a5537314954d53ec2fb774b34fe5d5a5f253a",
            filename: "mvnw",
            status: "added",
            additions: 322,
            deletions: 0,
            patch:
              '@@ -0,0 +1,322 @@\n+#!/bin/sh\n+# ----------------------------------------------------------------------------\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# "License"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#    https://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# ----------------------------------------------------------------------------\n+\n+# ----------------------------------------------------------------------------\n+# Maven Start Up Batch script\n+#\n+# Required ENV vars:\n+# ------------------\n+#   JAVA_HOME - location of a JDK home dir\n+#\n+# Optional ENV vars\n+# -----------------\n+#   M2_HOME - location of maven2\'s installed home dir\n+#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n+#     e.g. to debug Maven itself, use\n+#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n+#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n+# ----------------------------------------------------------------------------\n+\n+if [ -z "$MAVEN_SKIP_RC" ]; then\n+\n+  if [ -f /etc/mavenrc ]; then\n+    . /etc/mavenrc\n+  fi\n+\n+  if [ -f "$HOME/.mavenrc" ]; then\n+    . "$HOME/.mavenrc"\n+  fi\n+\n+fi\n+\n+# OS specific support.  $var _must_ be set to either true or false.\n+cygwin=false\n+darwin=false\n+mingw=false\n+case "$(uname)" in\n+CYGWIN*) cygwin=true ;;\n+MINGW*) mingw=true ;;\n+Darwin*)\n+  darwin=true\n+  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n+  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n+  if [ -z "$JAVA_HOME" ]; then\n+    if [ -x "/usr/libexec/java_home" ]; then\n+      export JAVA_HOME="$(/usr/libexec/java_home)"\n+    else\n+      export JAVA_HOME="/Library/Java/Home"\n+    fi\n+  fi\n+  ;;\n+esac\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  if [ -r /etc/gentoo-release ]; then\n+    JAVA_HOME=$(java-config --jre-home)\n+  fi\n+fi\n+\n+if [ -z "$M2_HOME" ]; then\n+  ## resolve links - $0 may be a link to maven\'s home\n+  PRG="$0"\n+\n+  # need this for relative symlinks\n+  while [ -h "$PRG" ]; do\n+    ls=$(ls -ld "$PRG")\n+    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n+    if expr "$link" : \'/.*\' >/dev/null; then\n+      PRG="$link"\n+    else\n+      PRG="$(dirname "$PRG")/$link"\n+    fi\n+  done\n+\n+  saveddir=$(pwd)\n+\n+  M2_HOME=$(dirname "$PRG")/..\n+\n+  # make it fully qualified\n+  M2_HOME=$(cd "$M2_HOME" && pwd)\n+\n+  cd "$saveddir"\n+  # echo Using m2 at $M2_HOME\n+fi\n+\n+# For Cygwin, ensure paths are in UNIX format before anything is touched\n+if $cygwin; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME=$(cygpath --unix "$M2_HOME")\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n+  [ -n "$CLASSPATH" ] &&\n+    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\n+fi\n+\n+# For Mingw, ensure paths are in UNIX format before anything is touched\n+if $mingw; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME="$( (\n+      cd "$M2_HOME"\n+      pwd\n+    ))"\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME="$( (\n+      cd "$JAVA_HOME"\n+      pwd\n+    ))"\n+fi\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  javaExecutable="$(which javac)"\n+  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n+    # readlink(1) is not available as standard on Solaris 10.\n+    readLink=$(which readlink)\n+    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n+      if $darwin; then\n+        javaHome="$(dirname \\"$javaExecutable\\")"\n+        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n+      else\n+        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n+      fi\n+      javaHome="$(dirname \\"$javaExecutable\\")"\n+      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n+      JAVA_HOME="$javaHome"\n+      export JAVA_HOME\n+    fi\n+  fi\n+fi\n+\n+if [ -z "$JAVACMD" ]; then\n+  if [ -n "$JAVA_HOME" ]; then\n+    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n+      # IBM\'s JDK on AIX uses strange locations for the executables\n+      JAVACMD="$JAVA_HOME/jre/sh/java"\n+    else\n+      JAVACMD="$JAVA_HOME/bin/java"\n+    fi\n+  else\n+    JAVACMD="$(which java)"\n+  fi\n+fi\n+\n+if [ ! -x "$JAVACMD" ]; then\n+  echo "Error: JAVA_HOME is not defined correctly." >&2\n+  echo "  We cannot execute $JAVACMD" >&2\n+  exit 1\n+fi\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  echo "Warning: JAVA_HOME environment variable is not set."\n+fi\n+\n+CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n+\n+# traverses directory structure from process work directory to filesystem root\n+# first directory with .mvn subdirectory is considered project base directory\n+find_maven_basedir() {\n+\n+  if [ -z "$1" ]; then\n+    echo "Path not specified to find_maven_basedir"\n+    return 1\n+  fi\n+\n+  basedir="$1"\n+  wdir="$1"\n+  while [ "$wdir" != \'/\' ]; do\n+    if [ -d "$wdir"/.mvn ]; then\n+      basedir=$wdir\n+      break\n+    fi\n+    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n+    if [ -d "${wdir}" ]; then\n+      wdir=$(\n+        cd "$wdir/.."\n+        pwd\n+      )\n+    fi\n+    # end of workaround\n+  done\n+  echo "${basedir}"\n+}\n+\n+# concatenates all lines of a file\n+concat_lines() {\n+  if [ -f "$1" ]; then\n+    echo "$(tr -s \'\\n\' \' \' <"$1")"\n+  fi\n+}\n+\n+BASE_DIR=$(find_maven_basedir "$(pwd)")\n+if [ -z "$BASE_DIR" ]; then\n+  exit 1\n+fi\n+\n+##########################################################################################\n+# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n+# This allows using the maven wrapper in projects that prohibit checking in binary data.\n+##########################################################################################\n+if [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Found .mvn/wrapper/maven-wrapper.jar"\n+  fi\n+else\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n+  fi\n+  if [ -n "$MVNW_REPOURL" ]; then\n+    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+  else\n+    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+  fi\n+  while IFS="=" read key value; do\n+    case "$key" in wrapperUrl)\n+      jarUrl="$value"\n+      break\n+      ;;\n+    esac\n+  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Downloading from: $jarUrl"\n+  fi\n+  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n+  if $cygwin; then\n+    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n+  fi\n+\n+  if command -v wget >/dev/null; then\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Found wget ... using wget"\n+    fi\n+    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n+      wget "$jarUrl" -O "$wrapperJarPath"\n+    else\n+      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n+    fi\n+  elif command -v curl >/dev/null; then\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Found curl ... using curl"\n+    fi\n+    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n+      curl -o "$wrapperJarPath" "$jarUrl" -f\n+    else\n+      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n+    fi\n+\n+  else\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Falling back to using Java to download"\n+    fi\n+    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n+    # For Cygwin, switch paths to Windows format before running javac\n+    if $cygwin; then\n+      javaClass=$(cygpath --path --windows "$javaClass")\n+    fi\n+    if [ -e "$javaClass" ]; then\n+      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n+        if [ "$MVNW_VERBOSE" = true ]; then\n+          echo " - Compiling MavenWrapperDownloader.java ..."\n+        fi\n+        # Compiling the Java class\n+        ("$JAVA_HOME/bin/javac" "$javaClass")\n+      fi\n+      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n+        # Running the downloader\n+        if [ "$MVNW_VERBOSE" = true ]; then\n+          echo " - Running MavenWrapperDownloader.java ..."\n+        fi\n+        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n+      fi\n+    fi\n+  fi\n+fi\n+##########################################################################################\n+# End of extension\n+##########################################################################################\n+\n+export MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\n+if [ "$MVNW_VERBOSE" = true ]; then\n+  echo $MAVEN_PROJECTBASEDIR\n+fi\n+MAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n+\n+# For Cygwin, switch paths to Windows format before running java\n+if $cygwin; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n+  [ -n "$CLASSPATH" ] &&\n+    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n+  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n+    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\n+fi\n+\n+# Provide a "standardized" way to retrieve the CLI args that will\n+# work with both Windows and non-Windows executions.\n+MAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\n+export MAVEN_CMD_LINE_ARGS\n+\n+WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n+\n+exec "$JAVACMD" \\\n+  $MAVEN_OPTS \\\n+  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n+  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n+  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"',
            rawContent:
              '#!/bin/sh\n# ----------------------------------------------------------------------------\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# "License"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#    https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# Maven Start Up Batch script\n#\n# Required ENV vars:\n# ------------------\n#   JAVA_HOME - location of a JDK home dir\n#\n# Optional ENV vars\n# -----------------\n#   M2_HOME - location of maven2\'s installed home dir\n#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n#     e.g. to debug Maven itself, use\n#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n# ----------------------------------------------------------------------------\n\nif [ -z "$MAVEN_SKIP_RC" ]; then\n\n  if [ -f /etc/mavenrc ]; then\n    . /etc/mavenrc\n  fi\n\n  if [ -f "$HOME/.mavenrc" ]; then\n    . "$HOME/.mavenrc"\n  fi\n\nfi\n\n# OS specific support.  $var _must_ be set to either true or false.\ncygwin=false\ndarwin=false\nmingw=false\ncase "$(uname)" in\nCYGWIN*) cygwin=true ;;\nMINGW*) mingw=true ;;\nDarwin*)\n  darwin=true\n  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n  if [ -z "$JAVA_HOME" ]; then\n    if [ -x "/usr/libexec/java_home" ]; then\n      export JAVA_HOME="$(/usr/libexec/java_home)"\n    else\n      export JAVA_HOME="/Library/Java/Home"\n    fi\n  fi\n  ;;\nesac\n\nif [ -z "$JAVA_HOME" ]; then\n  if [ -r /etc/gentoo-release ]; then\n    JAVA_HOME=$(java-config --jre-home)\n  fi\nfi\n\nif [ -z "$M2_HOME" ]; then\n  ## resolve links - $0 may be a link to maven\'s home\n  PRG="$0"\n\n  # need this for relative symlinks\n  while [ -h "$PRG" ]; do\n    ls=$(ls -ld "$PRG")\n    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n    if expr "$link" : \'/.*\' >/dev/null; then\n      PRG="$link"\n    else\n      PRG="$(dirname "$PRG")/$link"\n    fi\n  done\n\n  saveddir=$(pwd)\n\n  M2_HOME=$(dirname "$PRG")/..\n\n  # make it fully qualified\n  M2_HOME=$(cd "$M2_HOME" && pwd)\n\n  cd "$saveddir"\n  # echo Using m2 at $M2_HOME\nfi\n\n# For Cygwin, ensure paths are in UNIX format before anything is touched\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --unix "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\nfi\n\n# For Mingw, ensure paths are in UNIX format before anything is touched\nif $mingw; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME="$( (\n      cd "$M2_HOME"\n      pwd\n    ))"\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME="$( (\n      cd "$JAVA_HOME"\n      pwd\n    ))"\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  javaExecutable="$(which javac)"\n  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n    # readlink(1) is not available as standard on Solaris 10.\n    readLink=$(which readlink)\n    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n      if $darwin; then\n        javaHome="$(dirname \\"$javaExecutable\\")"\n        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n      else\n        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n      fi\n      javaHome="$(dirname \\"$javaExecutable\\")"\n      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n      JAVA_HOME="$javaHome"\n      export JAVA_HOME\n    fi\n  fi\nfi\n\nif [ -z "$JAVACMD" ]; then\n  if [ -n "$JAVA_HOME" ]; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n      # IBM\'s JDK on AIX uses strange locations for the executables\n      JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n      JAVACMD="$JAVA_HOME/bin/java"\n    fi\n  else\n    JAVACMD="$(which java)"\n  fi\nfi\n\nif [ ! -x "$JAVACMD" ]; then\n  echo "Error: JAVA_HOME is not defined correctly." >&2\n  echo "  We cannot execute $JAVACMD" >&2\n  exit 1\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  echo "Warning: JAVA_HOME environment variable is not set."\nfi\n\nCLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n\n# traverses directory structure from process work directory to filesystem root\n# first directory with .mvn subdirectory is considered project base directory\nfind_maven_basedir() {\n\n  if [ -z "$1" ]; then\n    echo "Path not specified to find_maven_basedir"\n    return 1\n  fi\n\n  basedir="$1"\n  wdir="$1"\n  while [ "$wdir" != \'/\' ]; do\n    if [ -d "$wdir"/.mvn ]; then\n      basedir=$wdir\n      break\n    fi\n    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n    if [ -d "${wdir}" ]; then\n      wdir=$(\n        cd "$wdir/.."\n        pwd\n      )\n    fi\n    # end of workaround\n  done\n  echo "${basedir}"\n}\n\n# concatenates all lines of a file\nconcat_lines() {\n  if [ -f "$1" ]; then\n    echo "$(tr -s \'\\n\' \' \' <"$1")"\n  fi\n}\n\nBASE_DIR=$(find_maven_basedir "$(pwd)")\nif [ -z "$BASE_DIR" ]; then\n  exit 1\nfi\n\n##########################################################################################\n# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n# This allows using the maven wrapper in projects that prohibit checking in binary data.\n##########################################################################################\nif [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Found .mvn/wrapper/maven-wrapper.jar"\n  fi\nelse\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n  fi\n  if [ -n "$MVNW_REPOURL" ]; then\n    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  else\n    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  fi\n  while IFS="=" read key value; do\n    case "$key" in wrapperUrl)\n      jarUrl="$value"\n      break\n      ;;\n    esac\n  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Downloading from: $jarUrl"\n  fi\n  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n  if $cygwin; then\n    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n  fi\n\n  if command -v wget >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found wget ... using wget"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      wget "$jarUrl" -O "$wrapperJarPath"\n    else\n      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n    fi\n  elif command -v curl >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found curl ... using curl"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      curl -o "$wrapperJarPath" "$jarUrl" -f\n    else\n      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n    fi\n\n  else\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Falling back to using Java to download"\n    fi\n    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n    # For Cygwin, switch paths to Windows format before running javac\n    if $cygwin; then\n      javaClass=$(cygpath --path --windows "$javaClass")\n    fi\n    if [ -e "$javaClass" ]; then\n      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Compiling MavenWrapperDownloader.java ..."\n        fi\n        # Compiling the Java class\n        ("$JAVA_HOME/bin/javac" "$javaClass")\n      fi\n      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        # Running the downloader\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Running MavenWrapperDownloader.java ..."\n        fi\n        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n      fi\n    fi\n  fi\nfi\n##########################################################################################\n# End of extension\n##########################################################################################\n\nexport MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\nif [ "$MVNW_VERBOSE" = true ]; then\n  echo $MAVEN_PROJECTBASEDIR\nfi\nMAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\nfi\n\n# Provide a "standardized" way to retrieve the CLI args that will\n# work with both Windows and non-Windows executions.\nMAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\nexport MAVEN_CMD_LINE_ARGS\n\nWRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nexec "$JAVACMD" \\\n  $MAVEN_OPTS \\\n  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"\n'
          },
          {
            sha: "c8d43372c986d97911cdc21bd87e0cbe3d83bdda",
            filename: "mvnw.cmd",
            status: "added",
            additions: 182,
            deletions: 0,
            patch:
              '@@ -0,0 +1,182 @@\n+@REM ----------------------------------------------------------------------------\n+@REM Licensed to the Apache Software Foundation (ASF) under one\n+@REM or more contributor license agreements.  See the NOTICE file\n+@REM distributed with this work for additional information\n+@REM regarding copyright ownership.  The ASF licenses this file\n+@REM to you under the Apache License, Version 2.0 (the\n+@REM "License"); you may not use this file except in compliance\n+@REM with the License.  You may obtain a copy of the License at\n+@REM\n+@REM    https://www.apache.org/licenses/LICENSE-2.0\n+@REM\n+@REM Unless required by applicable law or agreed to in writing,\n+@REM software distributed under the License is distributed on an\n+@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+@REM KIND, either express or implied.  See the License for the\n+@REM specific language governing permissions and limitations\n+@REM under the License.\n+@REM ----------------------------------------------------------------------------\n+\n+@REM ----------------------------------------------------------------------------\n+@REM Maven Start Up Batch script\n+@REM\n+@REM Required ENV vars:\n+@REM JAVA_HOME - location of a JDK home dir\n+@REM\n+@REM Optional ENV vars\n+@REM M2_HOME - location of maven2\'s installed home dir\n+@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n+@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n+@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n+@REM     e.g. to debug Maven itself, use\n+@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n+@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n+@REM ----------------------------------------------------------------------------\n+\n+@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n+@echo off\n+@REM set title of command window\n+title %0\n+@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n+@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n+\n+@REM set %HOME% to equivalent of $HOME\n+if "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n+\n+@REM Execute a user defined script before this one\n+if not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n+@REM check for pre script, once with legacy .bat ending and once with .cmd ending\n+if exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\n+if exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n+:skipRcPre\n+\n+@setlocal\n+\n+set ERROR_CODE=0\n+\n+@REM To isolate internal variables from possible post scripts, we use another setlocal\n+@setlocal\n+\n+@REM ==== START VALIDATION ====\n+if not "%JAVA_HOME%" == "" goto OkJHome\n+\n+echo.\n+echo Error: JAVA_HOME not found in your environment. >&2\n+echo Please set the JAVA_HOME variable in your environment to match the >&2\n+echo location of your Java installation. >&2\n+echo.\n+goto error\n+\n+:OkJHome\n+if exist "%JAVA_HOME%\\bin\\java.exe" goto init\n+\n+echo.\n+echo Error: JAVA_HOME is set to an invalid directory. >&2\n+echo JAVA_HOME = "%JAVA_HOME%" >&2\n+echo Please set the JAVA_HOME variable in your environment to match the >&2\n+echo location of your Java installation. >&2\n+echo.\n+goto error\n+\n+@REM ==== END VALIDATION ====\n+\n+:init\n+\n+@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n+@REM Fallback to current working directory if not found.\n+\n+set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\n+IF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n+\n+set EXEC_DIR=%CD%\n+set WDIR=%EXEC_DIR%\n+:findBaseDir\n+IF EXIST "%WDIR%"\\.mvn goto baseDirFound\n+cd ..\n+IF "%WDIR%"=="%CD%" goto baseDirNotFound\n+set WDIR=%CD%\n+goto findBaseDir\n+\n+:baseDirFound\n+set MAVEN_PROJECTBASEDIR=%WDIR%\n+cd "%EXEC_DIR%"\n+goto endDetectBaseDir\n+\n+:baseDirNotFound\n+set MAVEN_PROJECTBASEDIR=%EXEC_DIR%\n+cd "%EXEC_DIR%"\n+\n+:endDetectBaseDir\n+\n+IF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n+\n+@setlocal EnableExtensions EnableDelayedExpansion\n+for /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n+@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n+\n+:endReadAdditionalConfig\n+\n+SET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\n+set WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\n+set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n+\n+set DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+\n+FOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n+    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n+)\n+\n+@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n+@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\n+if exist %WRAPPER_JAR% (\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Found %WRAPPER_JAR%\n+    )\n+) else (\n+    if not "%MVNW_REPOURL%" == "" (\n+        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+    )\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n+        echo Downloading from: %DOWNLOAD_URL%\n+    )\n+\n+    powershell -Command "&{"^\n+\t\t"$webclient = new-object System.Net.WebClient;"^\n+\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n+\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n+\t\t"}"^\n+\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n+\t\t"}"\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Finished downloading %WRAPPER_JAR%\n+    )\n+)\n+@REM End of extension\n+\n+@REM Provide a "standardized" way to retrieve the CLI args that will\n+@REM work with both Windows and non-Windows executions.\n+set MAVEN_CMD_LINE_ARGS=%*\n+\n+%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\n+if ERRORLEVEL 1 goto error\n+goto end\n+\n+:error\n+set ERROR_CODE=1\n+\n+:end\n+@endlocal & set ERROR_CODE=%ERROR_CODE%\n+\n+if not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n+@REM check for post script, once with legacy .bat ending and once with .cmd ending\n+if exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\n+if exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n+:skipRcPost\n+\n+@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\n+if "%MAVEN_BATCH_PAUSE%" == "on" pause\n+\n+if "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n+\n+exit /B %ERROR_CODE%',
            rawContent:
              '@REM ----------------------------------------------------------------------------\n@REM Licensed to the Apache Software Foundation (ASF) under one\n@REM or more contributor license agreements.  See the NOTICE file\n@REM distributed with this work for additional information\n@REM regarding copyright ownership.  The ASF licenses this file\n@REM to you under the Apache License, Version 2.0 (the\n@REM "License"); you may not use this file except in compliance\n@REM with the License.  You may obtain a copy of the License at\n@REM\n@REM    https://www.apache.org/licenses/LICENSE-2.0\n@REM\n@REM Unless required by applicable law or agreed to in writing,\n@REM software distributed under the License is distributed on an\n@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@REM KIND, either express or implied.  See the License for the\n@REM specific language governing permissions and limitations\n@REM under the License.\n@REM ----------------------------------------------------------------------------\n\n@REM ----------------------------------------------------------------------------\n@REM Maven Start Up Batch script\n@REM\n@REM Required ENV vars:\n@REM JAVA_HOME - location of a JDK home dir\n@REM\n@REM Optional ENV vars\n@REM M2_HOME - location of maven2\'s installed home dir\n@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n@REM     e.g. to debug Maven itself, use\n@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n@REM ----------------------------------------------------------------------------\n\n@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n@echo off\n@REM set title of command window\ntitle %0\n@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n\n@REM set %HOME% to equivalent of $HOME\nif "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n\n@REM Execute a user defined script before this one\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n@REM check for pre script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\nif exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n:skipRcPre\n\n@setlocal\n\nset ERROR_CODE=0\n\n@REM To isolate internal variables from possible post scripts, we use another setlocal\n@setlocal\n\n@REM ==== START VALIDATION ====\nif not "%JAVA_HOME%" == "" goto OkJHome\n\necho.\necho Error: JAVA_HOME not found in your environment. >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n:OkJHome\nif exist "%JAVA_HOME%\\bin\\java.exe" goto init\n\necho.\necho Error: JAVA_HOME is set to an invalid directory. >&2\necho JAVA_HOME = "%JAVA_HOME%" >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n@REM ==== END VALIDATION ====\n\n:init\n\n@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n@REM Fallback to current working directory if not found.\n\nset MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\nIF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n\nset EXEC_DIR=%CD%\nset WDIR=%EXEC_DIR%\n:findBaseDir\nIF EXIST "%WDIR%"\\.mvn goto baseDirFound\ncd ..\nIF "%WDIR%"=="%CD%" goto baseDirNotFound\nset WDIR=%CD%\ngoto findBaseDir\n\n:baseDirFound\nset MAVEN_PROJECTBASEDIR=%WDIR%\ncd "%EXEC_DIR%"\ngoto endDetectBaseDir\n\n:baseDirNotFound\nset MAVEN_PROJECTBASEDIR=%EXEC_DIR%\ncd "%EXEC_DIR%"\n\n:endDetectBaseDir\n\nIF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n\n@setlocal EnableExtensions EnableDelayedExpansion\nfor /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n\n:endReadAdditionalConfig\n\nSET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\nset WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\nset WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nset DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n\nFOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n)\n\n@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\nif exist %WRAPPER_JAR% (\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Found %WRAPPER_JAR%\n    )\n) else (\n    if not "%MVNW_REPOURL%" == "" (\n        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n    )\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n        echo Downloading from: %DOWNLOAD_URL%\n    )\n\n    powershell -Command "&{"^\n\t\t"$webclient = new-object System.Net.WebClient;"^\n\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n\t\t"}"^\n\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n\t\t"}"\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Finished downloading %WRAPPER_JAR%\n    )\n)\n@REM End of extension\n\n@REM Provide a "standardized" way to retrieve the CLI args that will\n@REM work with both Windows and non-Windows executions.\nset MAVEN_CMD_LINE_ARGS=%*\n\n%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\nif ERRORLEVEL 1 goto error\ngoto end\n\n:error\nset ERROR_CODE=1\n\n:end\n@endlocal & set ERROR_CODE=%ERROR_CODE%\n\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n@REM check for post script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\nif exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n:skipRcPost\n\n@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\nif "%MAVEN_BATCH_PAUSE%" == "on" pause\n\nif "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n\nexit /B %ERROR_CODE%\n'
          },
          {
            sha: "e168b2799d20267ac52cf4acbd15701d9ce1aab4",
            filename: "pom.xml",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.springframework.boot</groupId>\n+        <artifactId>spring-boot-starter-parent</artifactId>\n+        <version>2.2.5.RELEASE</version>\n+        <relativePath/> <!-- lookup parent from repository -->\n+    </parent>\n+    <groupId>com.example</groupId>\n+    <artifactId>demo</artifactId>\n+    <version>0.0.1-SNAPSHOT</version>\n+    <name>demo</name>\n+    <description>Demo project for Spring Boot</description>\n+\n+    <properties>\n+        <java.version>1.8</java.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-data-jpa</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-web</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-web-services</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>mysql</groupId>\n+            <artifactId>mysql-connector-java</artifactId>\n+            <scope>runtime</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-test</artifactId>\n+            <scope>test</scope>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.junit.vintage</groupId>\n+                    <artifactId>junit-vintage-engine</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.springframework.boot</groupId>\n+                <artifactId>spring-boot-maven-plugin</artifactId>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+</project>',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.5.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web-services</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n'
          },
          {
            sha: "094d95b93ffb2708ff7037793fd189908b1ea6fb",
            filename: "src/main/java/com/example/demo/DemoApplication.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package com.example.demo;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class DemoApplication {\n+\n+    public static void main(String[] args) {\n+        SpringApplication.run(DemoApplication.class, args);\n+    }\n+\n+}",
            rawContent:
              "package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n"
          },
          {
            sha: "724cb23604d06cf9a508f444b8f9080b1dc2d00a",
            filename: "src/main/resources/application.properties",
            status: "added",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -0,0 +1,4 @@\n+spring.datasource.url=jdbc:mysql://localhost:3306/myDb\n+spring.datasource.username=root\n+spring.datasource.password=admin\n+spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\\ No newline at end of file",
            rawContent:
              "spring.datasource.url=jdbc:mysql://localhost:3306/myDb\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver"
          },
          {
            sha: "eaa99696e2ab439159031a591b363c39f4c240c1",
            filename:
              "src/test/java/com/example/demo/DemoApplicationTests.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package com.example.demo;\n+\n+import org.junit.jupiter.api.Test;\n+import org.springframework.boot.test.context.SpringBootTest;\n+\n+@SpringBootTest\n+class DemoApplicationTests {\n+\n+    @Test\n+    void contextLoads() {\n+    }\n+\n+}",
            rawContent:
              "package com.example.demo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Test\n    void contextLoads() {\n    }\n\n}\n"
          }
        ]
      }
    ],
    trees: [
      {
        subTrees: [
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "DemoApplicationTests.java",
                                sha: "eaa99696e2ab439159031a591b363c39f4c240c1",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "demo",
                            sha: "93e4bded8452e203035bd6b8abc7a82bb32a8d75"
                          }
                        ],
                        type: "FOLDER",
                        path: "example",
                        sha: "862eb54f328d7aecdd398b471e91052cd52deef9"
                      }
                    ],
                    type: "FOLDER",
                    path: "com",
                    sha: "3e68f2d1b3d549d5e6c7b2fcc48b068543a7e21e"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "11a164cc86eddd688bd55248d66b1e440c8aba00"
              }
            ],
            type: "FOLDER",
            path: "test",
            sha: "5b8f16582645727e0f73f9bfc69c64ba885c0ebe"
          },
          {
            subTrees: [
              {
                subTrees: [
                  {
                    type: "FILE",
                    path: "application.properties",
                    sha: "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6",
                    subTrees: []
                  }
                ],
                type: "FOLDER",
                path: "resources",
                sha: "a0da322879762d8496c522beed090a912db02eae"
              },
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "DemoApplication.java",
                                sha: "094d95b93ffb2708ff7037793fd189908b1ea6fb",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "demo",
                            sha: "5ac8d98532041c8c09ade371d71cc4dcf8d44c2a"
                          }
                        ],
                        type: "FOLDER",
                        path: "example",
                        sha: "c226961e386ea808b1f2a6e73f9ba2f81969eb57"
                      }
                    ],
                    type: "FOLDER",
                    path: "com",
                    sha: "f6071f0916b97cc4a745867541c5c0b07f96194f"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "bb9bf49398954eed70064e2e8bdd62574de6c442"
              }
            ],
            type: "FOLDER",
            path: "main",
            sha: "2526e45f3340ba78d441ebbbef2bc404110984ae"
          }
        ],
        type: "FOLDER",
        path: "src",
        sha: "f497f93edb6dc2f63380ab334fe152f283ca01a4"
      },
      {
        subTrees: [
          {
            subTrees: [
              {
                type: "FILE",
                path: "MavenWrapperDownloader.java",
                sha: "a45eb6ba269cd38f8965cef786729790945d9537",
                subTrees: []
              },
              {
                type: "FILE",
                path: "maven-wrapper.jar",
                sha: "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054",
                subTrees: []
              },
              {
                type: "FILE",
                path: "maven-wrapper.properties",
                sha: "642d572ce90e5085986bdd9c9204b9404f028084",
                subTrees: []
              }
            ],
            type: "FOLDER",
            path: "wrapper",
            sha: "6bef16b891b042bd96e7515ad6e3b1029795e3dd"
          }
        ],
        type: "FOLDER",
        path: ".mvn",
        sha: "88bf4cf610648943581817557053739d932c2ca6"
      },
      {
        type: "FILE",
        path: ".gitattributes",
        sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".gitignore",
        sha: "a2a3040aa86debfd8826d9c2b5c816314c17d9fe",
        subTrees: []
      },
      {
        type: "FILE",
        path: "mvnw",
        sha: "3c8a5537314954d53ec2fb774b34fe5d5a5f253a",
        subTrees: []
      },
      {
        type: "FILE",
        path: "mvnw.cmd",
        sha: "c8d43372c986d97911cdc21bd87e0cbe3d83bdda",
        subTrees: []
      },
      {
        type: "FILE",
        path: "pom.xml",
        sha: "e168b2799d20267ac52cf4acbd15701d9ce1aab4",
        subTrees: []
      }
    ],
    branches: [
      {
        name: "dev-yxw",
        commitHeadSha: "8a7fa401df16de95b4540aa6c61648d75fa4e99c"
      },
      {
        name: "master",
        commitHeadSha: "d452a08ee6b7772f30b876395b09ce7a15f8a58c"
      }
    ],
    shaFileContentMap: {
      eaa99696e2ab439159031a591b363c39f4c240c1:
        "package com.example.demo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Test\n    void contextLoads() {\n    }\n\n}\n",
      "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6":
        "spring.datasource.url=jdbc:mysql://localhost:3306/tle\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver",
      "094d95b93ffb2708ff7037793fd189908b1ea6fb":
        "package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n",
      a45eb6ba269cd38f8965cef786729790945d9537:
        '/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = "0.5.6";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            ".mvn/wrapper/maven-wrapper.properties";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            ".mvn/wrapper/maven-wrapper.jar";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n\n    public static void main(String args[]) {\n        System.out.println("- Downloader started");\n        File baseDirectory = new File(args[0]);\n        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if (mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n            } finally {\n                try {\n                    if (mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println("- Downloading from: " + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n        if (!outputFile.getParentFile().exists()) {\n            if (!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n            }\n        }\n        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println("Done");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println("- Error downloading");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n            String username = System.getenv("MVNW_USERNAME");\n            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n',
      "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054":
        "PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MF\u0095\u008fA\n0\u0010E\u0081!\u0017H\u0015E*\b\u0082\u00ad\u0084d\u008aC$LcVT+w{\u0083vXA\u0017\u0019C2P\tgE\u001b\u001ahE\u001d\u0087P\u0096\u0018\u001bD{pN:\u0004\u009f\u000f!Q+lK\u008a=8\u0092q8,a\u0013e\u0018\"\u009c\u009d\u0002\u0018v\u0093,l&kM\u008e@G\u0013\u009c2Q8^R+\u001enTrI\u0097;_\u0013PK\u0007\bK1\u0000\u0000\u0000+\u0001\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000META-INF/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000META-INF/maven/io.takari/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00005\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.properties+K-*533J//-L+IN,J,*LKL.\u0001\n&\u0096\u0096\u0017%\u0016\u0014\u0016q\u0001\u0000PK\u0007\bL@\u0005:\u0000\u0000\u00009\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/apache/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000org/apache/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000org/apache/maven/wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.class\u0095Vv\u0013G\u0014\u0085\u0086\u0016\u0099\u0004\u0006`#b\u0092\u0007up\b\u0001\u008b\u0098\u0081 \"\u001bc\u0083A\u0098\f-l\u0091\u0095\u00923'\u0090y^d\u0099Ua#\u0084\u0013\u008f/\u0092jlI\u0096sNzUu\u009f\u007f\u0014I`\u001be/hzE\u0017V\u0097=J\u0085%\u0012\u008e\u0084n\u00983B\u0005\u0015\u0019,KV\u0005zn\u0091\u0005C\u009ca\u001ab\u008c\u0017O2\u00ad\u0002\u000f\u0087*\u0002\b2\u0018&\u009f\u0096sJ\u009c!\u0092ziV\r9\u008c~Q4\u001c\u0006-\u0082J1\u0004\u001ce8\u0016\u009flD7#l\\H-\u0086]1J<%\u000b_^\u008a0,Q\u0010ag}&\f\u0086*p\u0080\u009f7BF\u009a\u0014\u0090}M\u0019zm\u00adC\u0005\u0087\u0018\u000e&\u0093\u000btf;N\u000b2\u0089\fjd\u0018\u0087a`T\u001cA\u008c\tt\u009a\u001ewSa<\u008bc\nZ*\u008e\u0084-i[\u00861 )>\u0015\u0083\u0018\"\u000b\\8\u0082\u0097\u009b\u0018\rm.nR\u0085&7oSM\u0011A\u009c\u00942\u0018aH4\u008e\u0011\u0016H\u00890N\u0082\u0017ZvhsE\u009ca\u0099\u0012np[[S\u0012fTE\n\u0088e\n,Z\bu\u008c\"\u0004\u0092I\u0012c2O\u0082.U'Y)ejr\u0003.\u0015\u009cd\u0013F\u0010I\u0082\u008a\u008bD\u0089(\u0011\u0098\u008bp<Y\u009c\u009b\u0092\u0099\neR+d*s)\u008e+*^U\u0012\"bJUtQl\u0081\u0086q\r\u0019\u0005d~\u0096*&0\u0083\u00921e[TRb\u0085L\u0087;T\u0014\u0014hNF2C\u0098&Ij9#Er)Ep\u008b\u00adt:8L5 Kr`\u008e\u008aC\u0087q\u0007x\u001do%8E\"q\\@pnS\u009b\t|DW\u009bVG `\u001dy\u00059\u0086C[\u00adQQ\u0000aA\\SlE3%6\u009b\u0088n/\u0090`*J\"`\u009a5\u0086\u0090;F\u0091|\u0007]G3[?)\u00170=U\u0094\u0007W~\u0086H^ia8z\u008fT\u001awvs\u0003c\u0017r%.\u0015QU\u0084\u0007F\fGHV2\u009axb\u0095\\m\u007f\u0085tR/\u00108$N\u0015>>TAk\u0001#|LHe]P\u00ad\u0092NUyW#11]5\u0085QC\b\u009f2\u008c\u008f[R!fZ\"V4\b\u001e\u0013E\u001e\u009b\u0090\u0012k\nk\u0017c\u0086Y\u000b6rU\t\u0011?'e\u009f\u0002_\u0092v-\u009bjN\u0007vz\u0005<\u0082\u0099|\u009e\ryB\u0019j\u0015w\u0010&v\u001c\u0097\u0007Q\u008fs*4e\u0006\u0006V\u0011zL\u009dm\b7\u001a\u0083j}\u0001;%\u0011c7\u00adC}?\u008dJ\u0018v\u0084vH8g`h\u0015&\u009f`;Yp\rptf\r5\fQ\u001a\u009e\u008fk8\u001bG^h 2>T5oG?P*f<S4\u0010\u0099%;Y_.\u008d\u0006AF\u0006_7H7o?v9G)4\u0090\u0082zq\u0088\u009e^!FQzF0\u0086c\u0081\u0013\u001f%zLjm\fD)xDeo\u001es.y\u0007\u000b(\u0012 0#),>\u0014\u0013R\u0099\u0012\u0094'&,ZUV\u009f{\u008b?!^\u007fo\u0090$;\u0018]\";\u001axz\u001b\u0005hgd\u0082r\u001cy\u0086~B`G>\u009f\u009ea6I#\u0001kl\u0015_~n\u0007\u00150L\u0093H\u000eR\u0014F\\z1W\u0000uzi\u0097\u0014\u00adK\u008f;\u0017\u007f\u0001PK\u0007\bB\u0005\u0000\u0000`\n\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00002\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.class\u0095SmO\u0013A\u0010~\u0096\u001e\u009c\u0087j\u008b\u0006J`\u008f\u001aa\u0005B\u0015b`\u0096vi\\w\u009b-\u0084\u007f\u001f\u0014\u0089?\u001fe\u009cT\u0083@\"\\rss<dfo?\u0000T\u0018\u0092]\u009f\u000fx'>?\u0010?|0\u0010\u008b}>\fM]\u001dP\u008e\u008a\u0083$C\u0003?\u0014\u000eMOH\u0013Q\u009a!ezA\u0094_&IW(y \u0003\u0017.\u0093XfHTGL\u0080\u0087+HH`\u0083\u0083k\f\u0089\u0082\u0005L5\u0002)\u0087=P0d\u001am\u0003{\u001e\u0005\u0093t\u0086%\u0015*}+&\u008fC;'\u0011(0_(6|\u008a\u0083\u001c\u007fP0^y^m\u008d\u000e0\u0090:\u008a\u008c{\u0087\u0010[\u0099VT9bX(4N\u008c\u000edwx64\u008e?J\u009bVkgc!\u000eU\u008a\u001e\u001ea\u0081\u0094\u008cjI)Y(\\dQs(2L\u009f#[q[jU`'\u0090;M\tv\"Jk\nS\u001d\u0007e\u0086at[;\u009cR\n]\u000b\"\u001c-S\u0082\u0007KF\u00917F\u0083q\u008aO\u0090\u008c6\u0096\u0016?\u00939\u0086)L\u0091M\u0011\u0006XE\u009a\u0017.#C$n\u0088\u0005\u009dwdeb&3K\u000b\u001e\u001cSd/O\u0090eGd\t\u0094b\"\u0096b':[1\u0016\rPK\u0007\b5C\u0012\u0002\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000S\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.class\u00ad\u0094]o\u0012A\u0014\u0086\u0003K\"*XZ.*^\u0099`L\b\u008d\u0089\t*\u0089\u0014FX\u0090\u008f27\u001f\u008f2\u0000*$E793s\u00999\u001f\u0000\u001e\u0089\u0083\u0004\u0095T\u00ad\u0080uY\u0083\u000e;\"+r\u0015l\u000f\u0017-\u0017\u0091dMw\u0007\u009d\u001d%\u008d[\u0087<6O\u0083JOa\u0083i\u001c\b\u008f\u0080\u0005\u0082\u0084\u008f0,\u0014~NHz~\u009d\u0090&w\u0091\\\u00063\u0098%,B_:\\e\u0011'j:S\u001d\u008f'S\u001d\u0084\u0085\u0097\tK-wX\u001cjNB)\bk\u009e_Ae\u0007\u0097\tgDq\u0085[Z\u0088w1W. O\u000eWGL\u0082\u0011r\u0006D\u0098h#\u0001aMi\u0015\u008aV?=\u0095Ms\u0084R\u0001J6\u00016\u0095_!<\u009d\"x\u0014.V`$\u0097\u00066\r\u00966S\u0015\u0098!Oy^E\u0016\u009e\u00adO(LW\u008dw\u0005.\bs\u0004wWT\u0083\bm\u009f*Y B\u0010\\U#sh<v\u0088P<?\u000fal\"\u0018\u009e$\u0093D~\u0003f\u0098Q`\u0010f\u008aGH\u007f1\u009d\u0084\u0016\u0086n3M\u009b\u0019\u0005\u0018{\u0014\u00168^\\1W\u008e\\\u0018Ws7r\u008eq+\u001e\u007fr\u0087\u0013r\u0085\u0091\\\n\u0017r\u001b&,$\u0086\u0083a\u0010%e7\u0010\u0098\u008c\u001bPK\u0007\b\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00000\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.class\u0095X\u0007`\u001b\u0019\u009e-0\u008e\u009c8QB\u0089\b\t\u0090\u00ad\u009a\u0091\u0010\u009b@\u0001\u0083\u0004v\u0004H>\u0090ut\u000e\u0085\u0086B\u0007e\u0094RZF[\u0092\u0016d\u0093M{\u009edY\u0015\n\t\u007f~{Q\u0000m\u0005\u001a*\u0004\u009a\u001cw4jN\u00981+:nNZ\u0094kNLXnt\u00875bfS\u000eg*\u009dra\u0013\u009c4)3=\u001a5t\u0099\u00954T\t\u009crl.\u00025c\u008bu\u009f?w\u0080\u00168~\u0093xf\u001b4SY\u0012;\u0002u\u000e\u0015\u001fU\tl\u00158\u0081Rvl'g\u008e[\u0002\u009ey]\u009ekG;XB6h\u0019~\u0004w\u008e\u0086g\u00964\u000e\n;V\u0000\u0095Xn\u0016+\u0004*\u001b\u001a\u0007!\u0091\u0090\u0081\u0013P\u0013h\u008d\u0081\u0013%\u0089I'=b\u008ff]k\u001c\u0098\u0096WF\u0012\u009ed`\u00ad$\\Y$\\HC3{\u0097\u001d\u001f~s(t\u0092fjtm9/,1;#\u0010y\u00811\u0018\u0089\t@r\u0003\u0088F\r\r\u000b\u0002\u001b\u009fx\u0081&43\u0014\u0096Gk\u009b\u00168\u008c\u0003\u001b\u0097.ih\u0011}\u00ad\u008b,\u00adb94\u0082\u008c\u0005b\rg\u009b\u0011\u000f4\u009ct\u0081zeM\u000bh\f\u009c\u0089M\u0002\u0081\u008c\u0015D0\u0005o,!&C\u001dg\u0011\u0083}{\u000fb}zt-\u0016\u008f\u0015lF9\u0018\u0016@\u0007\u0091~8W \\`\u00ad\u000f\u0017\u0002kK\u0094\u001f\u0088u\u0017v;\u0094\u0088\u0003]\u0007\u0092\u0084eF\u000e\u00818\u0017w\u0002\u00895\u009c'`\u0094\u009e7\u008d\u000b\u0098x\u0001;eT\u0095=\u0006zG/HT\u0099.\u001d&\u0089\u0086\u0085%n\u0003\u0017).\u0097\u000fnF&P@?\u0091~\u008egi3%\u0099\u0095\u009a\u0085\u0086\u0011V\u0085\u0014Y,i/.o\u00821\u0003\u0097R\u0001\fzJ\u0014o\u0010/bq\u008e\u008cX5+Md=f\u0081e\u008ek\u0018\u0012XU*t7\u0000\u00132\u008e~Yb\u0007\u001frw\u008cuf~\u0094\u0081\f)\r\u0097/T\u009d>\u001e\u0087\u0093\u0080OY\u0095\u00170!};a\nL\u0091\u009dfN.M\u008de\u0011\u0094\u0099TL3\u0090$\u0017W2\u009b2=K\u0016\u009cm(Lq\u0080\u0093T-\u008a,\u0080\u0017\u001a^R\u009a\u0093\u000b$\u0019x\u0019\u0096Q\u0002s2f]\u0091e\u0090*\u0095<r\u0003+\u0007b\u00ad;]\u001bo\tJ6:\u0090\u007fx\u0001\u009a\u0097Sk\u0000\u001aa\u001c3z\u009cQ\u008bu8lG\u001c\u0081\u0015\u008a$}zA4\\8\r\u00117\u0010oS\u0011\u0012ZnyMx\u008b\u00867eB\u0095\r\u00157Q.h?4vY\u0000\u00ad\u0006n\u0093\u008d?\u0099r2\u0096\u0094\u007f+3!EV\u0099\u0018U\u008a\u00ad@\u0085\u0015e\u001dHY7(\u0001{\\\u0093\u009d\u000b\u0099C*am_'\u008dMgc\u0084\u0013x3\u008d,def3\f\u0017hx\u007fJj\u008f\u0007\r\u008fCL\u0005(VqX\be!aG\u0089\u0019Y\u0007\u001e4\u0090\u0093\u0098\u00ad&d\f86\u008b\u001a\u001eZxA\u0006\u008eaY\u009a\u001fG\u001d\u008d{u<*p\u009em\u0003\u0019\u001e\f\u009f;R,0\u0086tNg$\u009f\u0007da\tU0\u000f\u0085{%\u0010,=\u0094\u0095$\u00ad)S\u0019\u009b5?\u009c-\u008b+8?n#\nS\u009b1Vb\u0081/V\nh8c\u009dY;En:\u009ey\u0003x\u0002\u009f\u0094\u0005\u008c\r|F>\u0016\u008c!JtFW:^OOs\u0006\u009eyJfK\u009a\u0001nyV\u000f\u0088\u0082\u000e\u008b\u0006$c{N~\u00935\"YRl!5\u0003_7\u0000nO\u00996[Pj\"~\u000bm\u0002n\u0096\u0081{\u009a=\u0085kh)\u0097\u009eg\u000f\nhe\u0010R\u00ad\u009d\u0005\u0001\b?c1\u0003?\b4\u0019\u0082\u001b\u008fk\u0005\u001d@Nv)2k&\u000f^\u008b_P\u0086%JH\u008aN\u008d9P\nW]\u000bbu\u0081^\u0010\u0018\r\u0006gU_.2\u008c\r\r\u007f'\"s9K\u00962iL&-]O&@\u0096d\u009a\u007f|;=\u008b.\u00ad/}\u009d:\nr@\u0081T\u0090\u009d\u001enaz7=a1\tY{th\u0004\u000fyy;\u0084p56h<\u0018\u000b\u0095=n\u0015\u0092.\u0010]<\u00924Q3)\u001b{\u0086:`gi\u000bg\u0013\u0013\u000eu\u0019\u000esm\u000b\u0006{[\u0003R=Q\u0099;\u009a1\u0099\u0092-\u0083zUub+\u008f\u0081e\u0002y\u001eYsHZ}l\u008c0\u0010\u0098SwawV\u0088\u0017\u0001#v\u0099n\u0096T+J\u008a\u001edzn\u0014\rB\u0096\u0094**d'\u0019`\u0010D\u0088B&%kdQ;R\u0006(\u0005\u0087\u008c\bhO\u0089\u0013dkLf8\u0010ke\u0091\u008d]\u008b.\u009a>\tmq\u0087u\u009e*O\u0018a\u00879 \u0082@uP4\u00ad\u0093\u008bM4J~\u008809)n7M79\u000b<k6d\u001b2\u0086\r\u0099\u000e_cP:4C\u009c.F\u001cw\u0016U\u0099\u0002plwQ\u0013\u0096b\u001c\u0090\u0004\u0083\u0082\u00ade[\u0093Ntq\u001b-!8Q\u009c%MJdHu\n\u00992\u008d\u0016\u000e'3+\u000f\u001fVC\u0083q5\u009fs\u0015|\n\u00adq%s\u0003As\u001c\u0094\r<\u009b2\u00069IS\u001955?\u0088\u0083Xj{!$o\u0094\u0002\u009fO\u0016mdu\u001a\u0019\u009c\u008ez\u009cAu@\u001a\u0006p\u008azYTb\u0085\u001aI\u0015{\"V\u0014T\u0003\u0083gqQ\u001cA$!f:\u008by\u00995\u008af\u009as\u0016\u0018s\u00059\u0015\u007f1\u0014x\u000e\u0016x\u000fnV<O\nnQz%I)#A\u0096\u0091\u0015p\u000e9(\u0091 \u0083\u000b\u0091\u0093c\u001fg\u00954\u008b\u0094\u0091\u001cn\u0086\u0010\u0017kOSsd\u0006y\u0001\u0090O\u0018i\u0005}\u000fz\u008f\u0001\u009a\u0091w\u001eP9\u00ad\u007fpS<\u009e+\u0087E\u009fh7\u0090h:\u0082\u0089#0\u0013\u0094\u009e\u009cH_*\u0007\u001c\u0099v-\u000bN\u0085\u001cC\u001cl/XWo\u000e\u0083H}`E@}`9^5^Q\u001bj\u0016Qsks%W\u0090?pcbSu\u001dO\u007f\u001em7\u0082o#a\u007f\u0014z\u009f--G\u00901v\u000e)\u0086\u007ft%C\t,\u009d~x\u0000k\u008duD#}\u0011E\u00820\u008bs\u008f\u0084=~R\u0088/1\u0084\u0014\u007f\\\u007f5Fp\rF\u0004\u008cFb&\\\u008e[\u000eq'}\\?\u0007\u0010\u001c\u0015\u008fU\u0086\u001c.p1\u001e\u0087\u008b\u0098SI\u009aa\u0081w2*w2\u0087H\u009b\u001fN\u008bp\u0000]L\u009f(u\u009b\u00124\u0095:K<[\u008d\u0097T~M\u0017#\n\u0096D>\u0005\u009bT31\u009a\u009ag\u0081\u0096'\u0089\u0087\u0088\u0082\u0007r\u0098\u0005z\u0091Y<\u0016\t~\b\u009eH\u0004\u008f\u0013M-3T\u000e\u009f\u000b\u008c<4O*\u0080*d(\u0093\u0004\u0014t\u001a\u009bTJ\u00974E\u0015]\u00922M\u00ad6|EQ\u0085|\u0018QD[V\u008c\u0083M9|5\u0087oF\u0082\u0087\u009fW>\u0082oHr{\u001f\u0089\u001f\\l\bWv\u007f\u0017s2Q\u001cG\u000e\"\u009f\u001e{\"yN\u0088}-\u001cq\u0011Q\u0099\u0013\u0096\u0019=F\u0005u\"\"fQ\u008c\u0095\u001dDAlmW Zq\u001d\u0010=\u0017\u0011\u00111c\u008172FoRN\u0089\u0091\u0092\u0015\u009drP9\u0080$^-\u00028r]\u0085-\u0010)\u00ad8Ep#U\u0004Q\u008d^\u00adU\u0092!\u0096\u0089r\u001e{B)\u0096s6\u00962QB&\"G\u0096F\u008652+\u0019\u009cX\u0092\u008f9\u0017\u0095\u009d\u009b\u0019\u0083[Xne\r\u0011Bw>mEDX\u008ao\u0090\u0093U\u00ad6A+4KT3yJ\u009a\u001e`\\'Na]\u00ad\u0013\u001b\u0013\u001bi\u0089F\u0089f\u00ad\u0013-\u0089h\u00ad\u0002\u00849\u009e\u0087DU*\u009eBZ<G\u0089\u0016PgE5\u0094;).\u0006w8C%{%\u0081\u0019+XGR\u009c\u0002cbIYV\u0087\u0001YY\u0006,\u008e|\u0012[8\u0093VQ\u00159\u009e):TV\u0088\u001eb8G]\u0015@O\u0004B\u009c\u008b\u0000PK\u0007\bC5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000org/apache/maven/wrapper/Downloader.classE\u008e\u000e@\u0010\u0086\u0094\u0092\u0090x\u0000\u0007\u0017.6\"\u0091H$\u0084j'fU\u001c<\u0080\u0087\u0012[\u0084I&3\u007fo&y\u0003\u0098B\u0018hs\u00102\u0095\u0091IDad\u009a\u0011S]D\u0090\u008d\u000b\u0087\u008de.E\"A1\u0007\u0019\u0011~\u0011B\u007f|\u008a3]/\u008f\u008a\u0098G\t\u001d\u009b]\u0003NH\u008b&s,\u0017\u0013pyE#\u008cKN TQ\u0016D5\u00adv\u00adrl^A\u0005PK\u0007\b\u0084q\u0012\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/apache/maven/wrapper/Installer.class\u009dXy`\u001cu=iY\u00ad\u0097\u008cl\u008b,\u0006\u0090u`\u001bd\u0090\u008d!\u0019D$YX\u0096`3\u008e;\u001e\u0096d\u0080m\u0012\b\bI\u0086p;\u0001\u0004\u0011`Z\u0002iS4E4mi\u009a-7{hW\u0092\u0013\u001fZ}3~}\u009f\u0016\u0080\u0015r@\u0089`\u0091\u0013\u001fjb\u001e)bMq+\u0016MD\n\u0087\u0001\u008f`->)lE\u0087\u009a\u001eH\njZ6og\u008dtZAU\u0004}O2\u001e\u008a\u000e\u00ad\u0011(h\nl/**'-\u0018J$\u0013\u0002o\u0019\u008e\u0086\u001d+(8j\u00adY\";\\cVr\u0086D\u008e\u0082g>]HkCPr\u009d\u001c*\u0010v\u009c\u0097\t<\u009b\u009cC)L\\Ae}\u0015\u0010T\u009bRWM\u0098\u0098!\u0098\u0011\u008a]n;\"\u0003u\u009f3`\u0085xH\u009f/==!\u00923k\u0091\u000f\u0019m\rm+i\u0082\u007f\u008e}\u0099\u008c`h(\u0015\u0092!'fY&~!is(l+\u0091\u0001;{\t\u0003~\u0089wX$0;wmm\u0087K@mQ\u008c&\u0092v\u0012,e\b\u0086\u001d'Xtj,\u009b\u0087:\u001bX^3\u0080F\u0081\u0011JEbQ\r\\J\u009d\\\u009dln`%]?T(\u0010+L\\\u008ef2iep\u0092n\u0099\u009f^\u0015B}%<\u009d9}^\u0095\u0084W\u0099X\u0087\u0000~\u0094pV\u000e\u008b\r\u0082uS\u0082\u009ayh<jln\\U};\u0014m\u001f\u008a\u001a\u009bL\u008d\u0085\u0097t2\u0002\u0004,\u009d&\\\u0005K{y+#6\u0090\u0083H\u0019P\u0089Fh/\u009b~\u001fC\u0087\u0081O\t.<cu8CCvD\u0013\u008a\u000e:>l\u0006\u0093\u008f\u0095&\u0087\u0094\u008f\u0087v5S%gQ6\u0005^\\e>\u007fr1V|?\u0018w\"~N\u0006\u0086I9c\u0002bo7Cqv(!<l\u008d&rt&\u0013;usfn7J\u001bp3v\u001b\u0098pg\u00074j\u0080`\u007f\u0089\u000bC\u0085m6\u0086\f(<LA\u0088\u00880m\u000f\u0014_\n\"\u0094C\u001c\u001f\"b \u009c+{\u0013Qu\\=B\u0089b&nUv3\u008a3\u0094Nw\u0012&\u0092\u009a\u0006w\b\u001b\u000ea1f\u0093=\u0095J\u0094xiVo3q+;h\u0087Y\u0001^I\nS\u0012\u009f=\u0006&h&\u0005\u000e.\u0096\u0016gf.\u0019\u0087L\u008bFi\u001d\bLRzv\r}&W_TM\u0080\u0010\u0081M\u0080\u0089A\ts\u008fL\u0093d\u001ey*A5\u0095xX\u0011&k\u008en<j\u008b\u0012\u0019\u0086\u00926Sa\u009d\u0090E{=<\u0086\u0006\u001enSwM\u001c\u0013=\u0092\u009c\f?b9\u00adyuu0\u0014[\u0087y3\u001ah-\r\u0013N8\u00955\u0007L<D\u008dV*GM|\u0015{D\u0017zU&do\u0094\u0018S^|\u009d\u0093\u008e_yh%I)D\u008a3f\"f\u0006^\u0011\u009c;aT4\u0019\u008a\u0005}U\f\u0004\u000b_R\u009bX\u000f:v\u001fu\u0092\u0001'\u009aBQ\u0015\u001d\u001b\u001c\u0013\u008d\u0091X\u0006\u0080`(\u001a#@2<_1\u0098Fd2\u001aLA'\u001e+1;}\u0013WhO\u009ax\u001dltiN{[8%X\u0090\u0093m#@*\u001d\u008eGB\u0089\u0084\u008e\u0011$q\u009f\n\u0015\u0013\u008awDh6v/\u0015x&\u0087e\u0094;\u001c\u007f\u0093y\u008b1P\b\u0091\u0082\u008f\u0089LBz\u0084\u0099-\u008c\u008b\u000eocNf*\f\u009c\f\u0013R\u0082\u008e@\u001f\u0085'\u00937\f;s\u0097\u009bm*KFbyR#\u0098\u0081\r\u0086&\u0082`h\u0005u\u007f^:\u001a\u008dI'\u0016K_G\u000e\u0015=\u0095LI~/@)\rqn4u\u00896R#T)V\u0089?\u0087\u0014\u0018<\\cj\u0089\u0089P\u008c\f%Zsy\u0097&\n\u007fMS\u00ad`p\u009c\u0097+\u001f\u00863v!\u0099{eS\u0011J3\u009c\u0084\u0017Hgrhb6\u0018'\u0004\u008b3`'\u0012Q\u008b\u007f!\f\u00898A/\u008d2W_~\u001f&S\u0011o6\u008bp\u0093\u0015u!;\u0003y\u001f\u008fB\u008e{G?\u0013?i}!\u0096qa\u0015guX\u0013\u0091RCxK\u009c3e\u0014\u008f\u00161l\u0085\u0092\u009b\u009dW\u0019\u001e;?6Q~\"P\u008b\u0010/yzcjp\u008e\u00adCC|RT\u0092*V$\u00ad\u0098\u0090\u0099YZ]@i`z(\u0001\u00152\u009b\u00909iI\u000f1d\u0012\u009d\u0099 \u0088U4\u0097yE9T\u008d*0\u0089(\u001f<\u0002\u009c/Xp\u0098\u001aUh)\u0017c9\u0095\fP\u0085m\"\u0090\u008bs-[m\u0094Z=sU'#d\r\u00125k\u0084(\u0085S1BDG\u0092:A&'\u0015\u000e\u00ad'\u000b\u0002^MipGa+N\u0006M\u0082\u0015aJ`~*\u0016x\u001d\u001d\u0087\u0006N?p\u008a4.liY\u008bk\u009d\bt\u009b\u009c\b\u000fL\bJbUin&|7\u009d&\u008fyV/\u000b:<\u0010\u0090H\u0006\u009d\u0094\u0016\u0011\u0091a\u0080\u0012<I\u008c>^\u0095,\u0018'C\u001co\u0094Mz\u00075\ni\u0093k\f\u009cfN6Zi-=+\u0005z3\u0096O\u0099!\u009d\u0098t:\u009ca(\u0086cZH=M\u008b\u0016-\fH)M*=z\u008e\u0006\u0011\bO{NN5j\u0099/7\u001eKd\u0090e\u001a\u0014bb\u000fa82d\u0012\bX5H\u00064\u008a\u0086\"\t;8\u00895e[\u0093Ov\u008awJW\u0003\u00045N\u0006\u0002:\u0001\u0010U\u008afh*bg\u009bv\fI\u0090=E\u009c\u000b\bLE'J\u009dL^n\r\t0P\u008f6\n\u001b\t\u0086Db^\u0018\"{_n\tE0z0\"\u0085\u001cL\u000fd\u0086r\u0092JI\f\u0019\u0091l\u0013+X>Im\ntKr\n r)w9\f8\"m\u009c\u001eEL{\u008f)\u0007\r8kw:q;G\u001f\u0087LW\u008d\u0095\r\u0084\u001dRw\u0004mM\u009dg\b\u001aC?7\u0093\u009f\u001cS\u001fWTO!y\u0090\u0087y\u0098N{S \u008f\u0092p\u009c\u0097\u001b\u008a\\cc{v\u008b/c\u0086R!\u0004G\u000b\u000e=.\u0087i\u00806v=qH\u0085\u001dR\u001c\u008a\u0016\u0001H\u0081\u000bi\u008b@%h\u001bv2\u0091a-\u001d_\u008f\u0093\u008a\u000fQ.QY\u0010@Qb@@c\u0094q\u0010\u0017q@)\u0005W\u00832\u0094S\t\u008f\u0094\\W'Jro&fw6\u009f\u0002s0nk85;\u001e^\u001e\u0091M<\u0082\"\u0000\u007f\u0018y\u0080R1TP\t\u0002_w\u001e>]\u0002K\u0017P1!?\u0004.jx\u000f\u001bXv\u0004W\u008e)0\u008e\u0015\u0081\u0086\u0013X5\u0086U-i\u00adZ\u009f46\u008easU]\u009d\u0086\u0013h?\u000642[U\u009fF_f\u008b\u0003\u001e\\V-jWKyMy\u001a\u0016[9\u0082\u001a#\u008d[\u008e\u0086q\rQF\u0088guH\u000fTT\u0015uG\u0091(?$+~OWe}b\f\u009fkU{\u008f\bfN!a\u001c\u0017x\r0\u008f<\t&R\ny\u0092Bj*x*on]M\u0018\u009eW\u0017\u0004GN\u007f;tF\u0086kQE\u000b\u000f\u0019\u001b9=\u0017\u008c\u009b\u0081\u009e7Q\u001a(\u00ad9\u0081_\u001e\u001a_I\u009c(QE\u0086R:x:KI\u00059 .Lfj\u0098\u008aV\\\u0089k\u0082\u000e.\\\u0005\u001b8G\n\u001bq;6.R<\u00806\u001cf\u008c\u0091\u0016\u008fv\u0018qq\u009br>*H\u000b\u00ad\u0095=\u0093\u0018e\u00047=\bc!_Mr\u001c;=\u0083\\f]._z\u000faV<\u001a~\u009dyA\u0004}/5D\u001bx\u009fW\u0086\u009b\\\u0095!%7=.}m|\u009f\u0019}\u0097\u0007RK;|WA\u008d\u0006>\u0087=Z\u000b\u0007|W\u0089\u000f\u0084I\u0099\u001fzJ\u009b\u000e\u007f\u00ad?rU\u0090\u008fG\u00811\u0093i|a?\t\u0094\\V9\u0086j=+X\u0018\u007f~\u0018\u0095\r'\u0012\u001fH?\u009f\u0088B\u0097_\u0090\u009aAb\b\u0083^\u0087:k{k\u0007[=v\u0094,Z}\u0091!JsA\u0006^\u0003z\u0082\u0014\u001f\u0010^0<\u0096W\u0003\u000bSQM\u0005J'\u009e@\u0019{_-\u009e\u001aO\u001aRVS\u0096f\u0002R\u0096\n q1\u0002R\u0011P1\u00995&U-R\u001d\u0018\u0093-1T\u0018seA&qk=i9\u009f)\u0017\u0004Z9S\u0096\u008e\u008ea\u009e+Q.2\\]V,W\u0096\u0095F\u001ex\u0006\"$\u008b\u009b;1\u009f1zV&\u0081H\u0092b\u001fVa\u0098U0\u001f%\u008d\u008d\u0014su'`\u0015<Gp7y\u001dQ\u001c8\u0084Wp/\u0088%x\u001d3\u0083\u001ep\u009f\u009eoq@.u4\u0017\nTwd\u009b\u0010\u0091Ur\u0019#\u0082A\\\u009a\u0099IV\u0015\u008fr%\u000eU\u0086ox\f\u0015QVZ\u008ag_qW*p\u0089F\u001d8\u007f\\}B6*\u00adi\u0083.JKw\u000b(X\u008e\u0010|~\u0084?Z3/#k\f\u0092mn#+~YI\u0084z\u0003\u0097<-\u009d\u008eaa\u009d\u009bY\u0017dj\u0011$\u009b=\ne/\u001e,\u0095\u000bz\u0087<\u007fB\u0089E4\u000b4ta\u0011{\u0002K$\u0096y%\u009es\u0095,#.n#a\u0001Nn39\u0090\u001bE0\b\r%\u0006.\u0098\u001cZ\f\u0095,r90.;\u0003L\u009af\u0005\u001bN\neo&#\u00871_\r\u0087(MJ\u008b\u007f\fW\u0015\u0083j<&>.)\u0096p\u0088fLFd\u007fZ\u0080g\u001cV\u0091\u0007'J7\u0087FA%_bL_b\"jO\u000b^#\u0099/17N\u001e\u009ct\u001d.cJ1\u00073ctY7f#>:\u0087Q_>GW,$R? \u009fSE\u0007.=kx\u0086WK\u009a\u001a?!-_dG\u007fG\f\u0091<1aD\u0006J\b7o3\u009a\u0098HpH6.\u0005\n\u0015\u0095'\u0094<\u00ad\u008f\u000b\u0019y\u0096\nW+1\u001e\u009e4\u0012y^\u000br\u0094\u0083\u0090\u008d\u009bf\u0001PK\u0007\b[\u0007\u000f\u0000\u0000\u0088\u001f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000org/apache/maven/wrapper/Logger.class\u0085SmOP\u0018=w\u001bkWP2\u0010m*%\u000b\u0018\t&&\u0005\u008c3%\u008bR\u001d3\u0004\u008d\u001f\u0001(s\u0086\u0017\u0087I{os\u009e\u009c~\t\u0011\u009eh(04#Y|\u0003aP\u0084\u0091\u0083\u0081\u0090\u0096\u001dy\u009e\u0090\u001aJ\f3\u0087|\u00ad\u0080\u0087\u009e;\u0014n9[o^v\u0018>\u0083\u0006~'\u0018\u008a\u00adP\u008c\u000b\u001d\u0093KdJ)\u0006s{\u0097\u0019\u0098\u0015\r3\u0017\u009fDM0PD\"!j>GI\u001fzq@\u001d4]Tj&c\u009ep1A\u000b#)6y,\u0018\u0097iWp\u0004\f\u001f\u008a\u009d\u0013-\u0005S#\u0097\u0007\u000e\u0097F6\u0081\"\u0016M,@W\u0093\u001f1\u0092\u009f\u0088\u0089\u0087\u001f\u007fq*\u0014\u0089hQQJG4?^\u0013'!}\n\u0083\u001a1^R6\u0000+\u0006\n\nB\u0092\u009e\u001af\u0089d\u0088Kb\u0018(\u0095x\u0001'Gf\u0014\u001dK\u0014P\u0091\"\u0086\u0086J\u0089v%d\u001a\nPGf\u009eW4\u0010RM\u0096\u0089\u0007V\u0086(\u009d\u0085^\u008bVU\u009d|C\u0096zb\u008e\bd6\u00ad\u0015,c%o~NlU\u001e\u00191tN>SfI\u00ad\u0081)Bd\u001e\u009e=1\u001d#\u0091\u0017i\u0006K1\u001f\u0001PK\u0007\b\u0084'+\u0001\u0000\u0000m\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000/\u0000\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.class\u0095X\u0007|\u001bW\u0019d:\u00893\u001a%e[h4I\u0087l+u\\\u00adTSN\u008c\u000e\n@Ye2\nP6i\u000biSV\u000beQ#@\u0081\u0002\u0085\u0093,\u001b%{O?0\u0080b\u008f\u000b\u000b\u0004\u001a\fs<&\u0084\u0016\u008c'5=xT\u0013\t\fv\u0090R\u000b\u0095\u0002\u008e'`L\u0083=\u008ek\u0011K`e[@pHWh0=r?7r+,S[fT\u001f'\u0084l770<\u0011\u001e\u0016XjIK\u00adA5\u0096\b,\n\u0092\u009a\u0019\u00980\u001aE\u0096\bw\u000fn,&\f=\u0094\u0091p_KO\u007f\u008d%\u0094bH\u0092P\u0017\u0096Mo\u0086\u0087zN\u009f\u000b\u001ct\u0002\u0081E\u0091\u008c{X%pg`w`\u0080[~\r\r\u001ctc\u008d3\u009c,\u009a\u009d\u0085}hj>\u0016\u00037D\u0013d?\u0012\u008bQr\u0081\u008a\u0086A\u0081VcTsGK}\u0092\u008aF5\u008d\u008d\u00029'y\t[\\\\\u00143IK\u008b+\u008az2YZg\u0004\fV-\u000fhr\u0098\u00adMA3\u0002\u0002\u00932p=c%,\u001d\u0094g\u001e\u0014l\u000e\u0081Yk3tE0\u0010!\u000fVp\t\u0090\u0084>*</\u001bU\u000fop>\n\\P_Fj0\n\u0016\u008a\u008cZw*~L3\u0007c1M\u0088A\u008cA\u0005ZQ5\u0011M\n4v;\u0098&\u0095q>\u0005V\u001f-\b\u0001OtDKXQf\u008b\u000b\u00025y\u0017\u000fP\u0089.ge\u001dRMn\u0011<\u0010\u008di$e\u008f\u0082^\\%<K\u0099FT\u0017\u0017\u00979`@\u001ew\u0099\u0086aEM7`HwI\u0096f&\u0097\u001bL\u0001zzg\u001a(u\u001a\u0081z\u0018\u001fL\u0005ITF1C\u0082\u0099\nT\u001cc\u001eamj\u0094\u0015\u008d\u0005_lG\u0015h T%T39\u0091'9`\u001a\u00909N&\u009b\u0086\u0080o\u0097\u009a \t\u001cw!J\f\u0095\u0013z\u0088D\n\u00ad/90(U\u0015\u0018`\tQGGK\u0015bpJ\u00031XM\u008c$X\u008a+\u008c\u0014\u007fks$\u009a\u001av'q\u0085S\u0002z6\u001b\u0085i-\u0092\fr=\u0083\u001b1\u001c*\u0084\u0094.[N\u0081\u0093BvR\\+q\u009f\u000b7\tl\u009c\u0095]\r\u0098f,\u0001tm\u0098\u009a\u008aYm)=fvu|\u0093)\u000fn\u00ad23\u009f+L(\u0097n.<\u008flVi5\u0011J&8\u008dq\u0002\u0005[l\u001dfM>h\u0097\")9\u008dx\u0089|{ov\"/c)\u009c\u0095\u0085\u0099\u0090\u0085RMK|\u0007Z$@^Ux5\u0093X\u0003\bG!\u007fver\u0001\u009a\u0083\u009c\u0006vMTd)#\u00915\u0018iH\u0094\u0080qYrF(\u009f,\u008a\u0081G0\u001fgjL\u008a=4\u008f\u007f>8\u009c\u007f@hV=\u0013\u0004KKB\u0011\u008f\u00939\u009d\u009cp\u0085\u0016\u0017.\u0010\u0098\u0093W^Yxn\u0089\u0083N\u0005]3bcq\u009ds\u0000,7\u008d(x/'\u000bZ,f\u009c:_\u0013=%~\u008eP\u009e\u00add\u0001\u0005\u001fY_v\u0016\b\u0097\u000f\u009c\u009cmv\u0005IW\u0000>\u0014\u00888\u0014h\u001f\u00860q!zP\u0004\nN\u0004Z\u00162\u009f\u0013\u0098#\u0012:\u0085\u008f-L77\u001ef~9}x><\u0098#\u008c}Lo\u0082\\\u0019\u0013\u0094\u000b\u009fJjTjA\u0016\u0093x\u008c\u0018>R\\_;)\u0098\u0019\u0005\u008f%Y\u0007\u0096$\u0095_>I}\u0091_T%n\u001a\u0007\u009aq>\u00179\u008fo(&E\u0099Z\"F\u0003Q3I\u0099\u0015S-\u009e\u00ad\u001e<\u0081]\u0016<AkLM\u009b>~8\u0084\b1S\u009bt\u008d\u001b{\u009e$+\u0096\u0019\u0004KiG\u0089\u000b?fo77\u0082\u009fg\u008e\fo\b\u0013n\f\u0011d\u000b\u0085_w\u0098\u008dF\u001bg\b\u0091\u0094W\u0097\u009a\u0015EF\u001f\\4\u001c\n\u0088?1-p_\u008cc\u0004\u009f\u0005V=\u0097\u00adh\\+h\u008c\u0012O\u0003\u0013qY\u0088)\u0017Q,]?OJd\u009bW\u0098\u008d&?\b\bAh'Rj,Y2LOAG\u0082\u0013E\u0086\u001b\u0098q\u009f/\"C\u009b\u0085c\u0084\u008f=o\u008c/B\u001dS\u0093\u009ao\u0000\u0089\u0085\u008a\u0012.\u008a#}\\%.-\u0083e4(\u0007F\u0085G\u0011\u008b/\u009b\u000b\u0089m.yM#\u0096z:S\u000eQ\\ \u0097\u0014\u0083.!duq|\u009f[p\u001d\n\u000f\u0084\u009a\u000fdB\bX\u009c\u009bD\u0088\u0017\u0013b\u0085\"V\u008aUNFiI\u001bd\n4>\u001ajl}[&v\r\u009f-\u0097\u0017\u0090\u0080yGN\u0088u\u008aPge\u0087\u0096Q\t;\u000e\u00adb\u0083\u009c\u008a\u009dG\u009e\u0016\u009bh*Ed7}=M\u0092\t-\u0012\u001d\u008bj;&T\u009fEh(\u0011[DKl\u009d\u009e\u008a)AN\u009c\u000b#1#\u0005M\u00adF\u008a|\u008aa6\r|t^43\u001f\u0004w\u00050C\u0098y\fO\u0096u_q\nvm\u0001<\u000e8\u0089\u008b\u0015K\u0089\u008a\u0093\u009c^\u009dyr@\u00066\u0015\u0000Q'\u0007u'\u0081\u0005\u0082\u0092\u0082R\u0097\u0015\u0097s-Xp}A\u0096\u0015\u0005\u0095\\\u0015WX\u009d\u000bs\u0085\u00ad\u001df\n\u0087\u001b2(\u0083\u0086I\u0004;\u0095\u000f\u0083W'#\u0093f\\i\u0082l\u0098\u0005\u0014|.O\"\u0094?Veo\u008f(\u000e\u0001Zf{%\u008c\u0003z\u0006+)j3\u0096\f\u009d\u0095\u009aWSJG\f\u008ed0waB\u007f\u0006\u00914\u009b3\u00887\u008f\u0013\u0019VUp\u0014n\u001eRW9\u0089L\f\u009e?\u0089\u0017NScx\u0012/O\u0015ym\u0003\u008c\u0007\u008dl~;\u0018\u008d\u008b]\u008aK\u0084=|\u008bK\u001f-\u008cU\u0007\u001d}\u001ad\u0002\u009dx\u001dF\u0004\u0002r\u000e\u0003| a\f'\u0095v%\u0080;\u008d\u00167M\u009foy\u008b\u008f\u0014O(m\u009d]Tm\u009dS\u009b{\u001a\u009bx\u0007{\u009f\u0011|l\u0094\u0015d\r\u0084\u0016\u0082\u0095hc>\u0087eVe73\u0089\fU^F|\u0004\u000f\u0092\u0083G\u008e\u001e%'\u0019\u0006z\nS\u0083\u0087&q.\u0083\u008fM\u007fV\u009fKlA\u0014~\b(@A\u0083\u0011\t\u0001\\\u0095\u0015+\u000bE=\u000e\u0090\u000bX,\u001d-YX\u0084t+m\u009d,\u007feW$]\u0080\u001cNteJ\u001f\u008a4\u0093\u000fy\u001a\u0017\u008b\u0019\u0088\u008d\u00939\u008a\u009b_i<}'f\u008dXP\u0010*\u0086+\u0019Q9)\u001ceDP\u0096+\u0016g5YmW\u00867L|\u001ca~^C_]Kt\u008d\u0082\u0014\u0015bXZ\u0004o5\u0016\u0085!bIbK\u0006\u0088W\u0088\u009a?\u0086%\u008eZu\u008e.\u0013\u0093bMg#\u0015ZX#|i)Gs\u0091i[\u009b*vg\u000e?)\u009aQ\u001f\u001f5?`\u008eV c\u0091\u0004\u001c0\f\u0098\u0088^\u009c863g\u009a\u0099)\u0011\u0006iO\tV\u0081\u0013\u0087I.I\u0006-\u0096j\u0089fYlg\b\u0013\u001b\u0005T\u0083\u001dvnE\u0086i\u001dG\u0011\u0090*\u0019spK\u008f((g{\u0003Fjp\u0013+\u0082[r\u0090B#\u0085J:!v\u0093\u0092\u0002PK\u0007\b\u0011ps]\u000b\u0000\u0000\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000>\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.class\u008dR]O\u0013Q\u0010=-PWX\u0003?A\bi\u0017t(1!\u0010\u008dI&\u009a>`r^lw\u009b[[\u009a\u0098\u000fG\u0011^\u001ab\u0081\u0087\u0099\u00993g\u009e\u009e\u0007`\u000f\u009b\u001e\u001cLb1\u0012\u009d\u008c\u0087D\u000f-F#\u001f\u001c\u0013\u009aYG$G*/j\u008f\u000b\u0095\u001e\u0084` ND\u009c\u0088\u0017\u007fj\u000fd x]\u001eF\u0084,~\u0012f:R\u009a\u0016}\u0095o$\u009b3W*\u0012M\u009a=`\u00165Z\u0084a\u0095KS},b\u0082\u0012\u0002\u001f\u0015\u0012JFt><&c\u0001.aRq<lKU\f!\u0084V\u0006O\u008beD9on0?9\u0092.7\u001a[9 \u0006_\u000b\u0010\u00880<\u0082!M>L\u0004s\u000f\u001b\u0084\u008e$^;\u0013\u001bM\u0089\u0012Bc\u0010g\f\b\u0002cU_\u009fw8(sE;\u0013\u008e`%\u009d \u008c\u009eOPu\u0007w\u000e3e2\u008eQE\u000fnj\u008f5fF\u0099Q7Z\u000fp\u0015s$\u008e\u000bo\u0084?/\u00978\u000b\u008b\u0081B\u001b\u0006\u0083\u0004O9V,}\u001d@PK\u0007\b\u001coI\u0001\u0000\u0000t\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler.class\u009dV\u007f\u0013\u0011}kK\u0096,\u0016\u0002\n\u0098`*\u0092-\u0085&\u0004\u0003\u0089/Rv}\u0081q\u001b\u0096\u0016yAUvW\u0006i\u009b\u001e$mNKz&\u0092\u001b7\u000fY\u0092mD>?Hyf6\u0080\u0093W\u0000M\nNXv.\u0015\u0082\u009e\\\u0096t3y\n\u0005N\u008ekB\u009f\u008by\u000e`umIK53\u0097\u001c\u009bg\\\u0005m\u0099\u0093C\u0013W\u0087CW'&R\u0017\u0015\u0084G\u0093m\u0098^\u0005;\u0007,q5\u009dE=\u0088V\u0005\u000fmq`SC\u0003SUWA\n\u0002gt\u0081\u009cvt{Zi]\u0089cX\u000bF^g\u008c\u0096\u0086i\u00154Gf\u0014\u0006\u001eB3\u001eV\u0010v3\u0088ay\u009e\u0098\u009a@2Z~F\r>\u000b\u0086 :=~\u0018xOt3\u0094\u0099V(P\u0013\u00186\u0083\u0086C&\u008ba\u0099\nn\u0083K\u0095+f\u008a&;z\u0089\u0098\u0097`!\u001cB$\u0080w+y\u0098*\u000e0\u000b\u001ffnrz\"E\u007f\n\u008e8\u0086\nvT3\u001b\u001eG\u009b-\u0081l~\u008f\u008a(H\u008b\u00ad/ZK-W7\u001d\u008f\u0096\u0013{wI\\E7z\u0088,B+\b\u001b8x`\u0010@R\u0081I\u0015\n\u001eR~!\u0092\u0000?}x\u0082\u0010\u0089)\u0099k\u0090\u0002x\\\u00adVE#\u009fml#<\u008f\u0010\u0000\u009e\u0015\u000f*.[\u0092\u001c\b\u0095^o\\\u0084\u0018\u0094bk\u0004\u007f&\b\u0002%)\u0086)\u0015O\u0003lP!R\u008at5;/VZ\u0017t\u00ad\u0010\u0012\u0018\u0017\u0000\u001f\u001e_#8\u008a)q\"_1\n<\u009eQqica,\u0080Y\u0005\u000b2\u0004\u0087\u0014\\\u001ci\u0094C}pe6*UA\u0001M\u0099qU\u0082Z\u0006d[\u0091\u0081\u0010H\u0007_\nfAWJgO\rkB\u0010\u0015\u008f;\u008e\b-b\u0011\u0084r\u00175~(\u001eoPm\u0089\u008c\u0088\u008av\u0012Y\u008e\u0010\u001c\u0014\u0003\u0003\u009eg\u008a.'h9SNw\\\u0015KY\u0099O)\u0093a.'/^z%\u009de\u0015\u001fGI\u00984\u008bv\u000b\u0090\u008f8>T\u008b\u00852\u0084?:5\u0013'9\u0001<$`!oRQ\u001d|ZgaK\u000b\u0012xA\"\u001fES_\u001e}N\u0092VH</\u0013E5\u00169K3zAj\u001d\u0017\u0015\u001c\u001c\u008al\u0002)\u008c\u0018fF\u001cC\"\u0084\u0097e\t\u0015\u0005FcdjnWR\u001aGL]-\"W<wz#\u0089\n:\u0091c\u00926_i\u008e\u0083H!\u008bF\u001a\u0004\r\u000e_'&S}\u0080k\u000e\u000b\u009coj8\u0086Rb#\u0015?O\u0014:u\u0094mT#fY]\n_J:\u0097*~%!@\u0005O\u0088\u0097\u001d3mk\u0091\u008f\u001f\u0014\u0003H\u0082g\u008bZ\u0002t]W\u0082x\u0083*+x\u0093\u001aTJ\u0019\u007f\n`u^v\\}Q\u009b\u0081\"qb\u009b2\f\u0007\u0083x\u008bAd\u009d\u0089\u0004q\u0097\u0016\u0011\u0089\u0014\u001bu\u0094z\u000f\u0012y\nMZE;h!h\u0018JH86~49@H#s\u008caN\u0083f\u001e'\u009b\u000e?Zx\u0017]\u0013\u0082\u000fm\u001fA\\\u0007\u008c\u00071*ce\u0084_L?+\u0087#\u0095Z1B\u001b*\u000eUup\u0081\u0096b\u001b\u0012\u0007\u001bh{A;F/\u008a\u0013\u009e\u008au\u0093\u0004\u0096\u00808\u0080\u0083U\u009f%p\u0081};\u0016/\u008c#Xw\u0019'Fc=2bg|kHGxl\rg<\u008ase\f\u0084/\u00940_\t#e\u008c\u009dNmz\u00965\\\u009e\u008d[RK\u0083\u0013O+zH@\u0082\t$1\u0080Gp\u008b\u0087yIm\u0002\u0096m|\u0018O3V<\u0087]Kx\u0086fZ\u0098Bj\u0006\u000f\u008d\u0014g'\u0012K\u009ed\\\u001b\u001f\u0087bDYB\u008cka\u0016\u009ag\u009b\u0093\u009eUXRS\u0090#\u008e\u008aUvP\u001d\u0010(J52\fC$\u009f\u0095j;';\u0013*4y5Sskx~G,\u009f*H\t\u009f]I\u0017X/<\u001fl\u0089^\u009f\nQy\t\u001c\u0093\u001e\u0098\u001f%u\u000f_\u000b\r|~|\u000b&\\\u0082x\u0092\u008b\u0090>7\"wKx;W\u0007Ka\u009d\u0097\u0097\u0010kt\u0081^.\u0092\u0094\u0017?R[\u008b\u0017?\u00adN\f?b\u009c]\u008deZt\u0090\u008f_E9\u009ed\u0095N3%\u001e,Qr<\u0089bbCU:jQ;[\u008e1|{O\u0001*\u0095 *<V\u0085/\u001e\u000e\u0096\n\u0082\u0012\u000fv\u008bT\u008a\u0094E4\u001f3\u001e\u0017.\u0002s\u00862\u0090\u0097\th\u0096\tm\u001a>#\t\u007f\u001d$p\u009f\u0082\u007fB\u001fPK\u0007\b\u0087|+\u009f?\u0007\u0000\u0000\u000e\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00006\u0000\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.class\u009dUY[\u0013W\u0018~\u008f\u0004\u0006AE\u0010\bQ\u0011\u0004ib\r\u008b\u0086P\f\u0098\f&3d\"Uo<\b<O\u008fj\u009e$\u0090\u0004b8g\u009d{\u00018\u008d4l\u00138e\u0089\u0018\f\u008d\n\u0086H7\u001c[x2=<x\\3\u0094t5\u0004v\u0019\u008dp\u0012\u00999\u0019\u0004\u0006L\u0006\u0005j::'\u0005|WYG\r\u001atN`gh6=#\tc&%\u0005\u009avHM\u001aEK\u009a\u0019\u00813WD`OBz\u009b\u0002G:yoM;|LHg\u0098Txp\u00103\u0013\u0096e]?\u0003R15\u00adDd+e0a\u008f\u00925#\u0093\u001fMhc\u001f\u000eh/\u0097#\u0080\u0016hf)\u000f\u0086C\u0002{KfJaq\u0010\r\u001a\u008e\b/72l9Y\u008f^H#G+\u008e*\u008f\u0093AM*t\u0004!O\u0081\u0092P\u0099\u0099l+:tt,SvFj\u0012h)}#kyfZ\u000e-\u0099!X\u0019.\u0097fjV\b\u000b\u001c\u001fr]m\u009bOJM]Ov\u009b\u0011]\u001dzy\u008fn\u009cV\u0011\u009c\u0011h\n\u001bgu\u001c\u0081Sa1\u008ePh:\u0099\u00882qA\u0017\u0002\u0093wlUl\u0010\u0003\u008b\u0002*\u000e\u0095Q&\u0092=*\u009a^\u0005vLf0ot\u0004;\u0084+\u001a.\u0003\u0095O+\u0013r!<nx\u009et-\u001d/aH@\u008bi'_\u0012j D\u009f\u001dQ)~Y5\f\u0013\u009cr1&=U\t\n$E\u001a*F4D\u0005W0t\u008cb\u008c\u0098\u00984fx+BwH\u0081\u0088i\u00861\u0081Xb\u0096\\6Z\u008d\u001a\u0012\u0017\u0014\u001atLa\u009a\u0001\r\u008fm\u001b{\u0003\u00924\u0098\u0097\u0095V\\V\t{Ds\u00867Z\u0014\u00964\u001d\u009aU\u0086\u008e\u0019Y\t:\u0086&_\"N+t$a\u0012\u0094\u0012^2\n:RH\u009cP\u009f\u0087,\u0092\u001aa\u009e\u0006\"\u001f\u009c\u001d:\\p\u009a3\u0005.T/\u00ad_GV}\u0005\u0080\u009642\u008b\u0086\u0005\u008d\u001fhc\u0081\u001d\u009e,L\u001d\u0095\u0083D(H\u0017\u0090<[N(W.\u008820n\u0004\u0002\u00157\u0094O\"\u0001A\u000f\u009aU<%Os\nuaJK\"Md\u0005\u009djuED\u0095jP\u0081U<e\u008bs\u009e\u000f\u0016n\\\u0016@?\u008c'G(\u001a\u008d\u007f|kj<\u0085\u000b\u0015\u0094g\u0089\u00adh\u0017\u0004o\u0080\u001dI]y\u0088xBn=?ij\u0005{\u001c\u009a\u001fky\r\u0007I8<\u0086)6\u001d\u0012~\u001f\u007fN\u0006|O\u0084k\bN\u00ad{g\u0005\u009b\n\"O\u009b\u0006\u007f\u008b9\\]+\u0002K\u0014]8}\u0080/\u0087\u001cn\u0005rx\u0011\u0003u$\u0005\u001cf\u009f+u+9\nM>s\u00adk\u00991\u001c\u000e\u0000\u001f\u0084I!0\u0089fG\u00191{\u009c\u0091S$O\u009d\\\u0083|\u0010p\u008ak/\b!\u0082\u001eN\u0098\u0019#=\u009c|t\u001e\u001c\u000f/SJ!z\u009b(\u0012-,\u001d\u0011R\u009eu\u0085Gx\u001f\u001f}j\u0003|H_\"~\u0084\u008f7\u008d[\u00846kh\u000f\u009fs\u00158\u0082z\u0088\u0016|\u0089\u0098\u008f\u008b9+&\u009f\u0087l}\u0017PK\u0007\b{\u0002`-\u0004\u0000\u0000\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.class\u0095\u0094S\u001bU\u0014\u0017B\u0012\u0085\u0084\u0004\u0088j\u0086-BZ\u008a\rI*mC\u0012I\u00030\u0017X\u009bT%\u001ftF\u008e\u000f\u0003\u001c@<!{~\u009f{y\u000b`\u0005\u0018\u0018\u0096x\u0097\u001f\u009d)?Mnk{,YFgs\u0018\"\fW\u008ck\u001dn+e\u0098)V\u008a?4\u000fZFReHW\u009am\u0098G\fSqNO\u008fc\u0092aa[\u001d\u0014\u001b\u008dP'\u0086L`\u0097{jX\u0016P\u0018nIi\f\n\u009cNw\u0085\u00813Lunv,~L9\u0086Cd\u0087=n\u0014\u0089MZ;\u008865\u0018\u008e\u001er5{\u0010Aa\u001a\u0006\u009a\u0088\u0094c=\u0081q|&KC|\u0014\u00adlv\\Tm|Lm3\u0086{k^w%p\u0007\u009fp\u0097Fq\u0015\u008eM\u0005\u009f\u001el\u0097\u008e\u001e\u0018d\u008d'*\u0098r\n\u0092\u0098\u008e>CV\u0093z]\u0011e\u0005iDx@so\u008d\u001eG\u0004?W\u0090AThk\nf}\u000b\u0005s\u0088Ran\u0087\u001d],\u008bu;6\u0084\u001d8#\u00890hwQ17)\u0086FMs\r\u0098qt7\u001c\u0089bD\u009a$/s/=4\u0094\u0088,+Hao0\u009c>\u000eg\u008bs3&\u0092!S#K\u0096\u008eR_p\u000f\u009b\u001e'\u009cA\u008f\u0004iz\u0091\u0010\u009a\u0097bYpa\u0091.e\u009cs&1\u008f\tD\u008a\u00915\u00868\u0089\u0001\u0006h<=\u0019HIOy2\u0013@y2I=dF~F\u0090\u001bt\r\u0016`\u0002K\u008d\u009e?@>\u0097.\u009e^k%=\u0010 \ba@m-B],7F\u0087\u0094\u0087+|M\u0092\u0011\u0003\u0010\u008d\u0088MBQ\u000e\u0014O\\\u0016?FPAc\";@WX\t{\u009fj^\u0087\u009b~VAhHA\u0096 \u000f O Ka\u00905)\u008c\u0000\u0099\n@\u008a\u0094\u0080\u0094\b\u0081<\u0094\u0082T\u001a\b\u008d\u0014\u0006Y\u009a#@\u0016\u0089\u0083\u0096\u0004$\u001f\u0006y\"\u0005y\u00862\u0090|\u0018L5\u0095\u0011 i\u0004\u0086\u0017R\u0090\u00950\u0096\u0014*\u0007Y\t\u0083Tf{\u0004H&\u0000\u0096\u0082\u0086A\u001aR\u0090\u009a\u001cd5\f\u0092jZ#@f\u0003\u0090\u0014\u0010\u0006^\n\u0090\u0083\u0014 ?RO#@\u0002\u0090\u009a\u009d\u0001PK\u0007\b\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.\u0000\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.class\u0095W\t{\u0013\u0015=\u0003r$\u008ba\u00136`\u0096Ta\t$e\u00007V,cb\bcil\u000f\u00915h\u00841Im\u0092\u0096[&mhZ`\t]I\u009b{\u007fM\u009ef$\u008d\u0000i{ss^{\u0003v7\u0088E\nb5\u0099ZzJOLkg\\byJ\u001cs\u009e}gt6\u00ad \u0002\nV\u009ch\u0089\u0096\u009bL\f\u008d\u009f\u0082\u0096p\u007f\u0091SG\u0087\u0007N%\u0087\u0087\u0092}#c\n\"\u0003U\u0094m\u0019=\n\u0096\u0098\u0082\u00adQ-[ChT<c\u0014zh\u001bf\u0095UjwWb6\u0004\u0095\u0081x5\u0082`p_r\u00059#\u009fb\u0016#[k>5r#\u001e3\u009f\u001au\u001e\u008el8o\u0099\u00846\u0082\u0082\u000e\b4\u0095M$+\u0004bYU\u0091eT\u001cIL\u0088\u0080jFrDmh\u008bv\u0094\u008beq)xOM\u0018\u0093\n\u0012\u0003wg\u008f\u0094,Z\u009aH\u008d&L\u008ba\u0089b\u001a\u0016\u007fMkVA2V\u001b\u008b;z+\u0087\u008e\u0002=fF\u000fb\u0013\u009a\u000ea\u008b\u0082k\u0095uVa\n>b\u001bbLy\u00913\n6:T\u0097s\u00adA\u00154!\u008cV\u000b\u0093\u001d\n\u0016ZG \u0088bN\u0005|-\u0017\u0016\u008c\u0092\u0003FN\u001f,N\u008f\u00888\u0014\raf\u0019b\u001e\n+Xr%k!r\u007fH\u0093g\u0082\u008cx\u0010Ij\u0010\u009cmL}gz^8\u0084\n]\u009b*\u0098\tZ\u008dnZ\u0016\u0098L;*v\u0086\u001f\t@M;XB7\u0003`\u0094\u001a\u0019+v3'\u0006\u0004\u0089r\u0093T\u0018+\u0080ScE\u0094b1\u00838H\u001d!7\u008e\u000f\u0080\u008dbuDj\u0011!\u0015k\"V\u008fX\u0087)\u0015#8\u009aZ&imo\u008b\u0000\u000ei\u008ex\u0014\u009cy\u0096\u009e,f\u00192\u0090=\"\u0013*\u001eIR^\r\u0005+c!\u009cR~hZyg5|\u0081V\u0090V\u0091\u0001\u0005\u0096P\u008d\u009cM\u0007v\u009fB\u0099<\u0004RaJnUH*\u001e\u008bTLH~ZEO>\u0003B?LFl\u0016jB\u0019\u00153\u001e\u0091Y\u0015<8\u0084\u000f\u001dzb6#)/j\u001e\u009d\u000e\u009c\u0096)\u0098\u0084`\u0093\n\u0087ld2g\u000f\u0090\u001c\u0085\u0094Azf|*,_\u0080\u008f9\u000bW6\u0085 \u009eU\u009clV$\u0004\u001d\u009eW\t\u0096e$&a\\\u0083Ty@*>#\u0090m$)\u0006:-'T|\u001e_\u0005A(=g;\u009f\n-#\u008c~I\u0097\u0085\u0089\u008a\u0089T^O\u001b\u0013F\u009a0\u0082\u008a\u0017E@\rI\u008f\u009c/\u0005h\u009fje\u009b74\u0088WU&5-\u0088Q(P\u0012A|\\2?T\u0001-\u0088\u0006M?/2]t\u0018\u0097=\u008fW\u009cVP\u008fc]\u0090\u008d3*1#e/A\u001bDU@\u0015\u0095jHgM!#\u009cWxQg\u008fSDKLEI@\u0082j\u0082;\u007f\u000fA]R\u0094\u0018\u0013>qK{\u0012\u0098mdMfZ\u0088&\u0092%Y(.`\u008e_\u0006\u000b\u0005\u009bl^kH\u009a\u0098r*+8\u0010<o\"of\u00107ne\u008b]{V \n\"V\u001fF&9-V\b\u0013\u007fI\u0094\u000eF\u008c\u0004v\u008bo\u00158\u0010as\u009aW9;mF\u009f\u008aY\u0086|87\u007f)\u001a4r\u0017\u009d1s\u0003)8\u0003AD\u008d\u009c4.U:Y\u0094\u001c\u000ei\u009b\u0094\u009d\u0002#N\u0014\u008d_N#Z\u0080{\u000br\b!\u009e\u0012\u0097z_~\u0095g\u0084\u0088Hp\u001d\u0011\b%B>yS{\u000ejD\u001b\">-@\u0019[}c\u0012.u\u0084\u0012:\u0015^e\u000fw\u0085wI\u001fb%\u0010s6\u0018\u0093\u0090\u0088\u0017v\u0001\"{\u0002cx\u001a\u0095s]\u008d[&\u0001z\u0090F\u001eb;=n;q\u000bq\u001fv*;\u0093\u008b\u0012\u000e!\u009a\u008ab v\u0015\u0083\u008eH1\u0017d[5\fu\t8.\u0097\u0091%1\u008f\u00950>\u008f\tlsfs93\u0099\u009c59gEyv\u00126\u000e;\u0099\u0089[\u0002%|eF\u0015\u001fxy?\u0096w\u000f\u0002j/\u008f\u0099g\u000eP\u000bqt\u0013\u0091\u001e\u0017'\u000bA\u001f8\u008cWh\u0087\u0093=>\u0082%F\u0017%Z\u008a\\\tj,\u0092+\u0081b\u00ad3\u0010)/\u0087\u0018\u0006(qY\u008c|\u0003l!:\r\u0010O\u0089\u0016I\u0093+\u0018\u009cgyEe\u001e_\u0099kV.B-A\u00ad\u0006\f\u0091n\u008f`\u0013R\u009emq#k Q\u008a\"\u0098\\\u0003\u009bk \u0012\u009aK7r\u0001\u0017HP\t(\u00959xLw(\u008e1g'k1\u000e\u008b\u0004Dho\\1&#m%\u0084\u0007\u009c.~/K\u0092_4\u009e\fC\u0099\u0004QI>*\u008d\u0012R\u0013b\u009e\u0096\u0014s\u001b\u0001>E!\u0087I[0I)5,\tWA+\u0017=\r\u0015\u009fu\u000f\u001eOI3Y\u0006-\u0014iwxcw\u00ad%0\u008f\\kY\"z\u008e\u0090\u009c\u00100R!`\u0004o\u000f_\u0004\u007f\u009f$\t\"3B0\u0013+A\u00114M`\u000f\b`Ma\u001b\u0084\u0087M\u008a\u009b &\u000bCkh\u0086;Q\u0082C$K\u0083\u001d718\u0007uT\u00075Rr\u008adlsa1Uqu(V\u007f\u0097s\u0091y\u0083+\u0011\u0095l\u0092\u001c ?\u001b10\u0016\u0010MT\u009e\u0083u)^q\u0083Q\u007f\u000fPK\u0007\b9\u0091\b\u0000\u0000,\u0013\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000org/apache/maven/wrapper/cli/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.class\u009dUN\u001aA\u0018=#\u008bJ\u0015\u0011mWXZ*\u009a\u0098Pk\"!\u000e\u0014B\u0096EKY\u001fL\u000f\u0087j.E\u0094-?v.|s\f??~\u0001XF\b}\fk\u0015*7\u000e\u0085^Ol^\u00ad\n[7JY967\u009c\u00adJ\u00ad\u0083i\u0089\u00ad\u008au,lG!(\fG\u0098%n\u0015\u008f\u0085#a8!3,w\u0005\u0003c\u0098\u0096l0\u0004\u0089<\u0083U9\u0010*\u0002\u0018\n#\u0084\u0001\u0086\u0011\u0099[/\u0017\u0084\u009d\u0085\u0092`\u0018V\f^s\u0094fPq\u000e\u001aC:{\f\u007foo\u000f\u009b\u001b\u0084\u001d2\bC<\u009epo\u0087R$G:\u0091j)mR\u007f5D1+V-\u0084uFi\u0017ea9\u00ad\f\u0083fNzR~\u00122m}6\u00ad\"\tO\u0090\u0010\u0019\u0016{vM*0\u0082A\u00183\u0098%z\u008bYtW@K'\u0012p>\u008c\u0087x\u0010(\u007f\u009c\n\"\u001eQ'a\u008c)ku=8\u0085E\u008e\u0011?}t]t\u0097n\u0003\u009e^O\u008eaiK7\u00160d\u0089\u0093\u001dp #q\u009fZesi\nC\u0084\u009dxv^S'.\u0095g\u00970i\u001a\u009dCG.\u001c<\u0000\u0006\u009c`U+u\u0010|[\u001e\u008b\u0012\u008bs&\t\u0019>]y\u009f\u0094y:\u0000}A\u008f\bROo/\u00834\u009ev\u000e;\r\u0002\bS\u0006q\u0087\u0097\u0080a\u008cP?z)2F=\u0099\u0082/Bc\u0085f\u0013\u0098Q\u001fb.)\u00ad\u0004\u009f\u0089OAK6p_K.40\u0016\u009b\u0016!e\u0013D\u001bu\u00adMj9z\u00868Q\f<\u0001\u008dH\u009c(^X+k\u00ad\u008b~>\u0092=Z\u0091TmAk \u0095]\r\u001e\u0012\u000bZ0Bm3b\u0087\u008dV\u0014cM#v\u00944\"%\u008dH^b\u009c\u0098*gI\u009cBT\u009aN+&\u0096\u0001R$=\t<b-ObMO5)\u008a|\u0004(i\\/\u008e2\u009bPK\u0007\bdQv\u0002\u0000\u0000T\b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.class\u00adVk[\u001bE\u0014~\u0087l$l\u0010\u0081\u008a\"\u0085Zjn\u0090\u0016\u008dP\u0014\u0081p -j\u0097e\tK\u0093uw\u000f~/\u0083>g\u007f\u0083E=\t\u0081d@,y\u0098\u0099\u009d9\u009e9g\u0000\\\u008f\"\u0018f\f+\u009f\u0092MYRSEyGS\u0096l\u009a\u0095R\nZjzv,Yq\u0096,\u0083\u001cMg\u008cbQ7\u009a\u0018\u000eM\u0096\b\u0081\f5Sgh\u009ft\u0099bEc9\u0006aPC!(\u008fv\u0086\u000b\\~T\\W\u00adGzAe\u0088d\rE.dKIl\u0086\u001b\u0094f\u0087B\u008b\u0019:CW4\u0096\u0096wTAe<\u0089zDgUG\n\u0006C_\u00935[b\u009bZd\u0011\u0081\u007fC?\u0006tIlB\u0019\u0089f\b7b\n\u0081\u0084G\u0012|.\u00130r]$\u0012\u009d\u0092Q\u0085<\u0017}uB+NH\u00870\u0088E\\>\u0003\u009c\u008a\u0084+\u0018b\u0090d{\u0097\u008a\u008fF[@\u0081\u0084N\u009aA$\u0091`8OvNh6\u0006\u0092L\u0099\fzgQm\u0019vd]<\u008c\u0092\u0015RI\u0012e-\u008e\u001by\u001a'\u009c3Si\u0011dHlo\u0091v\bc\b2\u0088J%\u009d\u0018\u0096N\u0088l\u00971\u001e\u0006^=Eu\"&N\u0080\u008e\u0099>\f\u009a\u009a>\t\u0094j!\u0087\"NJ\u0014\u000fH\u009e\u001f1<8{zL2c\u008a\u0098a\u0018oE_\u001cQ\u008d\u0098\u0093\u000b%\u00956R\u0017xYv\u001d\u008f\u0007\"2\u0094\u008a+\u0012>E\u0096!,;\u0006RO\u009dv:O\u0016\u0016$b\u0091{W%|\u0086\u0087T,tui\u0017UI\u0007\u0088\u0081\r\u000b9\t+\u0082BY7M\u0086f\u0004\u0098\u0001\u001dXW\"d8Ww\u0012S*of\u0089\u001d\u009di\u0002\u008bY\u0097\u0080J.:F\u009bs/d2M\u0012\u0017y\u000e\u0099\u0004\u0093&a\u001b\u0088 ]{\u000bK\b\u0013\u0017r'^>4k\u0095W\u008d<S\u0000\u00983-\u001c\u008c4+> \u000b\u008cb\u009b\u0087UFKI\u0090k1O<$\u0086=\t7q\u008b\u008f\u0095\u00905rQ\u0014\u009e\u0011'N\u0004\u0019\u0019=g\u009aY\u0098l5Sia\u0090\u008247\u0018\"}0\u0087?\u0012\u0081_h\u0086\u0010d\u000f\u0085? U\u0004?\u0007\b\u0002\u007f\u0082}w\u009ed\"xj$i\u0084wt\u00ade,\n\\;2\u0006\u0093y\u008c\u0011\b\".\u000f\u0003\u0018\"\u0011\fTU\u0010$\u0086{\u0088v\bi\u000bP\u001auQ\u008c\u0088#\u000f\u0086\u0097s\u0003+\u0005\u0019?f6\u008d\u0005S\u0098v-:\u000eXKpFeL\u00961}\u0080O\u0018&\u0084\u0017\u0098\u0015\u000e0\u001a]\u000b\u0011M\u007f9\u0001\u009e\u0002a_\fy/<-C\u00ad,p-\u0086\u009f~\u0095(}.\u0084\n\u0088\u0012\u0018qb\u009c lILh\u0089f\u001e\u0013c`\u009cP\u0011\u009awP@e\u0006\u001d\u0006\u001f I\u0013\u0090(,s\u0012}\u0087\u008fsq\u000f\u0013X+c\u008fE\u0006\u0084g\u0014\u001eVc`\u0016Xe\n\u007fW\u001d?PK\u0007\bj F\u0004\u0000\u0000\f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.class\u009d\u0090AO0\u0014Et \nF\u0012\u008d\u0004\u008c\u008bG\u0083!1D\u0013\u0093\u0083\u0010e4f\u0096n\u0003\u0096'\u0012\u000f~\u0000?\u0094\u001d\u0004\u008d\u0012\u000f_?^\u0000\\D\u008e*\u0094\u009eM#N\u0098\u001d)\u0013L(bv}n bpn\u0097\u0006L$.\u008b\u0012\u001e\n\u0013y\u0082\u0013\u009dR\u001fS\u0091\u0080\u00ad\t\u008ck.x%\u009e9_~\":!A\u0017\u008e\u0099\u0085\rl\u0015Q\u0080AP\u009d\u001e`\u0080\u008e|FPqB\u0097C*\u0097|21A\u000e\u0081\u00198^\u0097;\u0082\u001a*\u0083\u0089\fg\u008d\u001aDOP\u0013\u0094\t\n.Mc\u0012X0\u0095.z\u008e_\u0016/4\u0000\r\u0010E+\"Ij7UUyN\u009dF=KvoGJY\u008aj\u000b\u0015\u008a(\u0006vQR\f*/Y\u0083as\u0084\u001dG'\u0019t![%LG8,VOPK\u0007\bm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.class\u0095R]O0\u0014\u009d\u0004;\u0003\u0095\u0010\u0013e\u0084&&K4\u0081^u\u0096lR\u000fG\u0019K1H\u0087g\u009cs\u000e\u0000u8\"P\u008fe@Yg\u0011P\u0017\u0092\u0004%CN;q\u001411N,2\u0094)J\u001b\n\u0004#\u00961\u001a2\u0011\u0087\b\u0094\u0080 Py?ja\u0083\u0010]\u0012\u0098<\u0016c\u001b\u0004\u0096$B\u0091\t\u0094<\u0010,\u009dH$pjZuSE]S>\u009aF\u008e\u008dC\u009c\u0016SZ3\u009b\u009a\u008fL\u008eq0Ybu\u001a-_/U\\L<\u0092\u0013\u000f5Y \u008cu*Lx\"}81eljY\u0005k.o/\u0097J\u0004\b+\u0017\u0004\u0016TPu\u009d\u0005\u001b\u001a4 [\u001a6 ;\u001a\u001a\u0090]\u0085\u001f\u001b9\u0002PK\u0007\b=8\u009f\u0094L\u0001\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.class\u009dU[W\u0013W\u0014\u000e\u0017'\u0084ITXXDC\"V@\u0095\u0012\u0016\u0004A\u000ei\u0018LfKK\u0087Y_|h\n.Z]}kgod\u009djW\u0099s9_\u007f\u0003p\u0006hh\u0011\u0018\u009dL\u001bM\u0099\u0019\u008f\u0095x\u0018t\u0012\u0099\u0098s9J'MK]4\tto\u0019\u008f\u008dD2\u0089\u008d-\u0099r\u00054.\bt%kf\u0013\u000b\u001d\u0013X03\u0096\u0016\u001d)0X;\u009e@-\u008eieC7\u009cL1'-wY\u009eN&F@\u0093\u0003k1\u0099\u0096\u0085\u0094cz\bD\u001a\u0005\u0082\u0085F\u008b\u0016i\u0099wdP\u0086c\u0084\u0016\u0095*npMMq2\u0002*iW:FV\u008e\r/\t\u009b4&\f\u0015:\"\u0013h\u008d\u000e/i8D\u00956\n\u009bQ\u0010\u0080\u0007:\u0003GqL\u0080@\u0002d\u009bi\u001d\u001f\"H\u0095;7\u0095q\u001d\u001d\bv\u0004\u001aN\u0092jc~:\u0086\u0011\u0013\b\u0098j\u008e@OtCX'NaT.J\u008e\u0004N3%\u009fR\t\u0007v\u00111l\u008dlJy\\pA T\n\u001d\u0097p\u009951h#J\u008a\u008e1\u008cS{\u009bFa\u008b**\u0005Rs\u0086t\u0016\u0015K\u0003;ed\u0097\fTs\u007f4w;\u0001u+\u008b\u0080*}\u0086\u0086\u0090Y#`Fgj\u007fMWJj~m\u000fNV\u007f\u009c\u0004\u009dU\u0010\u0005\r]y\u0091\u0093f\u0081!PujUTyGG\u0018!\u008a!g\u000b\u008bvT\u007fd\u0095\u0001Ljr\u001fh\u00ad\u000fqhf\tn\u0094\u00ad\u0011R:\u001e`\u008d}U\u0014H\u0004\u0000~\u0004f@\u008a`YieMOjC(_\n\u001c\u008eN\u008d\u0015\u0000=w/+\u0099\u001e\u0018\u0019\b`\u008b\u009a\n\u0093\u008d\u0001P{:\u001c\u000fk\u00970\u0099\u0083#\u000b,g@Fcj.SVz6k?hAPyq\u0096\u0088f>+6\u0083\u0095|y\u008ef4l\u0017\u0093\u0092Lu@z\u001a\u001a:21\u0092l>\u0096\u000398kA\u0080\u000f/\u0093\u000f}\u0087\u001fY!\u008e!F\u001e%\u008f\u00038\u00058^\u008bBO\rW^m\u001c\u008e\u008c#\u0018\u008c\u0090\u000b\u008dF\\w\u009c\u0099\u008d\u0082^\\\u000b\u0096\u0091w\u0013!Z1\u0011\u000f~\u0090L\u001f=8\u008e\u0018\u0086p\u0081U\u009c\u0003\fx\u00941}:\u008b\u0091\r&\u0082I\\)MK&n\u0095\u0093K>\u00ad\u0003*\u001f\u008d\tVj1\u0085*\u0081\u0004nc\u009ao|\u0091j/\u0010\u008b\u009c!X?\u0011\u0018%N\n#P\u0019L3\u008cs8\u0014c\u0016s>F5\u0089z\u0012\u0097\u009b\u0092\f\u009fh\u00ad\u0002i6\u001b\u008fi\u0083)\u0099\u0095KaS\u0084b9\u0093?}0\u0006w)\u0083$3\u0016z\\\u008d;X]\u0016\u000e\u001e~\u008f`{`\u0007x$\u0094\u00111}G6\u0099z\u0085\u0082\u0005\u001f`>v({}\u0082]\u001ea\u0013\u0098\nf\u009e#y\u0006\u000fIBM\u0002X\u0083\u0083\u0082Gm^{\ruZf\u009dQ'S\u0091,\u0081]\u001e&A\u009e\u0093ho{u\u000fZ\u0017.q\u0019\u0092\u008f\u0012R(\u0091\u0099\u001f\u009a\u0082<\u0002\t\u0095A\u009e4+M^r\u000f^]>\u009a/\u0019im<j\u00003\tU\u0095\u008fViS1\u008bj*g\u009e\u0002PK\u0007\b6WK\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classV[O\u0013Q\u0010-,,UxU.-]\u008aH-I\u0095\u0084\u0096v.K\u000f>bA%1\u0099\u008cs\u0002\u0016a\u0011\u0013\u001f9g|3sf\u0000\fbFA\u0080\u0090p\u0094.X3\u008c4m}\u0015F\u0013N&#96_\n7g\u001bt',7%7V\u008ab\u0005!OC\u008bYr\u0096p\u008b\u009c'<\u0093P\u00adY\u0000a`\u009f\u0018\u000e[\u008d\u0010\u008cn\u007f>\u009f?Z\u0015Y\"\u0084\u0012Y\u000bB\u009d\u0086*T\b^\u0083\u0082\u001aB<\u0091Y1Wb%Z\u001cC\u0097\u0084k}\u0091\u0019\u0092`9v>\u00ad\u0098\u0005_g\u001c\u009e<1\u0080\u0098\b\u008eipBr\bksbSiaZv*V~|Ic*qIA\u0007\u009f-\r\u0097q\u0085P#\f\u0083\u0084\u0014 mxVZ\u009f\u0017X\u001d\u0086\u0082\u001c\u008f#\u0002\r7q\u008b\u0010L\u0099\u001e44\u008b+\u001b*e)\u0003S!0\n\u0012&}v\u0082\u000b*\u0091\u0019!UJr\u009b|=\u000e\u001dC\u0005lEk\n\t3\u0015s!\u0086*0 Cuzs\u007f\u0096TDq_~\u0001Q\u009c\u009b\t\u001f?rA.\u0090oAd.\u001c\u008f\u001b&\u009b\u008d\u0019_\u0010u.sFV\u001dF\u0082\u009at6\\\u009c(k+\u0097!#hm\u0089L\u009eu\u0017+d)`A\u0087\u0082\u0082\u0004ao\u000e\u0002O+\u00ads\u0005\u0093\u0084\"O#\u008eZ\u0019\u000f\u00176~\u009aQS\u0093|N*\u0088\u0080|N0\u0096wS\u0097r-\u0012\u00045\u0012\u0081\u0081\u00014\u007f\u0083\u0094Q\u0002U4\u0086:\u001aG#X\u0084f 1<\u0002Z\u008bV\u0010x#h\u0082\u0001|\u0085\u001fhEx9\u0092\b{{\u0017eyn\u0017}^f}{\u0007H\u00834\u008df\u009aA+\"Lyw\"\u0085\u000f\u001d\u0013C<b71\u0002\u001f\u0013<E\t\f|b\u0017C\u0093\u009aJ\u001es\u0010sTf\u008dy\u008e\r\u009fa\u0084\u0010\u009b ~W<gN\u0094( x(\u0080\u0017LB]c\u001c*&\u0098N\u0085\u0084l4_PK\u0007\bk-\u0003\u0000\u0000%\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.class\u0095mO\u0013A\u0010s-\u00ad\\\u000b\u0005\u0015\u0004\u001f\u0011\u0011i+\u001c\u0088B|&JL*\u0092\u0000M\u008dY\u009c{\u0000N\u0090D%\u000f\u00872\u009d\u00024\u0097vfvv\u0000p/\t\u0083\u0015KEiKZ5#\u0095\u008az]Vj[\u008bN\u00ad&T`+\"\u0086t'\u009e\u008ej$\u0011'<\u0088\b\b\u009aUOx\u0092\u0090*\u001d\u0013f\u000b'|r\u000bq\u0081\u0090xh+{L\u0098\u009f\u008aj\u009c-\u0012\u008bNY\u009a\u0088!\u0095F\u0012i\u0093S0'^\u0010A\u0082\u0090ZM\u0089*\u0007x\u0094D(\\[\u008fCa\u001b\u0084GQ\u0017n\t@M|\u0094\u0087\u0005BT\u0083\u0011VU\u008a,d7\b1V3m\u0093\u0084>G\u001dAlu@t\u0080F=.\u0089\u008b\u0084\u0088\u0098uQ9\u008dfb\u0014\u0097\u008e^!\u001ct\u008a btS\u0013Qm\u008f\u008b\u0084\u0013KQ\u008eK+\u009d6\u001bM\u008cc\"\u0089\u001b\u0084\u0099hJ&&\u008cD\u0093\u008anc*\u0091G>]\u009d\u0092l\u0099\u0095q\u0086`:nI)\u001cn3\u009d\u001e\u0013\u0094\u0092bU4\u001a\u0092o\u0099RaKs\u008eB\u0018 K\u001d\u0019\u008d\u001cWJ\u0018,\u0011K@_U\u0081\u0093\u0092^\u001e-6\u0095}\u0098w@\u0086\u0094C0\u0088\u0001\u0096\r\u0007\u0018d \u009e\u0012\u007fp>\u0084Vk\u0019/M\u0096\u0001m0\u008c&\u00104\u0002FBk\u008eg~am>\r}K_\u0003\u0081c\u0081j\u0013\u0098\t\u0081w_\u008ep\u0085F?\u000fc655\u0003s\u0087TSP\u0099\u008bFj6f@$n\u0085I'r}L\u009a\t\u0002<ns;\u008e8Ob,wu\u009a|\\i\u000b/PK\u0007\b\u001b\u001b['\u0093\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classVS\u0013g\u0010mrpx9%BE\u001b-\n$\u0084#\u008a/\u0010b\u0004k\u008d@\u001b\u008de\u008ei8\u009b1\u0097\u008b_\u009fov\u001dl\u0099Vu/\u008f:'9$\u0098S93\u0090=v{v\u009f\u009f\u0000rVE\u008cp*\u0086aZ\u0099\u000f\u0085clz\u0086\fj\u001b\u0005V3\u009d\u0088e\u000bo\u009a\u0082Rc5\u0090P\b\u0011=-mm\u009a^)/\b]\u001f\u009e$L\u0016yeY\u00825\u001aM6\nA)k\u0010\b\t\u001d]\u0010a\u001d*z\bRiQ[\u0015\u001dsy\u0015]\u0098\u009e-\u0001S\u0091\u0012\u0016\"F\u001b^\u0006\u0006 a\u0016\b\u0087]\u0087\u00ad\u0010G\u008b\u000f\u0087Q5\u009d\u008aQ=;9cQoo{^{\u0084\u0081\u00820\u0080A\u0089\u0084}E}wR^0\u0084\u0013*\u008e\u0013&9!R\u0084\u001eD>\u009c#EnV:\r\u001a\u008d|\u00020#\u001e\u0081\u008e8C\u0088W\u0084O8\u000e\u0003a;\u008eY*F#BE\u0082\u0091\u0091nbg\t'vO\u0004FuwM9\u000fh\u008fs\u0084ga\u0011[\u0089=\u001eeq\u00178O\u00989\t\u009f\u0012Mg=H8\u0019O\u0005G)\u0090\u001a9]\u001f\u0099P1MH)\u001a\u001eQ\u000bN\u001d\u0098/dj&t\b_\u008d\u0081\u0096\u0086)]#\u0087x\u0091\u0010\\\u008f>~n\u0085\u0002\u0080\u0005\u001bD<C^sepp\u009b33nz\u00159\f;\u0006CGw\u0080!\\y#\\\tG\u00ad\u0017\u008b\\\u0004p\u0013~w\u008a\u0005c\u0080\u0095\u0086g\\n\u001a\u0003\u001d\u0013\u0004\fM\u0011^j\u0082W\u0091Pl\u001f^S\u0016\u0084/r*$\\}\u0080\u008b\u0017\u000b+\u009b\u009b\u0097=c/l\u0091bX;S2)=~\u008a#&=\u001f'|\u0096r=\u009d\u0015Z:3\u0005g>p\u0084\u008fH\u0019\u0019I$(\u0087^\r\u008c\u0091Q\u0083\u008ay\u0084w\u001fx\u009bw1\u0015\u0018(gi\u000b\u0016@{\u008c\u000f\u007f\u0018\u009ebdF\u0019TB\u001e\u0011}\u00963|4\u009f{\u008dr\u0005\u000f\\*\u0098'(\u0094EvP\u009c\u007f<\u0013\u009c\u0018<\u0087z\u0081W\u009c\u008b8E\u0097xO#Oy,l3V`\u0017\fM\u000e[>}O1$p\u000fP\u008f6\u0016$\u009e\u0097\u0082FX0U\u009bh--0ZM\u008e}\u001c%3\u0082x\u009c\u0002LLW\u0094\u0018`ZV68/p\u009f\u008a\u009cC\u0006PK\u0007\b\u0014\u0003\u0000\u0000\u0000\r\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000T\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.class\u00adS[O\u0013A\u0014ftl\u0080\u008aVPQz\u0083\u0015_K\u009a\u0098&&M\u001a$)P\u00862d;no?\u0017L|0>\u009f\u009c@\u0018c999?~}\u0006`\u000f;\u000e,\u0086\u0083@\u000f=>\u00833\u008dT(\u0097^;\u0018\u008d:J%\u000e\u000e\u0085jPtT(T(#9\u0015HK51<\n\u0083\fC\u009cOs5>\u001c\u009f\u008bA \u0012{'\u0091x\u0086T2j1\u0095j\u009f!\u000eND\u000e6\u0096\\8l\u008a\u001fLFB\u001fc_0\u0014\u0080}Sg&:\u0093!an4\u0019\u009cAlQ\u008dJ\u008aY\u0012\u009cT;9\u0094`$\u0092[\u0017kxPJ1\u008f\u0082P\u0005Z\u0098.\u0018VoO\u001eX7y\u008b\u0097yW0\u008ed@.hN)\u0003`\u0090915\u0019^(\u0001Cr3\u00ad\r\u0012C\u0017L@\u0097f\u0083ks@3\"\u0093C\u0089YG\u001d\u0084n<\fE\u007f\u00186\u000eo\u0088\u009bMg\u0081\f,\u008aZ$#H. \u0099\u0014\u000b.}~\"O\u009b\u0004>\u0096I2\u00814\u00943$\u008b\u0005\u008a\u00ad',\u0094gF\u007f4D*\u009a\b\u001bY\u000bZv\u008cZK2ST=R\u0011e,3l.\u009a\u009bi\u001d\"b\u0093Qjc\u000f\u0011\u0097i+\u0092Vuv@v,+\u0092\u0083\u0081?PK\u0007\bG*\u0002\u0000\u0000\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classXw\u0014U\u0016C5\u0003c#\u0080K\u0001\u0092\u0088b0C\u0004h\b`\u0098d\u00823hL\n;UmUu\u0002\u008e,*nq!8c`L\u0087\u0018q\u008e\u009e\u0007?\u001f@ts\u0013?z8tw\u0097\u007fz\u0003\u0000k\u00822\u0081\u00ad\u0096\u0017Z_\u008f\u000fh\u0083\u0019\u001ftZ\u0089\u0094\u0011l\r\fhf0\u009d\u009av\u008d5dH\u0086e#\u009d\nB\u0002\u009bJ\u0084*@\u0011\u0090\u00967\u0086'pM\u009c \u0002\u000b|8\u00815\u001aG\u008b\u0012S\u0083g\u0004'\u0010@\u0085T#16\fj\u008c\bT\u0006x5Rvqinagjn&157\u0094f\u0003BZ\u00187\u009c\u009a5P{7\u001a\b!kK</G\u0096R}5\u001f\u0007u\t\u00846[I}!\u0004\u00958\u001b\bQ-\u0014)Je0+H\u0084\u0082\u0005\u0096N\u0003\bVB\u0016u\u0091@ym]\u0017+qb,\u0012\u0015X\u00ad\u0095\u0012\nZ-\u0010\u0011nI,\u0082\u00148\u008b\u0085wd\u0006zu{\u009bP\u008a[\t-\u0006\u0083\u0010\u0007\u008eR)^0(\u009a\"\u0096je\u0006t\u0015Y[\u0018uK\u0084,\\+q\u0019.\u0017Xk\u00944j\u008f\u0082+\u00046Z\t['t\u00960\u0014<X\u0098%_l+\u009dj\u001d\\nUT\u0000I\u0006)cw\u0013f\\`\u008c)\u009f\u0007\u0089\u0016\u0081\u00926\u001eH\rE}6 W*\u0082uhhV`Y1X\u008d-\u0012[q\u001d\tLf\u009f\u0016TZMU\u001fH\u0007C\u009amkHI\u00954T\u0013ai\u0011n@\u0082\u001b\u001d3\u000b\u0095vt\u0090\u0014-\u0099\u009cV\u0092=\u009d\u0012p\u0093\u00176z:smm\u009dW\u0090\b\u0084|PD\u000b\t!]\biw)\u0006\"F\u008f\u0082?\t4\u0095V\u0093$p$F)\u0012[S)k(\u001f\u008c\u000eg\u0089b8[\u0099_\u0005\bl)\u0086\u0090<\u0082L\u008c`/4vy#A-*\u0015R\u0014ha\u0090wXs\u0089\bnC\u0002\u001f4T\u00910\u008f\u0003 \u0091\u001df\u00ad9\u0093/WE\u0012.\u0005S\u0099H\u0092\u0090\u009drbGp\u00859X$aK=\u0018\u0090,\u0005j\u00048Dm\t\u0087B1\u000eRTe0`P`\\\u0000%\u0000YG\u0015\\nu7\u009ckwJ\u0089<\u009f73)O\u0018P\u001d\rQ\u0087t[/6'WO\u0001a\u00ad\u0096-P5C`\u009cx\u0010\u000f+x\u0088.\u009c\u0095\u001bN4\u0099T0\u0004\u00ad+g?%\u001e2\u0088<\u009c3\u0085q\u001f\u00938U\u0082~\u009a$<!$\u009eH$l\u009eXn6[L!\u001b\n\u009e)RA-\u001c\u009e\u009f\u000be[@\u001f\u008a$en\u009b9mV0BW\u009a^\u009b1RI\u000e\b_W#8\u008cVyY\u0015J\u0007\u0011\u008b2^4\u0016;\u001c\nL\u000f\u0000\u009bx]\u009c\u009f\rGM\u0006Q44zR\u0002\u0098\u0085{l\u007fK.\t\u0096?\u0019\u007f_\u0005oi3M\u0097\u001f;[IPd\u008eJ\u001cg\u0084Lo\u0010\u009a\u0011\u001fc\n\u0015z\u009aD\u0016q\n-\\\u0090i/\u0017ss\u0004\u009e#Bt\u0004\u0098\u0099x\u009a\u001b1\u0004\u001ctZ\u0019;_g\u0000\u0089\u008cf\u009a99\u000eWT:\u008a\u009e\u0002g\u0017{\u0083O'\u009eh$T\u001c\u0002DiA\u00ad(?,/=+/=*/=BhY.Cee%\u008c\u009del ,\u0084(\r1T8\u008bMbE8.\u0018\u0083\u001ak\u0018%1CcX\u0015\u0018Cq\u000f1F\u0017\u0092l\u0088\u0011DX&^\u0011z\b\u0088\u0095%\u008b\u0097QOk\u0091\u009e\u0084O\u001a\u0001U-k!W\u0090vM\u0088uT\u001d,\u008c`$D\u0087N\u009e$\u001e\u000f\u009c\u009bV8Mm~\u0002me&\u001dy+\u00963\u0003u((i\u0006V\u0089ch\u0011oMYPK[\u0081N&\u0004\u0088\u009b\u0002\u001dI{A\u0095$&\u008bfy\u0013YPZ<\u0089=L\u00ad3E/a;\u0012P\tO\u009c\u0081\u0002q\u0082_P\u0081\u0090<@8\u0010v\u001eg\u0001\u008f\u0013p~\u009c\u0092b/\u0011$D\u001ei\u001a%\u008a\u008a'Roo!@\u0084^\u009c\u0007s\u001e\u0007&p@1D\u001b'\u0080Gh^\u0090??0\u008f\u007f\u00818NI\u001c\u00890\u008e\u0017\u0019*\u008b\u0097eq4XE\u00ad,\u008ee\u0096\u007f\u000bDU\u001b81)SR@\u008f\u0014\u0005G\u008f\t\u0086g8$>=\"3+|'\u001b xUP1\u0005'0\u008e\u0093!\n\t\n\u0088JPb\u0017\u0081|7b\r\u008d\u008aqL\u001e\u009f\u0011\u000f\u007f\u0000\u001f7%0\u0091SF\u0087a|\f\u008b0>\t{\u0018\u009f\u0082\u008fa|\u0016\u008a\u0002PK\u0007\bF{)6N\u0007\u0000\u0000M\u0014\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.class\u00ad\u0095[O\u0013A\u0014\u0096\u0096.[.\n(\u008a\n\u000b5\u0001E\u0011\u0018+\u0090`jL\u009afv\u0081\u0098~\u0015\u001f$QH|\u0003\u008cgv\u0097Z/MI\u009d9\u0093s~si\u001b\u001c\u001ef\u0090`x\u001b-,\u0097\ni)h\be\u001cZ\\\u0097\u00ad-\u0006WP\u0093ole}\u0011\u009e\\R\u0080\u0007\"\u0083\u0014|\u0087h\t\u0019^\bdx^\u0010\u0013)i\u0081-\u0010-`\u0091a%=PaH-{[@\u0012}&20\u0019\u009ev\f>\u008e\u0082D\u000f\f\u0003km\u00ad\n\u0096W\u001dWN\u0085+[a*}\u0086N/n[1J?V\u0005Y*X\u008f\u0093?\u0092/\u007fr[\u009b\u0081\u0085{\u0083\u008e\u009a\u0080a\u0086^?rNrUROE0<y\u008c\u0086ke`\u001c2[\u0096\u0089\t\\g0<I\rG.]w$n\u009a\u0018e\u0086>Oy(A\u001b\u0012Ue\"\u008f\u0015;\u0090\u0001U=|\u009f\u0015E\u0085\u0016z\u0006r6\u00adY\u008e\u00ad'\u00ad\u0097oz;&Vm=\u0003\u0018:o\f+)\u0085Zv\u000b?\u0083\f\u009dio\u0086a{RZ,\u0013!0\u0081]\u001a\t-\u009eNd$+Ak_\u0091\u001d(\u0096~\"Of\u0002\u0003A\u000fsa0\u0089A:\u001b\u008d1D@\u0084;\u008de9\u008f\u0018:\u001fC\u0001F5y\u000fLpMN\u001a\u0017q)P\u000b\u009ct\u0016\u009f+@\u0000WJ3\u0007\u0004n/MD\u008eM\\.]\u000f\u0012\u009fT\f~\u0012\u000bj0i\u009c>\t1\u0084f\u009b\u001a\u000b(G\u001dH3t8L\u008d%\u0099\u0091c\u0084\u0083\fJ1d\u009a<\u0093Q\u000e1\u007fB\u008c\u0013F'lp\u00871\u008aagy\u000fzp?\u0087x\u000e\u000fR?PK\u0007\b\n\u0081\u009a\u0002\u0000\u0000I\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classU]O\u0013A\u0014=\u0016\u0096\u0095\u0016\u0004/@BKeIQC\u001a0&\r\u00924\u0081v,Kfv\u000bS\u0005\u0083&F\u0012\u007f\u0080?x,I;\u009es\u009cw\u0097\u0000\u0096 \u0086\u0010\u0086#\u0006opsO\u0018u~ lPFCHYF])X\u00152Y\u008e~S'b\u00880\u00063\f\u0099?\fK\u0085r\u0090\u0095\u000e\u001cCR_lW\u001d\nf\u0096\u0090\u009c\u000f\n\u000eZh\u0010;\u00151\b\u0086:b\u0018\u0010F\\ \u0012\f\u008f\u0082\u0016\"\u0091+Q\u001dg\u0010e\u0088\u00adf,3^\u0091\u0005\u0012\u0097\u0096\u0088\u0012\u008eq;\u0081L Kz'1\f\u0085}~\u008d\u001aF\u0093\u0096]v5*\u008eK\u0098d\u00180\u0097UUk\u0017\u0082\u001c4p\u0017*0\u0018Zu$q\u009d\u0093W*\u001b/<K\u00148vI\u001cR1U\u008e4\u0016H*n\u009amJ~Mp\u0093!\u001fP\u009e\u0090\u009b\u0096tb5d`B\tz*&c2\u0084\\\u008d\u009e[\u0019\u001a}N\u008fNgn\u001dZiJSlZjt'\u0000\u008b\u0018'-d]Wl\u008f\u0012\u0083:\u0089\u00adDuX\u0091\u0019\u001a0\u0081\u00840\u009e\u0019 \u0091P\u008f\u0018\u0084\u0011!YP\u000f\u0091U\b\u0015\u0097H/\u001cAOO\u0018Ng\u008e0\u0085=Gi\f\u0001\u0013#\f\u000b\u00ad/\u0095#D\u009c13\u0092\u00ad\u0085\u008f\u0017%?X\u0083'\u00892\u0090\u009fa\n>>ql\u0003F\u0088j\u0086V3n12;R\u001e|5X\u0095w\u009c\u009ab`)\ftGl;o\u001b\u009d\u0016.:KJe\u0015O;T\u009bC.4\u009bZD\u0001PK\u0007\b=\u0086\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000E\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classT[O\u0013Q\u0010-\u0094r- \u0005\u0015j[.]\u008a\u0088J\u0091\u008bU\u0093\u009a\u0006LjHPN\u0092v\u0087\u000b\u0018I\f\u001f\u0018l7 -\n\u00873gvfw9_\u007f}\u0002 \u008dg\u001a\u0002\u0084\u0015.*\u008a;R\u0088=imQ\u00adJ[/\u0096\r=kU*\u001b|-lG\u0013\u001bULW\u0085-\\\u0010\"\u008a=\u0097\u0085Y7veN\u00185(\u0084%4eB0\u0091$\u0084\f#\u0088\b4\\#k\u0095-i\u0011[eI[EQ\u00141\u0018\u000ea-\u009f\rd\bZqby2\u00ad'saD1a\u0080\u0090j-6\u0082!\\'\u0084K\u00ad\u001bD2\u007f\nsA\u0019\r#\u0084\u0017W\u0002\u0086Y:\u0085&\u008caPr\u00933g&\u0019m0F\u0018\u0093!2\u0013Gu\u0015]czT\f\u0093\u009a\u009f\u0094\u009fG\u008c\u000f\u001fLd<&\u0010^\u0090\u0086\u0084\u0016;\nGLG\u009a\u008e\u001a{\u0019\u0018\u0012\n$2\\\u0017$p\u008ba*\u0082^L\u0013\u0089|cK\u0099fK2{H\u0013f[I\u001c\u008f\u001bFZ\u008db!\u007fs\r57[\u0000\u0010\u001e>\bH\u0006`\b\u009d<\u0018\u0005f\u0017KC=\u000fCM\u0091)U\n`\u0094L[\rZj\u0015eF%\u00923Migqa\u0085y\u0017L\u0018\u0080\u0014LF8\u0007\u000f\u008cR\u0090W\u001b!\u0004c\u000e,\u0089e!\u001fY\t veob=Rw@7zX\u0092<?\u0003'S)\u0017\u000e\u007f\u0084t\u0088Ou\u008c&b\b1\u008f\u008c\u0084\u000e0\u007frZ7\u0017\u0007\u008e(@\u009c~z3*m\u0006)\u0092\u0005.:\u0091Q\u008csci\u008e\u008d\u001ck5\u0081_\f\u009a\u009c:Ft\u009a\u0001p\u001c\u0087X\u0006|T\u001e\u009d\u008f\u008a\u001dcO{\u0082EOfr\u00941<\nkr\u009505\u008c\u0006PK\u0007\bK\u0002\u0096\u0017\u0002\u0000\u0000\u0081\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000F\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classRMo@\u0010}I\u00864M|\u001e@Jz\u0095V\u0015\u0010\u0081@\u008aJA9p#w+{m\u00ad7\u0085?\u000f\t\u0089\u0003?\u0080\u001fU1F*\u0088^JV}Fow\u009e\u008f\u009f\u0000^b\u0085\u0080iJ\u0095\u009cr\u009cs6\u0017\u0092m\u009cd:\u001e\u0016yH\u001b>Vbt0Wd\u0094\u0016BBL\u009d8S&\u008d\u008fg\u009c8Bs_\u001b\u000e\b\u008d`B\b\u0087\tGh`\u008d%4\tk^p\u0096O~R\u008c\tQ\u0091l|\u009e\f\boG\u008bs\u008f)\u008c\u0084\u001dW\u0084\u0083\u007f+F\u0085\u0011YF:>\u008fm\u0018;M~'eAUo\u0088\u0099\u009fgf\u0099\u0013\u0087\u0017f0\u0089@X\u0011q1\t\u007f\u0006\t\u008f\u001dfj1av_ 0H\b.\u001f,\u0096\u0086\u001a\u0089\u008f\u009c\u0096X\u0090\u0004\u0097vcB\u0082\u0000Q]$I\u0086U\u0089W\u0005\u0082w\u0083\u001aX\u0087\u008d\u001a|W\u009b\u008b\u0010\f\u009b7\u008b\u0007_\u009f\u000fP'\u0011\u0011\u009e\u0084\u0011\u009e\nn\u0085oPK\u0007\b\n\u0095\u0094\u0001\u0000\u0000\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classS]O\u0013Q\u0010=SZk\u0005\n\u0089\n.+~G\u00071&&\u00044\u0098\u001a|)K\u0082\u000b|\u0095DJ\u0089?dDnW\u0004\u008a\u0089\u0086\u0087\u009d{f\u0099o{\u009f\u0002\u0098CMC\u008aP\u0083%^\u0097VKlIz\u001b\u0088v[\u0006\u0096:\u0082j\tx\bB\u0019L.#V\u009a\u001a\u0084\u0086\u0012\u0096+!\u0088'\u0082&\u008d\u0011\u0098\u0003sG\u0084Ro\\/R\u0013\u000b~C\u0083a \u008b\\T\u000f\u00800h \u0083~e\u009d1\u009f\u0011xi&\u0083\u0097b\u0095J\u008do\u000b.\u0002G\u00130\u001d\u00ad;!\t\u0086M\u009a2z\u0084mW[\u0012-;\\*\u00908!U8\u0087\u000b\u001a\u001f\u001a]7E\\\"a$\u0082(|D\u0084\u0091cS~\u00ad2a6dc\u0002W\u008c&B\u0088k\u0006Q\u0097P\u009dz\rB\u001e(QS)L\u00033\u0018%d#B n\u0091`\u0019(*_\u009fD/!P\u001d\u000f\u0018a2\f'\b/J'{\u0006+f`\u008eZbO\u0086\u0010\u008cg\u009e'\u0083\u0005W\u0084\f5#TO\t8\u0085\u0087\u0014\nj*Uo\u00861n\u009c:V\u0006]\u009c2gv\u00903gw\u0090N\u008a\u0096\u0007\u009f{L\u0089\u001c\u0001C\u008cLti\u0018\b\u0010[\f\u0096*\u0094b\u009b\u001f4)\u0086\u0095o\u0084\\a\u00831\u0005\u0013\u0085]\\a0T\u0007\u000f(!\u009a\u0002\n\u008cnD\u0001JYU\u008cA(9{\u0080\u009c\u0092\u0089\\O,U\u00993bn0\u009d'1\u0014#gq\u0013\u0012~E\u0016}\"v|\u000e\u007f\u0098t\u0017\u0002PK\u0007\b\u0016\u0018v\u0002\u0000\u0000f\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.class\u00adTMO\u0013A\u0018~feeY(\"ZPAh)v\u0005\u008c\u0097\u0012\u0012i\u0086DoC\u0099K\u0016\u007f\u000b\u009cy\u0017/\u0090hb<\u008cl+\b\u0085\u0090&f3;<~\u0000X\t\u000fj\u008eh\u008aj]:\rq$\u00951\u0010\f\u009c:E\u0010*V\u0004\f\u0016w\u009b\u0091J\u0014F\bD\u0007&\f\u0086Cq$\u001cO\u009a\u007f(\u0091\u0089\u0001\u00868\u008a\\g\u0018t\u0095\u001bm1$2=\u0006\u001fH\u000b\t\f0q\u0087!i5eN{\u0092aW\u0085'\u0002W\u0011\u0090u(0\u0098\u0099\u0005Ne7\u0092-Y\u0098\u0094\u0089K\u0002t6q\u0097zRzd\u001eN\u009fp\u008b\"\u0094%\u0015J\u0015\u0091{$0\u0083Z\u0007\f\u0095LZ\u0090l\u008cb\u008c\u0004c\u0081q\u009e^'a\u000f\"c\u001f:WT\\\u0093BoD0o67\u009c&0`UVP\u0095\\}}{5\u0016\u0086\u008a[S\"j\u008by\u0013+\u0097zW\u008f-R.)%\u0083'P\u0086&\u001c\u0086|\u007f\u0094\u0018o9\"\"r=m<#\t\u001aI\rpm\u00917H\u009eC39r\u0006+\u0019\u001c6\u0007t\u0090\u009b\u0018&\u0014`\u0004)\u009a\u0099>/T\u009db\u0004\f#H\u001f\u009a2N\u0090\u00896\u008f\u009141\u009e\u009da6Gs\u0084\r|\u0010#B\u009a\u000fa\u0089\u0011\u00146X\fyg. ma\fr\u001b\u008f\u0094c,\u00104\u0016Y\u00801M\u009ft\u0081?L\u0082\u0095OL8R2{\u001aq\u0084\u0011R\u0082w\u0005\\/\u0098N'\u0090\u008d\u00ad\u0015y\u0095\u0004\u009aA\u009ec\u0096\u009d\u0003PK\u0007\b7y\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000@\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.class\u0093n@\u0014\u0085M:uS\u0092\u0006\u001a\u007f\u007fI#b%\u0015 E !EmTY\u009b8\u0095=\u008en\u0011\u0086\rH,x\u0000\u001e\nq\u000e\u00904\u0094X\u009as{?\u009f3\u009a\u000f\u0000/pd#Gx\u0019+\u001bI7\u0014WR\u001f\u0018\u008fvwQ\u0018\n5J\u009e\t\u001dK\u0097\u0085n\"\u0012i\"\u0094/\u0095p\u0003\u0086iBz\taW~\u008a\u0090{\u0004\u001d\r\u0083<\u008aX*dp'\u0097a_s\u000f$\u0089<\u0011\u0084M>yi%#?&\u001cw_a\u008b\u0085S_r\u0093qG\u008aU\u0013M\u0086\u00ad\u0007B\u008f\u0092\u0002*,y\u000e6flf\u001dEE\u0089`\u0087\"aa3/8\u0099C\u00136\"5#`@\u0002I75\u009egG$R\u007f~|\u0092\u001b\u0092j@x][\u0006Y9 \u0011\u009cnt=7\u0087:4N\bJI\u000eD\u001c>f\u0090\u0019\u00859\u009f\u001d\u0095\u0087y\u0099\u009b\u0099\u00918\u001c}C\u000b/rpx6\u009fAE\u0098\u0015p\u0080tPJAe\u008e\u0019]9\u0083nT6k\u0098r\u008af%\u0019&]m\u001e\u0088\u0081 \u0005?#~OxW]#y\\W=\u008c2dh|2i\u0098\u009bYl+\u0097\u008e\f\u001c+\u0001j\u00969\u0004\u0007[oPK\u0007\btS\u0083\u0001\u0000\u0000\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000M\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classU[O\u0013Q\u0010WX\u0016(H+\r\u0015]\n\u000b/\u0084H\b*\tA\u0012\u000f\u001d\u00936-A\u0012.\u0089\u000f\u0000\u0001^\u001e|\u0017\u00039\rT\n\u009a\u008a\u0089\u000f\u0099s739\u001d\u0080q\u0089#DxESTD~Y\u009ae\"ms\u0015\u0095\u008at|2\u009drY\u00859\u0096\u000b\u00adJw\u0099vV'\u0015r'<\u0019G\u0084E&\u0014BZ\u0097\u0013s-b5'\u0084\u0085[$\u0010+,\th.ze\u0017#K\u0018}\u001c\u001f\u0010\u008d\u0001b\u0013\u0096my\u0093\u0084WfV\u008eSf&G\u0088L;\u0005!\u008cn\u001d\u001dH\u0010f\u00adB6u\u0081\u0081\u0088Mi}:)-#\u008a\u0018[K}*\u0096JRqE)'\\K\u00ad\u0083\u0088lU\t\u00adt\u00941]E=\u0016)X+KV3y\u009a7z?\u0099\u001c\u0087[\u008d\u008b\u001dq\u0001\b\u009acq$`b?!\u0013p\u00846\u0011k\u0082t\u001cW\t\u00ad\u0094\u008e\f\fB(\u0014f<WD\u0089'\u000f\u0095'h?O?\u009b\u008dLN5mD\u0003\u009d|h9L5\u008c\u009a\tmKw$UY\u008d\u009fn!\u001c\u0016${J\u008de\u007fT\u0018\u0082\u009a\u0087%k\u0092o,\u0018B\u008a\u000fU\u0099W\u0011\u0096I\u0083e\fon\u00841\u0089:\u001f\u0084p\u0092)\u0006\u0003\"J\u0007tG'\u0099Q\u0007)\f\u0000\u0002\u0092\u0090!_S\u0084y4\u0004,\u0095U(z/NLg\u001fW\u009f\u0006\u00848\u0017x\u009a\u0081g7\u0007\u009c48G\u009c/R|\u0097e(snWQ\u0014C~En\u007f\u000036*D`6\u0085,\u0092\u0088~\r\u001d!D\u001d5\u0001np\u0080\u0095f\u0006\u0099_\u0019\u0091md\u000fd\u008751r\u0080\u0019\r\u001f\u0088\u0086\u001b,oE\u008f6\u009fPK\u0007\bO<\u0002\u0000\u0000\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classZ\u000b|T\u0099\u007fd\n!\u0098 H\u0004\"!(I\u0000C\u0000\u008d\u0090\u0080\u008dB\u0003\u0082$7d&L\u0080~*P\u00ad\u0015\u00826Z\u0015\u0095\u0084\u0098\n\u0096Z+vn]Gn\u00ad}\u0085\u009f;w^ \f\u0099s9||\u000eo\u001e{ \u0080\u008bd\u0086,AE0Qit\u001b\u00ad\u009dfe\u0097\fTn\u000e\u0019f\u000bvu\u0019\u0081e\u0080\b\u0085\u0090\u0006\u0087 o\u0083\u001b\u0081\u008e-\u001b\u0088`l;\u000b\u0006\u000b{\u009b\"!_\u00833,\u009e\u0088_`tW\u000bM\u008e\u0080\u0011\t\u0099\u0082\u009ae\t\u0091Q\u0001N\u00960\u0083\u009b\u001b|[lX \u0005\u00ad\u0002\u001b\u0003\u0081J~\u009b\u001d2[\r\u0082:#fHP\u0010\u0017V\u0085|\u009c\u008d0X\u0017F\u008bl\u0013jhL\u0017\u0099/.\u0099R\u000b\u0099\u001e\u008cG\u0081\u0086\u0019\u0084\u0084[u~\nQ\u0088s\u0004\u0085mf\u00172jc\"\u009b\"\u008cK\u0012\r\u0081W\u0018xT\u0010`cOW\u008b\u0019V\u0082\u00ad\u0086\u007f\u0011w{Yc\u0019<\u0098{\"=\u0011F4nQ\u0084\u001aOp1\r?\u0013\u0019\u0015\u0083\u0088j\u000f&\u0002\u001d\u00930\u0083\u0095,KzJ\u000f\u00ad\u009fJ\u0019\u0004\u0095\u001dG+D\u0091N\u001f]\u009478\u009ay\u009f\u008d\n%9O\u0085D\u0002]e\u0084;\u0099D\u001eTBEb\u001d9pj\u0098C\u0013\u0007\u0097`L\u0087\u008e\u0018\u008d\u0091f\nr\u0095R\u00925Ss\u0017\u009bn\u0096\u0000y\u0016oi5\u0089\u0081r:_\u001b2\u0003\u00918\u0007W`\u0086&Z\u0011\r\u0085\u008c^fW\u001d\u00161\u001b\u008c2_\u0098X\u009cb|Ti|\u0082M\u0091U\u001d[\nWr,Ibg(T~\u009d\u008e\u00ad\u0089WB\u009a \nVS\u0096\u0006\tgn\u0080\u0086e'\u0083QL\u001a\u001aGeU\u0093\u0019\n|I5\u0082R KG\u0013e7\u0019\u001e\u0093<$9uA\u009fVA\u0003V]\u0095\u009b\u00914n\u0096YQ\u0011I\u000b+5\\/X\u0094YL_h\u0007C\u0012_(\u001cii=X\u0083uJ\r\u0082J2\u00adLw#CM0\u0085(8:>:Ts\u00026\"ABya\u008e\u0080OCgLJ\u008e\rH\u008c\n\u0098[X@g$$\u0017\u0090\u0086T\u0000\u0083 n-N\u0000\u0010\u0002S)m19\u0013\u008aD\u000f+BrI\u001a\u0018ZB\u008f \u0003?6\u0082^&yc\u008f\u000f\u008f`\u0089\u0015j\r7\u000b34\u009dM\u000fn\u00ad*un\u0013t\u009f$u<\u0015\u009253\u0003\\C\u0095\u0097Y7o,]:V!\u008c\be\u0086=:}7=-a\u001b)(\u009f9:\u0082j\u009fm\u009d\u0089\u0088w\u0089xGh\u0087\u0093\u009cFlN\r;\u0004W\u009c,\u001d_\u0083\u00821+\u008dLb\u009e\u001f\u0082%\u0019\u0099l\u000b_\tfG}^E\n7t<\u0082]\f/fnY\u009aa\u0088R\u009f\u008a\u001eU\u007f\u0083\u001d\u008f&\u001e` v\tV3\t\u0002\u0082e6\u00adv/TYWTw\b\tuNlq(\u0014d\u0087mT(=UT<\u0002\u0011\u0017\b/5{5|\u009f\u0010=\u0085=>\u007f\u009b\u0019r\u0019\u009c,*\u0092NP+\u0015>\u001d/Eu`\u0000\u00118\u0081j%b\u008e\u0001\fH0x\u0082VR\u0087t1\u001df\u0084\u0087[,j\u0087:^Q\u0099`HfT;yH\u0011\r\u009b\u0081\u008eH\u009f:rQ\u0013\u001d\u009d\r\u0006\u001a\u0083vo\u00ad\u0010\r\u001dG\u00942\u00ad\b<T\u007f\u0090G|6nt'\u001e\u008f\u0091\br1me\u0089\u0092BPs&)\u0010\u001854z\u0018\u0082,<slPp\u001ehjX\u0012Ek\u0087\u008b8#Eh\u0007\u008b.~\u001d#\u009cr%\u0098\u0092F;pm q\u009a\u009d1T9\u00ad5\u009en\u008d_\u00176:DO\u0014\u00adC\u0012:x\u0090^\u0012\f\u0011\u00ad\u000e=\u0087*w5\u009f]\u001b2M6m\u001a>\u0014,8\u00ad7^\u0083\u000f;#v]\u00996IY5[A\tN0\u0089*\u0017\u001f\u0013\r\u0095p'\u001d\u008dQ`V\u007fA/31\u0084F-~KTa\u0093\fQ\u007f4\u001cB\u0011M\u001e\u0013a4$Kpi\u0086wL+\u009f\u008bC\u0097\u001cq2\u0088t\u009c\u001d\u0097\u000e2\u009aRE;\u0091G4Hr,Mt\u0002f\u008dI\u00971LF\u0084p\u0096UV;\u00942^xwl\bX5'\u009eSAjD.(hWp\f\u0086|\u0096'.\n\u0088+\\]&d\u001a\u00ad.\u0097iNxK\u009eRR\u0002h22\u001e\u0099*5\u0099\u0016s\"o0\"\u009d\u0014\u0005el\u001dY\u009d\u008aD\u0097\u0099\u008a$\u0004h2+%\u008bZ\u0094J.\u0015v\u0095\u0012\u001d\u0080Z\u009e\u00adje\u001eu\u0099\\\u0094S\u0016\u0002$\u0082\u009b\u001c\u0093uQ\u0092i\u0090\u0096j\u001eR#\u0098\u0094?\u008c\u001d.\u008d]\u000b\u0017\u0015)\u0013\u0095=WR\u000e\u009cv\u007fOS\u0081nZ\u0004#2\u008c0Fuk!*Ib5vD\u009aR\u008f\u009f\u0089\u009f7\u0013\u0018\u000f\u0014Q\u0094\u008e\u0090n\u0001|l&ow\u0001\u009eg$&:\u0093\u0083X\u0017^\u008e^\u0015f2zqn9'J\u0098\u0000\u009b6RwZ#<>\u0001Yu:\u0007O\u0094\u0005at!\u0081&_f~\u008dv\u001e\u0083J\u001aB\\\u00adN\u00884N%9oe^*J~]3\u009a$\u00851ML\u001b\u0082IbI`\u007f}\"r\u009e%9\u009f\u008b\u0097'\tCwz\u001fF'\u0099&OMj\u008c\u008f\u0092 (S\u008c\u008c\"_\u0087L\u00ad\u008d\u0095\u00140*1\u008d\n\u0019\u0001T\n\u008b\u001f*Q=lRW[OX|\u0091N\u0097\u0010v\u008c@ \u0018)S\u0014LE\u0081Lk\u0094b-L\u00193hh\u008ew\u008f\u00942Z[px:\u008c?\u0003\\\u009d\u0010N6s\u0001~\"\u0088\u0089\u009b\u009dxXpJ\u001e\u0015\u0014\t\u009aK|#.\u001cW\u0088{\u0081\u0080\u0019>+*^\u0093\u0004ub\u0087,\u0016ji=c\u0007\u00815g0M\u001e\u00104fhF\u009d\u00116\u0003a3\u0010E|\u009b\u0091]\u0013S$\u0014\u009a[\u009a%N_n6aZ\u001a\u0015U\u0014\u009d\u001bn6Bf\u0017'Z\u001bL\u009e?-O9\u008e\u001d1o)jrPmf)N8\u0012m/\u001b@\u000eo1|\u0096\u0005\u0017\u0015z|\u001b\f\u00907A1\u0019\u008b<r\u008cS?SrT\u008d\u0097\u0001\u0081\u0087#ELg\u0089\u0098N\u008b\nZ38<8\u0098\u0002\fx\u0010%\tf\u008f\u0088Z\u0017[\u0002(9f\u0016Uj\u008b\u009e\u0014A\u0094S\\e .\u008f|y \t\u0006jJ\u008a-\u0085Q\u0019|rj\u0093\u000eTs\u00ad\u0086syY\u0016t\u0001,\u0018Gx\u0094$\u001d\u0017z\u008bQ\u0087\u0090\u0010\u001a\u0084\u0095\u009d\u0098\\0\u00966\u000f%\u001er \u001b\u0097\u001b\u0086L\u0006q\u0010SZN\u0019BU\u001c^\u0000\u0002}\u001d#?2\u0080M}\u001bM\u008a\u0096~y\u0098\u000f>L$\u00913\u0080\u00ad\u0003V:\u0007\u0000\t$x\":\r(e\u0001)v+Zy\u001d\u0005Nz\u008bQ2',-Z%v-p\n_\u0084=( ^RA0={\u0010YHTTz\u009dCn\u0016Pd9m\u008d\u0096u-J(5\u009ba<\u009c ~(\u009f\u001fKjV\u0006p\u000f^WW\u0081\u001djz1g\u009fR\u001c\u0005\u0002fw\u0095'I\u0090\u0016\u0089\u000b\u001an\u0096\u0002\u008a\u0012Zq8P\u009b\u001fe_h\u0091X;Z\u009f\n\u001c)\u001f\u009be*\u009d\u00adt:\u0088J]\u0087\t\u0001\u009e\u0089c\u000e-h@+VM\u0082\u0010\u0005\u001d\u0007\u009d\u0001\u001f\u001e\u0006\u0000\u001b28\u0082.\u0012\u0001\u0085 \u0080n|\u008a\u001b\u0089\u0090\u0083)DD\u0091,\u0017b\u008b|\rn\u0092Y\u0016i\u00adyn\u0093^.\u000f\u000e'q|\u000f[9+CO\u000ea\u009b\u001c\u000e\u001e\u0090xPC!s\u0013<\"\u007f.\f\u009eQi-\u009f\u0080OWgL\t.\u001a\u007f\u009f&o[\\%w\u0005\"R{OS\u000f\u0015\u009f\u001eg9\u008d~x\u009f\u0002N\u0014!#4t\u00835n\u001d\u009b%>\u0096\u0094\u008fS\u000e9<\u0018XvU\u0082\u007ff\u000e\u00adU\u0005\u0095:\u0089\u008f\u0002\u0092\u0000K\u008b\u0003Vnz\u0011\u0087G\u0089x\u0082\"\u0015\u001b\u001b\u0015\u0091=\u008b\u001e(\u008882\u008c\u0014;1\u008a\u000f\u009aY9\u00887\u0096Ac\b\u007fa|\u001a_B\u0010>#b8\u0013Uc\u0016b|^\u0095\u0013?F~\u00053;g@mn\u009a\u0007\u009e~4x=qq{\u0006\u0013\u0098u%R\u001dM!PD?&k\u0091QkJ\u0092y]e\u0001\u0019G\u0089^Pz^G\u0083{\t\u009cqxd\u0090\u0089dt\u008c\u0097f:\u0086<2PX@gA\u008e\u0083\u0007|\u0012j6Q2#\u0089+\"\n\u0086bO*\u001b/\u0095\u008eW\u0090\u009c\u00adVX7\r%2x\u008c~\u00152/]N\nu\u0096h\u008dY6 \u000b\u000b.\u0014\u0099O\u0099R\u009e\u008dgyn<\u0087x\u009ee\u008fe\u0002E<\u0088\u0097H\u009f\u0014\u0003x\u009ds?g\u008da\u001c\u000f\u0011^48\u009e\u00157\u000e\u008b\u008e\u001fL&s8.r=\u0086\u0085#r\u000f\u0094\u00979\u001a~&o$U\u0004\u008b\u0017\u0011\u0016B\u009f[^\u0095:YTX\u0096KdJ:h\u0000\u0092\u0098sU;jYa\u001b2\u0016\u0099\u009bV\u0016K\u0083t\u0014I*<Z\u008a\u0014\u0018shn\u0015\u0093V\u0093\u0082UY^BQ\u00ad\u00975)Z\u0096v\u0094:rz?k\u009d_qbf778)4&!/\u0093xb}V9&\u0081l\u0080]UF\u0096){~\f\u008f-4\u0012\u0098]j\u0093h\"\u0092y\u00884c\u00885\u000b\u0088ItB:SEd\u0012k4GZj\u0015\u0096J\u001b\u0003\u0016$\u0012gQR\u00adt@/@t\u0012\u001c\t87p\u0093\u0018E\t\u0019O\u0097\u0095\u0093}\u009ar\u000eudWU\u009b3yv\u0083\u0002\u00872\u000e\u008b\u009f\u001b\u0088vY\u0001\u001e\u0094\u0007$\u0012_<bykL.p=0>oVM6\u0094Y\u0080j\u0089D\u0016\u0097]~\u008dJ_y\u0099]\u000e;j)K@_4d\u000fp\u001e>d8~#Q#\u000f?\u008f\u009d.|\u0092\u0014xw'7Y8,\u000e\u0084,r]dec\u0016y\u0019\u0095\u009d\u0092\u009b\u0016\u001b\u0089\u008b-pg3L~\u0088\u0016n^q%\u00adr[\u001a\u0096#$\u0096j9<R\u0082$\u0096;4,\u0097\u008eR\u001bX\u0095c\bc\u0014+\u001e[\u00856+PD\u009fvL\u0094\u001d\u001c\u00079~\u009d\u00150G\u001cY\u008c.q#}\u001c\u001f%1\u008e\u008fq>\u009b\u009c\u007f\u009c\u0013?PK\u0007\b5\u0010\u0000\u0000(\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.class\u00adVi{\u0013\u0015~\u0016\u0083\u008e1(\tF`\u0090-\u0090`\u001b\u0083\u0083\u0017\u008a]\u0013d\u0090\u0006y\u0088\u0011\u0091\u0083Mk\u0097,t_\u0007>$S\u0094>O\u001f\u009ao\u0019i{g$K8\t4_4w9=G_\u009fo\u0000\u000e\u008f\u0011\u0004\u0004-;\u0097\u008bzfH/F!\u0094\u00ad\u0017\u008b\u0086\u009d).\u00191kiI/d'\u0082\u0011AH`E}YOB.=s\u0091q\u00046YE\n\u0095Y6\u000b9L*cSzqP`\u0099+N6\u0004\u0016w\u0087&W]\u000e\u0006'\f\u008c\u007fp\u0098\u0016md\u0014\u001cwT\u000feph]srd\\vl}\u0095\u0097\u008e\u008e6\u001c\u009b4K5Kj\u001a2\u000b3,5Qc0\u0018~>o\f\tL\f}6\r~\u0004H_1+kD\u0011D\u0087\u0086M\"\u0010LEUm\u0015\tHD\u0006\b!\u008c\bo\"EQZ\u0001\bv\nj5b\u008a\u008c?\u008ak[\u0083\u0086\u008d-\u008bD\u0004=\u0002\u008diER\u0094s\u0005:\u00135|Nx\u0083-H?\u0082\u008a\u0097]\rig\u0005fKF\u009e\u0083\u0011\u001c<70\u0019a\u0081w#(\u000e#\n{PC8*\u0010\u0019bl\u000bQ\u0005\u0083\u0092!\u0081\u008du\u001b\u0011\f\u009a+\u0016|\u0015\u0011\u008cY3\u008d\u001a0\u0013],\u0093\u0085\u0087\u0012\u008d$40%\u0099\u001e\bN\bD\u0016\"\u00959+\u0088!N\u0097\u0097\u001b\u0019\u0099>fc96[\f9\u008b&\u007f\u0087\u0005\"\u0089X\u0015\u0092:\u008a\u0084U\u001a|\u0010\u008a\u0019\u0091/b.\u0006&CPp=)+\n1_N}`\u001ceah\u0006#s \u0094\u008aw2\u0016e\u008d\u009e\u0018En.\u0095-\u0018)dOZ&I\u008b8\u0086'48\\%\u009db9\u009ah4|Wn\u0007T\u009f\u0011\u0090\u00adk\u0097Gf>kQd\u008cE\u0081@*.'\u00175<\u0089<qK\u000bY\u0081>\u001f\u008dx1\u0089\u0012=\u0013Ko\u001e|K$uZvT\u001d=Os4n%Z\te\u000b3@)@+z\u0087L3\u001afI\ndz^\u001d\u008a1c\u0015\u001c\u0094U\u0011Ha\u00025\u0096i\u0080cV>O;U\u009aKl\u000b~ ;\u008b\u0003S2\u00975\\\n\u009bWM\u001aF\u0088;Q\b$8\u0004\u008c&b\u0093d\u0097\u0017\u0081?;\u0002j2krzR/g\f\u0085\u0019?\u0012b\u008e)\u000b\u0096\u0013\u001a\u0017\u0098\u008cl\u007f\u0014o'\u001fu\u0004@\u001ba\u001d_\u008ei\u000f^2{\u001b\u0016\u0091F=\u009bU\u001e|h\u008b\b~Ri\r\u0094\bZ ,m)Y*:x\u0007\u009dC{ \u001b@6;\u0092g'\u0088Ze;c\u008c\u009bYw6\u001c\u0097`\u0093\u009a\n\u001cD|-q\u0016,\u0080f.[8:o.\u0098\u001c+m\u0080\u0090\u008f49\u007f>y\u0013$os&]G\u008c8~\u001d]\u001c9u\u001dna\u008fU\u009c\u0085}\u0002\u00818\u0007\u0006B\u001b8r\u000b\u0003\u0002\u0003MW=Y\u001c\u001b\b'\u0084X,\u001c\u000bW\u0082\u0098\u0097;\u0005>op#\u0015\u0004\u007f\u0089\u001c\u008c2&l\u0081=\u0085(v\u001cg\u0017u\u001c\u00128Id\u0082\u0011k\u0098\u0004h\n\u008c(Y\u009e):\u008a\u0083:N921\u008b3<\rZjr8\u0012\u008f\u0097o\u0093\u008b/\u0084\u008aB0 n\u0085\u0090\u001cv\u009f\u0087\u008aK\u0089O)D\u0087( g\u0094p\u0092\u000bSa\u0097\u0081U\u001c\u0088\u0085\u0085_A4\u009e\u0001s>>P,8,\u00ad\u0015\u008ff\n\u000fp\u009f8@e\u001c$\u0087ab<\u0083\u0018p\u0084,\u008dqo\u008a\\\u00adryi\\R\\6sF\u00898Ac'sL.C5\\J\u0014\u0097l{\u001e\u0097\u0013<\u0015-\u0006\u009e\u009e\u0097D2\u0002V%/\f\u008e\u0093\u0092q\u0005=P\u0085D\u009eQn\u008b\u0017T~O\u007f\u0085\u0010t}\u00ad\u0015u\u001e\u009bJ\u0092\u0092\u0097>@8t\u00ad\"O\u0082\fuhO\u0083\u009f8a4'Ud\u009dV!W\t\u0083`%\u0098@Mr5\u0005\u008f\u007fu^%\u0082T\u001e\t\u0000\u0001\u001d\u009aJ\u0013n\u0085\u001f\u0086\u0094I\u0015\u008f\u009eZ\u0095R\u008aqJ\t\u008euB\u0003e\u0095\"\u001d=_\u0003\u0005$\u00ad\u0080\u0001\f5Wp\u0015E\u0097;M\u001ef\u0014?\r`5i{\u0092:M+\u0005\u00105~y,xeZ \u0015}8[U\u0016E\u0092'zjZ\u0091[\u00adt\u0092\u0092 W|]\u001fPK\u0007\b\u0088!@\u0006\u0000\u0000z\u0010\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000:\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.class\u009dS]O\u0013A\u0014=\u0096n)K\u0081\u0002U\bB[+\u008a\u0015E\u0084\u0011\u0093\u009a\u001ax\u001bIdm[\u0014\u0089>\u009b\u0083&*A\u0012\u001fe\u0085\u0086\u0017_vv{g'\u0080\u0015+1\u00ad\u008a\u001bT\u0015Z\u008d\u001f\bS{mFCXZ\u0017j\u008aFVf9\u009bbauSA\u0080ax\u009f\u001fpfE\u0017%\u009b!x\u008d\u0096hY9l\u009de/\u0015\u0093-K0,\u009c;;X\u0005Jv\u008dJ\u008295\u0006\u007f\"Yd\bl\"\f?\u0006U#`\u0088a\u0003nYP\u0085\u0011`?\u0018*\u0010d\u0018\u0092\u009fj{z\f\"\u0010K(rK\u0097{/\u0018:qG\u0012\u001b\b(\u0005`\u0018K${G\n\u0013I\u0015S\u0098*oz4\u0082+\f\u009d\u008a-\u0010\u0015n\u0014ln\u008b7%\b!NInx.\u009aqn0}:\u008c\u0019\\\u00953\u008c'zI$\u008b\u0003\u0086%\u0005\u008b\f\u0091\"\u0081$BXf\u0098:\u0012x\u00adez\u0010nfZbP\u0091\u0086F\u00054=\u008c\u0082\u00953\u0086q\u0090)N%#\u009auf'x\u0081W\u0006xnUZ5a\u0092]\u0015p\u009fXQ\u009c\u0012\u001e.]\u0003J%zp%C\u0015k\u0014Yk\u0087\fBe\u00953]zf\u0002;%\u0018\b]:\u0091V\u0085v>\u0084h\u0087;@\u0091'\u0094h\u001dN\u001dAM\u009d s\u0084o\u0018d\u008f7\u008c#\u0080\u0018\u0086h\u001d\u009d.\u0084\u001e^c=\u0006O0\u0013\u009d=W\u008c\u001cc\u0081n\u0083\u0017N\u009d\u0086o\u001a#\u009e\u0004\u009e\bq\u0085\u0095lWL-*wU\u0087\u0085FQ\u0099';A'8\u0005\u0006Cqw\u0084\u0094\u0093\u0019x\u0018\u0019\u001f^u\b;gK\u0094\u0099ppbn\u0087#\u001e !<:QW\u0083\u001c;(\u008f\b\u0004>\u009d-z\u000fPK\u0007\b=!C\u0002\u0000\u0000@\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000H\u0000\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.class\u0091MO\"A\u0010\u0086\u0012\u0004DB]ua\u0081\tL<\u0091(fOd%xo\u0086rh33=i\u001a\fJO&\u001e\u0001(c\u0080\u0093]\u0093C\u0095Nu=\u00008\"\u0016\b\u0017J\u0088\u00857`7\u0014c\u008e{-\u0098\u0005hu\u009eb+FPD\u008c-.\"OhyohW#BDF\u009c\u0011r\r!R}.#\u0087\n\u0016Q %Z\u0002&T\u0013\u008d2\u008ay3\u0090Ce\u0087;&la\u009a\\F\u0088UX\u0081\u0088|k\u008c\u00126\b!A\\\u00112~\t[\u0084J<}a5&g\u0087\u009e\u0096iZ\u008e]R\u0097\u008d3\u0083\u0012M\u00ad\u00ad\u008e\u0019\u001bL\tM4:$\u009d\u0086\u0093\bF\\o\u0012]5\u001e\u0092\u000f\u001d~kf2\"\u000e`\u0081mf`c\\du\tG\u009b,lc!-nb`u%W6\u0083\u001b38W]\u007f\u0098CwO\u009a\u0081n\u0099v\u0006c\u001e=@\tk\u001dPK\u0007\bBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000G\u0000\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.class\u0091N\u001b1\u0014\u0086CB\u0012\u0002-\u0090r\u008b.\u0094\u008cbEB\u0089Xp\u0091ReLN'f#\u008f\u0013\u0094*+$\u0016<@\u001f\n\u0019\u0002B\b!\u008bs\u001d\u007f\u001f\u001f\u0000^\u0019\u000b\u0084S}W\u001b\u001b\u008a\tG\u008d\u0016q\u0002\u0089Z+[0\u0092\u0093\nC\u0011\r2\u008a&\u008c\"n\u009bAb\u008d\b#\u0019IsB(\u001b}B\u00ad\u0086\\E\u0001K+XD\u0089\u009a/\u0080O1\b\u0098P*O\u0004}e\u009a\u008aE3\u0092\u0089Sg;$rUl\u008a\b\u001bF\u0098\b7\u0010\u0091\u008c\u0096\u0091\u007fX:\u0081:\u0084\u007f\u0088\u000e\u001b!\u0003\u001eVAXN\u0083\u009b\u0095\u0010\u0088\u0013O,`\u009bpc<3N<S:\u0097cF\u009c/\u009c:\u0096\u0084t8\u009cND0F\u008bPL\u008f\u00adt*|\u0083\u0001h#\u0096mZO/~C\u0006\u000bZ[\u008a5,[,S\u0086\u007f\fnBm\u001c\u0006-\u001c<\u009f\u008bn[\u0093\u0083\u0012v2\u0013PK\u0007\bv\u0089\u0001\u0000\u0000&\u0003\u0000\u0000PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000K1\u0000\u0000\u0000+\u0001\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000#\u0001\u0000\u0000META-INF/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000b\u0001\u0000\u0000META-INF/maven/io.takari/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000META-INF/maven/io.takari/maven-wrapper/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000L@\u0005:\u0000\u0000\u00009\u0000\u0000\u00005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0002\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.propertiesPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u009f\u0002\u0000\u0000org/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000org/apache/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000e\u0003\u0000\u0000org/apache/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000O\u0003\u0000\u0000org/apache/maven/wrapper/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000B\u0005\u0000\u0000`\n\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0098\u0003\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005C\u0012\u0002\u0000\u0000\u0003\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001;\t\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000S\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u00ad\u000b\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000C5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00017\u000e\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084q\u0012\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0005\u001b\u0000\u0000org/apache/maven/wrapper/Downloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000[\u0007\u000f\u0000\u0000\u0088\u001f\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\f\u001c\u0000\u0000org/apache/maven/wrapper/Installer.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084'+\u0001\u0000\u0000m\u0003\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001>,\u0000\u0000org/apache/maven/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0011ps]\u000b\u0000\u0000\u0018\u0000\u0000/\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008d.\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001coI\u0001\u0000\u0000t\u0003\u0000\u0000>\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001G:\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0087|+\u009f?\u0007\u0000\u0000\u000e\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001n<\u0000\u0000org/apache/maven/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000{\u0002`-\u0004\u0000\u0000\t\u0000\u00006\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0007D\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001SI\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00009\u0091\b\u0000\u0000,\u0013\u0000\u0000.\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001LM\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009V\u0000\u0000org/apache/maven/wrapper/cli/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000dQv\u0002\u0000\u0000T\b\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0086V\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000j F\u0004\u0000\u0000\f\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001Y\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000m6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0015_\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=8\u009f\u0094L\u0001\u0000\u0000\u0003\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001`\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00006WK\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0087b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000k-\u0003\u0000\u0000%\u000b\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001g\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b\u001b['\u0093\u0002\u0000\u0000\u0007\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u009ek\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0014\u0003\u0000\u0000\u0000\r\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001n\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000G*\u0002\u0000\u0000\u0004\u0000\u0000T\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001r\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000F{)6N\u0007\u0000\u0000M\u0014\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001u\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0081\u009a\u0002\u0000\u0000I\u0007\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001h}\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=\u0086\u0002\u0000\u0000\u0007\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001z\u0080\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000K\u0002\u0096\u0017\u0002\u0000\u0000\u0081\u0007\u0000\u0000E\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u009d\u0083\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0095\u0094\u0001\u0000\u0000\u0003\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0086\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0016\u0018v\u0002\u0000\u0000f\u0005\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0088\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00007y\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000tS\u0083\u0001\u0000\u0000\u0004\u0000\u0000@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u008e\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000O<\u0002\u0000\u0000\u0007\u0000\u0000M\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u001c\u0091\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005\u0010\u0000\u0000(\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001^\u0094\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0088!@\u0006\u0000\u0000z\u0010\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001r\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=!C\u0002\u0000\u0000@\u0005\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000Bm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000H\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000v\u0089\u0001\u0000\u0000&\u0003\u0000\u0000G\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.classPK\u0005\u0006\u0000\u0000\u0000\u0000/\u0000/\u0000\u0006\u0012\u0000\u0000\u0000\u0000\u0000\u0000",
      "642d572ce90e5085986bdd9c9204b9404f028084":
        "distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n",
      dfe0770424b2a19faf507a501ebfc23be8f54e7b:
        "# Auto detect text files and perform LF normalization\n* text=auto\n",
      a2a3040aa86debfd8826d9c2b5c816314c17d9fe:
        "HELP.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**\n!**/src/test/**\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n\n### VS Code ###\n.vscode/\n",
      "3c8a5537314954d53ec2fb774b34fe5d5a5f253a":
        '#!/bin/sh\n# ----------------------------------------------------------------------------\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# "License"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#    https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# Maven Start Up Batch script\n#\n# Required ENV vars:\n# ------------------\n#   JAVA_HOME - location of a JDK home dir\n#\n# Optional ENV vars\n# -----------------\n#   M2_HOME - location of maven2\'s installed home dir\n#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n#     e.g. to debug Maven itself, use\n#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n# ----------------------------------------------------------------------------\n\nif [ -z "$MAVEN_SKIP_RC" ]; then\n\n  if [ -f /etc/mavenrc ]; then\n    . /etc/mavenrc\n  fi\n\n  if [ -f "$HOME/.mavenrc" ]; then\n    . "$HOME/.mavenrc"\n  fi\n\nfi\n\n# OS specific support.  $var _must_ be set to either true or false.\ncygwin=false\ndarwin=false\nmingw=false\ncase "$(uname)" in\nCYGWIN*) cygwin=true ;;\nMINGW*) mingw=true ;;\nDarwin*)\n  darwin=true\n  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n  if [ -z "$JAVA_HOME" ]; then\n    if [ -x "/usr/libexec/java_home" ]; then\n      export JAVA_HOME="$(/usr/libexec/java_home)"\n    else\n      export JAVA_HOME="/Library/Java/Home"\n    fi\n  fi\n  ;;\nesac\n\nif [ -z "$JAVA_HOME" ]; then\n  if [ -r /etc/gentoo-release ]; then\n    JAVA_HOME=$(java-config --jre-home)\n  fi\nfi\n\nif [ -z "$M2_HOME" ]; then\n  ## resolve links - $0 may be a link to maven\'s home\n  PRG="$0"\n\n  # need this for relative symlinks\n  while [ -h "$PRG" ]; do\n    ls=$(ls -ld "$PRG")\n    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n    if expr "$link" : \'/.*\' >/dev/null; then\n      PRG="$link"\n    else\n      PRG="$(dirname "$PRG")/$link"\n    fi\n  done\n\n  saveddir=$(pwd)\n\n  M2_HOME=$(dirname "$PRG")/..\n\n  # make it fully qualified\n  M2_HOME=$(cd "$M2_HOME" && pwd)\n\n  cd "$saveddir"\n  # echo Using m2 at $M2_HOME\nfi\n\n# For Cygwin, ensure paths are in UNIX format before anything is touched\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --unix "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\nfi\n\n# For Mingw, ensure paths are in UNIX format before anything is touched\nif $mingw; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME="$( (\n      cd "$M2_HOME"\n      pwd\n    ))"\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME="$( (\n      cd "$JAVA_HOME"\n      pwd\n    ))"\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  javaExecutable="$(which javac)"\n  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n    # readlink(1) is not available as standard on Solaris 10.\n    readLink=$(which readlink)\n    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n      if $darwin; then\n        javaHome="$(dirname \\"$javaExecutable\\")"\n        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n      else\n        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n      fi\n      javaHome="$(dirname \\"$javaExecutable\\")"\n      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n      JAVA_HOME="$javaHome"\n      export JAVA_HOME\n    fi\n  fi\nfi\n\nif [ -z "$JAVACMD" ]; then\n  if [ -n "$JAVA_HOME" ]; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n      # IBM\'s JDK on AIX uses strange locations for the executables\n      JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n      JAVACMD="$JAVA_HOME/bin/java"\n    fi\n  else\n    JAVACMD="$(which java)"\n  fi\nfi\n\nif [ ! -x "$JAVACMD" ]; then\n  echo "Error: JAVA_HOME is not defined correctly." >&2\n  echo "  We cannot execute $JAVACMD" >&2\n  exit 1\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  echo "Warning: JAVA_HOME environment variable is not set."\nfi\n\nCLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n\n# traverses directory structure from process work directory to filesystem root\n# first directory with .mvn subdirectory is considered project base directory\nfind_maven_basedir() {\n\n  if [ -z "$1" ]; then\n    echo "Path not specified to find_maven_basedir"\n    return 1\n  fi\n\n  basedir="$1"\n  wdir="$1"\n  while [ "$wdir" != \'/\' ]; do\n    if [ -d "$wdir"/.mvn ]; then\n      basedir=$wdir\n      break\n    fi\n    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n    if [ -d "${wdir}" ]; then\n      wdir=$(\n        cd "$wdir/.."\n        pwd\n      )\n    fi\n    # end of workaround\n  done\n  echo "${basedir}"\n}\n\n# concatenates all lines of a file\nconcat_lines() {\n  if [ -f "$1" ]; then\n    echo "$(tr -s \'\\n\' \' \' <"$1")"\n  fi\n}\n\nBASE_DIR=$(find_maven_basedir "$(pwd)")\nif [ -z "$BASE_DIR" ]; then\n  exit 1\nfi\n\n##########################################################################################\n# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n# This allows using the maven wrapper in projects that prohibit checking in binary data.\n##########################################################################################\nif [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Found .mvn/wrapper/maven-wrapper.jar"\n  fi\nelse\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n  fi\n  if [ -n "$MVNW_REPOURL" ]; then\n    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  else\n    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  fi\n  while IFS="=" read key value; do\n    case "$key" in wrapperUrl)\n      jarUrl="$value"\n      break\n      ;;\n    esac\n  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Downloading from: $jarUrl"\n  fi\n  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n  if $cygwin; then\n    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n  fi\n\n  if command -v wget >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found wget ... using wget"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      wget "$jarUrl" -O "$wrapperJarPath"\n    else\n      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n    fi\n  elif command -v curl >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found curl ... using curl"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      curl -o "$wrapperJarPath" "$jarUrl" -f\n    else\n      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n    fi\n\n  else\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Falling back to using Java to download"\n    fi\n    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n    # For Cygwin, switch paths to Windows format before running javac\n    if $cygwin; then\n      javaClass=$(cygpath --path --windows "$javaClass")\n    fi\n    if [ -e "$javaClass" ]; then\n      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Compiling MavenWrapperDownloader.java ..."\n        fi\n        # Compiling the Java class\n        ("$JAVA_HOME/bin/javac" "$javaClass")\n      fi\n      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        # Running the downloader\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Running MavenWrapperDownloader.java ..."\n        fi\n        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n      fi\n    fi\n  fi\nfi\n##########################################################################################\n# End of extension\n##########################################################################################\n\nexport MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\nif [ "$MVNW_VERBOSE" = true ]; then\n  echo $MAVEN_PROJECTBASEDIR\nfi\nMAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\nfi\n\n# Provide a "standardized" way to retrieve the CLI args that will\n# work with both Windows and non-Windows executions.\nMAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\nexport MAVEN_CMD_LINE_ARGS\n\nWRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nexec "$JAVACMD" \\\n  $MAVEN_OPTS \\\n  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"\n',
      c8d43372c986d97911cdc21bd87e0cbe3d83bdda:
        '@REM ----------------------------------------------------------------------------\n@REM Licensed to the Apache Software Foundation (ASF) under one\n@REM or more contributor license agreements.  See the NOTICE file\n@REM distributed with this work for additional information\n@REM regarding copyright ownership.  The ASF licenses this file\n@REM to you under the Apache License, Version 2.0 (the\n@REM "License"); you may not use this file except in compliance\n@REM with the License.  You may obtain a copy of the License at\n@REM\n@REM    https://www.apache.org/licenses/LICENSE-2.0\n@REM\n@REM Unless required by applicable law or agreed to in writing,\n@REM software distributed under the License is distributed on an\n@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@REM KIND, either express or implied.  See the License for the\n@REM specific language governing permissions and limitations\n@REM under the License.\n@REM ----------------------------------------------------------------------------\n\n@REM ----------------------------------------------------------------------------\n@REM Maven Start Up Batch script\n@REM\n@REM Required ENV vars:\n@REM JAVA_HOME - location of a JDK home dir\n@REM\n@REM Optional ENV vars\n@REM M2_HOME - location of maven2\'s installed home dir\n@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n@REM     e.g. to debug Maven itself, use\n@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n@REM ----------------------------------------------------------------------------\n\n@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n@echo off\n@REM set title of command window\ntitle %0\n@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n\n@REM set %HOME% to equivalent of $HOME\nif "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n\n@REM Execute a user defined script before this one\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n@REM check for pre script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\nif exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n:skipRcPre\n\n@setlocal\n\nset ERROR_CODE=0\n\n@REM To isolate internal variables from possible post scripts, we use another setlocal\n@setlocal\n\n@REM ==== START VALIDATION ====\nif not "%JAVA_HOME%" == "" goto OkJHome\n\necho.\necho Error: JAVA_HOME not found in your environment. >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n:OkJHome\nif exist "%JAVA_HOME%\\bin\\java.exe" goto init\n\necho.\necho Error: JAVA_HOME is set to an invalid directory. >&2\necho JAVA_HOME = "%JAVA_HOME%" >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n@REM ==== END VALIDATION ====\n\n:init\n\n@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n@REM Fallback to current working directory if not found.\n\nset MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\nIF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n\nset EXEC_DIR=%CD%\nset WDIR=%EXEC_DIR%\n:findBaseDir\nIF EXIST "%WDIR%"\\.mvn goto baseDirFound\ncd ..\nIF "%WDIR%"=="%CD%" goto baseDirNotFound\nset WDIR=%CD%\ngoto findBaseDir\n\n:baseDirFound\nset MAVEN_PROJECTBASEDIR=%WDIR%\ncd "%EXEC_DIR%"\ngoto endDetectBaseDir\n\n:baseDirNotFound\nset MAVEN_PROJECTBASEDIR=%EXEC_DIR%\ncd "%EXEC_DIR%"\n\n:endDetectBaseDir\n\nIF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n\n@setlocal EnableExtensions EnableDelayedExpansion\nfor /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n\n:endReadAdditionalConfig\n\nSET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\nset WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\nset WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nset DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n\nFOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n)\n\n@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\nif exist %WRAPPER_JAR% (\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Found %WRAPPER_JAR%\n    )\n) else (\n    if not "%MVNW_REPOURL%" == "" (\n        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n    )\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n        echo Downloading from: %DOWNLOAD_URL%\n    )\n\n    powershell -Command "&{"^\n\t\t"$webclient = new-object System.Net.WebClient;"^\n\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n\t\t"}"^\n\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n\t\t"}"\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Finished downloading %WRAPPER_JAR%\n    )\n)\n@REM End of extension\n\n@REM Provide a "standardized" way to retrieve the CLI args that will\n@REM work with both Windows and non-Windows executions.\nset MAVEN_CMD_LINE_ARGS=%*\n\n%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\nif ERRORLEVEL 1 goto error\ngoto end\n\n:error\nset ERROR_CODE=1\n\n:end\n@endlocal & set ERROR_CODE=%ERROR_CODE%\n\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n@REM check for post script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\nif exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n:skipRcPost\n\n@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\nif "%MAVEN_BATCH_PAUSE%" == "on" pause\n\nif "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n\nexit /B %ERROR_CODE%\n',
      e168b2799d20267ac52cf4acbd15701d9ce1aab4:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.5.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web-services</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n'
    }
  }
];
