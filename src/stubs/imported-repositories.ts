/* eslint-disable */
export const importedRepository = [
  {
    name: "refactoring-crawler",
    currentBranch: "master",
    ownerId: "PatrickLai7528",
    commits: [
      {
        sha: "27447784904e85b61609a78983e4ecbecaf37c4f",
        message:
          "Merge pull request #4 from PatrickLai7528/develop\n\ntest(PushDownMethod): test push down method detection",
        stats: {
          total: 221,
          additions: 216,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "6b11e9932c8355342ef55dc552b6774ed4725edd"
          },
          {
            sha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c"
          }
        ],
        committedAt: 1585577675000,
        changedFiles: [
          {
            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 50,
            deletions: 5,
            patch:
              '@@ -20,12 +20,12 @@\n   static void setUp() {\n     settings = new Hashtable<>();\n \n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n   }\n \n   @Test\n@@ -297,4 +297,49 @@ void testPullUpMethod() throws IOException {\n         "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n         nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPushDownMethod() throws IOException {\n+    String originalFolder = "testPushDownMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPushDownMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler =\n+        new RefactoringCrawler("test pull down method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PushedDownMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2dc66023a72d428c6c21fd74e2234072326a49e2",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "701f29bc236e688897a8a591086c04fde5b966e9",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "986e673462260d92feac4b036a4d2b48af19cb71",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          },
          {
            sha: "3663e804b7832ea04bf4a3ff8eafea32070498dd",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c",
        message: "test(PushDownMethod): test push down method detection",
        stats: {
          total: 221,
          additions: 216,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f"
          }
        ],
        committedAt: 1585577616000,
        changedFiles: [
          {
            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 50,
            deletions: 5,
            patch:
              '@@ -20,12 +20,12 @@\n   static void setUp() {\n     settings = new Hashtable<>();\n \n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n   }\n \n   @Test\n@@ -297,4 +297,49 @@ void testPullUpMethod() throws IOException {\n         "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n         nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPushDownMethod() throws IOException {\n+    String originalFolder = "testPushDownMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPushDownMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler =\n+        new RefactoringCrawler("test pull down method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PushedDownMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2dc66023a72d428c6c21fd74e2234072326a49e2",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "701f29bc236e688897a8a591086c04fde5b966e9",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "986e673462260d92feac4b036a4d2b48af19cb71",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/newVersion/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPushDownMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          },
          {
            sha: "3663e804b7832ea04bf4a3ff8eafea32070498dd",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
            filename:
              "src/test/java/refactoring/crawler/testPushDownMethod/original/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPushDownMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "6b11e9932c8355342ef55dc552b6774ed4725edd",
        message:
          "Merge pull request #3 from PatrickLai7528/develop\n\ntest pull up method",
        stats: {
          total: 245,
          additions: 232,
          deletions: 13
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "35d82874cab17a326c6a72ca59ee3867d3160d20"
          },
          {
            sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f"
          }
        ],
        committedAt: 1585556937000,
        changedFiles: [
          {
            sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              '@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-//        updateFeedbackLoop(pair);\n+        //        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -119,7 +119,7 @@ private void updateFeedbackLoop(Node[] pair) {\n         for (Node node : verCallers) {\n           if (origInV2Callers.contains(node))\n             if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n               nodesToRemove.add(pair);\n             }\n         }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ca0cc03d4aaf1bdba7e7155a01518bc000a5b3cd",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 61,
            deletions: 6,
            patch:
              '@@ -208,17 +208,28 @@ void testRenameClass() {\n \n   @Test\n   void testMoveMethod() throws IOException {\n-    String originalArray = TestUtils.readFile("original", "Array.java", null);\n-    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n-    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n \n     String newVersionArray =\n-        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Array.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionArrayStack =\n         TestUtils.readFile(\n-            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+            "testMoveMethod",\n+            "ArrayStack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionStack =\n-        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Stack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n \n     List<String> originalList = new ArrayList<>();\n     List<String> newVersionList = new ArrayList<>();\n@@ -242,4 +253,48 @@ void testMoveMethod() throws IOException {\n     assertEquals(\n         "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPullUpMethod() throws IOException {\n+    String originalFolder = "testPullUpMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPullUpMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PulledUpMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "modified",
            additions: 3,
            deletions: 5,
            patch:
              '@@ -10,7 +10,8 @@\n  * @create: 2020-03-29 13:55\n  */\n public class TestUtils {\n-  public static String readFile(String folder, String filename, String packageName)\n+  public static String readFile(\n+      String folder, String filename, String replacePackage, String packageName)\n       throws IOException {\n     String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n     BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n@@ -22,10 +23,7 @@ public static String readFile(String folder, String filename, String packageName\n     }\n     String fileContent = sb.toString();\n     if (packageName != null) {\n-      fileContent =\n-          fileContent.replace(\n-              "package refactoring.crawler.testMoveMethod;",\n-              "package refactoring.crawler.original;");\n+      fileContent = fileContent.replace(replacePackage, packageName);\n     }\n     return fileContent;\n   }',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n'
          },
          {
            sha: "dd83f48f6ade0ae1135e1142522e3d14895cb000",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "e4e3a2ff422284c53ab262608b26088f45ae47e1",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          },
          {
            sha: "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "3f2ff494d20eee827750dbc6d19301fdcde5fc3f",
        message: "test(PullUpMethodDetection): add test for pull up method",
        stats: {
          total: 79,
          additions: 66,
          deletions: 13
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "70cd2cbd746583044f719566a0354aa4b2beb5ea"
          }
        ],
        committedAt: 1585556845000,
        changedFiles: [
          {
            sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              '@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-//        updateFeedbackLoop(pair);\n+        //        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -119,7 +119,7 @@ private void updateFeedbackLoop(Node[] pair) {\n         for (Node node : verCallers) {\n           if (origInV2Callers.contains(node))\n             if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n               nodesToRemove.add(pair);\n             }\n         }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ca0cc03d4aaf1bdba7e7155a01518bc000a5b3cd",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 61,
            deletions: 6,
            patch:
              '@@ -208,17 +208,28 @@ void testRenameClass() {\n \n   @Test\n   void testMoveMethod() throws IOException {\n-    String originalArray = TestUtils.readFile("original", "Array.java", null);\n-    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n-    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n \n     String newVersionArray =\n-        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Array.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionArrayStack =\n         TestUtils.readFile(\n-            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+            "testMoveMethod",\n+            "ArrayStack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n     String newVersionStack =\n-        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+        TestUtils.readFile(\n+            "testMoveMethod",\n+            "Stack.java",\n+            "package refactoring.crawler.testMoveMethod",\n+            "package refactoring.crawler.original;");\n \n     List<String> originalList = new ArrayList<>();\n     List<String> newVersionList = new ArrayList<>();\n@@ -242,4 +253,48 @@ void testMoveMethod() throws IOException {\n     assertEquals(\n         "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testPullUpMethod() throws IOException {\n+    String originalFolder = "testPullUpMethod/original";\n+    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n+    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n+    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n+\n+    String newVersionFolder = "testPullUpMethod/newVersion";\n+    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n+    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n+\n+    String newVersionUnit =\n+        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n+    String newVersionTank =\n+        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n+    String newVersionSoldier =\n+        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalUnit);\n+    originalList.add(originalTank);\n+    originalList.add(originalSoldier);\n+\n+    newVersionList.add(newVersionUnit);\n+    newVersionList.add(newVersionTank);\n+    newVersionList.add(newVersionSoldier);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("PulledUpMethods", refactoringCategory.getName());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n+        nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n+        nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "modified",
            additions: 3,
            deletions: 5,
            patch:
              '@@ -10,7 +10,8 @@\n  * @create: 2020-03-29 13:55\n  */\n public class TestUtils {\n-  public static String readFile(String folder, String filename, String packageName)\n+  public static String readFile(\n+      String folder, String filename, String replacePackage, String packageName)\n       throws IOException {\n     String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n     BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n@@ -22,10 +23,7 @@ public static String readFile(String folder, String filename, String packageName\n     }\n     String fileContent = sb.toString();\n     if (packageName != null) {\n-      fileContent =\n-          fileContent.replace(\n-              "package refactoring.crawler.testMoveMethod;",\n-              "package refactoring.crawler.original;");\n+      fileContent = fileContent.replace(replacePackage, packageName);\n     }\n     return fileContent;\n   }',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n'
          }
        ]
      },
      {
        sha: "70cd2cbd746583044f719566a0354aa4b2beb5ea",
        message: "test(*): add test classes for pull up method",
        stats: {
          total: 166,
          additions: 166,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "dd0b341819343cb1eededc8901d8252d943f4e71"
          }
        ],
        committedAt: 1585556822000,
        changedFiles: [
          {
            sha: "dd83f48f6ade0ae1135e1142522e3d14895cb000",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Soldier.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Tank.java",
            status: "added",
            additions: 23,
            deletions: 0,
            patch:
              '@@ -0,0 +1,23 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "e4e3a2ff422284c53ab262608b26088f45ae47e1",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/newVersion/Unit.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.testPullUpMethod.newVersion;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n"
          },
          {
            sha: "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Soldier.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:50\n+ */\n+public class Soldier extends Unit {\n+\n+  public Soldier() {\n+    super();\n+  }\n+\n+  public Soldier(String name) {\n+    super(name, "Solider");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Tank.java",
            status: "added",
            additions: 27,
            deletions: 0,
            patch:
              '@@ -0,0 +1,27 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:53\n+ */\n+public class Tank extends Unit {\n+\n+  public Tank() {\n+    super();\n+  }\n+\n+  public Tank(String name) {\n+    super(name, "Tank");\n+  }\n+\n+  public int getHealth() {\n+    return this.health;\n+  }\n+\n+  public void printUnitInfo() {\n+    System.out.println(this.getName() + this.getHealth());\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n'
          },
          {
            sha: "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
            filename:
              "src/test/java/refactoring/crawler/testPullUpMethod/original/Unit.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.testPullUpMethod.original;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Class for testing push up method\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-30 14:48\n+ */\n+public class Unit {\n+\n+  private String name;\n+  private String unitType;\n+\n+  protected int health;\n+\n+  public Unit() {}\n+\n+  public Unit(String name, String unitType) {\n+    this.name = name;\n+    this.unitType = unitType;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public String getUnitType() {\n+    return this.unitType;\n+  }\n+}",
            rawContent:
              "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n"
          }
        ]
      },
      {
        sha: "35d82874cab17a326c6a72ca59ee3867d3160d20",
        message:
          "Merge pull request #2 from PatrickLai7528/develop\n\nAdd tests for move method and rename class detection",
        stats: {
          total: 725,
          additions: 706,
          deletions: 19
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a"
          },
          {
            sha: "dd0b341819343cb1eededc8901d8252d943f4e71"
          }
        ],
        committedAt: 1585495169000,
        changedFiles: [
          {
            sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
            filename: "build.gradle",
            status: "modified",
            additions: 36,
            deletions: 2,
            patch:
              "@@ -5,11 +5,46 @@\n  * For more details take a look at the Java Libraries chapter in the Gradle\n  * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n  */\n-\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n     id 'com.github.sherter.google-java-format' version '0.8'\n+    id 'jacoco'\n+}\n+\n+jacoco {\n+    toolVersion = \"0.8.5\"\n+    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n+}\n+\n+jacocoTestReport {\n+    reports {\n+        xml.enabled false\n+        csv.enabled false\n+        html.destination file(\"${buildDir}/jacocoHtml\")\n+    }\n+}\n+\n+jacocoTestCoverageVerification {\n+    violationRules {\n+        rule {\n+            limit {\n+                minimum = 0.5\n+            }\n+        }\n+\n+        rule {\n+            enabled = false\n+            element = 'CLASS'\n+            includes = ['org.gradle.*']\n+\n+            limit {\n+                counter = 'LINE'\n+                value = 'TOTALCOUNT'\n+                maximum = 0.3\n+            }\n+        }\n+    }\n }\n \n repositories {\n@@ -47,7 +82,6 @@ dependencies {\n     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n     implementation 'org.jetbrains:annotations:15.0'\n }\n-\n test {\n     // Use junit platform for unit tests\n     useJUnitPlatform()",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -2,8 +2,14 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import java.util.*;\n import lombok.Getter;\n@@ -37,10 +43,35 @@ public RefactoringCrawler(String projectName, Dictionary<Settings, Double> setti\n   }\n \n   private static List<CompilationUnit> parse(List<String> files) {\n+\n     TypeSolver typeSolver = new ReflectionTypeSolver();\n     JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n     StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n \n+    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n+      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n+      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n+        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n+          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n+        }\n+      }\n+      if (null != classOrInterfaceDeclaration) {\n+        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n+        if (fullyQualifiedName.isPresent()) {\n+          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n+              classOrInterfaceDeclaration.resolve();\n+          memoryTypeSolver.addDeclaration(\n+              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n+        }\n+      }\n+    }\n+\n+    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n+\n     List<CompilationUnit> resList = new LinkedList<>();\n     for (String source : files) {\n       CompilationUnit cu = StaticJavaParser.parse(source);",
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          },
          {
            sha: "da52b72d6129eeaaecc0171a5c6ec463564026b1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 13,
            deletions: 2,
            patch:
              "@@ -50,7 +50,7 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n    */\n   public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> refactoredNodes = new ArrayList<>();\n     List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n     return pruneFalsePositives(listWithFP);\n   }\n@@ -76,6 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n+//        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -84,6 +85,16 @@ protected String extractPotentialRename(String parentClassOriginal) {\n     return refactoredNodes;\n   }\n \n+  /** @param pair */\n+  private void updateFeedbackLoop(Node[] pair) {\n+    if (isRename()) {\n+      Node original = pair[0];\n+      Node renamed = pair[1];\n+      Dictionary<String, String> dict = getRenamingDictionary();\n+      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n+    }\n+  }\n+\n   public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n     List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n     for (Node[] pair : listWithFP) {\n@@ -365,7 +376,7 @@ protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigr\n         result -> {\n           if (graph.hasNamedNode(result))\n             graph.addEdge(\n-                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n         });\n     // Possible change to methods that instantiate classes\n     // from class -> class edges.",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n//        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 15,
            deletions: 6,
            patch:
              "@@ -2,10 +2,7 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-import refactoring.crawler.graph.ClassNode;\n-import refactoring.crawler.graph.FieldNode;\n-import refactoring.crawler.graph.MethodNode;\n-import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n   public static List<String> findFieldReferences(FieldNode node) {\n@@ -16,8 +13,20 @@\n     return node.getSuperClasses();\n   }\n \n-  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-    return node.getClassesImported();\n+  public static List<String> findClassReferences(\n+      NamedDirectedMultigraph graph, ClassNode classNode) {\n+    //    return node.getClassesImported();\n+    List<String> res = new LinkedList<>();\n+    for (Node n : graph.vertexSet()) {\n+      if (n.getType() == Node.Type.CLASS) {\n+        for (String imported : ((ClassNode) n).getClassesImported()) {\n+          if (imported.equals(classNode.getFullyQualifiedName())) {\n+            res.add(n.getFullyQualifiedName());\n+          }\n+        }\n+      }\n+    }\n+    return res;\n   }\n \n   public static List<String> findMethodCallers(",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 5,
            deletions: 4,
            patch:
              "@@ -19,15 +19,16 @@ public RenameMethodDetection(\n    */\n   public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n     List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n     for (Node[] pair : prePrunedMethods) {\n       Node original = pair[0];\n       Node version = pair[1];\n       String parentClassOriginal = extractFullyQualifiedParentName(original);\n       String parentClassVersion = extractFullyQualifiedParentName(version);\n-      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-        candidatesWithSameParentClass.add(pair);\n+      boolean isTheSameModuloRename =\n+          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n+      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n     }\n \n     return candidatesWithSameParentClass;",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -277,7 +277,7 @@ private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph gr\n       for (Node c : this.oldVersionClassList) {\n         if (!c.isAPI()) continue;\n \n-        for (Node c2 : this.oldVersionClassList) {\n+        for (Node c2 : this.newVersionClassList) {\n           if (!c2.isAPI()) continue;\n \n           if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {",
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "d417febc4d7566232396eca5c9745c45efdea9d9",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 117,
            deletions: 4,
            patch:
              '@@ -5,9 +5,8 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import java.util.Dictionary;\n-import java.util.Hashtable;\n-import java.util.List;\n+import java.io.IOException;\n+import java.util.*;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n@@ -23,7 +22,7 @@ static void setUp() {\n \n     settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n@@ -129,4 +128,118 @@ void testChangeMethodSignature() {\n     assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n     assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testRenameClass() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String source2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library123 {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(1);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String newVersion2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library123;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library123();\\n"\n+            + "}\\n";\n+\n+    List<String> originals = new LinkedList<>();\n+    List<String> newVersions = new LinkedList<>();\n+\n+    originals.add(source);\n+    originals.add(source2);\n+\n+    newVersions.add(newVersion);\n+    newVersions.add(newVersion2);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(originals, newVersions);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedClasses", refactoringCategory.getName());\n+    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+  }\n+\n+  @Test\n+  void testMoveMethod() throws IOException {\n+    String originalArray = TestUtils.readFile("original", "Array.java", null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+\n+    String newVersionArray =\n+        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+    String newVersionArrayStack =\n+        TestUtils.readFile(\n+            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+    String newVersionStack =\n+        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalArray);\n+    originalList.add(originalStack);\n+    originalList.add(originalArrayStack);\n+\n+    newVersionList.add(newVersionArray);\n+    newVersionList.add(newVersionStack);\n+    newVersionList.add(newVersionArrayStack);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("MovedMethods", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n\n    String newVersionArray =\n        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "d18a5d147ebcf0a40f031c5cf65e1b6fb0ac8c20",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "added",
            additions: 32,
            deletions: 0,
            patch:
              '@@ -0,0 +1,32 @@\n+package refactoring.crawler;\n+\n+import java.io.*;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Utils Class For Testing\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-29 13:55\n+ */\n+public class TestUtils {\n+  public static String readFile(String folder, String filename, String packageName)\n+      throws IOException {\n+    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n+    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n+    String st;\n+    StringBuilder sb = new StringBuilder();\n+    while ((st = bufferedReader.readLine()) != null) {\n+      sb.append(st);\n+      sb.append(System.getProperty("line.separator"));\n+    }\n+    String fileContent = sb.toString();\n+    if (packageName != null) {\n+      fileContent =\n+          fileContent.replace(\n+              "package refactoring.crawler.testMoveMethod;",\n+              "package refactoring.crawler.original;");\n+    }\n+    return fileContent;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(String folder, String filename, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent =\n          fileContent.replace(\n              "package refactoring.crawler.testMoveMethod;",\n              "package refactoring.crawler.original;");\n    }\n    return fileContent;\n  }\n}\n'
          },
          {
            sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
            filename: "src/test/java/refactoring/crawler/original/Array.java",
            status: "added",
            additions: 152,
            deletions: 0,
            patch:
              '@@ -0,0 +1,152 @@\n+package refactoring.crawler.original;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // 构造函数，传入数组的容量capacity构造Array\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.getLast());\n+  }\n+\n+  // 无参数的构造函数，默认数组的容量capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // 获取数组的容量\n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // 获取数组中的元素个数\n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // 返回数组是否为空\n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // 在index索引的位置插入一个新元素e\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // 向所有元素后添加一个新元素\n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // 在所有元素前添加一个新元素\n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // 获取index索引位置的元素\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // 修改index索引位置的元素为e\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // 查找数组中是否有元素e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // 从数组中删除index位置的元素, 返回删除的元素\n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // 从数组中删除第一个元素, 返回删除的元素\n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // 从数组中删除最后一个元素, 返回删除的元素\n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // 从数组中删除元素e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // 将数组空间的容量变成newCapacity大小\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
            filename:
              "src/test/java/refactoring/crawler/original/ArrayStack.java",
            status: "added",
            additions: 62,
            deletions: 0,
            patch:
              '@@ -0,0 +1,62 @@\n+package refactoring.crawler.original;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.array.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
            filename: "src/test/java/refactoring/crawler/original/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.original;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          },
          {
            sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Array.java",
            status: "added",
            additions: 148,
            deletions: 0,
            patch:
              '@@ -0,0 +1,148 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // 构造函数，传入数组的容量capacity构造Array\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  // 无参数的构造函数，默认数组的容量capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // 获取数组的容量\n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // 获取数组中的元素个数\n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // 返回数组是否为空\n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // 在index索引的位置插入一个新元素e\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // 向所有元素后添加一个新元素\n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // 在所有元素前添加一个新元素\n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // 获取index索引位置的元素\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // 修改index索引位置的元素为e\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // 查找数组中是否有元素e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // 从数组中删除index位置的元素, 返回删除的元素\n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // 从数组中删除第一个元素, 返回删除的元素\n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // 从数组中删除最后一个元素, 返回删除的元素\n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // 从数组中删除元素e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // 将数组空间的容量变成newCapacity大小\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/ArrayStack.java",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.peek());\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          }
        ]
      },
      {
        sha: "dd0b341819343cb1eededc8901d8252d943f4e71",
        message: "fix(test): fix change method signature detection failed",
        stats: {
          total: 2,
          additions: 1,
          deletions: 1
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "7c561f5ca55b8f558802d42395673ab9d92a5fa9"
          }
        ],
        committedAt: 1585495096000,
        changedFiles: [
          {
            sha: "da52b72d6129eeaaecc0171a5c6ec463564026b1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -76,7 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n-        updateFeedbackLoop(pair);\n+//        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n//        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          }
        ]
      },
      {
        sha: "7c561f5ca55b8f558802d42395673ab9d92a5fa9",
        message: "test(MovedMethodsDetection): test and fix",
        stats: {
          total: 101,
          additions: 90,
          deletions: 11
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ecedbb481795ccea9f78c784c875d04dbf7e2cf5"
          }
        ],
        committedAt: 1585494132000,
        changedFiles: [
          {
            sha: "d55b1786c1cbd3593a570a6f84796eac01d18305",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 12,
            deletions: 1,
            patch:
              "@@ -50,7 +50,7 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n    */\n   public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> refactoredNodes = new ArrayList<>();\n     List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n     return pruneFalsePositives(listWithFP);\n   }\n@@ -76,6 +76,7 @@ protected String extractPotentialRename(String parentClassOriginal) {\n         // candidates.remove(pair); acivating this line would fail to\n         // detect those cases when two\n         // types of refactorings happened to the same node\n+        updateFeedbackLoop(pair);\n       }\n     }\n     if (foundNewRefactoring) {\n@@ -84,6 +85,16 @@ protected String extractPotentialRename(String parentClassOriginal) {\n     return refactoredNodes;\n   }\n \n+  /** @param pair */\n+  private void updateFeedbackLoop(Node[] pair) {\n+    if (isRename()) {\n+      Node original = pair[0];\n+      Node renamed = pair[1];\n+      Dictionary<String, String> dict = getRenamingDictionary();\n+      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n+    }\n+  }\n+\n   public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n     List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n     for (Node[] pair : listWithFP) {",
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 5,
            deletions: 4,
            patch:
              "@@ -19,15 +19,16 @@ public RenameMethodDetection(\n    */\n   public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n     List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n     for (Node[] pair : prePrunedMethods) {\n       Node original = pair[0];\n       Node version = pair[1];\n       String parentClassOriginal = extractFullyQualifiedParentName(original);\n       String parentClassVersion = extractFullyQualifiedParentName(version);\n-      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-        candidatesWithSameParentClass.add(pair);\n+      boolean isTheSameModuloRename =\n+          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n+      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n     }\n \n     return candidatesWithSameParentClass;",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "d417febc4d7566232396eca5c9745c45efdea9d9",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 41,
            deletions: 6,
            patch:
              '@@ -5,10 +5,8 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import java.util.Dictionary;\n-import java.util.Hashtable;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.io.IOException;\n+import java.util.*;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n@@ -24,7 +22,7 @@ static void setUp() {\n \n     settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n@@ -185,7 +183,7 @@ void testRenameClass() {\n             + "package refactoring.a;\\n"\n             + "import refactoring.crawler.Library123;\\n"\n             + "public class A {\\n"\n-            + "private Library library = new Library();\\n"\n+            + "private Library library = new Library123();\\n"\n             + "}\\n";\n \n     List<String> originals = new LinkedList<>();\n@@ -207,4 +205,41 @@ void testRenameClass() {\n     assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n     assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n   }\n+\n+  @Test\n+  void testMoveMethod() throws IOException {\n+    String originalArray = TestUtils.readFile("original", "Array.java", null);\n+    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n+    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n+\n+    String newVersionArray =\n+        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n+    String newVersionArrayStack =\n+        TestUtils.readFile(\n+            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n+    String newVersionStack =\n+        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n+\n+    List<String> originalList = new ArrayList<>();\n+    List<String> newVersionList = new ArrayList<>();\n+\n+    originalList.add(originalArray);\n+    originalList.add(originalStack);\n+    originalList.add(originalArrayStack);\n+\n+    newVersionList.add(newVersionArray);\n+    newVersionList.add(newVersionStack);\n+    newVersionList.add(newVersionArrayStack);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n+    refactoringCrawler.detect(originalList, newVersionList);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals("MovedMethods", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n+    assertEquals(\n+        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null);\n\n    String newVersionArray =\n        TestUtils.readFile("testMoveMethod", "Array.java", "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod", "ArrayStack.java", "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile("testMoveMethod", "Stack.java", "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n}\n'
          },
          {
            sha: "d18a5d147ebcf0a40f031c5cf65e1b6fb0ac8c20",
            filename: "src/test/java/refactoring/crawler/TestUtils.java",
            status: "added",
            additions: 32,
            deletions: 0,
            patch:
              '@@ -0,0 +1,32 @@\n+package refactoring.crawler;\n+\n+import java.io.*;\n+\n+/**\n+ * @program: refactoring-crawler\n+ * @description: Utils Class For Testing\n+ * @author: laikinmeng\n+ * @package: ${IntelliJ IDEA}\n+ * @create: 2020-03-29 13:55\n+ */\n+public class TestUtils {\n+  public static String readFile(String folder, String filename, String packageName)\n+      throws IOException {\n+    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n+    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n+    String st;\n+    StringBuilder sb = new StringBuilder();\n+    while ((st = bufferedReader.readLine()) != null) {\n+      sb.append(st);\n+      sb.append(System.getProperty("line.separator"));\n+    }\n+    String fileContent = sb.toString();\n+    if (packageName != null) {\n+      fileContent =\n+          fileContent.replace(\n+              "package refactoring.crawler.testMoveMethod;",\n+              "package refactoring.crawler.original;");\n+    }\n+    return fileContent;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(String folder, String filename, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent =\n          fileContent.replace(\n              "package refactoring.crawler.testMoveMethod;",\n              "package refactoring.crawler.original;");\n    }\n    return fileContent;\n  }\n}\n'
          }
        ]
      },
      {
        sha: "ecedbb481795ccea9f78c784c875d04dbf7e2cf5",
        message:
          "feat(UseMemoryTypeSolver): parse to cu and added to memory type solver first",
        stats: {
          total: 31,
          additions: 31,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "d06c38c0ad3c96244a0f1ac69bf8ddfad2c85eaf"
          }
        ],
        committedAt: 1585494105000,
        changedFiles: [
          {
            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -2,8 +2,14 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import java.util.*;\n import lombok.Getter;\n@@ -37,10 +43,35 @@ public RefactoringCrawler(String projectName, Dictionary<Settings, Double> setti\n   }\n \n   private static List<CompilationUnit> parse(List<String> files) {\n+\n     TypeSolver typeSolver = new ReflectionTypeSolver();\n     JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n     StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n \n+    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n+      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n+      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n+        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n+          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n+        }\n+      }\n+      if (null != classOrInterfaceDeclaration) {\n+        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n+        if (fullyQualifiedName.isPresent()) {\n+          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n+              classOrInterfaceDeclaration.resolve();\n+          memoryTypeSolver.addDeclaration(\n+              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n+        }\n+      }\n+    }\n+\n+    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n+\n     List<CompilationUnit> resList = new LinkedList<>();\n     for (String source : files) {\n       CompilationUnit cu = StaticJavaParser.parse(source);",
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          }
        ]
      },
      {
        sha: "d06c38c0ad3c96244a0f1ac69bf8ddfad2c85eaf",
        message: "test(MovedMethodsDetection): add java file for testing",
        stats: {
          total: 456,
          additions: 456,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "51c79a1d70c10f3b81a73b9f67fef233e22f9b19"
          }
        ],
        committedAt: 1585494005000,
        changedFiles: [
          {
            sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
            filename: "src/test/java/refactoring/crawler/original/Array.java",
            status: "added",
            additions: 152,
            deletions: 0,
            patch:
              '@@ -0,0 +1,152 @@\n+package refactoring.crawler.original;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // 构造函数，传入数组的容量capacity构造Array\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.getLast());\n+  }\n+\n+  // 无参数的构造函数，默认数组的容量capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // 获取数组的容量\n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // 获取数组中的元素个数\n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // 返回数组是否为空\n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // 在index索引的位置插入一个新元素e\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // 向所有元素后添加一个新元素\n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // 在所有元素前添加一个新元素\n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // 获取index索引位置的元素\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // 修改index索引位置的元素为e\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // 查找数组中是否有元素e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // 从数组中删除index位置的元素, 返回删除的元素\n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // 从数组中删除第一个元素, 返回删除的元素\n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // 从数组中删除最后一个元素, 返回删除的元素\n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // 从数组中删除元素e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // 将数组空间的容量变成newCapacity大小\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
            filename:
              "src/test/java/refactoring/crawler/original/ArrayStack.java",
            status: "added",
            additions: 62,
            deletions: 0,
            patch:
              '@@ -0,0 +1,62 @@\n+package refactoring.crawler.original;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.array.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
            filename: "src/test/java/refactoring/crawler/original/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.original;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          },
          {
            sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Array.java",
            status: "added",
            additions: 148,
            deletions: 0,
            patch:
              '@@ -0,0 +1,148 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class Array<E> {\n+\n+  private E[] data;\n+  private int size;\n+\n+  // 构造函数，传入数组的容量capacity构造Array\n+  public Array(int capacity) {\n+    data = (E[]) new Object[capacity];\n+    size = 0;\n+  }\n+\n+  // 无参数的构造函数，默认数组的容量capacity=10\n+  public Array() {\n+    this(10);\n+  }\n+\n+  // 获取数组的容量\n+  public int getCapacity() {\n+    return data.length;\n+  }\n+\n+  // 获取数组中的元素个数\n+  public int getSize() {\n+    return size;\n+  }\n+\n+  // 返回数组是否为空\n+  public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  // 在index索引的位置插入一个新元素e\n+  public void add(int index, E e) {\n+\n+    if (index < 0 || index > size)\n+      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n+\n+    if (size == data.length) resize(2 * data.length);\n+\n+    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n+\n+    data[index] = e;\n+\n+    size++;\n+  }\n+\n+  // 向所有元素后添加一个新元素\n+  public void addLast(E e) {\n+    add(size, e);\n+  }\n+\n+  // 在所有元素前添加一个新元素\n+  public void addFirst(E e) {\n+    add(0, e);\n+  }\n+\n+  // 获取index索引位置的元素\n+  public E get(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Get failed. Index is illegal.");\n+    return data[index];\n+  }\n+\n+  public E getLast() {\n+    return get(size - 1);\n+  }\n+\n+  public E getFirst() {\n+    return get(0);\n+  }\n+\n+  // 修改index索引位置的元素为e\n+  public void set(int index, E e) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Set failed. Index is illegal.");\n+    data[index] = e;\n+  }\n+\n+  // 查找数组中是否有元素e\n+  public boolean contains(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return true;\n+    }\n+    return false;\n+  }\n+\n+  // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n+  public int find(E e) {\n+    for (int i = 0; i < size; i++) {\n+      if (data[i].equals(e)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  // 从数组中删除index位置的元素, 返回删除的元素\n+  public E remove(int index) {\n+    if (index < 0 || index >= size)\n+      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n+\n+    E ret = data[index];\n+    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n+    size--;\n+    data[size] = null; // loitering objects != memory leak\n+\n+    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n+    return ret;\n+  }\n+\n+  // 从数组中删除第一个元素, 返回删除的元素\n+  public E removeFirst() {\n+    return remove(0);\n+  }\n+\n+  // 从数组中删除最后一个元素, 返回删除的元素\n+  public E removeLast() {\n+    return remove(size - 1);\n+  }\n+\n+  // 从数组中删除元素e\n+  public void removeElement(E e) {\n+    int index = find(e);\n+    if (index != -1) remove(index);\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    StringBuilder res = new StringBuilder();\n+    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n+    res.append(\'[\');\n+    for (int i = 0; i < size; i++) {\n+      res.append(data[i]);\n+      if (i != size - 1) res.append(", ");\n+    }\n+    res.append(\']\');\n+    return res.toString();\n+  }\n+\n+  // 将数组空间的容量变成newCapacity大小\n+  private void resize(int newCapacity) {\n+\n+    E[] newData = (E[]) new Object[newCapacity];\n+    for (int i = 0; i < size; i++) newData[i] = data[i];\n+    data = newData;\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n'
          },
          {
            sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/ArrayStack.java",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public class ArrayStack<E> implements Stack<E> {\n+\n+  private Array<E> array;\n+\n+  public ArrayStack(int capacity) {\n+    array = new Array<>(capacity);\n+  }\n+\n+  public ArrayStack() {\n+    array = new Array<>();\n+  }\n+\n+  public void printLast() {\n+    System.out.println(this.peek());\n+  }\n+\n+  public void printFirstAndLast() {\n+    E first = this.array.getFirst();\n+    System.out.println(first);\n+    this.printLast();\n+  }\n+\n+  @Override\n+  public int getSize() {\n+    return array.getSize();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return array.isEmpty();\n+  }\n+\n+  public int getCapacity() {\n+    return array.getCapacity();\n+  }\n+\n+  @Override\n+  public void push(E e) {\n+    array.addLast(e);\n+  }\n+\n+  @Override\n+  public E pop() {\n+    return array.removeLast();\n+  }\n+\n+  @Override\n+  public E peek() {\n+    return array.getLast();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder res = new StringBuilder();\n+    res.append("Stack: ");\n+    res.append(\'[\');\n+    for (int i = 0; i < array.getSize(); i++) {\n+      res.append(array.get(i));\n+      if (i != array.getSize() - 1) res.append(", ");\n+    }\n+    res.append("] top");\n+    return res.toString();\n+  }\n+}',
            rawContent:
              'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
            filename:
              "src/test/java/refactoring/crawler/testMoveMethod/Stack.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.testMoveMethod;\n+\n+public interface Stack<E> {\n+\n+  int getSize();\n+\n+  boolean isEmpty();\n+\n+  void push(E e);\n+\n+  E pop();\n+\n+  E peek();\n+}",
            rawContent:
              "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n"
          }
        ]
      },
      {
        sha: "51c79a1d70c10f3b81a73b9f67fef233e22f9b19",
        message: "style(*): format code",
        stats: {
          total: 1413,
          additions: 704,
          deletions: 709
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "5547ee77aae8348fb47173c17db3bbe8bef88da0"
          }
        ],
        committedAt: 1585458717000,
        changedFiles: [
          {
            sha: "87155fad22f81e508316285eaa34f383811496b3",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 412,
            deletions: 417,
            patch:
              '@@ -1,7 +1,6 @@\n package refactoring.crawler.detection;\n \n import java.util.*;\n-\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n@@ -12,420 +11,416 @@\n \n public abstract class RefactoringDetection {\n \n-\t@Getter\n-\t@Setter\n-\tprivate double threshold;\n-\n-\tprotected NamedDirectedMultigraph graph1;\n-\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\tprivate double lowerThreshold;\n-\n-\t/**\n-\t * Dictionary contains <Original, Version> pairs for the renaming.\n-\t */\n-\tprivate static Dictionary<String, String> renamingDictionary;\n-\n-\tpublic static Dictionary<String, String> getRenamingDictionary() {\n-\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-\t\treturn renamingDictionary;\n-\t}\n-\n-\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tthis.graph1 = graph;\n-\t\tthis.graph2 = graph2;\n-\t}\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n-\n-\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-\tpublic abstract boolean isRename();\n-\n-\t/**\n-\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-\t * computeLikeliness and pruneOriginalCandidates.\n-\t */\n-\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-\t\treturn pruneFalsePositives(listWithFP);\n-\t}\n-\n-\tprotected String extractPotentialRename(String parentClassOriginal) {\n-\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n-\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n-\t}\n-\n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Node[] pair : prunedCandidates) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n-\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n-\t\t\t\t// detect those cases when two\n-\t\t\t\t// types of refactorings happened to the same node\n-\t\t\t}\n-\t\t}\n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n-\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n-\t\t\tif (originalInV2 != null) {\n-\t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-\t\t\t\tList<Edge> verIncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges =\n-\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n-\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n-\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n-\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Node node : verCallers) {\n-\t\t\t\t\tif (origInV2Callers.contains(node))\n-\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-\t\t\t\t// pair\n-\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n-\t\t\t\t// call sites\n-\t\t\t\t// should be different\n-\t\t\t\tfor (Node node : origInV1Callers) {\n-\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n-\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tlistWithFP.remove(pair);\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\n-\t\tpruneOverloadedMethodFP(listWithFP);\n-\n-\t\treturn listWithFP;\n-\t}\n-\n-\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<>();\n-\t\tfor (Edge edge : incomingEdges) {\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n-\n-\t/**\n-\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-\t *\n-\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-\t * because of a method overload.\n-\t *\n-\t * <p>This method is never called in the ChangeMethodSignature detection.\n-\t */\n-\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n-\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n-\t\t\tboolean hasSameNameAndSignature = false;\n-\t\t\tNode[] pair = listWithFP.get(i);\n-\t\t\tNode source = pair[0];\n-\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (hasSameNameAndSignature) {\n-\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-\t\t\tlistWithFP.remove(pair);\n-\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This takes into account the possible renaming in the parent of the node\n-\t *\n-\t * @param g        is the Version2 graph\n-\t * @param original is a node from Version1\n-\t * @return\n-\t */\n-\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tString fqnParent = extractFullyQualifiedParentName(original);\n-\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n-\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-\t\tNode parentNode = g.findNamedNode(fqnParent);\n-\n-\t\tif (parentNode != null) {\n-\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-\t\t\t\tEdge edge = (Edge) iter.next();\n-\t\t\t\tNode child = (Node) edge.getTarget();\n-\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n-\t\t\t\t\tif (original.getSignature() != null) {\n-\t\t\t\t\t\t// This handles the method nodes\n-\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n-\t\t\t\t\t} else\n-\t\t\t\t\t\t// Classes and packages\n-\t\t\t\t\t\treturn child;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (label.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\tprotected String extractFullyQualifiedParentName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\treturn extractFullyQualifiedParentName(originalName);\n-\t}\n-\n-\tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fq_parentName = "";\n-\t\tint lastIndex = originalName.lastIndexOf(".");\n-\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-\t\treturn fq_parentName;\n-\t}\n-\n-\t/**\n-\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-\t * IDE.openEditor(IWorkbenchPage, IFile)\n-\t */\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null) return false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/**\n-\t * This helper method takes a string containing the dot separated name of a node and it returns\n-\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-\t * class1)\n-\t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n-\t}\n-\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original))) return true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original\n-\t\t\t.substring(original.lastIndexOf("."))\n-\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-\t\telse return false;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t// TODO this is bug pruned\n-\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-\t\t//\t\ttry {\n-\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-\t\tresults.forEach(\n-\t\t\tresult -> {\n-\t\t\t\tif (graph.hasNamedNode(result))\n-\t\t\t\t\tgraph.addEdge(\n-\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n-\t\t\t});\n-\t\t// Possible change to methods that instantiate classes\n-\t\t// from class -> class edges.\n-\t\t//\t\t\tfor (String result : results) {\n-\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-\t\t//\t\t\t\tString callingNode = null;\n-\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n-\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n-\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n-\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n-\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-\t\t//\t\t\t\t\t// Workaround\n-\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += ".";\n-\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n-\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-\t\t// ASTNodes\n-\t\t//\t\t\t\t\t\t.getParent(initializer,\n-\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-\t\t//\t\t\t\t\t\tIType.class);\n-\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-\t\t//\t\t\t\t}\n-\t\t//\n-\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n-\t\t//\t\t\t\t// ImportDeclaration\n-\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n-\t\t//\t\t\t\t// Initializer\n-\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-\t\t//\t\t\t\t// Level\n-\t\t//\t\t\t\tif (callingNode == null) {\n-\t\t//\t\t\t\t\tSystem.out.print("");\n-\t\t//\t\t\t\t}\n-\t\t//\t\t\t\tif (callingNode != null) {\n-\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-\t\t//\t\t\t\t\tif (callerNode != null)\n-\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-\t\t//\t\t\t\t}\n-\t\t//\n-\t\t//\t\t\t}\n-\t\t//\n-\t\t//\t\t} catch (CoreException e) {\n-\t\t//\t\t\tJavaPlugin.log(e);\n-\t\t//\t\t}\n-\t}\n+  @Getter @Setter private double threshold;\n+\n+  protected NamedDirectedMultigraph graph1;\n+\n+  protected NamedDirectedMultigraph graph2;\n+\n+  private double lowerThreshold;\n+\n+  /** Dictionary contains <Original, Version> pairs for the renaming. */\n+  private static Dictionary<String, String> renamingDictionary;\n+\n+  public static Dictionary<String, String> getRenamingDictionary() {\n+    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+    return renamingDictionary;\n+  }\n+\n+  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    this.graph1 = graph;\n+    this.graph2 = graph2;\n+  }\n+\n+  public abstract double computeLikeliness(Node node1, Node node12);\n+\n+  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+  public abstract boolean isRename();\n+\n+  /**\n+   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+   * computeLikeliness and pruneOriginalCandidates.\n+   */\n+  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+    return pruneFalsePositives(listWithFP);\n+  }\n+\n+  protected String extractPotentialRename(String parentClassOriginal) {\n+    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+    return renamedName == null ? parentClassOriginal : renamedName;\n+  }\n+\n+  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+    boolean foundNewRefactoring = false;\n+    for (Node[] pair : prunedCandidates) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      double likeliness = computeLikeliness(original, version);\n+      if (likeliness >= threshold) {\n+        if (!refactoredNodes.contains(pair)) {\n+          refactoredNodes.add(pair);\n+          foundNewRefactoring = true;\n+        }\n+        // candidates.remove(pair); acivating this line would fail to\n+        // detect those cases when two\n+        // types of refactorings happened to the same node\n+      }\n+    }\n+    if (foundNewRefactoring) {\n+      doDetectRefactorings(candidates, refactoredNodes);\n+    }\n+    return refactoredNodes;\n+  }\n+\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+    for (Node[] pair : listWithFP) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+      if (originalInV2 != null) {\n+        createCallGraph(originalInV2, graph2);\n+        List<Edge> origIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+        List<Edge> verIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        List<Edge> origInVer1IncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+        List<Node> verCallers = getCallers(verIncomingEdges);\n+        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+        // since a call site cannot be calling both the old and the new entity at the same time\n+        for (Node node : verCallers) {\n+          if (origInV2Callers.contains(node))\n+            if (!nodesToRemove.contains(pair)) {\n+              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              nodesToRemove.add(pair);\n+            }\n+        }\n+\n+        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+        // pair\n+        // is a false positive (since there should be either no more callers for N1inV2 or their\n+        // call sites\n+        // should be different\n+        for (Node node : origInV1Callers) {\n+          for (Node callingNode : origInV2Callers) {\n+            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+              if (!nodesToRemove.contains(pair)) {\n+                nodesToRemove.add(pair);\n+              }\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    for (Node[] pair : nodesToRemove) {\n+      listWithFP.remove(pair);\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n+    }\n+\n+    pruneOverloadedMethodFP(listWithFP);\n+\n+    return listWithFP;\n+  }\n+\n+  private List<Node> getCallers(List<Edge> incomingEdges) {\n+    List<Node> callers = new ArrayList<>();\n+    for (Edge edge : incomingEdges) {\n+      callers.add(edge.getSource());\n+    }\n+    return callers;\n+  }\n+\n+  /**\n+   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+   *\n+   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+   * because of a method overload.\n+   *\n+   * <p>This method is never called in the ChangeMethodSignature detection.\n+   */\n+  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<>();\n+    for (int i = 0; i < listWithFP.size(); i++) {\n+      boolean hasSameNameAndSignature = false;\n+      Node[] pair = listWithFP.get(i);\n+      Node source = pair[0];\n+      for (int j = i; j < listWithFP.size(); j++) {\n+        Node[] pair2 = listWithFP.get(j);\n+        Node source2 = pair2[0];\n+        if (source.equals(source2)) {\n+          Node target2 = pair2[1];\n+          if (source.getSimpleName().equals(target2.getSimpleName()))\n+            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+        }\n+      }\n+      if (hasSameNameAndSignature) {\n+        for (int j = i; j < listWithFP.size(); j++) {\n+          Node[] pair2 = listWithFP.get(j);\n+          Node source2 = pair2[0];\n+          if (source.equals(source2)) {\n+            Node target2 = pair2[1];\n+            if (source.getSimpleName().equals(target2.getSimpleName()))\n+              if (!signatureEqualsModuloMoveMethod(source, target2))\n+                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+          }\n+        }\n+      }\n+    }\n+    for (Node[] pair : nodesToRemove) {\n+      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+      listWithFP.remove(pair);\n+\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n+    }\n+  }\n+\n+  /**\n+   * This takes into account the possible renaming in the parent of the node\n+   *\n+   * @param g is the Version2 graph\n+   * @param original is a node from Version1\n+   * @return\n+   */\n+  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    String fqnParent = extractFullyQualifiedParentName(original);\n+    String possiblyRenamedFQN = dictionary.get(fqnParent);\n+    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+    Node parentNode = g.findNamedNode(fqnParent);\n+\n+    if (parentNode != null) {\n+      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+        Edge edge = (Edge) iter.next();\n+        Node child = (Node) edge.getTarget();\n+        if (original.getSimpleName().equals(child.getSimpleName()))\n+          if (original.getSignature() != null) {\n+            // This handles the method nodes\n+            if (original.getSignature().equals(child.getSignature())) return child;\n+          } else\n+            // Classes and packages\n+            return child;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge edge : list) {\n+      if (label.equals(edge.getLabel())) {\n+        results.add(edge);\n+      }\n+    }\n+    return results;\n+  }\n+\n+  protected String extractFullyQualifiedParentName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    return extractFullyQualifiedParentName(originalName);\n+  }\n+\n+  public String extractFullyQualifiedParentName(String originalName) {\n+    String fq_parentName = "";\n+    int lastIndex = originalName.lastIndexOf(".");\n+    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+    return fq_parentName;\n+  }\n+\n+  /**\n+   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+   * IDE.openEditor(IWorkbenchPage, IFile)\n+   */\n+  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+    boolean retval = false;\n+\n+    if (source.getSignature() == null) return false;\n+\n+    retval = source.getSignature().equals(target.getSignature());\n+\n+    if (!retval && (this instanceof MoveMethodDetection)) {\n+      String sourceParent = extractParentSimpleName(source);\n+      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+      String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+      for (int i = 0; i < sourceTokens.length; i++) {\n+        sourceTokens[i] = sourceTokenizer.nextToken();\n+      }\n+\n+      for (int i = 0; i < targetTokens.length; i++) {\n+        targetTokens[i] = targetTokenizer.nextToken();\n+      }\n+\n+      if (targetTokens.length == sourceTokens.length + 1) {\n+        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+        else {\n+          for (int i = 0; i < sourceTokens.length; i++) {\n+            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+          }\n+          retval = true;\n+        }\n+      }\n+    }\n+    return retval;\n+  }\n+\n+  /**\n+   * This helper method takes a string containing the dot separated name of a node and it returns\n+   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+   * class1)\n+   */\n+  protected String extractParentSimpleName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+    return parentName;\n+  }\n+\n+  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+    double count = 0;\n+\n+    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+    for (Edge edge1 : edges1) {\n+      Node node1 = edge1.getSource();\n+      for (int i = 0; i < arrEdge2.length; i++) {\n+        Edge edge2 = arrEdge2[i];\n+        if (edge2 != null) {\n+          Node node2 = (Node) edge2.getSource();\n+          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+            count++;\n+            // we mark this edge as already counted so that we don\'t\n+            // count it\n+            // twice when there are multiple edges between two nodes\n+            arrEdge2[i] = null;\n+          }\n+        }\n+      }\n+    }\n+\n+    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+    return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  protected boolean isTheSameModuloRename(String original, String version) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    if (version.equals(dictionary.get(original))) return true;\n+    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+      return original.equals(version);\n+    else if (original\n+        .substring(original.lastIndexOf("."))\n+        .equals(version.substring(version.lastIndexOf("."))))\n+      return isTheSameModuloRename(\n+          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+    else return false;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+        if (pair[0].isAPI() && pair[1].isAPI()) {\n+          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+          if ((n2inV1 == null)) {\n+            prunedCandidates.add(pair);\n+          }\n+        }\n+      }\n+    }\n+    return prunedCandidates;\n+  }\n+\n+  // TODO this is bug pruned\n+  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    //\t\ttry {\n+    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+    results.forEach(\n+        result -> {\n+          if (graph.hasNamedNode(result))\n+            graph.addEdge(\n+                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n+        });\n+    // Possible change to methods that instantiate classes\n+    // from class -> class edges.\n+    //\t\t\tfor (String result : results) {\n+    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+    //\t\t\t\tString callingNode = null;\n+    //\t\t\t\tif (resultNode instanceof IMethod) {\n+    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof IType) {\n+    //\t\t\t\t\tIType rst = (IType) resultNode;\n+    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t} else if (resultNode instanceof IField) {\n+    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+    //\t\t\t\t\t// Workaround\n+    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += ".";\n+    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+    // ASTNodes\n+    //\t\t\t\t\t\t.getParent(initializer,\n+    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+    //\t\t\t\t\t\tIType.class);\n+    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// ImportDeclaration\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// Initializer\n+    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+    //\t\t\t\t// Level\n+    //\t\t\t\tif (callingNode == null) {\n+    //\t\t\t\t\tSystem.out.print("");\n+    //\t\t\t\t}\n+    //\t\t\t\tif (callingNode != null) {\n+    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+    //\t\t\t\t\tif (callerNode != null)\n+    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t}\n+    //\n+    //\t\t} catch (CoreException e) {\n+    //\t\t\tJavaPlugin.log(e);\n+    //\t\t}\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 53,
            deletions: 53,
            patch:
              "@@ -2,63 +2,63 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-\n import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n-\tpublic static List<String> findFieldReferences(FieldNode node) {\n-\t\treturn node.getFieldReferenceToMethod();\n-\t}\n+  public static List<String> findFieldReferences(FieldNode node) {\n+    return node.getFieldReferenceToMethod();\n+  }\n \n-\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n-\t\treturn node.getSuperClasses();\n-\t}\n+  public static List<String> findSuperClassesOf(ClassNode node) {\n+    return node.getSuperClasses();\n+  }\n \n-\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n-//    return node.getClassesImported();\n-\t\tList<String> res = new LinkedList<>();\n-\t\tfor (Node n : graph.vertexSet()) {\n-\t\t\tif (n.getType() == Node.Type.CLASS) {\n-\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n-\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn res;\n-\t}\n+  public static List<String> findClassReferences(\n+      NamedDirectedMultigraph graph, ClassNode classNode) {\n+    //    return node.getClassesImported();\n+    List<String> res = new LinkedList<>();\n+    for (Node n : graph.vertexSet()) {\n+      if (n.getType() == Node.Type.CLASS) {\n+        for (String imported : ((ClassNode) n).getClassesImported()) {\n+          if (imported.equals(classNode.getFullyQualifiedName())) {\n+            res.add(n.getFullyQualifiedName());\n+          }\n+        }\n+      }\n+    }\n+    return res;\n+  }\n \n-\tpublic static List<String> findMethodCallers(\n-\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-\t\treturn graph\n-\t\t\t.vertexSet()\n-\t\t\t.stream()\n-\t\t\t.filter(n -> (n instanceof MethodNode))\n-\t\t\t.map(methodNode -> (MethodNode) methodNode)\n-\t\t\t.filter(\n-\t\t\t\tmethodNode ->\n-\t\t\t\t\tmethodNode\n-\t\t\t\t\t\t.getCalledInside()\n-\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t.anyMatch(\n-\t\t\t\t\t\t\tcalledMethod -> {\n-\t\t\t\t\t\t\t\tString expect =\n-\t\t\t\t\t\t\t\t\twithSignature\n-\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n-\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n-\t\t\t\t\t\t\t\tString actual =\n-\t\t\t\t\t\t\t\t\twithSignature\n-\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n-\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n-\t\t\t\t\t\t\t\treturn expect.equals(actual);\n-\t\t\t\t\t\t\t}))\n-\t\t\t.map(\n-\t\t\t\tmethodNode -> {\n-\t\t\t\t\treturn withSignature\n-\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n-\t\t\t\t})\n-\t\t\t.collect(Collectors.toList());\n-\t}\n+  public static List<String> findMethodCallers(\n+      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+    return graph\n+        .vertexSet()\n+        .stream()\n+        .filter(n -> (n instanceof MethodNode))\n+        .map(methodNode -> (MethodNode) methodNode)\n+        .filter(\n+            methodNode ->\n+                methodNode\n+                    .getCalledInside()\n+                    .stream()\n+                    .anyMatch(\n+                        calledMethod -> {\n+                          String expect =\n+                              withSignature\n+                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                          String actual =\n+                              withSignature\n+                                  ? node.getFullyQualifiedName() + node.getSignature()\n+                                  : node.getFullyQualifiedName();\n+                          return expect.equals(actual);\n+                        }))\n+        .map(\n+            methodNode -> {\n+              return withSignature\n+                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                  : methodNode.getFullyQualifiedName();\n+            })\n+        .collect(Collectors.toList());\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "f069e44153341cbf9da6818393293f5e7e9ac108",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 48,
            deletions: 49,
            patch:
              "@@ -2,59 +2,58 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import refactoring.crawler.graph.Edge;\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n-\t}\n-\n-\t/**\n-\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-\t * computeLikelinessIncomingEdges in RefactoringDetection\n-\t *\n-\t * @param nodeOriginal\n-\t * @param nodeVersion\n-\t * @return\n-\t */\n-\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal =\n-\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion =\n-\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-\t\tfor (Node[] pair : prePruned) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n-\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n-\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentPackage;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+  }\n+\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+  }\n+\n+  /**\n+   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+   * computeLikelinessIncomingEdges in RefactoringDetection\n+   *\n+   * @param nodeOriginal\n+   * @param nodeVersion\n+   * @return\n+   */\n+  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+    for (Node[] pair : prePruned) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractParentSimpleName(original);\n+      String parentPackageVersion = extractParentSimpleName(version);\n+      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithSameParentPackage.add(pair);\n+      }\n+    }\n+\n+    return candidatesWithSameParentPackage;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n"
          },
          {
            sha: "d3e68342476ab78bcaf0e3af02c379adf650eb64",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 191,
            deletions: 190,
            patch:
              '@@ -9,201 +9,202 @@\n import java.util.Hashtable;\n import java.util.LinkedList;\n import java.util.List;\n-\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n-\n-\t@BeforeAll\n-\tstatic void setUp() {\n-\t\tsettings = new Hashtable<>();\n-\n-\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-\t}\n-\n-\t@Test\n-\tvoid testRenameMethod() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo12() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(source, newVersion);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n-\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n-\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n-\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n-\t}\n-\n-\t@Test\n-\tvoid testChangeMethodSignature() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(source, newVersion);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tRefactoringCategory refactoringCategory = categories.get(0);\n-\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n-\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n-\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n-\t}\n-\n-\t@Test\n-\tvoid testRenameClass() {\n-\t\tString source =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\t\tString source2 = "/*\\n"\n-\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t+ " */\\n"\n-\t\t\t+ "package refactoring.a;\\n"\n-\t\t\t+ "import refactoring.crawler.Library;\\n"\n-\t\t\t+ "public class A {\\n"\n-\t\t\t+ "private Library library = new Library();\\n"\n-\t\t\t+ "}\\n";\n-\t\tString newVersion =\n-\t\t\t"/*\\n"\n-\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t\t+ " */\\n"\n-\t\t\t\t+ "package refactoring.crawler;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "public class Library123 {\\n"\n-\t\t\t\t+ "\\tprivate int a;\\n"\n-\t\t\t\t+ "\\tprivate int b;\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void foo() {\\n"\n-\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "\\n"\n-\t\t\t\t+ "\\tpublic void bar() {\\n"\n-\t\t\t\t+ "\\t\\tthis.foo();\\n"\n-\t\t\t\t+ "\\t}\\n"\n-\t\t\t\t+ "}\\n";\n-\t\tString newVersion2 = "/*\\n"\n-\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-\t\t\t+ " */\\n"\n-\t\t\t+ "package refactoring.a;\\n"\n-\t\t\t+ "import refactoring.crawler.Library123;\\n"\n-\t\t\t+ "public class A {\\n"\n-\t\t\t+ "private Library library = new Library();\\n"\n-\t\t\t+ "}\\n";\n-\n-\t\tList<String> originals = new LinkedList<>();\n-\t\tList<String> newVersions = new LinkedList<>();\n-\n-\t\toriginals.add(source);\n-\t\toriginals.add(source2);\n-\n-\t\tnewVersions.add(newVersion);\n-\t\tnewVersions.add(newVersion2);\n-\n-\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-\t\trefactoringCrawler.detect(originals, newVersions);\n-\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-\t\tRefactoringCategory refactoringCategory = categories.get(0);\n-\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-\t\tassertEquals(1, categories.size());\n-\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n-\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n-\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n-\t}\n+  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    settings = new Hashtable<>();\n+\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+  }\n+\n+  @Test\n+  void testRenameMethod() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo12() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo12();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedMethods", categories.get(0).getName());\n+    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+  }\n+\n+  @Test\n+  void testChangeMethodSignature() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo(int i) {\\n"\n+            + "\\t\\tSystem.out.println(i);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo(1);\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n+  }\n+\n+  @Test\n+  void testRenameClass() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String source2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library123 {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(1);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+    String newVersion2 =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.a;\\n"\n+            + "import refactoring.crawler.Library123;\\n"\n+            + "public class A {\\n"\n+            + "private Library library = new Library();\\n"\n+            + "}\\n";\n+\n+    List<String> originals = new LinkedList<>();\n+    List<String> newVersions = new LinkedList<>();\n+\n+    originals.add(source);\n+    originals.add(source2);\n+\n+    newVersions.add(newVersion);\n+    newVersions.add(newVersion2);\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(originals, newVersions);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedClasses", refactoringCategory.getName());\n+    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n}\n'
          }
        ]
      },
      {
        sha: "5547ee77aae8348fb47173c17db3bbe8bef88da0",
        message: "test(RenameClasses): test rename classes",
        stats: {
          total: 1332,
          additions: 712,
          deletions: 620
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "fed214ccff862674ed63f5dd5f017cda31b6ef80"
          }
        ],
        committedAt: 1585458618000,
        changedFiles: [
          {
            sha: "10e10408f92f26211f650f1c23409f3eee6b05b5",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 417,
            deletions: 412,
            patch:
              '@@ -1,6 +1,7 @@\n package refactoring.crawler.detection;\n \n import java.util.*;\n+\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n@@ -11,416 +12,420 @@\n \n public abstract class RefactoringDetection {\n \n-  @Getter @Setter private double threshold;\n-\n-  protected NamedDirectedMultigraph graph1;\n-\n-  protected NamedDirectedMultigraph graph2;\n-\n-  private double lowerThreshold;\n-\n-  /** Dictionary contains <Original, Version> pairs for the renaming. */\n-  private static Dictionary<String, String> renamingDictionary;\n-\n-  public static Dictionary<String, String> getRenamingDictionary() {\n-    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-    return renamingDictionary;\n-  }\n-\n-  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-    this.graph1 = graph;\n-    this.graph2 = graph2;\n-  }\n-\n-  public abstract double computeLikeliness(Node node1, Node node12);\n-\n-  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-  public abstract boolean isRename();\n-\n-  /**\n-   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-   * computeLikeliness and pruneOriginalCandidates.\n-   */\n-  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-    return pruneFalsePositives(listWithFP);\n-  }\n-\n-  protected String extractPotentialRename(String parentClassOriginal) {\n-    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n-    return renamedName == null ? parentClassOriginal : renamedName;\n-  }\n-\n-  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-    boolean foundNewRefactoring = false;\n-    for (Node[] pair : prunedCandidates) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      double likeliness = computeLikeliness(original, version);\n-      if (likeliness >= threshold) {\n-        if (!refactoredNodes.contains(pair)) {\n-          refactoredNodes.add(pair);\n-          foundNewRefactoring = true;\n-        }\n-        // candidates.remove(pair); acivating this line would fail to\n-        // detect those cases when two\n-        // types of refactorings happened to the same node\n-      }\n-    }\n-    if (foundNewRefactoring) {\n-      doDetectRefactorings(candidates, refactoredNodes);\n-    }\n-    return refactoredNodes;\n-  }\n-\n-  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-    for (Node[] pair : listWithFP) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-      if (originalInV2 != null) {\n-        createCallGraph(originalInV2, graph2);\n-        List<Edge> origIncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-        List<Edge> verIncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-        List<Edge> origInVer1IncomingEdges =\n-            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-        List<Node> verCallers = getCallers(verIncomingEdges);\n-        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-        // since a call site cannot be calling both the old and the new entity at the same time\n-        for (Node node : verCallers) {\n-          if (origInV2Callers.contains(node))\n-            if (!nodesToRemove.contains(pair)) {\n-              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-              nodesToRemove.add(pair);\n-            }\n-        }\n-\n-        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-        // pair\n-        // is a false positive (since there should be either no more callers for N1inV2 or their\n-        // call sites\n-        // should be different\n-        for (Node node : origInV1Callers) {\n-          for (Node callingNode : origInV2Callers) {\n-            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-              if (!nodesToRemove.contains(pair)) {\n-                nodesToRemove.add(pair);\n-              }\n-              break;\n-            }\n-          }\n-        }\n-      }\n-    }\n-    for (Node[] pair : nodesToRemove) {\n-      listWithFP.remove(pair);\n-      Dictionary<String, String> dictionary = getRenamingDictionary();\n-      dictionary.remove(pair[0].getFullyQualifiedName());\n-    }\n-\n-    pruneOverloadedMethodFP(listWithFP);\n-\n-    return listWithFP;\n-  }\n-\n-  private List<Node> getCallers(List<Edge> incomingEdges) {\n-    List<Node> callers = new ArrayList<>();\n-    for (Edge edge : incomingEdges) {\n-      callers.add(edge.getSource());\n-    }\n-    return callers;\n-  }\n-\n-  /**\n-   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-   *\n-   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-   * because of a method overload.\n-   *\n-   * <p>This method is never called in the ChangeMethodSignature detection.\n-   */\n-  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-    List<Node[]> nodesToRemove = new ArrayList<>();\n-    for (int i = 0; i < listWithFP.size(); i++) {\n-      boolean hasSameNameAndSignature = false;\n-      Node[] pair = listWithFP.get(i);\n-      Node source = pair[0];\n-      for (int j = i; j < listWithFP.size(); j++) {\n-        Node[] pair2 = listWithFP.get(j);\n-        Node source2 = pair2[0];\n-        if (source.equals(source2)) {\n-          Node target2 = pair2[1];\n-          if (source.getSimpleName().equals(target2.getSimpleName()))\n-            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-        }\n-      }\n-      if (hasSameNameAndSignature) {\n-        for (int j = i; j < listWithFP.size(); j++) {\n-          Node[] pair2 = listWithFP.get(j);\n-          Node source2 = pair2[0];\n-          if (source.equals(source2)) {\n-            Node target2 = pair2[1];\n-            if (source.getSimpleName().equals(target2.getSimpleName()))\n-              if (!signatureEqualsModuloMoveMethod(source, target2))\n-                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-          }\n-        }\n-      }\n-    }\n-    for (Node[] pair : nodesToRemove) {\n-      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-      listWithFP.remove(pair);\n-\n-      Dictionary<String, String> dictionary = getRenamingDictionary();\n-      dictionary.remove(pair[0].getFullyQualifiedName());\n-    }\n-  }\n-\n-  /**\n-   * This takes into account the possible renaming in the parent of the node\n-   *\n-   * @param g is the Version2 graph\n-   * @param original is a node from Version1\n-   * @return\n-   */\n-  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-    Dictionary<String, String> dictionary = getRenamingDictionary();\n-    String fqnParent = extractFullyQualifiedParentName(original);\n-    String possiblyRenamedFQN = dictionary.get(fqnParent);\n-    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-    Node parentNode = g.findNamedNode(fqnParent);\n-\n-    if (parentNode != null) {\n-      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-        Edge edge = (Edge) iter.next();\n-        Node child = (Node) edge.getTarget();\n-        if (original.getSimpleName().equals(child.getSimpleName()))\n-          if (original.getSignature() != null) {\n-            // This handles the method nodes\n-            if (original.getSignature().equals(child.getSignature())) return child;\n-          } else\n-            // Classes and packages\n-            return child;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-    List<Edge> results = new ArrayList<>();\n-    for (Edge edge : list) {\n-      if (label.equals(edge.getLabel())) {\n-        results.add(edge);\n-      }\n-    }\n-    return results;\n-  }\n-\n-  protected String extractFullyQualifiedParentName(Node original) {\n-    String originalName = original.getFullyQualifiedName();\n-    return extractFullyQualifiedParentName(originalName);\n-  }\n-\n-  public String extractFullyQualifiedParentName(String originalName) {\n-    String fq_parentName = "";\n-    int lastIndex = originalName.lastIndexOf(".");\n-    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-    return fq_parentName;\n-  }\n-\n-  /**\n-   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-   * IDE.openEditor(IWorkbenchPage, IFile)\n-   */\n-  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-    boolean retval = false;\n-\n-    if (source.getSignature() == null) return false;\n-\n-    retval = source.getSignature().equals(target.getSignature());\n-\n-    if (!retval && (this instanceof MoveMethodDetection)) {\n-      String sourceParent = extractParentSimpleName(source);\n-      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-      String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-      for (int i = 0; i < sourceTokens.length; i++) {\n-        sourceTokens[i] = sourceTokenizer.nextToken();\n-      }\n-\n-      for (int i = 0; i < targetTokens.length; i++) {\n-        targetTokens[i] = targetTokenizer.nextToken();\n-      }\n-\n-      if (targetTokens.length == sourceTokens.length + 1) {\n-        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n-        else {\n-          for (int i = 0; i < sourceTokens.length; i++) {\n-            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-          }\n-          retval = true;\n-        }\n-      }\n-    }\n-    return retval;\n-  }\n-\n-  /**\n-   * This helper method takes a string containing the dot separated name of a node and it returns\n-   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-   * class1)\n-   */\n-  protected String extractParentSimpleName(Node original) {\n-    String originalName = original.getFullyQualifiedName();\n-    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-    return parentName;\n-  }\n-\n-  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-    double count = 0;\n-\n-    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-    for (Edge edge1 : edges1) {\n-      Node node1 = edge1.getSource();\n-      for (int i = 0; i < arrEdge2.length; i++) {\n-        Edge edge2 = arrEdge2[i];\n-        if (edge2 != null) {\n-          Node node2 = (Node) edge2.getSource();\n-          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-            count++;\n-            // we mark this edge as already counted so that we don\'t\n-            // count it\n-            // twice when there are multiple edges between two nodes\n-            arrEdge2[i] = null;\n-          }\n-        }\n-      }\n-    }\n-\n-    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-    return (fraction1 + fraction2) / 2.0;\n-  }\n-\n-  protected boolean isTheSameModuloRename(String original, String version) {\n-    Dictionary<String, String> dictionary = getRenamingDictionary();\n-    if (version.equals(dictionary.get(original))) return true;\n-    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-      return original.equals(version);\n-    else if (original\n-        .substring(original.lastIndexOf("."))\n-        .equals(version.substring(version.lastIndexOf("."))))\n-      return isTheSameModuloRename(\n-          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-    else return false;\n-  }\n-\n-  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-    List<Node[]> prunedCandidates = new ArrayList<>();\n-    for (Node[] pair : candidates) {\n-      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-        if (pair[0].isAPI() && pair[1].isAPI()) {\n-          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-          if ((n2inV1 == null)) {\n-            prunedCandidates.add(pair);\n-          }\n-        }\n-      }\n-    }\n-    return prunedCandidates;\n-  }\n-\n-  // TODO this is bug pruned\n-  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-    //\t\ttry {\n-    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-    results.forEach(\n-        result -> {\n-          if (graph.hasNamedNode(result))\n-            graph.addEdge(\n-                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-        });\n-    // Possible change to methods that instantiate classes\n-    // from class -> class edges.\n-    //\t\t\tfor (String result : results) {\n-    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-    //\t\t\t\tString callingNode = null;\n-    //\t\t\t\tif (resultNode instanceof IMethod) {\n-    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-    //\t\t\t\t} else if (resultNode instanceof IType) {\n-    //\t\t\t\t\tIType rst = (IType) resultNode;\n-    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t} else if (resultNode instanceof IField) {\n-    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-    //\t\t\t\t\t// Workaround\n-    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += ".";\n-    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n-    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-    // ASTNodes\n-    //\t\t\t\t\t\t.getParent(initializer,\n-    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-    //\t\t\t\t\t\tIType.class);\n-    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-    //\t\t\t\t}\n-    //\n-    //\t\t\t\t// TODO treat the case when resultNode is instance of\n-    //\t\t\t\t// ImportDeclaration\n-    //\t\t\t\t// TODO treat the case when resultNode is instance of\n-    //\t\t\t\t// Initializer\n-    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-    //\t\t\t\t// Level\n-    //\t\t\t\tif (callingNode == null) {\n-    //\t\t\t\t\tSystem.out.print("");\n-    //\t\t\t\t}\n-    //\t\t\t\tif (callingNode != null) {\n-    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-    //\t\t\t\t\tif (callerNode != null)\n-    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-    //\t\t\t\t}\n-    //\n-    //\t\t\t}\n-    //\n-    //\t\t} catch (CoreException e) {\n-    //\t\t\tJavaPlugin.log(e);\n-    //\t\t}\n-  }\n+\t@Getter\n+\t@Setter\n+\tprivate double threshold;\n+\n+\tprotected NamedDirectedMultigraph graph1;\n+\n+\tprotected NamedDirectedMultigraph graph2;\n+\n+\tprivate double lowerThreshold;\n+\n+\t/**\n+\t * Dictionary contains <Original, Version> pairs for the renaming.\n+\t */\n+\tprivate static Dictionary<String, String> renamingDictionary;\n+\n+\tpublic static Dictionary<String, String> getRenamingDictionary() {\n+\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+\t\treturn renamingDictionary;\n+\t}\n+\n+\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tthis.graph1 = graph;\n+\t\tthis.graph2 = graph2;\n+\t}\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tpublic abstract boolean isRename();\n+\n+\t/**\n+\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+\t * computeLikeliness and pruneOriginalCandidates.\n+\t */\n+\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+\t\treturn pruneFalsePositives(listWithFP);\n+\t}\n+\n+\tprotected String extractPotentialRename(String parentClassOriginal) {\n+\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n+\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n+\t}\n+\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Node[] pair : prunedCandidates) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n+\t\t\t\t}\n+\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n+\t\t\t\t// detect those cases when two\n+\t\t\t\t// types of refactorings happened to the same node\n+\t\t\t}\n+\t\t}\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n+\t}\n+\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n+\t\t\tif (originalInV2 != null) {\n+\t\t\t\tcreateCallGraph(originalInV2, graph2);\n+\t\t\t\tList<Edge> origIncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+\t\t\t\tList<Edge> verIncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges =\n+\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n+\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n+\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n+\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n+\t\t\t\tfor (Node node : verCallers) {\n+\t\t\t\t\tif (origInV2Callers.contains(node))\n+\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+\t\t\t\t// pair\n+\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n+\t\t\t\t// call sites\n+\t\t\t\t// should be different\n+\t\t\t\tfor (Node node : origInV1Callers) {\n+\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n+\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tlistWithFP.remove(pair);\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\n+\t\tpruneOverloadedMethodFP(listWithFP);\n+\n+\t\treturn listWithFP;\n+\t}\n+\n+\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<>();\n+\t\tfor (Edge edge : incomingEdges) {\n+\t\t\tcallers.add(edge.getSource());\n+\t\t}\n+\t\treturn callers;\n+\t}\n+\n+\t/**\n+\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+\t *\n+\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+\t * because of a method overload.\n+\t *\n+\t * <p>This method is never called in the ChangeMethodSignature detection.\n+\t */\n+\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n+\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n+\t\t\tboolean hasSameNameAndSignature = false;\n+\t\t\tNode[] pair = listWithFP.get(i);\n+\t\t\tNode source = pair[0];\n+\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (hasSameNameAndSignature) {\n+\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+\t\t\tlistWithFP.remove(pair);\n+\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This takes into account the possible renaming in the parent of the node\n+\t *\n+\t * @param g        is the Version2 graph\n+\t * @param original is a node from Version1\n+\t * @return\n+\t */\n+\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tString fqnParent = extractFullyQualifiedParentName(original);\n+\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n+\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+\t\tNode parentNode = g.findNamedNode(fqnParent);\n+\n+\t\tif (parentNode != null) {\n+\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+\t\t\t\tEdge edge = (Edge) iter.next();\n+\t\t\t\tNode child = (Node) edge.getTarget();\n+\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n+\t\t\t\t\tif (original.getSignature() != null) {\n+\t\t\t\t\t\t// This handles the method nodes\n+\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n+\t\t\t\t\t} else\n+\t\t\t\t\t\t// Classes and packages\n+\t\t\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (label.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tprotected String extractFullyQualifiedParentName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\treturn extractFullyQualifiedParentName(originalName);\n+\t}\n+\n+\tpublic String extractFullyQualifiedParentName(String originalName) {\n+\t\tString fq_parentName = "";\n+\t\tint lastIndex = originalName.lastIndexOf(".");\n+\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+\t\treturn fq_parentName;\n+\t}\n+\n+\t/**\n+\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+\t * IDE.openEditor(IWorkbenchPage, IFile)\n+\t */\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n+\n+\t\tif (source.getSignature() == null) return false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+\t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a node and it returns\n+\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+\t * class1)\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n+\t}\n+\n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n+\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original))) return true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original\n+\t\t\t.substring(original.lastIndexOf("."))\n+\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+\t\telse return false;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\t// TODO this is bug pruned\n+\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+\t\t//\t\ttry {\n+\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+\t\tresults.forEach(\n+\t\t\tresult -> {\n+\t\t\t\tif (graph.hasNamedNode(result))\n+\t\t\t\t\tgraph.addEdge(\n+\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n+\t\t\t});\n+\t\t// Possible change to methods that instantiate classes\n+\t\t// from class -> class edges.\n+\t\t//\t\t\tfor (String result : results) {\n+\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+\t\t//\t\t\t\tString callingNode = null;\n+\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n+\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n+\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n+\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n+\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+\t\t//\t\t\t\t\t// Workaround\n+\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += ".";\n+\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n+\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+\t\t// ASTNodes\n+\t\t//\t\t\t\t\t\t.getParent(initializer,\n+\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+\t\t//\t\t\t\t\t\tIType.class);\n+\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+\t\t//\t\t\t\t}\n+\t\t//\n+\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n+\t\t//\t\t\t\t// ImportDeclaration\n+\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n+\t\t//\t\t\t\t// Initializer\n+\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+\t\t//\t\t\t\t// Level\n+\t\t//\t\t\t\tif (callingNode == null) {\n+\t\t//\t\t\t\t\tSystem.out.print("");\n+\t\t//\t\t\t\t}\n+\t\t//\t\t\t\tif (callingNode != null) {\n+\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+\t\t//\t\t\t\t\tif (callerNode != null)\n+\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+\t\t//\t\t\t\t}\n+\t\t//\n+\t\t//\t\t\t}\n+\t\t//\n+\t\t//\t\t} catch (CoreException e) {\n+\t\t//\t\t\tJavaPlugin.log(e);\n+\t\t//\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n\t * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n\t * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges =\n\t\t\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n\t\t\t\t// pair\n\t\t\t\t// is a false positive (since there should be either no more callers for N1inV2 or their\n\t\t\t\t// call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n\t *\n\t * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n\t * because of a method overload.\n\t *\n\t * <p>This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature().equals(child.getSignature())) return child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null) return false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent)) return false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a node and it returns\n\t * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n\t * class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original))) return true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original\n\t\t\t.substring(original.lastIndexOf("."))\n\t\t\t.equals(version.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n\t\telse return false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t// TODO this is bug pruned\n\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n\t\t//\t\ttry {\n\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n\t\tresults.forEach(\n\t\t\tresult -> {\n\t\t\t\tif (graph.hasNamedNode(result))\n\t\t\t\t\tgraph.addEdge(\n\t\t\t\t\t\tgraph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n\t\t\t});\n\t\t// Possible change to methods that instantiate classes\n\t\t// from class -> class edges.\n\t\t//\t\t\tfor (String result : results) {\n\t\t////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n\t\t//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n\t\t//\t\t\t\tString callingNode = null;\n\t\t//\t\t\t\tif (resultNode instanceof IMethod) {\n\t\t//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n\t\t//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n\t\t//\t\t\t\t} else if (resultNode instanceof IType) {\n\t\t//\t\t\t\t\tIType rst = (IType) resultNode;\n\t\t//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t} else if (resultNode instanceof IField) {\n\t\t//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n\t\t//\t\t\t\t\t// Workaround\n\t\t//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n\t\t//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += ".";\n\t\t//\t\t\t\t\tcallingNode += rsf1.getElementName();\n\t\t//\t\t\t\t} else if (resultNode instanceof Initializer) {\n\t\t//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n\t\t//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n\t\t// ASTNodes\n\t\t//\t\t\t\t\t\t.getParent(initializer,\n\t\t//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n\t\t//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n\t\t//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n\t\t//\t\t\t\t\t\tIType.class);\n\t\t//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n\t\t//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n\t\t//\t\t\t\t}\n\t\t//\n\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n\t\t//\t\t\t\t// ImportDeclaration\n\t\t//\t\t\t\t// TODO treat the case when resultNode is instance of\n\t\t//\t\t\t\t// Initializer\n\t\t//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n\t\t//\t\t\t\t// Level\n\t\t//\t\t\t\tif (callingNode == null) {\n\t\t//\t\t\t\t\tSystem.out.print("");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tif (callingNode != null) {\n\t\t//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n\t\t//\t\t\t\t\tif (callerNode != null)\n\t\t//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n\t\t//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n\t\t//\t\t\t\t}\n\t\t//\n\t\t//\t\t\t}\n\t\t//\n\t\t//\t\t} catch (CoreException e) {\n\t\t//\t\t\tJavaPlugin.log(e);\n\t\t//\t\t}\n\t}\n}\n'
          },
          {
            sha: "f09ca701b33f45cc7fde18db284114c3d50a6da8",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 54,
            deletions: 45,
            patch:
              "@@ -2,54 +2,63 @@\n \n import java.util.*;\n import java.util.stream.Collectors;\n-import refactoring.crawler.graph.ClassNode;\n-import refactoring.crawler.graph.FieldNode;\n-import refactoring.crawler.graph.MethodNode;\n-import refactoring.crawler.graph.NamedDirectedMultigraph;\n+\n+import refactoring.crawler.graph.*;\n \n public class SearchHelper {\n-  public static List<String> findFieldReferences(FieldNode node) {\n-    return node.getFieldReferenceToMethod();\n-  }\n+\tpublic static List<String> findFieldReferences(FieldNode node) {\n+\t\treturn node.getFieldReferenceToMethod();\n+\t}\n \n-  public static List<String> findSuperClassesOf(ClassNode node) {\n-    return node.getSuperClasses();\n-  }\n+\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n+\t\treturn node.getSuperClasses();\n+\t}\n \n-  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-    return node.getClassesImported();\n-  }\n+\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n+//    return node.getClassesImported();\n+\t\tList<String> res = new LinkedList<>();\n+\t\tfor (Node n : graph.vertexSet()) {\n+\t\t\tif (n.getType() == Node.Type.CLASS) {\n+\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n+\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn res;\n+\t}\n \n-  public static List<String> findMethodCallers(\n-      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-    return graph\n-        .vertexSet()\n-        .stream()\n-        .filter(n -> (n instanceof MethodNode))\n-        .map(methodNode -> (MethodNode) methodNode)\n-        .filter(\n-            methodNode ->\n-                methodNode\n-                    .getCalledInside()\n-                    .stream()\n-                    .anyMatch(\n-                        calledMethod -> {\n-                          String expect =\n-                              withSignature\n-                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n-                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n-                          String actual =\n-                              withSignature\n-                                  ? node.getFullyQualifiedName() + node.getSignature()\n-                                  : node.getFullyQualifiedName();\n-                          return expect.equals(actual);\n-                        }))\n-        .map(\n-            methodNode -> {\n-              return withSignature\n-                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-                  : methodNode.getFullyQualifiedName();\n-            })\n-        .collect(Collectors.toList());\n-  }\n+\tpublic static List<String> findMethodCallers(\n+\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+\t\treturn graph\n+\t\t\t.vertexSet()\n+\t\t\t.stream()\n+\t\t\t.filter(n -> (n instanceof MethodNode))\n+\t\t\t.map(methodNode -> (MethodNode) methodNode)\n+\t\t\t.filter(\n+\t\t\t\tmethodNode ->\n+\t\t\t\t\tmethodNode\n+\t\t\t\t\t\t.getCalledInside()\n+\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t.anyMatch(\n+\t\t\t\t\t\t\tcalledMethod -> {\n+\t\t\t\t\t\t\t\tString expect =\n+\t\t\t\t\t\t\t\t\twithSignature\n+\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n+\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n+\t\t\t\t\t\t\t\tString actual =\n+\t\t\t\t\t\t\t\t\twithSignature\n+\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n+\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n+\t\t\t\t\t\t\t\treturn expect.equals(actual);\n+\t\t\t\t\t\t\t}))\n+\t\t\t.map(\n+\t\t\t\tmethodNode -> {\n+\t\t\t\t\treturn withSignature\n+\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n+\t\t\t\t})\n+\t\t\t.collect(Collectors.toList());\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n\tpublic static List<String> findFieldReferences(FieldNode node) {\n\t\treturn node.getFieldReferenceToMethod();\n\t}\n\n\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n\t\treturn node.getSuperClasses();\n\t}\n\n\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode classNode) {\n//    return node.getClassesImported();\n\t\tList<String> res = new LinkedList<>();\n\t\tfor (Node n : graph.vertexSet()) {\n\t\t\tif (n.getType() == Node.Type.CLASS) {\n\t\t\t\tfor (String imported : ((ClassNode) n).getClassesImported()) {\n\t\t\t\t\tif (imported.equals(classNode.getFullyQualifiedName())) {\n\t\t\t\t\t\tres.add(n.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static List<String> findMethodCallers(\n\t\tNamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph\n\t\t\t.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(\n\t\t\t\tmethodNode ->\n\t\t\t\t\tmethodNode\n\t\t\t\t\t\t.getCalledInside()\n\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t.anyMatch(\n\t\t\t\t\t\t\tcalledMethod -> {\n\t\t\t\t\t\t\t\tString expect =\n\t\t\t\t\t\t\t\t\twithSignature\n\t\t\t\t\t\t\t\t\t\t? calledMethod.getFullyQualifiedNameWithSignature()\n\t\t\t\t\t\t\t\t\t\t: calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\t\t\tString actual =\n\t\t\t\t\t\t\t\t\twithSignature\n\t\t\t\t\t\t\t\t\t\t? node.getFullyQualifiedName() + node.getSignature()\n\t\t\t\t\t\t\t\t\t\t: node.getFullyQualifiedName();\n\t\t\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t\t\t}))\n\t\t\t.map(\n\t\t\t\tmethodNode -> {\n\t\t\t\t\treturn withSignature\n\t\t\t\t\t\t? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n\t\t\t\t\t\t: methodNode.getFullyQualifiedName();\n\t\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n}\n"
          },
          {
            sha: "5526c7aeb020c013e422550ea546e1cc94a686f6",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 49,
            deletions: 48,
            patch:
              "@@ -2,58 +2,59 @@\n \n import java.util.ArrayList;\n import java.util.List;\n+\n import refactoring.crawler.graph.Edge;\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-    super(graph1, graph2);\n-  }\n-\n-  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n-  }\n-\n-  /**\n-   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-   * computeLikelinessIncomingEdges in RefactoringDetection\n-   *\n-   * @param nodeOriginal\n-   * @param nodeVersion\n-   * @return\n-   */\n-  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-    double edgeGrade;\n-    createCallGraph(nodeOriginal, nodeVersion);\n-    List<Edge> incomingEdgesOriginal =\n-        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-    List<Edge> incomingEdgesVersion =\n-        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-    return edgeGrade;\n-  }\n-\n-  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-    for (Node[] pair : prePruned) {\n-      Node original = pair[0];\n-      Node version = pair[1];\n-      String parentPackageOriginal = extractParentSimpleName(original);\n-      String parentPackageVersion = extractParentSimpleName(version);\n-      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-        candidatesWithSameParentPackage.add(pair);\n-      }\n-    }\n-\n-    return candidatesWithSameParentPackage;\n-  }\n-\n-  @Override\n-  public boolean isRename() {\n-    return true;\n-  }\n+\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n+\t}\n+\n+\t/**\n+\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+\t * computeLikelinessIncomingEdges in RefactoringDetection\n+\t *\n+\t * @param nodeOriginal\n+\t * @param nodeVersion\n+\t * @return\n+\t */\n+\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal =\n+\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion =\n+\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+\t\tfor (Node[] pair : prePruned) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n+\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n+\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentPackage;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n\t}\n\n\t/**\n\t * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n\t * computeLikelinessIncomingEdges in RefactoringDetection\n\t *\n\t * @param nodeOriginal\n\t * @param nodeVersion\n\t * @return\n\t */\n\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal =\n\t\t\tfilterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion =\n\t\t\tfilterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n\t\tfor (Node[] pair : prePruned) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version.getSimpleName())))) {\n\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithSameParentPackage;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n}\n"
          },
          {
            sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -277,7 +277,7 @@ private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph gr\n       for (Node c : this.oldVersionClassList) {\n         if (!c.isAPI()) continue;\n \n-        for (Node c2 : this.oldVersionClassList) {\n+        for (Node c2 : this.newVersionClassList) {\n           if (!c2.isAPI()) continue;\n \n           if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {",
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "553efb98631d251ca093e8374d61cb29a646e846",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 191,
            deletions: 114,
            patch:
              '@@ -7,126 +7,203 @@\n \n import java.util.Dictionary;\n import java.util.Hashtable;\n+import java.util.LinkedList;\n import java.util.List;\n+\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n-\n-  @BeforeAll\n-  static void setUp() {\n-    settings = new Hashtable<>();\n-\n-    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-  }\n-\n-  @Test\n-  void testRenameMethod() {\n-    String source =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    String newVersion =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo12() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo12();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-    refactoringCrawler.detect(source, newVersion);\n-    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    assertEquals(1, categories.size());\n-    assertEquals("RenamedMethods", categories.get(0).getName());\n-    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n-    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n-    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n-  }\n-\n-  @Test\n-  void testChangeMethodSignature() {\n-    String source =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo() {\\n"\n-            + "\\t\\tSystem.out.println(11111);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo();\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    String newVersion =\n-        "/*\\n"\n-            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-            + " */\\n"\n-            + "package refactoring.crawler;\\n"\n-            + "\\n"\n-            + "public class Library {\\n"\n-            + "\\tprivate int a;\\n"\n-            + "\\tprivate int b;\\n"\n-            + "\\n"\n-            + "\\tpublic void foo(int i) {\\n"\n-            + "\\t\\tSystem.out.println(i);\\n"\n-            + "\\t}\\n"\n-            + "\\n"\n-            + "\\tpublic void bar() {\\n"\n-            + "\\t\\tthis.foo(1);\\n"\n-            + "\\t}\\n"\n-            + "}\\n";\n-\n-    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n-    refactoringCrawler.detect(source, newVersion);\n-    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    RefactoringCategory refactoringCategory = categories.get(0);\n-    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n-    assertEquals(1, categories.size());\n-    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n-    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n-    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n-  }\n+\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+\t@BeforeAll\n+\tstatic void setUp() {\n+\t\tsettings = new Hashtable<>();\n+\n+\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+\t}\n+\n+\t@Test\n+\tvoid testRenameMethod() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo12() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(source, newVersion);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n+\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+\t}\n+\n+\t@Test\n+\tvoid testChangeMethodSignature() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(source, newVersion);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tRefactoringCategory refactoringCategory = categories.get(0);\n+\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n+\t}\n+\n+\t@Test\n+\tvoid testRenameClass() {\n+\t\tString source =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\t\tString source2 = "/*\\n"\n+\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t+ " */\\n"\n+\t\t\t+ "package refactoring.a;\\n"\n+\t\t\t+ "import refactoring.crawler.Library;\\n"\n+\t\t\t+ "public class A {\\n"\n+\t\t\t+ "private Library library = new Library();\\n"\n+\t\t\t+ "}\\n";\n+\t\tString newVersion =\n+\t\t\t"/*\\n"\n+\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t\t+ " */\\n"\n+\t\t\t\t+ "package refactoring.crawler;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "public class Library123 {\\n"\n+\t\t\t\t+ "\\tprivate int a;\\n"\n+\t\t\t\t+ "\\tprivate int b;\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void foo() {\\n"\n+\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "\\n"\n+\t\t\t\t+ "\\tpublic void bar() {\\n"\n+\t\t\t\t+ "\\t\\tthis.foo();\\n"\n+\t\t\t\t+ "\\t}\\n"\n+\t\t\t\t+ "}\\n";\n+\t\tString newVersion2 = "/*\\n"\n+\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+\t\t\t+ " */\\n"\n+\t\t\t+ "package refactoring.a;\\n"\n+\t\t\t+ "import refactoring.crawler.Library123;\\n"\n+\t\t\t+ "public class A {\\n"\n+\t\t\t+ "private Library library = new Library();\\n"\n+\t\t\t+ "}\\n";\n+\n+\t\tList<String> originals = new LinkedList<>();\n+\t\tList<String> newVersions = new LinkedList<>();\n+\n+\t\toriginals.add(source);\n+\t\toriginals.add(source2);\n+\n+\t\tnewVersions.add(newVersion);\n+\t\tnewVersions.add(newVersion2);\n+\n+\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+\t\trefactoringCrawler.detect(originals, newVersions);\n+\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+\t\tRefactoringCategory refactoringCategory = categories.get(0);\n+\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+\t\tassertEquals(1, categories.size());\n+\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n+\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n+\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n+\t}\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n\t@BeforeAll\n\tstatic void setUp() {\n\t\tsettings = new Hashtable<>();\n\n\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\t}\n\n\t@Test\n\tvoid testRenameMethod() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo12() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo12();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(source, newVersion);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("RenamedMethods", categories.get(0).getName());\n\t\tNode[] nodes = categories.get(0).getRefactoringPairs().get(0);\n\t\tassertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n\t\tassertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n\t}\n\n\t@Test\n\tvoid testChangeMethodSignature() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo(int i) {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(i);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo(1);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(source, newVersion);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tRefactoringCategory refactoringCategory = categories.get(0);\n\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n\t\tassertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n\t\tassertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n\t}\n\n\t@Test\n\tvoid testRenameClass() {\n\t\tString source =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(11111);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\t\tString source2 = "/*\\n"\n\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t+ " */\\n"\n\t\t\t+ "package refactoring.a;\\n"\n\t\t\t+ "import refactoring.crawler.Library;\\n"\n\t\t\t+ "public class A {\\n"\n\t\t\t+ "private Library library = new Library();\\n"\n\t\t\t+ "}\\n";\n\t\tString newVersion =\n\t\t\t"/*\\n"\n\t\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t\t+ " */\\n"\n\t\t\t\t+ "package refactoring.crawler;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "public class Library123 {\\n"\n\t\t\t\t+ "\\tprivate int a;\\n"\n\t\t\t\t+ "\\tprivate int b;\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void foo() {\\n"\n\t\t\t\t+ "\\t\\tSystem.out.println(1);\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "\\n"\n\t\t\t\t+ "\\tpublic void bar() {\\n"\n\t\t\t\t+ "\\t\\tthis.foo();\\n"\n\t\t\t\t+ "\\t}\\n"\n\t\t\t\t+ "}\\n";\n\t\tString newVersion2 = "/*\\n"\n\t\t\t+ " * This Java source file was generated by the Gradle \'init\' task.\\n"\n\t\t\t+ " */\\n"\n\t\t\t+ "package refactoring.a;\\n"\n\t\t\t+ "import refactoring.crawler.Library123;\\n"\n\t\t\t+ "public class A {\\n"\n\t\t\t+ "private Library library = new Library();\\n"\n\t\t\t+ "}\\n";\n\n\t\tList<String> originals = new LinkedList<>();\n\t\tList<String> newVersions = new LinkedList<>();\n\n\t\toriginals.add(source);\n\t\toriginals.add(source2);\n\n\t\tnewVersions.add(newVersion);\n\t\tnewVersions.add(newVersion2);\n\n\t\tRefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n\t\trefactoringCrawler.detect(originals, newVersions);\n\t\tList<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n\t\tRefactoringCategory refactoringCategory = categories.get(0);\n\t\tNode[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n\t\tassertEquals(1, categories.size());\n\t\tassertEquals("RenamedClasses", refactoringCategory.getName());\n\t\tassertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n\t\tassertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "fed214ccff862674ed63f5dd5f017cda31b6ef80",
        message: "chore(*): add jacoco for coverage",
        stats: {
          total: 38,
          additions: 36,
          deletions: 2
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a"
          }
        ],
        committedAt: 1585458591000,
        changedFiles: [
          {
            sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
            filename: "build.gradle",
            status: "modified",
            additions: 36,
            deletions: 2,
            patch:
              "@@ -5,11 +5,46 @@\n  * For more details take a look at the Java Libraries chapter in the Gradle\n  * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n  */\n-\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n     id 'com.github.sherter.google-java-format' version '0.8'\n+    id 'jacoco'\n+}\n+\n+jacoco {\n+    toolVersion = \"0.8.5\"\n+    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n+}\n+\n+jacocoTestReport {\n+    reports {\n+        xml.enabled false\n+        csv.enabled false\n+        html.destination file(\"${buildDir}/jacocoHtml\")\n+    }\n+}\n+\n+jacocoTestCoverageVerification {\n+    violationRules {\n+        rule {\n+            limit {\n+                minimum = 0.5\n+            }\n+        }\n+\n+        rule {\n+            enabled = false\n+            element = 'CLASS'\n+            includes = ['org.gradle.*']\n+\n+            limit {\n+                counter = 'LINE'\n+                value = 'TOTALCOUNT'\n+                maximum = 0.3\n+            }\n+        }\n+    }\n }\n \n repositories {\n@@ -47,7 +82,6 @@ dependencies {\n     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n     implementation 'org.jetbrains:annotations:15.0'\n }\n-\n test {\n     // Use junit platform for unit tests\n     useJUnitPlatform()",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          }
        ]
      },
      {
        sha: "f58eb5ea5bc5678263b195d87db66abc2813f19a",
        message:
          "Merge pull request #1 from PatrickLai7528/circleci-project-setup\n\nAdd .circleci/config.yml",
        stats: {
          total: 42,
          additions: 42,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4"
          },
          {
            sha: "2a8ff280c4626e929dec89adc0992be9af6c2c55"
          }
        ],
        committedAt: 1585234852000,
        changedFiles: [
          {
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            filename: ".circleci/config.yml",
            status: "added",
            additions: 42,
            deletions: 0,
            patch:
              '@@ -0,0 +1,42 @@\n+# Java Gradle CircleCI 2.0 configuration file\n+#\n+# Check https://circleci.com/docs/2.0/language-java/ for more details\n+#\n+version: 2\n+jobs:\n+  build:\n+    docker:\n+      # specify the version you desire here\n+      - image: circleci/openjdk:8-jdk\n+\n+      # Specify service dependencies here if necessary\n+      # CircleCI maintains a library of pre-built images\n+      # documented at https://circleci.com/docs/2.0/circleci-images/\n+      # - image: circleci/postgres:9.4\n+\n+    working_directory: ~/repo\n+\n+    environment:\n+      # Customize the JVM maximum heap limit\n+      JVM_OPTS: -Xmx3200m\n+      TERM: dumb\n+\n+    steps:\n+      - checkout\n+\n+      # Download and cache dependencies\n+      - restore_cache:\n+          keys:\n+            - v1-dependencies-{{ checksum "build.gradle" }}\n+            # fallback to using the latest cache if no exact match is found\n+            - v1-dependencies-\n+\n+      - run: gradle dependencies\n+\n+      - save_cache:\n+          paths:\n+            - ~/.gradle\n+          key: v1-dependencies-{{ checksum "build.gradle" }}\n+\n+      # run tests!\n+      - run: gradle test\n\\ No newline at end of file',
            rawContent:
              '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test'
          }
        ]
      },
      {
        sha: "2a8ff280c4626e929dec89adc0992be9af6c2c55",
        message: "Add .circleci/config.yml",
        stats: {
          total: 42,
          additions: 42,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4"
          }
        ],
        committedAt: 1585234706000,
        changedFiles: [
          {
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            filename: ".circleci/config.yml",
            status: "added",
            additions: 42,
            deletions: 0,
            patch:
              '@@ -0,0 +1,42 @@\n+# Java Gradle CircleCI 2.0 configuration file\n+#\n+# Check https://circleci.com/docs/2.0/language-java/ for more details\n+#\n+version: 2\n+jobs:\n+  build:\n+    docker:\n+      # specify the version you desire here\n+      - image: circleci/openjdk:8-jdk\n+\n+      # Specify service dependencies here if necessary\n+      # CircleCI maintains a library of pre-built images\n+      # documented at https://circleci.com/docs/2.0/circleci-images/\n+      # - image: circleci/postgres:9.4\n+\n+    working_directory: ~/repo\n+\n+    environment:\n+      # Customize the JVM maximum heap limit\n+      JVM_OPTS: -Xmx3200m\n+      TERM: dumb\n+\n+    steps:\n+      - checkout\n+\n+      # Download and cache dependencies\n+      - restore_cache:\n+          keys:\n+            - v1-dependencies-{{ checksum "build.gradle" }}\n+            # fallback to using the latest cache if no exact match is found\n+            - v1-dependencies-\n+\n+      - run: gradle dependencies\n+\n+      - save_cache:\n+          paths:\n+            - ~/.gradle\n+          key: v1-dependencies-{{ checksum "build.gradle" }}\n+\n+      # run tests!\n+      - run: gradle test\n\\ No newline at end of file',
            rawContent:
              '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test'
          }
        ]
      },
      {
        sha: "3a0966bea2a05cbf7e06e2e4c7eefb516a0cd3b4",
        message: "Create README.md",
        stats: {
          total: 2,
          additions: 2,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "GitHub"
        },
        parents: [
          {
            sha: "60611e9d306af2245db7837ec774c40ad294bb7b"
          }
        ],
        committedAt: 1585224669000,
        changedFiles: [
          {
            sha: "b34fbf6028059b5e0f654d1d1645aef6f2400c75",
            filename: "README.md",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# refactoring-crawler\n+Java tool for detecting refactor",
            rawContent:
              "# refactoring-crawler\nJava tool for detecting refactor\n"
          }
        ]
      },
      {
        sha: "60611e9d306af2245db7837ec774c40ad294bb7b",
        message: "test(*): test rename method, change method signature",
        stats: {
          total: 65,
          additions: 60,
          deletions: 5
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ae654f2173cfa166b3d03a9663357095ad227969"
          }
        ],
        committedAt: 1585224530000,
        changedFiles: [
          {
            sha: "f01bbc1df8c35dbe9a882751728487b090a1ad25",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 60,
            deletions: 5,
            patch:
              '@@ -3,19 +3,20 @@\n  */\n package refactoring.crawler;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n import java.util.Dictionary;\n import java.util.Hashtable;\n import java.util.List;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n+import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n   private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n \n-  private static RefactoringCrawler refactoringCrawler;\n-\n   @BeforeAll\n   static void setUp() {\n     settings = new Hashtable<>();\n@@ -26,8 +27,6 @@ static void setUp() {\n     settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n     settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n-\n-    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n   }\n \n   @Test\n@@ -70,8 +69,64 @@ void testRenameMethod() {\n             + "\\t}\\n"\n             + "}\\n";\n \n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    assertEquals(1, categories.size());\n+    assertEquals("RenamedMethods", categories.get(0).getName());\n+    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n+    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n+    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n+  }\n+\n+  @Test\n+  void testChangeMethodSignature() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo(int i) {\\n"\n+            + "\\t\\tSystem.out.println(i);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo(1);\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n+\n+    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n     refactoringCrawler.detect(source, newVersion);\n     List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-    System.out.println(categories);\n+    RefactoringCategory refactoringCategory = categories.get(0);\n+    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n+    assertEquals(1, categories.size());\n+    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n+    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n   }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n}\n'
          }
        ]
      },
      {
        sha: "ae654f2173cfa166b3d03a9663357095ad227969",
        message: "format(*): format all code",
        stats: {
          total: 5208,
          additions: 2596,
          deletions: 2612
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "f38d6d29251fbdacab8f8a7a8390339bd60e65f2"
          }
        ],
        committedAt: 1585222642000,
        changedFiles: [
          {
            sha: "c344d7ed7a76b5681a9bfc5ca07fe5e1940bf67e",
            filename: "build.gradle",
            status: "modified",
            additions: 1,
            deletions: 17,
            patch:
              '@@ -9,25 +9,9 @@\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id \'java-library\'\n-    id "com.diffplug.gradle.spotless" version "3.16.0"\n+    id \'com.github.sherter.google-java-format\' version \'0.8\'\n }\n \n-sourceCompatibility = 1.8\n-\n-spotless {\n-    java {\n-        googleJavaFormat()\n-        indentWithTabs(2)\n-        indentWithSpaces(4)\n-    }\n-}\n-\n-def hook = new File("$rootProject.projectDir/.git/hooks/pre-commit")\n-hook.text = """#!/bin/bash\n-echo "will run nova code format"\n-./gradlew spotlessApply\n-"""\n-\n repositories {\n     // Use jcenter for resolving dependencies.\n     // You can declare any Maven/Ivy/file repository here.',
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "b2f029504a118dbd1bc75b63bec2d151004ae6ee",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 177,
            deletions: 177,
            patch:
              '@@ -17,188 +17,188 @@\n \n public class RefactoringCrawler {\n \n-    public static enum Settings {\n-        T_RENAME_METHOD,\n-        T_RENAME_CLASS,\n-        T_MOVE_METHOD,\n-        T_PULL_UP_METHOD,\n-        T_PUSH_DOWN_METHOD,\n-        T_CHANGE_METHOD_SIGNATURE\n+  public static enum Settings {\n+    T_RENAME_METHOD,\n+    T_RENAME_CLASS,\n+    T_MOVE_METHOD,\n+    T_PULL_UP_METHOD,\n+    T_PUSH_DOWN_METHOD,\n+    T_CHANGE_METHOD_SIGNATURE\n+  }\n+\n+  private String projectName;\n+  private Dictionary<Settings, Double> settings;\n+\n+  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n+\n+  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n+    this.projectName = projectName;\n+    this.settings = settings;\n+  }\n+\n+  private static List<CompilationUnit> parse(List<String> files) {\n+    TypeSolver typeSolver = new ReflectionTypeSolver();\n+    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n+    List<CompilationUnit> resList = new LinkedList<>();\n+    for (String source : files) {\n+      CompilationUnit cu = StaticJavaParser.parse(source);\n+      resList.add(cu);\n     }\n-\n-    private String projectName;\n-    private Dictionary<Settings, Double> settings;\n-\n-    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n-\n-    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n-        this.projectName = projectName;\n-        this.settings = settings;\n-    }\n-\n-    private static List<CompilationUnit> parse(List<String> files) {\n-        TypeSolver typeSolver = new ReflectionTypeSolver();\n-        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n-        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n-\n-        List<CompilationUnit> resList = new LinkedList<>();\n-        for (String source : files) {\n-            CompilationUnit cu = StaticJavaParser.parse(source);\n-            resList.add(cu);\n-        }\n-        return resList;\n-    }\n-\n-    public void detect(String oldVersion, String newVersion) {\n-        List<String> oldVersionList = new LinkedList<>();\n-        List<String> newVersionList = new LinkedList<>();\n-\n-        oldVersionList.add(oldVersion);\n-        newVersionList.add(newVersion);\n-\n-        this.detect(oldVersionList, newVersionList);\n-    }\n-\n-    public void detect(List<String> oldVersion, List<String> newVersion) {\n-        ShinglesUtil shinglesUtil = new ShinglesUtil();\n-\n-        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n-        List<CompilationUnit> newVersionCU = parse(newVersion);\n-        SourceNavigator navigator = new SourceNavigator();\n-        navigator.setShinglesUtil(shinglesUtil);\n-        navigator.browseProject(projectName, oldVersionCU);\n-        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n-\n-        SourceNavigator navigatorForVersion = new SourceNavigator();\n-        navigatorForVersion.setShinglesUtil(shinglesUtil);\n-        navigatorForVersion.browseProject(projectName, newVersionCU);\n-        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n-\n-        shinglesUtil.initialize(originalGraph, versionGraph);\n-\n-        // must in this order\n-\n-        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n-        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n-        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n-        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n-        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n-        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n-        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+    return resList;\n+  }\n+\n+  public void detect(String oldVersion, String newVersion) {\n+    List<String> oldVersionList = new LinkedList<>();\n+    List<String> newVersionList = new LinkedList<>();\n+\n+    oldVersionList.add(oldVersion);\n+    newVersionList.add(newVersion);\n+\n+    this.detect(oldVersionList, newVersionList);\n+  }\n+\n+  public void detect(List<String> oldVersion, List<String> newVersion) {\n+    ShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n+    List<CompilationUnit> newVersionCU = parse(newVersion);\n+    SourceNavigator navigator = new SourceNavigator();\n+    navigator.setShinglesUtil(shinglesUtil);\n+    navigator.browseProject(projectName, oldVersionCU);\n+    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+    SourceNavigator navigatorForVersion = new SourceNavigator();\n+    navigatorForVersion.setShinglesUtil(shinglesUtil);\n+    navigatorForVersion.browseProject(projectName, newVersionCU);\n+    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+    shinglesUtil.initialize(originalGraph, versionGraph);\n+\n+    // must in this order\n+\n+    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+  }\n+\n+  private void detectChangeMethodSignature(\n+      double tChangeMethodSignature,\n+      ShinglesUtil shinglesUtil,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tChangeMethodSignature);\n+    List<Node[]> changedMethodSignatures =\n+        detector.detectRefactorings(candidateChangedMethodSignatures);\n+    if (changedMethodSignatures.size() > 0) {\n+      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+      changeSignatureCategory.setName("ChangedMethodSignatures");\n+      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+      this.refactoringCategories.add(changeSignatureCategory);\n     }\n-\n-    private void detectChangeMethodSignature(\n-            double tChangeMethodSignature,\n-            ShinglesUtil shinglesUtil,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tChangeMethodSignature);\n-        List<Node[]> changedMethodSignatures =\n-                detector.detectRefactorings(candidateChangedMethodSignatures);\n-        if (changedMethodSignatures.size() > 0) {\n-            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-            changeSignatureCategory.setName("ChangedMethodSignatures");\n-            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n-            this.refactoringCategories.add(changeSignatureCategory);\n-        }\n+  }\n+\n+  private void detectRenameMethod(\n+      double tMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph oldVersionGraph,\n+      NamedDirectedMultigraph newVersionGraph) {\n+    List<Node[]> candidateMethods = se.findSimilarMethods();\n+    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+    detector.setThreshold(tMethod);\n+\n+    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+    if (renamedMethods.size() > 0) {\n+      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+      renameMethodCategory.setName("RenamedMethods");\n+      renameMethodCategory.setRefactoringPairs(renamedMethods);\n+      this.refactoringCategories.add(renameMethodCategory);\n     }\n-\n-    private void detectRenameMethod(\n-            double tMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph oldVersionGraph,\n-            NamedDirectedMultigraph newVersionGraph) {\n-        List<Node[]> candidateMethods = se.findSimilarMethods();\n-        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-        detector.setThreshold(tMethod);\n-\n-        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n-        if (renamedMethods.size() > 0) {\n-            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n-            renameMethodCategory.setName("RenamedMethods");\n-            renameMethodCategory.setRefactoringPairs(renamedMethods);\n-            this.refactoringCategories.add(renameMethodCategory);\n-        }\n+  }\n+\n+  public void detectRenameClass(\n+      double tClass,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidateClasses = se.findSimilarClasses();\n+    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tClass);\n+    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+    if (renamedClasses.size() > 0) {\n+      RefactoringCategory renameClassCategory = new RefactoringCategory();\n+      renameClassCategory.setName("RenamedClasses");\n+      renameClassCategory.setRefactoringPairs(renamedClasses);\n+      this.refactoringCategories.add(renameClassCategory);\n     }\n-\n-    public void detectRenameClass(\n-            double tClass,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidateClasses = se.findSimilarClasses();\n-        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tClass);\n-        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n-        if (renamedClasses.size() > 0) {\n-            RefactoringCategory renameClassCategory = new RefactoringCategory();\n-            renameClassCategory.setName("RenamedClasses");\n-            renameClassCategory.setRefactoringPairs(renamedClasses);\n-            this.refactoringCategories.add(renameClassCategory);\n-        }\n+  }\n+\n+  public void detectMoveMethod(\n+      double tMoveMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> methodCandidates = se.findSimilarMethods();\n+    se.findSimilarClasses();\n+    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+    detector.setThreshold(tMoveMethod);\n+    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+    if (movedMethods.size() > 0) {\n+      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n+      moveMethodCategory.setName("MovedMethods");\n+      moveMethodCategory.setRefactoringPairs(movedMethods);\n+      this.refactoringCategories.add(moveMethodCategory);\n     }\n-\n-    public void detectMoveMethod(\n-            double tMoveMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> methodCandidates = se.findSimilarMethods();\n-        se.findSimilarClasses();\n-        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n-        detector.setThreshold(tMoveMethod);\n-        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n-        if (movedMethods.size() > 0) {\n-            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n-            moveMethodCategory.setName("MovedMethods");\n-            moveMethodCategory.setRefactoringPairs(movedMethods);\n-            this.refactoringCategories.add(moveMethodCategory);\n-        }\n+  }\n+\n+  public void detectPullUpMethod(\n+      double tPullUpMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tPullUpMethod);\n+    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+    if (pullUpMethodResults.size() > 0) {\n+      RefactoringCategory pullUpCategory = new RefactoringCategory();\n+      pullUpCategory.setName("PulledUpMethods");\n+      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+      this.refactoringCategories.add(pullUpCategory);\n     }\n-\n-    public void detectPullUpMethod(\n-            double tPullUpMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n-        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tPullUpMethod);\n-        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n-        if (pullUpMethodResults.size() > 0) {\n-            RefactoringCategory pullUpCategory = new RefactoringCategory();\n-            pullUpCategory.setName("PulledUpMethods");\n-            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n-            this.refactoringCategories.add(pullUpCategory);\n-        }\n-    }\n-\n-    public void detectPushDownMethod(\n-            double tPushDownMethod,\n-            ShinglesUtil se,\n-            NamedDirectedMultigraph originalGraph,\n-            NamedDirectedMultigraph versionGraph) {\n-        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n-        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n-        detector.setThreshold(tPushDownMethod);\n-        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n-        if (pushDownMethodResults.size() > 0) {\n-            RefactoringCategory pushDownCategory = new RefactoringCategory();\n-            pushDownCategory.setName("PushedDownMethods");\n-            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n-            this.refactoringCategories.add(pushDownCategory);\n-        }\n+  }\n+\n+  public void detectPushDownMethod(\n+      double tPushDownMethod,\n+      ShinglesUtil se,\n+      NamedDirectedMultigraph originalGraph,\n+      NamedDirectedMultigraph versionGraph) {\n+    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+    detector.setThreshold(tPushDownMethod);\n+    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+    if (pushDownMethodResults.size() > 0) {\n+      RefactoringCategory pushDownCategory = new RefactoringCategory();\n+      pushDownCategory.setName("PushedDownMethods");\n+      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+      this.refactoringCategories.add(pushDownCategory);\n     }\n+  }\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n'
          },
          {
            sha: "5218fee4bcbf9d8299259e5f503c3c584b100aae",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 374,
            deletions: 374,
            patch:
              '@@ -11,416 +11,416 @@\n \n public abstract class RefactoringDetection {\n \n-    @Getter @Setter private double threshold;\n+  @Getter @Setter private double threshold;\n \n-    protected NamedDirectedMultigraph graph1;\n+  protected NamedDirectedMultigraph graph1;\n \n-    protected NamedDirectedMultigraph graph2;\n+  protected NamedDirectedMultigraph graph2;\n \n-    private double lowerThreshold;\n+  private double lowerThreshold;\n \n-    /** Dictionary contains <Original, Version> pairs for the renaming. */\n-    private static Dictionary<String, String> renamingDictionary;\n+  /** Dictionary contains <Original, Version> pairs for the renaming. */\n+  private static Dictionary<String, String> renamingDictionary;\n \n-    public static Dictionary<String, String> getRenamingDictionary() {\n-        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n-        return renamingDictionary;\n-    }\n+  public static Dictionary<String, String> getRenamingDictionary() {\n+    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+    return renamingDictionary;\n+  }\n \n-    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        this.graph1 = graph;\n-        this.graph2 = graph2;\n-    }\n+  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    this.graph1 = graph;\n+    this.graph2 = graph2;\n+  }\n \n-    public abstract double computeLikeliness(Node node1, Node node12);\n+  public abstract double computeLikeliness(Node node1, Node node12);\n \n-    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n \n-    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n \n-    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n \n-    public abstract boolean isRename();\n+  public abstract boolean isRename();\n \n-    /**\n-    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n-    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n-    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n-    * computeLikeliness and pruneOriginalCandidates.\n-    */\n-    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+  /**\n+   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+   * computeLikeliness and pruneOriginalCandidates.\n+   */\n+  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n \n-        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-        return pruneFalsePositives(listWithFP);\n-    }\n+    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+    return pruneFalsePositives(listWithFP);\n+  }\n \n-    protected String extractPotentialRename(String parentClassOriginal) {\n-        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n-        return renamedName == null ? parentClassOriginal : renamedName;\n-    }\n+  protected String extractPotentialRename(String parentClassOriginal) {\n+    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+    return renamedName == null ? parentClassOriginal : renamedName;\n+  }\n \n-    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-        boolean foundNewRefactoring = false;\n-        for (Node[] pair : prunedCandidates) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            double likeliness = computeLikeliness(original, version);\n-            if (likeliness >= threshold) {\n-                if (!refactoredNodes.contains(pair)) {\n-                    refactoredNodes.add(pair);\n-                    foundNewRefactoring = true;\n-                }\n-                // candidates.remove(pair); acivating this line would fail to\n-                // detect those cases when two\n-                // types of refactorings happened to the same node\n-            }\n-        }\n-        if (foundNewRefactoring) {\n-            doDetectRefactorings(candidates, refactoredNodes);\n+  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+    boolean foundNewRefactoring = false;\n+    for (Node[] pair : prunedCandidates) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      double likeliness = computeLikeliness(original, version);\n+      if (likeliness >= threshold) {\n+        if (!refactoredNodes.contains(pair)) {\n+          refactoredNodes.add(pair);\n+          foundNewRefactoring = true;\n         }\n-        return refactoredNodes;\n+        // candidates.remove(pair); acivating this line would fail to\n+        // detect those cases when two\n+        // types of refactorings happened to the same node\n+      }\n     }\n-\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-        for (Node[] pair : listWithFP) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-            if (originalInV2 != null) {\n-                createCallGraph(originalInV2, graph2);\n-                List<Edge> origIncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n-                List<Edge> verIncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-                List<Edge> origInVer1IncomingEdges =\n-                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-\n-                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-                List<Node> verCallers = getCallers(verIncomingEdges);\n-                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-                // since a call site cannot be calling both the old and the new entity at the same time\n-                for (Node node : verCallers) {\n-                    if (origInV2Callers.contains(node))\n-                        if (!nodesToRemove.contains(pair)) {\n-                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-                            nodesToRemove.add(pair);\n-                        }\n-                }\n-\n-                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n-                // pair\n-                // is a false positive (since there should be either no more callers for N1inV2 or their\n-                // call sites\n-                // should be different\n-                for (Node node : origInV1Callers) {\n-                    for (Node callingNode : origInV2Callers) {\n-                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-                            if (!nodesToRemove.contains(pair)) {\n-                                nodesToRemove.add(pair);\n-                            }\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            listWithFP.remove(pair);\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-\n-        pruneOverloadedMethodFP(listWithFP);\n-\n-        return listWithFP;\n+    if (foundNewRefactoring) {\n+      doDetectRefactorings(candidates, refactoredNodes);\n     }\n-\n-    private List<Node> getCallers(List<Edge> incomingEdges) {\n-        List<Node> callers = new ArrayList<>();\n-        for (Edge edge : incomingEdges) {\n-            callers.add(edge.getSource());\n-        }\n-        return callers;\n-    }\n-\n-    /**\n-    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n-    *\n-    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n-    * because of a method overload.\n-    *\n-    * <p>This method is never called in the ChangeMethodSignature detection.\n-    */\n-    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<>();\n-        for (int i = 0; i < listWithFP.size(); i++) {\n-            boolean hasSameNameAndSignature = false;\n-            Node[] pair = listWithFP.get(i);\n-            Node source = pair[0];\n-            for (int j = i; j < listWithFP.size(); j++) {\n-                Node[] pair2 = listWithFP.get(j);\n-                Node source2 = pair2[0];\n-                if (source.equals(source2)) {\n-                    Node target2 = pair2[1];\n-                    if (source.getSimpleName().equals(target2.getSimpleName()))\n-                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n-                }\n+    return refactoredNodes;\n+  }\n+\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+    for (Node[] pair : listWithFP) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+      if (originalInV2 != null) {\n+        createCallGraph(originalInV2, graph2);\n+        List<Edge> origIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+        List<Edge> verIncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        List<Edge> origInVer1IncomingEdges =\n+            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+        List<Node> verCallers = getCallers(verIncomingEdges);\n+        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+        // since a call site cannot be calling both the old and the new entity at the same time\n+        for (Node node : verCallers) {\n+          if (origInV2Callers.contains(node))\n+            if (!nodesToRemove.contains(pair)) {\n+              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+              nodesToRemove.add(pair);\n             }\n-            if (hasSameNameAndSignature) {\n-                for (int j = i; j < listWithFP.size(); j++) {\n-                    Node[] pair2 = listWithFP.get(j);\n-                    Node source2 = pair2[0];\n-                    if (source.equals(source2)) {\n-                        Node target2 = pair2[1];\n-                        if (source.getSimpleName().equals(target2.getSimpleName()))\n-                            if (!signatureEqualsModuloMoveMethod(source, target2))\n-                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-            listWithFP.remove(pair);\n-\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n         }\n-    }\n \n-    /**\n-    * This takes into account the possible renaming in the parent of the node\n-    *\n-    * @param g is the Version2 graph\n-    * @param original is a node from Version1\n-    * @return\n-    */\n-    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        String fqnParent = extractFullyQualifiedParentName(original);\n-        String possiblyRenamedFQN = dictionary.get(fqnParent);\n-        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n-        Node parentNode = g.findNamedNode(fqnParent);\n-\n-        if (parentNode != null) {\n-            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-                Edge edge = (Edge) iter.next();\n-                Node child = (Node) edge.getTarget();\n-                if (original.getSimpleName().equals(child.getSimpleName()))\n-                    if (original.getSignature() != null) {\n-                        // This handles the method nodes\n-                        if (original.getSignature().equals(child.getSignature())) return child;\n-                    } else\n-                        // Classes and packages\n-                        return child;\n+        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+        // pair\n+        // is a false positive (since there should be either no more callers for N1inV2 or their\n+        // call sites\n+        // should be different\n+        for (Node node : origInV1Callers) {\n+          for (Node callingNode : origInV2Callers) {\n+            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+              if (!nodesToRemove.contains(pair)) {\n+                nodesToRemove.add(pair);\n+              }\n+              break;\n             }\n+          }\n         }\n-        return null;\n+      }\n     }\n-\n-    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge edge : list) {\n-            if (label.equals(edge.getLabel())) {\n-                results.add(edge);\n-            }\n-        }\n-        return results;\n+    for (Node[] pair : nodesToRemove) {\n+      listWithFP.remove(pair);\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n     }\n \n-    protected String extractFullyQualifiedParentName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        return extractFullyQualifiedParentName(originalName);\n-    }\n+    pruneOverloadedMethodFP(listWithFP);\n \n-    public String extractFullyQualifiedParentName(String originalName) {\n-        String fq_parentName = "";\n-        int lastIndex = originalName.lastIndexOf(".");\n-        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n-        return fq_parentName;\n-    }\n+    return listWithFP;\n+  }\n \n-    /**\n-    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-    * IDE.openEditor(IWorkbenchPage, IFile)\n-    */\n-    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-        boolean retval = false;\n-\n-        if (source.getSignature() == null) return false;\n-\n-        retval = source.getSignature().equals(target.getSignature());\n-\n-        if (!retval && (this instanceof MoveMethodDetection)) {\n-            String sourceParent = extractParentSimpleName(source);\n-            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n-            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n-            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-            String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-            for (int i = 0; i < sourceTokens.length; i++) {\n-                sourceTokens[i] = sourceTokenizer.nextToken();\n-            }\n-\n-            for (int i = 0; i < targetTokens.length; i++) {\n-                targetTokens[i] = targetTokenizer.nextToken();\n-            }\n-\n-            if (targetTokens.length == sourceTokens.length + 1) {\n-                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n-                else {\n-                    for (int i = 0; i < sourceTokens.length; i++) {\n-                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n-                    }\n-                    retval = true;\n-                }\n-            }\n+  private List<Node> getCallers(List<Edge> incomingEdges) {\n+    List<Node> callers = new ArrayList<>();\n+    for (Edge edge : incomingEdges) {\n+      callers.add(edge.getSource());\n+    }\n+    return callers;\n+  }\n+\n+  /**\n+   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+   *\n+   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+   * because of a method overload.\n+   *\n+   * <p>This method is never called in the ChangeMethodSignature detection.\n+   */\n+  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+    List<Node[]> nodesToRemove = new ArrayList<>();\n+    for (int i = 0; i < listWithFP.size(); i++) {\n+      boolean hasSameNameAndSignature = false;\n+      Node[] pair = listWithFP.get(i);\n+      Node source = pair[0];\n+      for (int j = i; j < listWithFP.size(); j++) {\n+        Node[] pair2 = listWithFP.get(j);\n+        Node source2 = pair2[0];\n+        if (source.equals(source2)) {\n+          Node target2 = pair2[1];\n+          if (source.getSimpleName().equals(target2.getSimpleName()))\n+            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+        }\n+      }\n+      if (hasSameNameAndSignature) {\n+        for (int j = i; j < listWithFP.size(); j++) {\n+          Node[] pair2 = listWithFP.get(j);\n+          Node source2 = pair2[0];\n+          if (source.equals(source2)) {\n+            Node target2 = pair2[1];\n+            if (source.getSimpleName().equals(target2.getSimpleName()))\n+              if (!signatureEqualsModuloMoveMethod(source, target2))\n+                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+          }\n         }\n-        return retval;\n+      }\n     }\n+    for (Node[] pair : nodesToRemove) {\n+      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+      listWithFP.remove(pair);\n \n-    /**\n-    * This helper method takes a string containing the dot separated name of a node and it returns\n-    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n-    * class1)\n-    */\n-    protected String extractParentSimpleName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n-        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-        return parentName;\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      dictionary.remove(pair[0].getFullyQualifiedName());\n     }\n-\n-    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-        double count = 0;\n-\n-        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-        for (Edge edge1 : edges1) {\n-            Node node1 = edge1.getSource();\n-            for (int i = 0; i < arrEdge2.length; i++) {\n-                Edge edge2 = arrEdge2[i];\n-                if (edge2 != null) {\n-                    Node node2 = (Node) edge2.getSource();\n-                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n-                        count++;\n-                        // we mark this edge as already counted so that we don\'t\n-                        // count it\n-                        // twice when there are multiple edges between two nodes\n-                        arrEdge2[i] = null;\n-                    }\n-                }\n-            }\n-        }\n-\n-        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-        return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  /**\n+   * This takes into account the possible renaming in the parent of the node\n+   *\n+   * @param g is the Version2 graph\n+   * @param original is a node from Version1\n+   * @return\n+   */\n+  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    String fqnParent = extractFullyQualifiedParentName(original);\n+    String possiblyRenamedFQN = dictionary.get(fqnParent);\n+    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+    Node parentNode = g.findNamedNode(fqnParent);\n+\n+    if (parentNode != null) {\n+      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+        Edge edge = (Edge) iter.next();\n+        Node child = (Node) edge.getTarget();\n+        if (original.getSimpleName().equals(child.getSimpleName()))\n+          if (original.getSignature() != null) {\n+            // This handles the method nodes\n+            if (original.getSignature().equals(child.getSignature())) return child;\n+          } else\n+            // Classes and packages\n+            return child;\n+      }\n     }\n-\n-    protected boolean isTheSameModuloRename(String original, String version) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        if (version.equals(dictionary.get(original))) return true;\n-        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-            return original.equals(version);\n-        else if (original\n-                .substring(original.lastIndexOf("."))\n-                .equals(version.substring(version.lastIndexOf("."))))\n-            return isTheSameModuloRename(\n-                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n-        else return false;\n+    return null;\n+  }\n+\n+  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge edge : list) {\n+      if (label.equals(edge.getLabel())) {\n+        results.add(edge);\n+      }\n     }\n-\n-    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n-\n-                if (pair[0].isAPI() && pair[1].isAPI()) {\n-                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n-\n-                    if ((n2inV1 == null)) {\n-                        prunedCandidates.add(pair);\n-                    }\n-                }\n-            }\n+    return results;\n+  }\n+\n+  protected String extractFullyQualifiedParentName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    return extractFullyQualifiedParentName(originalName);\n+  }\n+\n+  public String extractFullyQualifiedParentName(String originalName) {\n+    String fq_parentName = "";\n+    int lastIndex = originalName.lastIndexOf(".");\n+    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+    return fq_parentName;\n+  }\n+\n+  /**\n+   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+   * IDE.openEditor(IWorkbenchPage, IFile)\n+   */\n+  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+    boolean retval = false;\n+\n+    if (source.getSignature() == null) return false;\n+\n+    retval = source.getSignature().equals(target.getSignature());\n+\n+    if (!retval && (this instanceof MoveMethodDetection)) {\n+      String sourceParent = extractParentSimpleName(source);\n+      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+      String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+      for (int i = 0; i < sourceTokens.length; i++) {\n+        sourceTokens[i] = sourceTokenizer.nextToken();\n+      }\n+\n+      for (int i = 0; i < targetTokens.length; i++) {\n+        targetTokens[i] = targetTokenizer.nextToken();\n+      }\n+\n+      if (targetTokens.length == sourceTokens.length + 1) {\n+        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+        else {\n+          for (int i = 0; i < sourceTokens.length; i++) {\n+            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+          }\n+          retval = true;\n         }\n-        return prunedCandidates;\n+      }\n+    }\n+    return retval;\n+  }\n+\n+  /**\n+   * This helper method takes a string containing the dot separated name of a node and it returns\n+   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+   * class1)\n+   */\n+  protected String extractParentSimpleName(Node original) {\n+    String originalName = original.getFullyQualifiedName();\n+    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+    return parentName;\n+  }\n+\n+  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+    double count = 0;\n+\n+    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+    for (Edge edge1 : edges1) {\n+      Node node1 = edge1.getSource();\n+      for (int i = 0; i < arrEdge2.length; i++) {\n+        Edge edge2 = arrEdge2[i];\n+        if (edge2 != null) {\n+          Node node2 = (Node) edge2.getSource();\n+          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+            count++;\n+            // we mark this edge as already counted so that we don\'t\n+            // count it\n+            // twice when there are multiple edges between two nodes\n+            arrEdge2[i] = null;\n+          }\n+        }\n+      }\n     }\n \n-    // TODO this is bug pruned\n-    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-        //\t\ttry {\n-        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-        results.forEach(\n-                result -> {\n-                    if (graph.hasNamedNode(result))\n-                        graph.addEdge(\n-                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-                });\n-        // Possible change to methods that instantiate classes\n-        // from class -> class edges.\n-        //\t\t\tfor (String result : results) {\n-        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-        //\t\t\t\tString callingNode = null;\n-        //\t\t\t\tif (resultNode instanceof IMethod) {\n-        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-        //\t\t\t\t} else if (resultNode instanceof IType) {\n-        //\t\t\t\t\tIType rst = (IType) resultNode;\n-        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t} else if (resultNode instanceof IField) {\n-        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-        //\t\t\t\t\t// Workaround\n-        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += ".";\n-        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n-        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-        // ASTNodes\n-        //\t\t\t\t\t\t.getParent(initializer,\n-        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-        //\t\t\t\t\t\tIType.class);\n-        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-        //\t\t\t\t}\n-        //\n-        //\t\t\t\t// TODO treat the case when resultNode is instance of\n-        //\t\t\t\t// ImportDeclaration\n-        //\t\t\t\t// TODO treat the case when resultNode is instance of\n-        //\t\t\t\t// Initializer\n-        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-        //\t\t\t\t// Level\n-        //\t\t\t\tif (callingNode == null) {\n-        //\t\t\t\t\tSystem.out.print("");\n-        //\t\t\t\t}\n-        //\t\t\t\tif (callingNode != null) {\n-        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-        //\t\t\t\t\tif (callerNode != null)\n-        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-        //\t\t\t\t}\n-        //\n-        //\t\t\t}\n-        //\n-        //\t\t} catch (CoreException e) {\n-        //\t\t\tJavaPlugin.log(e);\n-        //\t\t}\n+    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+    return (fraction1 + fraction2) / 2.0;\n+  }\n+\n+  protected boolean isTheSameModuloRename(String original, String version) {\n+    Dictionary<String, String> dictionary = getRenamingDictionary();\n+    if (version.equals(dictionary.get(original))) return true;\n+    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+      return original.equals(version);\n+    else if (original\n+        .substring(original.lastIndexOf("."))\n+        .equals(version.substring(version.lastIndexOf("."))))\n+      return isTheSameModuloRename(\n+          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+    else return false;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+        if (pair[0].isAPI() && pair[1].isAPI()) {\n+          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+          if ((n2inV1 == null)) {\n+            prunedCandidates.add(pair);\n+          }\n+        }\n+      }\n     }\n+    return prunedCandidates;\n+  }\n+\n+  // TODO this is bug pruned\n+  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    //\t\ttry {\n+    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+    results.forEach(\n+        result -> {\n+          if (graph.hasNamedNode(result))\n+            graph.addEdge(\n+                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+        });\n+    // Possible change to methods that instantiate classes\n+    // from class -> class edges.\n+    //\t\t\tfor (String result : results) {\n+    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+    //\t\t\t\tString callingNode = null;\n+    //\t\t\t\tif (resultNode instanceof IMethod) {\n+    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof IType) {\n+    //\t\t\t\t\tIType rst = (IType) resultNode;\n+    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t} else if (resultNode instanceof IField) {\n+    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+    //\t\t\t\t\t// Workaround\n+    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += ".";\n+    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+    // ASTNodes\n+    //\t\t\t\t\t\t.getParent(initializer,\n+    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+    //\t\t\t\t\t\tIType.class);\n+    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// ImportDeclaration\n+    //\t\t\t\t// TODO treat the case when resultNode is instance of\n+    //\t\t\t\t// Initializer\n+    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+    //\t\t\t\t// Level\n+    //\t\t\t\tif (callingNode == null) {\n+    //\t\t\t\t\tSystem.out.print("");\n+    //\t\t\t\t}\n+    //\t\t\t\tif (callingNode != null) {\n+    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+    //\t\t\t\t\tif (callerNode != null)\n+    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+    //\t\t\t\t}\n+    //\n+    //\t\t\t}\n+    //\n+    //\t\t} catch (CoreException e) {\n+    //\t\t\tJavaPlugin.log(e);\n+    //\t\t}\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n'
          },
          {
            sha: "61e3c86c3f1a509ae8b075433384dfcb2ef2bb22",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 41,
            deletions: 41,
            patch:
              "@@ -8,48 +8,48 @@\n import refactoring.crawler.graph.NamedDirectedMultigraph;\n \n public class SearchHelper {\n-    public static List<String> findFieldReferences(FieldNode node) {\n-        return node.getFieldReferenceToMethod();\n-    }\n+  public static List<String> findFieldReferences(FieldNode node) {\n+    return node.getFieldReferenceToMethod();\n+  }\n \n-    public static List<String> findSuperClassesOf(ClassNode node) {\n-        return node.getSuperClasses();\n-    }\n+  public static List<String> findSuperClassesOf(ClassNode node) {\n+    return node.getSuperClasses();\n+  }\n \n-    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-        return node.getClassesImported();\n-    }\n+  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+    return node.getClassesImported();\n+  }\n \n-    public static List<String> findMethodCallers(\n-            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-        return graph\n-                .vertexSet()\n-                .stream()\n-                .filter(n -> (n instanceof MethodNode))\n-                .map(methodNode -> (MethodNode) methodNode)\n-                .filter(\n-                        methodNode ->\n-                                methodNode\n-                                        .getCalledInside()\n-                                        .stream()\n-                                        .anyMatch(\n-                                                calledMethod -> {\n-                                                    String expect =\n-                                                            withSignature\n-                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n-                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n-                                                    String actual =\n-                                                            withSignature\n-                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n-                                                                    : node.getFullyQualifiedName();\n-                                                    return expect.equals(actual);\n-                                                }))\n-                .map(\n-                        methodNode -> {\n-                            return withSignature\n-                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n-                                    : methodNode.getFullyQualifiedName();\n-                        })\n-                .collect(Collectors.toList());\n-    }\n+  public static List<String> findMethodCallers(\n+      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+    return graph\n+        .vertexSet()\n+        .stream()\n+        .filter(n -> (n instanceof MethodNode))\n+        .map(methodNode -> (MethodNode) methodNode)\n+        .filter(\n+            methodNode ->\n+                methodNode\n+                    .getCalledInside()\n+                    .stream()\n+                    .anyMatch(\n+                        calledMethod -> {\n+                          String expect =\n+                              withSignature\n+                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                          String actual =\n+                              withSignature\n+                                  ? node.getFullyQualifiedName() + node.getSignature()\n+                                  : node.getFullyQualifiedName();\n+                          return expect.equals(actual);\n+                        }))\n+        .map(\n+            methodNode -> {\n+              return withSignature\n+                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                  : methodNode.getFullyQualifiedName();\n+            })\n+        .collect(Collectors.toList());\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n    return node.getClassesImported();\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n"
          },
          {
            sha: "072aa07a114622cd395391b740b9a1e46b64fb70",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "modified",
            additions: 53,
            deletions: 53,
            patch:
              "@@ -11,67 +11,67 @@\n \n public class ClassDetection extends RefactoringDetection {\n \n-    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        // TODO Auto-generated method stub\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    // TODO Auto-generated method stub\n+    return false;\n+  }\n \n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    /**\n-    * We need to find all the places that the original and version classes are instantiated. We will\n-    * incorporate this into the likeliness grade.\n-    */\n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  /**\n+   * We need to find all the places that the original and version classes are instantiated. We will\n+   * incorporate this into the likeliness grade.\n+   */\n+  protected void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createCallGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        createClassReferenceGraph(node, graph);\n-        node.setCreatedCallGraph();\n+    if (!version.hasCallGraph()) {\n+      createCallGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+    createClassReferenceGraph(node, graph);\n+    node.setCreatedCallGraph();\n+  }\n \n-    /**\n-    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n-    * parameter.\n-    */\n-    public static boolean isSuperClassOf(Node node1, Node node2) {\n-        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n-        for (String superClass : superClasses) {\n-            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n-        }\n-        return false;\n+  /**\n+   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n+   * parameter.\n+   */\n+  public static boolean isSuperClassOf(Node node1, Node node2) {\n+    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+    for (String superClass : superClasses) {\n+      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n     }\n+    return false;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * We need to find all the places that the original and version classes are instantiated. We will\n   * incorporate this into the likeliness grade.\n   */\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    createClassReferenceGraph(node, graph);\n    node.setCreatedCallGraph();\n  }\n\n  /**\n   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n   * parameter.\n   */\n  public static boolean isSuperClassOf(Node node1, Node node2) {\n    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n    for (String superClass : superClasses) {\n      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n    }\n    return false;\n  }\n}\n"
          },
          {
            sha: "e753da375cfabc5fb57d8d5440f95671d7bf42f9",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "modified",
            additions: 30,
            deletions: 30,
            patch:
              "@@ -9,38 +9,38 @@\n \n public class MoveClassDetection extends ClassDetection {\n \n-    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-        double edgeGrade;\n-        createCallGraph(nodeOriginal, nodeVersion);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n-        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return edgeGrade;\n-    }\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n-        for (Node[] pair : prePrunedClasses) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n-            String parentPackageVersion = extractFullyQualifiedParentName(version);\n-            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesInDifferentPackages.add(pair);\n-            }\n-        }\n-        return candidatesInDifferentPackages;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+    for (Node[] pair : prePrunedClasses) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n+      String parentPackageVersion = extractFullyQualifiedParentName(version);\n+      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesInDifferentPackages.add(pair);\n+      }\n     }\n+    return candidatesInDifferentPackages;\n+  }\n \n-    public boolean isRename() {\n-        return false;\n-    }\n+  public boolean isRename() {\n+    return false;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n    for (Node[] pair : prePrunedClasses) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n      String parentPackageVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesInDifferentPackages.add(pair);\n      }\n    }\n    return candidatesInDifferentPackages;\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n"
          },
          {
            sha: "f069e44153341cbf9da6818393293f5e7e9ac108",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 45,
            deletions: 45,
            patch:
              "@@ -8,52 +8,52 @@\n \n public class RenameClassDetection extends ClassDetection {\n \n-    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-        super(graph1, graph2);\n+  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+  }\n+\n+  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+  }\n+\n+  /**\n+   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+   * computeLikelinessIncomingEdges in RefactoringDetection\n+   *\n+   * @param nodeOriginal\n+   * @param nodeVersion\n+   * @return\n+   */\n+  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+    double edgeGrade;\n+    createCallGraph(nodeOriginal, nodeVersion);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return edgeGrade;\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+    for (Node[] pair : prePruned) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentPackageOriginal = extractParentSimpleName(original);\n+      String parentPackageVersion = extractParentSimpleName(version);\n+      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithSameParentPackage.add(pair);\n+      }\n     }\n \n-    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n-    }\n-\n-    /**\n-    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n-    * computeLikelinessIncomingEdges in RefactoringDetection\n-    *\n-    * @param nodeOriginal\n-    * @param nodeVersion\n-    * @return\n-    */\n-    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-        double edgeGrade;\n-        createCallGraph(nodeOriginal, nodeVersion);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return edgeGrade;\n-    }\n+    return candidatesWithSameParentPackage;\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-        for (Node[] pair : prePruned) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentPackageOriginal = extractParentSimpleName(original);\n-            String parentPackageVersion = extractParentSimpleName(version);\n-            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithSameParentPackage.add(pair);\n-            }\n-        }\n-\n-        return candidatesWithSameParentPackage;\n-    }\n-\n-    @Override\n-    public boolean isRename() {\n-        return true;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n"
          },
          {
            sha: "67bf6cf86456904a46c7d568fe0527ed920c971f",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "modified",
            additions: 73,
            deletions: 73,
            patch:
              "@@ -11,90 +11,90 @@\n \n public class FieldDetection extends RefactoringDetection {\n \n-    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n+  @Override\n+  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n \n-    @Override\n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  @Override\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n \n-    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n \n-        for (String result : results) {\n-            //\t\t\t\tIMember resultNode = (IMember) result;\n-            //\t\t\t\tString callingNode = null;\n-            //\t\t\t\tif (resultNode instanceof IMethod) {\n-            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n-            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n-            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n-            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n-            // ASTNodes\n-            //\t\t\t\t\t\t.getParent(initializer,\n-            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n-            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n-            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n-            //\t\t\t\t}\n+    for (String result : results) {\n+      //\t\t\t\tIMember resultNode = (IMember) result;\n+      //\t\t\t\tString callingNode = null;\n+      //\t\t\t\tif (resultNode instanceof IMethod) {\n+      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+      // ASTNodes\n+      //\t\t\t\t\t\t.getParent(initializer,\n+      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+      //\t\t\t\t}\n \n-            Node callerNode = graph.findNamedNode(result);\n-            if (callerNode != null)\n-                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n-        }\n+      Node callerNode = graph.findNamedNode(result);\n+      if (callerNode != null)\n+        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n     }\n+  }\n \n-    public void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createFieldReferenceGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createFieldReferenceGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  public void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createFieldReferenceGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n-        incomingEdgesGrade =\n-                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n+    if (!version.hasCallGraph()) {\n+      createFieldReferenceGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public double analyzeIncomingEdges(Node original, Node version) {\n+    double incomingEdgesGrade;\n+    createCallGraph(original, version);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+    incomingEdgesGrade =\n+        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return incomingEdgesGrade;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n  @Override\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n    for (String result : results) {\n      //\t\t\t\tIMember resultNode = (IMember) result;\n      //\t\t\t\tString callingNode = null;\n      //\t\t\t\tif (resultNode instanceof IMethod) {\n      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n      // ASTNodes\n      //\t\t\t\t\t\t.getParent(initializer,\n      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n      //\t\t\t\t}\n\n      Node callerNode = graph.findNamedNode(result);\n      if (callerNode != null)\n        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n    }\n  }\n\n  public void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createFieldReferenceGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createFieldReferenceGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n"
          },
          {
            sha: "184ff327f5f763cae4d3307e3cf0ae9b0391eb70",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "modified",
            additions: 25,
            deletions: 25,
            patch:
              "@@ -7,34 +7,34 @@\n \n public class MoveFieldDetection extends FieldDetection {\n \n-    /*\n-    * We already have Class - Field edges. So we need to make sure that they\n-    * are different parents, and also make sure that their call graph is still\n-    * the same.\n-    */\n+  /*\n+   * We already have Class - Field edges. So we need to make sure that they\n+   * are different parents, and also make sure that their call graph is still\n+   * the same.\n+   */\n \n-    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public double computeLikeliness(Node original, Node version) {\n-        return analyzeIncomingEdges(original, version);\n-    }\n+  public double computeLikeliness(Node original, Node version) {\n+    return analyzeIncomingEdges(original, version);\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedFields) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedFields) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n \n-            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n-        return candidatesWithDifferentParentClass;\n+      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n+    return candidatesWithDifferentParentClass;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n  /*\n   * We already have Class - Field edges. So we need to make sure that they\n   * are different parents, and also make sure that their call graph is still\n   * the same.\n   */\n\n  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    return analyzeIncomingEdges(original, version);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedFields) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n}\n"
          },
          {
            sha: "6f93400dab485c9315236a4fe01494f3d3b2aef8",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 105,
            deletions: 105,
            patch:
              '@@ -7,123 +7,123 @@\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n \n-    /**\n-    * @param graph\n-    * @param graph2\n-    */\n-    public ChangeMethodSignatureDetection(\n-            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n+  /**\n+   * @param graph\n+   * @param graph2\n+   */\n+  public ChangeMethodSignatureDetection(\n+      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n+\n+  /**\n+   * We need to go from the node to the AST and get the actual method. Then we will call\n+   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n+   * checked, since we do not want to detect polymorphism as change method signature.\n+   */\n+  public double computeLikeliness(Node original, Node version) {\n+    // Need to find out if in V2 there is a node with the same signature\n+    // as the original\n+    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n+    else {\n+      // This is when we have a method overload or deprecated. So when\n+      // we can check deprecated methods we need to add it here\n+      return analyzeIncomingEdges(original, version);\n     }\n+  }\n \n-    /**\n-    * We need to go from the node to the AST and get the actual method. Then we will call\n-    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n-    * checked, since we do not want to detect polymorphism as change method signature.\n-    */\n-    public double computeLikeliness(Node original, Node version) {\n-        // Need to find out if in V2 there is a node with the same signature\n-        // as the original\n-        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n-        else {\n-            // This is when we have a method overload or deprecated. So when\n-            // we can check deprecated methods we need to add it here\n-            return analyzeIncomingEdges(original, version);\n-        }\n-    }\n+  /** This will handle the same name condition, explained above. */\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prunedCandidates = new ArrayList<>();\n+    for (Node[] pair : candidates) {\n+      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n \n-    /** This will handle the same name condition, explained above. */\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n+      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n \n-            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n+      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n \n-            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+      if (hasSameNameAndSignature) continue;\n \n-            if (hasSameNameAndSignature) continue;\n-\n-            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n-                prunedCandidates.add(pair);\n-        }\n-        return prunedCandidates;\n-    }\n-\n-    private boolean hasTheSameSignatureAndName(Node[] pair) {\n-        // TODO here we have to take into account the RenamigsDictionary\n-        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n-        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n-\n-        boolean hasSameNameAndSignature = false;\n-\n-        if (n2ParentInV1 != null) {\n-            // Calling the overloaded method\n-            List<Edge> allMethodEdges =\n-                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n-            for (Edge methodEdge : allMethodEdges) {\n-                Node targetMethod = methodEdge.getTarget();\n-                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n-                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n-                    hasSameNameAndSignature = true;\n-            }\n-        }\n-        return hasSameNameAndSignature;\n+      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n+        prunedCandidates.add(pair);\n     }\n-\n-    private boolean isDeprecatedOrRemoved(Node[] pair) {\n-        Node source = pair[0];\n-        String parentOfOriginal = extractFullyQualifiedParentName(source);\n-        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n-        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n-        boolean isDeprecated = false;\n-        boolean isRemoved = true;\n-        if (parentOfOriginalInV2 != null) {\n-            List<Edge> methodEdges =\n-                    filterNamedEdges(\n-                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n-            for (Edge edge : methodEdges) {\n-                Node methodNode = edge.getTarget();\n-                if (methodNode.getSimpleName().equals(source.getSimpleName())\n-                        && methodNode.getSignature().equals(source.getSignature())) {\n-                    isRemoved = false;\n-                    isDeprecated = methodNode.isDeprecated();\n-                }\n-            }\n-        }\n-\n-        return isDeprecated || isRemoved;\n+    return prunedCandidates;\n+  }\n+\n+  private boolean hasTheSameSignatureAndName(Node[] pair) {\n+    // TODO here we have to take into account the RenamigsDictionary\n+    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+    boolean hasSameNameAndSignature = false;\n+\n+    if (n2ParentInV1 != null) {\n+      // Calling the overloaded method\n+      List<Edge> allMethodEdges =\n+          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+      for (Edge methodEdge : allMethodEdges) {\n+        Node targetMethod = methodEdge.getTarget();\n+        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n+            && targetMethod.getSignature().equals(pair[1].getSignature()))\n+          hasSameNameAndSignature = true;\n+      }\n     }\n-\n-    @Override\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n-        List<Node[]> goodResults = new ArrayList<Node[]>();\n-\n-        for (Node[] pair : listWithFP) {\n-            String signatureN1 = pair[0].getSignature();\n-            String signatureN2 = pair[1].getSignature();\n-            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n+    return hasSameNameAndSignature;\n+  }\n+\n+  private boolean isDeprecatedOrRemoved(Node[] pair) {\n+    Node source = pair[0];\n+    String parentOfOriginal = extractFullyQualifiedParentName(source);\n+    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n+    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+    boolean isDeprecated = false;\n+    boolean isRemoved = true;\n+    if (parentOfOriginalInV2 != null) {\n+      List<Edge> methodEdges =\n+          filterNamedEdges(\n+              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+      for (Edge edge : methodEdges) {\n+        Node methodNode = edge.getTarget();\n+        if (methodNode.getSimpleName().equals(source.getSimpleName())\n+            && methodNode.getSignature().equals(source.getSignature())) {\n+          isRemoved = false;\n+          isDeprecated = methodNode.isDeprecated();\n         }\n-        return goodResults;\n+      }\n     }\n \n-    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n-        // TODO filters out (IPluginDescriptor) with\n-        // (org.eclipse.core.runtime.IPluginDescriptor)\n-        // right now this is checked only for case when there is a one argument\n-        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n-        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n-        return simpleName1.equals(simpleName2);\n-    }\n+    return isDeprecated || isRemoved;\n+  }\n \n-    private String extractSimpleName(String fqn) {\n-        int lastIndex = fqn.lastIndexOf(".");\n-        if (lastIndex < 0) return fqn;\n-        else return fqn.substring(lastIndex + 1);\n-    }\n+  @Override\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+    List<Node[]> goodResults = new ArrayList<Node[]>();\n \n-    public boolean isRename() {\n-        return false;\n+    for (Node[] pair : listWithFP) {\n+      String signatureN1 = pair[0].getSignature();\n+      String signatureN2 = pair[1].getSignature();\n+      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n     }\n+    return goodResults;\n+  }\n+\n+  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+    // TODO filters out (IPluginDescriptor) with\n+    // (org.eclipse.core.runtime.IPluginDescriptor)\n+    // right now this is checked only for case when there is a one argument\n+    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n+    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n+    return simpleName1.equals(simpleName2);\n+  }\n+\n+  private String extractSimpleName(String fqn) {\n+    int lastIndex = fqn.lastIndexOf(".");\n+    if (lastIndex < 0) return fqn;\n+    else return fqn.substring(lastIndex + 1);\n+  }\n+\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n  /**\n   * @param graph\n   * @param graph2\n   */\n  public ChangeMethodSignatureDetection(\n      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We need to go from the node to the AST and get the actual method. Then we will call\n   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n   * checked, since we do not want to detect polymorphism as change method signature.\n   */\n  public double computeLikeliness(Node original, Node version) {\n    // Need to find out if in V2 there is a node with the same signature\n    // as the original\n    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n    else {\n      // This is when we have a method overload or deprecated. So when\n      // we can check deprecated methods we need to add it here\n      return analyzeIncomingEdges(original, version);\n    }\n  }\n\n  /** This will handle the same name condition, explained above. */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n      if (hasSameNameAndSignature) continue;\n\n      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n        prunedCandidates.add(pair);\n    }\n    return prunedCandidates;\n  }\n\n  private boolean hasTheSameSignatureAndName(Node[] pair) {\n    // TODO here we have to take into account the RenamigsDictionary\n    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n    boolean hasSameNameAndSignature = false;\n\n    if (n2ParentInV1 != null) {\n      // Calling the overloaded method\n      List<Edge> allMethodEdges =\n          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n      for (Edge methodEdge : allMethodEdges) {\n        Node targetMethod = methodEdge.getTarget();\n        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n            && targetMethod.getSignature().equals(pair[1].getSignature()))\n          hasSameNameAndSignature = true;\n      }\n    }\n    return hasSameNameAndSignature;\n  }\n\n  private boolean isDeprecatedOrRemoved(Node[] pair) {\n    Node source = pair[0];\n    String parentOfOriginal = extractFullyQualifiedParentName(source);\n    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n    boolean isDeprecated = false;\n    boolean isRemoved = true;\n    if (parentOfOriginalInV2 != null) {\n      List<Edge> methodEdges =\n          filterNamedEdges(\n              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n      for (Edge edge : methodEdges) {\n        Node methodNode = edge.getTarget();\n        if (methodNode.getSimpleName().equals(source.getSimpleName())\n            && methodNode.getSignature().equals(source.getSignature())) {\n          isRemoved = false;\n          isDeprecated = methodNode.isDeprecated();\n        }\n      }\n    }\n\n    return isDeprecated || isRemoved;\n  }\n\n  @Override\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n    List<Node[]> goodResults = new ArrayList<Node[]>();\n\n    for (Node[] pair : listWithFP) {\n      String signatureN1 = pair[0].getSignature();\n      String signatureN2 = pair[1].getSignature();\n      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n    }\n    return goodResults;\n  }\n\n  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n    // TODO filters out (IPluginDescriptor) with\n    // (org.eclipse.core.runtime.IPluginDescriptor)\n    // right now this is checked only for case when there is a one argument\n    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n    return simpleName1.equals(simpleName2);\n  }\n\n  private String extractSimpleName(String fqn) {\n    int lastIndex = fqn.lastIndexOf(".");\n    if (lastIndex < 0) return fqn;\n    else return fqn.substring(lastIndex + 1);\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "9e492fa56e3b1f654735d03da1b18778ea4a3c5e",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "modified",
            additions: 58,
            deletions: 58,
            patch:
              "@@ -11,72 +11,72 @@\n import refactoring.crawler.graph.Node;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n+  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n+  @Override\n+  public double computeLikeliness(Node node1, Node node12) {\n+    // TODO Auto-generated method stub\n+    return 0;\n+  }\n \n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n+  @Override\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    // TODO Auto-generated method stub\n+    return null;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        // TODO Auto-generated method stub\n-        return false;\n-    }\n+  @Override\n+  public boolean isRename() {\n+    // TODO Auto-generated method stub\n+    return false;\n+  }\n \n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge value : list) {\n-            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n-                results.add(value);\n-            }\n-        }\n-        return results;\n+  public List<Edge> filterNamedEdges(List<Edge> list) {\n+    List<Edge> results = new ArrayList<>();\n+    for (Edge value : list) {\n+      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+        results.add(value);\n+      }\n     }\n+    return results;\n+  }\n \n-    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        List<String> callers;\n-        if (this instanceof ChangeMethodSignatureDetection)\n-            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n-        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n-        for (String s : callers) {\n-            Node callerNode = graph.findNamedNode(s);\n-            if (callerNode != null) {\n-                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n-            }\n-        }\n-        node.setCreatedCallGraph();\n+  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+    List<String> callers;\n+    if (this instanceof ChangeMethodSignatureDetection)\n+      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+    for (String s : callers) {\n+      Node callerNode = graph.findNamedNode(s);\n+      if (callerNode != null) {\n+        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+      }\n     }\n+    node.setCreatedCallGraph();\n+  }\n \n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n+  protected void createCallGraph(Node original, Node version) {\n+    if (!original.hasCallGraph()) {\n+      createCallGraph(original, graph1);\n+      original.setCreatedCallGraph();\n     }\n-\n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        List<Edge> incomingEdgesOriginal =\n-                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n-        List<Edge> incomingEdgesVersion =\n-                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n-        incomingEdgesGrade =\n-                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n+    if (!version.hasCallGraph()) {\n+      createCallGraph(version, graph2);\n+      version.setCreatedCallGraph();\n     }\n+  }\n+\n+  public double analyzeIncomingEdges(Node original, Node version) {\n+    double incomingEdgesGrade;\n+    createCallGraph(original, version);\n+    List<Edge> incomingEdgesOriginal =\n+        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+    List<Edge> incomingEdgesVersion =\n+        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+    incomingEdgesGrade =\n+        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+    return incomingEdgesGrade;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    List<String> callers;\n    if (this instanceof ChangeMethodSignatureDetection)\n      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n    for (String s : callers) {\n      Node callerNode = graph.findNamedNode(s);\n      if (callerNode != null) {\n        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n      }\n    }\n    node.setCreatedCallGraph();\n  }\n\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n"
          },
          {
            sha: "76a947129555279bb0423f831c949f1899b2074a",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "modified",
            additions: 186,
            deletions: 186,
            patch:
              '@@ -10,207 +10,207 @@\n \n public class MoveMethodDetection extends MethodDetection {\n \n-    private Node targetClassInVerGraph;\n-\n-    private Node targetClassInOrigGraph;\n-\n-    private RefactoringCrawler crawler;\n-\n-    /**\n-    * Checks for MoveMethod\n-    *\n-    * <p>1. Check that from the old method, all the references to objects having the same type as the\n-    * destination class were removed\n-    *\n-    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n-    */\n-    public MoveMethodDetection(\n-            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-        super(graph1, graph2);\n-        this.crawler = crawler;\n-    }\n-\n-    public double computeLikeliness(Node original, Node version) {\n-        double edgeGrade = 0.0;\n-\n-        double referenceGrade = 0.0;\n-\n-        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+  private Node targetClassInVerGraph;\n+\n+  private Node targetClassInOrigGraph;\n+\n+  private RefactoringCrawler crawler;\n+\n+  /**\n+   * Checks for MoveMethod\n+   *\n+   * <p>1. Check that from the old method, all the references to objects having the same type as the\n+   * destination class were removed\n+   *\n+   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n+   */\n+  public MoveMethodDetection(\n+      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+    super(graph1, graph2);\n+    this.crawler = crawler;\n+  }\n+\n+  public double computeLikeliness(Node original, Node version) {\n+    double edgeGrade = 0.0;\n+\n+    double referenceGrade = 0.0;\n+\n+    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+\n+    // FIXME: Potential problem when we subtract 0.01 from reference grade\n+    referenceGrade = referencesRemoved(original, version);\n+    edgeGrade = analyzeIncomingEdges(original, version);\n+    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+  }\n+\n+  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+    String sourceInOriginal = extractFullyQualifiedParentName(original);\n+    String targetInVersion = extractFullyQualifiedParentName(version);\n+    // treat case 1\n+    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+  }\n+\n+  /**\n+   * 1. Check that from the old method, all the references to objects having the same type as the\n+   * destination class were removed\n+   */\n+  private double referencesRemoved(Node original, Node version) {\n+    String targetInVersion = extractFullyQualifiedParentName(version);\n+\n+    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+    // treat case 2\n+    if (targetClassInOrigGraph == null) {\n+      Dictionary<String, String> dictionary = getRenamingDictionary();\n+      Enumeration<String> keys = dictionary.keys();\n+      for (; keys.hasMoreElements(); ) {\n+        String aKey = keys.nextElement();\n+        String aValue = dictionary.get(aKey);\n+        if (targetInVersion.equals(aValue)) {\n+          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n+        }\n+      }\n \n-        // FIXME: Potential problem when we subtract 0.01 from reference grade\n-        referenceGrade = referencesRemoved(original, version);\n-        edgeGrade = analyzeIncomingEdges(original, version);\n-        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+      // treat case 3\n+      if (targetClassInOrigGraph == null) return 1.0;\n     }\n \n-    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n-        String sourceInOriginal = extractFullyQualifiedParentName(original);\n-        String targetInVersion = extractFullyQualifiedParentName(version);\n-        // treat case 1\n-        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+    // treat case 2 and 4\n+    if (!targetClassInVerGraph.hasCallGraph()) {\n+      createClassReferenceGraph(targetClassInVerGraph, graph2);\n+      targetClassInVerGraph.setCreatedCallGraph();\n     }\n-\n-    /**\n-    * 1. Check that from the old method, all the references to objects having the same type as the\n-    * destination class were removed\n-    */\n-    private double referencesRemoved(Node original, Node version) {\n-        String targetInVersion = extractFullyQualifiedParentName(version);\n-\n-        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n-        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n-        // treat case 2\n-        if (targetClassInOrigGraph == null) {\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            Enumeration<String> keys = dictionary.keys();\n-            for (; keys.hasMoreElements(); ) {\n-                String aKey = keys.nextElement();\n-                String aValue = dictionary.get(aKey);\n-                if (targetInVersion.equals(aValue)) {\n-                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n-                }\n-            }\n-\n-            // treat case 3\n-            if (targetClassInOrigGraph == null) return 1.0;\n-        }\n-\n-        // treat case 2 and 4\n-        if (!targetClassInVerGraph.hasCallGraph()) {\n-            createClassReferenceGraph(targetClassInVerGraph, graph2);\n-            targetClassInVerGraph.setCreatedCallGraph();\n-        }\n-        if (!targetClassInOrigGraph.hasCallGraph()) {\n-            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n-            targetClassInOrigGraph.setCreatedCallGraph();\n-        }\n-\n-        List<Edge> originalClassReferences =\n-                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n-        List<Edge> versionClassReferences =\n-                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n-        if (originalClassReferences.size() == 0) {\n-            if (original.isStatic()) return 1.0;\n-            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n-            if (versionClassReferences.size() == 0) return 1.0;\n-            return 0.0;\n-        } else\n-            return Math.abs(\n-                    ((originalClassReferences.size() - versionClassReferences.size())\n-                            / originalClassReferences.size()));\n+    if (!targetClassInOrigGraph.hasCallGraph()) {\n+      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n+      targetClassInOrigGraph.setCreatedCallGraph();\n     }\n \n-    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n-        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n-        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n-        List<Node> fields = new ArrayList<Node>();\n-        for (Edge value : edges) {\n-            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-                fields.add((Node) value.getTarget());\n-            }\n-        }\n-\n-        return fields.contains(theTargetClassInOrigGraph);\n+    List<Edge> originalClassReferences =\n+        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+    List<Edge> versionClassReferences =\n+        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n+    if (originalClassReferences.size() == 0) {\n+      if (original.isStatic()) return 1.0;\n+      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n+      if (versionClassReferences.size() == 0) return 1.0;\n+      return 0.0;\n+    } else\n+      return Math.abs(\n+          ((originalClassReferences.size() - versionClassReferences.size())\n+              / originalClassReferences.size()));\n+  }\n+\n+  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n+    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+    List<Node> fields = new ArrayList<Node>();\n+    for (Edge value : edges) {\n+      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+        fields.add((Node) value.getTarget());\n+      }\n     }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-\n-            // Prune toString since the SearchEngine finds all the toString()\n-            // methods, even those that are called from different classes\n-            if ("toString".equals(original.getSimpleName())) continue;\n-\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n-        return candidatesWithDifferentParentClass;\n+    return fields.contains(theTargetClassInOrigGraph);\n+  }\n+\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+\n+      // Prune toString since the SearchEngine finds all the toString()\n+      // methods, even those that are called from different classes\n+      if ("toString".equals(original.getSimpleName())) continue;\n+\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n-\n-    @Override\n-    public boolean isRename() {\n-        return false;\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n+\n+  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+    return withoutFP;\n+  }\n+\n+  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+    boolean needsOneMorePass = false;\n+    List<Node[]> addToPUM = new ArrayList<>();\n+    List<Node[]> addToPDM = new ArrayList<>();\n+    for (Node[] pair : withoutFP) {\n+      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n+      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n+      if (sourceClass != null && destinationClass != null) {\n+        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n+        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n+      }\n     }\n \n-    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n-        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n-        return withoutFP;\n+    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+    RefactoringCategory pulledUpCategory = null;\n+    RefactoringCategory pushedDownCategory = null;\n+    // TODO this only checks whether we already have such a category\n+    // created. It might be\n+    // that such a category has not been created previously (because no\n+    // results were found\n+    // for that category. In this case, will need to create a brand new\n+    // Category object.\n+    for (RefactoringCategory category : refactoringsList) {\n+      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n+      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n     }\n \n-    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n-        boolean needsOneMorePass = false;\n-        List<Node[]> addToPUM = new ArrayList<>();\n-        List<Node[]> addToPDM = new ArrayList<>();\n-        for (Node[] pair : withoutFP) {\n-            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n-            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n-            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n-            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n-            if (sourceClass != null && destinationClass != null) {\n-                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n-                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n-            }\n-        }\n-\n-        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\n-        RefactoringCategory pulledUpCategory = null;\n-        RefactoringCategory pushedDownCategory = null;\n-        // TODO this only checks whether we already have such a category\n-        // created. It might be\n-        // that such a category has not been created previously (because no\n-        // results were found\n-        // for that category. In this case, will need to create a brand new\n-        // Category object.\n-        for (RefactoringCategory category : refactoringsList) {\n-            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n-            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n-        }\n-\n-        for (Node[] pair : addToPDM) {\n-            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n-            withoutFP.remove(pair);\n-            needsOneMorePass = true;\n-        }\n-\n-        for (Node[] pair : addToPUM) {\n-            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n-            withoutFP.remove(pair);\n-            needsOneMorePass = true;\n-        }\n-        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n-        else return withoutFP;\n+    for (Node[] pair : addToPDM) {\n+      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n+      withoutFP.remove(pair);\n+      needsOneMorePass = true;\n     }\n \n-    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n-        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-        List<Node[]> pairsToRemove = new ArrayList<>();\n-        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-        for (RefactoringCategory category : refactoringsList) {\n-            if (category.getName().equals("PulledUpMethods")\n-                    || category.getName().equals("PushedDownMethods")) {\n-                for (Node[] pair : category.getRefactoringPairs()) {\n-                    for (Node[] prunedPair : prunedList) {\n-                        // The OR below takes care about n->1 and 1->n\n-                        // overlappings\n-                        // between PullUp/PushDown and MoveMethod\n-                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n-                    }\n-                }\n-            }\n-        }\n-        for (Node[] pair : pairsToRemove) {\n-            prunedList.remove(pair);\n+    for (Node[] pair : addToPUM) {\n+      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n+      withoutFP.remove(pair);\n+      needsOneMorePass = true;\n+    }\n+    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n+    else return withoutFP;\n+  }\n+\n+  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+    List<Node[]> pairsToRemove = new ArrayList<>();\n+    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+    for (RefactoringCategory category : refactoringsList) {\n+      if (category.getName().equals("PulledUpMethods")\n+          || category.getName().equals("PushedDownMethods")) {\n+        for (Node[] pair : category.getRefactoringPairs()) {\n+          for (Node[] prunedPair : prunedList) {\n+            // The OR below takes care about n->1 and 1->n\n+            // overlappings\n+            // between PullUp/PushDown and MoveMethod\n+            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n+          }\n         }\n-        return prunedList;\n+      }\n+    }\n+    for (Node[] pair : pairsToRemove) {\n+      prunedList.remove(pair);\n     }\n+    return prunedList;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n  private Node targetClassInVerGraph;\n\n  private Node targetClassInOrigGraph;\n\n  private RefactoringCrawler crawler;\n\n  /**\n   * Checks for MoveMethod\n   *\n   * <p>1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   *\n   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n   */\n  public MoveMethodDetection(\n      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n    this.crawler = crawler;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    double edgeGrade = 0.0;\n\n    double referenceGrade = 0.0;\n\n    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n    // FIXME: Potential problem when we subtract 0.01 from reference grade\n    referenceGrade = referencesRemoved(original, version);\n    edgeGrade = analyzeIncomingEdges(original, version);\n    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n  }\n\n  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n    String sourceInOriginal = extractFullyQualifiedParentName(original);\n    String targetInVersion = extractFullyQualifiedParentName(version);\n    // treat case 1\n    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n  }\n\n  /**\n   * 1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   */\n  private double referencesRemoved(Node original, Node version) {\n    String targetInVersion = extractFullyQualifiedParentName(version);\n\n    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n    // treat case 2\n    if (targetClassInOrigGraph == null) {\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      Enumeration<String> keys = dictionary.keys();\n      for (; keys.hasMoreElements(); ) {\n        String aKey = keys.nextElement();\n        String aValue = dictionary.get(aKey);\n        if (targetInVersion.equals(aValue)) {\n          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n        }\n      }\n\n      // treat case 3\n      if (targetClassInOrigGraph == null) return 1.0;\n    }\n\n    // treat case 2 and 4\n    if (!targetClassInVerGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInVerGraph, graph2);\n      targetClassInVerGraph.setCreatedCallGraph();\n    }\n    if (!targetClassInOrigGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n      targetClassInOrigGraph.setCreatedCallGraph();\n    }\n\n    List<Edge> originalClassReferences =\n        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n    List<Edge> versionClassReferences =\n        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n    if (originalClassReferences.size() == 0) {\n      if (original.isStatic()) return 1.0;\n      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n      if (versionClassReferences.size() == 0) return 1.0;\n      return 0.0;\n    } else\n      return Math.abs(\n          ((originalClassReferences.size() - versionClassReferences.size())\n              / originalClassReferences.size()));\n  }\n\n  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n    List<Node> fields = new ArrayList<Node>();\n    for (Edge value : edges) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        fields.add((Node) value.getTarget());\n      }\n    }\n\n    return fields.contains(theTargetClassInOrigGraph);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n\n      // Prune toString since the SearchEngine finds all the toString()\n      // methods, even those that are called from different classes\n      if ("toString".equals(original.getSimpleName())) continue;\n\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n    return withoutFP;\n  }\n\n  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n    boolean needsOneMorePass = false;\n    List<Node[]> addToPUM = new ArrayList<>();\n    List<Node[]> addToPDM = new ArrayList<>();\n    for (Node[] pair : withoutFP) {\n      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n      if (sourceClass != null && destinationClass != null) {\n        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n      }\n    }\n\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n    RefactoringCategory pulledUpCategory = null;\n    RefactoringCategory pushedDownCategory = null;\n    // TODO this only checks whether we already have such a category\n    // created. It might be\n    // that such a category has not been created previously (because no\n    // results were found\n    // for that category. In this case, will need to create a brand new\n    // Category object.\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n    }\n\n    for (Node[] pair : addToPDM) {\n      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n\n    for (Node[] pair : addToPUM) {\n      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n    else return withoutFP;\n  }\n\n  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    List<Node[]> pairsToRemove = new ArrayList<>();\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")\n          || category.getName().equals("PushedDownMethods")) {\n        for (Node[] pair : category.getRefactoringPairs()) {\n          for (Node[] prunedPair : prunedList) {\n            // The OR below takes care about n->1 and 1->n\n            // overlappings\n            // between PullUp/PushDown and MoveMethod\n            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n          }\n        }\n      }\n    }\n    for (Node[] pair : pairsToRemove) {\n      prunedList.remove(pair);\n    }\n    return prunedList;\n  }\n}\n'
          },
          {
            sha: "2c24f295bf40887025a35ce694a69c056b81a7a3",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "modified",
            additions: 50,
            deletions: 50,
            patch:
              '@@ -8,59 +8,59 @@\n \n public class PullUpMethodDetection extends MethodDetection {\n \n-    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    /**\n-    * We should now check for the same method being in the parent class, thus for the two nodes,\n-    * check if the version now resides in the superclass of the original method\'s parent class.\n-    */\n-    // TODO: Check why we get a null pointer exception with parentclassver and\n-    // parent class orig)\n-    public double computeLikeliness(Node original, Node version) {\n-        double incomingEdgesGrade = 0.0;\n-        boolean isSuperclass = false;\n-        // TODO: Think about possible different cases that this might be\n-        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n-        // find it.\n-        // TODO: Think about the NULL case. Return 0.0 if you find null,\n-        // since clearly they are not "like" each other.\n-        String parentClassOriginal = extractFullyQualifiedParentName(original);\n-        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n-        String parentClassVersion = extractFullyQualifiedParentName(version);\n-        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-        if (parentClassOrig == null) return 0.0;\n-        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n-        // Now we should check if parentClassOrig is a subclass of\n-        // parentClassVer\n-        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n+  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-        if (isSuperclass) {\n-            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n-            return incomingEdgesGrade;\n-        } else return 0.0;\n-    }\n+  /**\n+   * We should now check for the same method being in the parent class, thus for the two nodes,\n+   * check if the version now resides in the superclass of the original method\'s parent class.\n+   */\n+  // TODO: Check why we get a null pointer exception with parentclassver and\n+  // parent class orig)\n+  public double computeLikeliness(Node original, Node version) {\n+    double incomingEdgesGrade = 0.0;\n+    boolean isSuperclass = false;\n+    // TODO: Think about possible different cases that this might be\n+    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+    // find it.\n+    // TODO: Think about the NULL case. Return 0.0 if you find null,\n+    // since clearly they are not "like" each other.\n+    String parentClassOriginal = extractFullyQualifiedParentName(original);\n+    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+    String parentClassVersion = extractFullyQualifiedParentName(version);\n+    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+    if (parentClassOrig == null) return 0.0;\n+    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+    // Now we should check if parentClassOrig is a subclass of\n+    // parentClassVer\n+    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractParentSimpleName(original);\n-            String parentClassVersion = extractParentSimpleName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n+    if (isSuperclass) {\n+      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n+      return incomingEdgesGrade;\n+    } else return 0.0;\n+  }\n \n-        return candidatesWithDifferentParentClass;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractParentSimpleName(original);\n+      String parentClassVersion = extractParentSimpleName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We should now check for the same method being in the parent class, thus for the two nodes,\n   * check if the version now resides in the superclass of the original method\'s parent class.\n   */\n  // TODO: Check why we get a null pointer exception with parentclassver and\n  // parent class orig)\n  public double computeLikeliness(Node original, Node version) {\n    double incomingEdgesGrade = 0.0;\n    boolean isSuperclass = false;\n    // TODO: Think about possible different cases that this might be\n    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n    // find it.\n    // TODO: Think about the NULL case. Return 0.0 if you find null,\n    // since clearly they are not "like" each other.\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassOrig is a subclass of\n    // parentClassVer\n    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n    if (isSuperclass) {\n      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n      return incomingEdgesGrade;\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "296bce275d7968716d7f0bed80da373e18210114",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "modified",
            additions: 39,
            deletions: 39,
            patch:
              '@@ -8,47 +8,47 @@\n \n public class PushDownMethodDetection extends MethodDetection {\n \n-    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    public double computeLikeliness(Node original, Node version) {\n-        boolean superClassGrade = false;\n-        String parentClassOriginal = extractFullyQualifiedParentName(original);\n-        String parentClassVersion = extractFullyQualifiedParentName(version);\n-        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n-        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-        if (parentClassOrig == null) return 0.0;\n-        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n-        // Now we should check if parentClassVer is a subclass of\n-        // parentClassOrig\n-        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n-            System.out.println("stop");\n-        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n-        if (superClassGrade) {\n-            return (analyzeIncomingEdges(original, version));\n-        } else return 0.0;\n-    }\n+  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+    super(graph, graph2);\n+  }\n \n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractParentSimpleName(original);\n-            String parentClassVersion = extractParentSimpleName(version);\n-            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n-                candidatesWithDifferentParentClass.add(pair);\n-            }\n-        }\n+  public double computeLikeliness(Node original, Node version) {\n+    boolean superClassGrade = false;\n+    String parentClassOriginal = extractFullyQualifiedParentName(original);\n+    String parentClassVersion = extractFullyQualifiedParentName(version);\n+    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+    if (parentClassOrig == null) return 0.0;\n+    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+    // Now we should check if parentClassVer is a subclass of\n+    // parentClassOrig\n+    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+      System.out.println("stop");\n+    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n+    if (superClassGrade) {\n+      return (analyzeIncomingEdges(original, version));\n+    } else return 0.0;\n+  }\n \n-        return candidatesWithDifferentParentClass;\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractParentSimpleName(original);\n+      String parentClassVersion = extractParentSimpleName(version);\n+      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+        candidatesWithDifferentParentClass.add(pair);\n+      }\n     }\n \n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n+    return candidatesWithDifferentParentClass;\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return false;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    boolean superClassGrade = false;\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassVer is a subclass of\n    // parentClassOrig\n    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n      System.out.println("stop");\n    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n    if (superClassGrade) {\n      return (analyzeIncomingEdges(original, version));\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n'
          },
          {
            sha: "8cb105ce7458d9c39635ff368d652f3cd45ba1ef",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 60,
            deletions: 60,
            patch:
              "@@ -8,71 +8,71 @@\n \n public class RenameMethodDetection extends MethodDetection {\n \n-    public RenameMethodDetection(\n-            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-        super(oldVersion, newVersion);\n-    }\n-\n-    /**\n-    * @param candidates List containing clone methods\n-    * @return A List containing only the candidate methods that are in the same class\n-    */\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n-                candidatesWithSameParentClass.add(pair);\n-        }\n+  public RenameMethodDetection(\n+      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+    super(oldVersion, newVersion);\n+  }\n \n-        return candidatesWithSameParentClass;\n+  /**\n+   * @param candidates List containing clone methods\n+   * @return A List containing only the candidate methods that are in the same class\n+   */\n+  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+    for (Node[] pair : prePrunedMethods) {\n+      Node original = pair[0];\n+      Node version = pair[1];\n+      String parentClassOriginal = extractFullyQualifiedParentName(original);\n+      String parentClassVersion = extractFullyQualifiedParentName(version);\n+      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n+        candidatesWithSameParentClass.add(pair);\n     }\n \n-    public double computeLikeliness(Node original, Node version) {\n-        // createCallGraph(original, version);\n-        // return computeLikelinessConsideringEdges(original, version);\n-        return analyzeIncomingEdges(original, version);\n-    }\n+    return candidatesWithSameParentClass;\n+  }\n \n-    @Override\n-    public boolean isRename() {\n-        return true;\n-    }\n+  public double computeLikeliness(Node original, Node version) {\n+    // createCallGraph(original, version);\n+    // return computeLikelinessConsideringEdges(original, version);\n+    return analyzeIncomingEdges(original, version);\n+  }\n+\n+  @Override\n+  public boolean isRename() {\n+    return true;\n+  }\n \n-    /**\n-    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n-    * getStartConnector) in JHD5.3 )\n-    */\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-        for (int i = 0; i < prunedList.size(); i++) {\n-            Node[] pair = prunedList.get(i);\n-            Node target = pair[1];\n-            String targetName = target.getSimpleName().toLowerCase().trim();\n-            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n-            for (Node[] nodes : prunedList) {\n-                Node potentialTarget = (nodes)[1];\n-                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n-            }\n-            if (allPairsWithSameTarget.size() > 1) {\n-                for (Object o : allPairsWithSameTarget) {\n-                    Node[] sameTargetPair = (Node[]) o;\n-                    Node sourceNode = sameTargetPair[0];\n-                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n-                    // Changed from || to && and changed the !='s to =='s\n-                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n-                        prunedList.remove(sameTargetPair);\n-                        Dictionary<String, String> dictionary = getRenamingDictionary();\n-                        dictionary.remove(sourceNode.getFullyQualifiedName());\n-                    }\n-                }\n-            }\n+  /**\n+   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n+   * getStartConnector) in JHD5.3 )\n+   */\n+  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+    for (int i = 0; i < prunedList.size(); i++) {\n+      Node[] pair = prunedList.get(i);\n+      Node target = pair[1];\n+      String targetName = target.getSimpleName().toLowerCase().trim();\n+      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+      for (Node[] nodes : prunedList) {\n+        Node potentialTarget = (nodes)[1];\n+        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n+      }\n+      if (allPairsWithSameTarget.size() > 1) {\n+        for (Object o : allPairsWithSameTarget) {\n+          Node[] sameTargetPair = (Node[]) o;\n+          Node sourceNode = sameTargetPair[0];\n+          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n+          // Changed from || to && and changed the !='s to =='s\n+          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n+            prunedList.remove(sameTargetPair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(sourceNode.getFullyQualifiedName());\n+          }\n         }\n-        return prunedList;\n+      }\n     }\n+    return prunedList;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName()))))\n        candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n"
          },
          {
            sha: "66cc05cc40337a87d4835854e19c62d19d2c4067",
            filename: "src/main/java/refactoring/crawler/graph/ClassNode.java",
            status: "modified",
            additions: 6,
            deletions: 6,
            patch:
              "@@ -7,12 +7,12 @@\n \n public class ClassNode extends Node {\n \n-    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n+  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n \n-    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n+  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public ClassNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.CLASS);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public ClassNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.CLASS);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public ClassNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.CLASS);\n  }\n}\n"
          },
          {
            sha: "7774ec8b37feef6882a868e2660021a320eeaa54",
            filename: "src/main/java/refactoring/crawler/graph/Edge.java",
            status: "modified",
            additions: 26,
            deletions: 26,
            patch:
              '@@ -6,30 +6,30 @@\n \n public class Edge extends DefaultEdge {\n \n-    @Getter @Setter private Node.Type label;\n-\n-    public Edge(Node.Type label) {\n-        this.label = label;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-    }\n-\n-    @Override\n-    public Node getSource() {\n-        return (Node) super.getSource();\n-    }\n-\n-    @Override\n-    public Node getTarget() {\n-        return (Node) super.getTarget();\n-    }\n-\n-    public Node oppositeVertex(Node n) {\n-        Node source = this.getSource();\n-        Node target = this.getTarget();\n-        return n.equals(source) ? target : source;\n-    }\n+  @Getter @Setter private Node.Type label;\n+\n+  public Edge(Node.Type label) {\n+    this.label = label;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+  }\n+\n+  @Override\n+  public Node getSource() {\n+    return (Node) super.getSource();\n+  }\n+\n+  @Override\n+  public Node getTarget() {\n+    return (Node) super.getTarget();\n+  }\n+\n+  public Node oppositeVertex(Node n) {\n+    Node source = this.getSource();\n+    Node target = this.getTarget();\n+    return n.equals(source) ? target : source;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n  @Getter @Setter private Node.Type label;\n\n  public Edge(Node.Type label) {\n    this.label = label;\n  }\n\n  @Override\n  public String toString() {\n    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n  }\n\n  @Override\n  public Node getSource() {\n    return (Node) super.getSource();\n  }\n\n  @Override\n  public Node getTarget() {\n    return (Node) super.getTarget();\n  }\n\n  public Node oppositeVertex(Node n) {\n    Node source = this.getSource();\n    Node target = this.getTarget();\n    return n.equals(source) ? target : source;\n  }\n}\n'
          },
          {
            sha: "51d845ea135825c28660aac7c258adde05243914",
            filename: "src/main/java/refactoring/crawler/graph/FieldNode.java",
            status: "modified",
            additions: 5,
            deletions: 5,
            patch:
              "@@ -6,10 +6,10 @@\n \n public class FieldNode extends Node {\n \n-    @Getter @Setter private List<String> fieldReferenceToMethod;\n+  @Getter @Setter private List<String> fieldReferenceToMethod;\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public FieldNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.FIELD);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public FieldNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.FIELD);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n  @Getter @Setter private List<String> fieldReferenceToMethod;\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public FieldNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.FIELD);\n  }\n}\n"
          },
          {
            sha: "e2919264f5aa7154db6f0c0501950564a730a1e3",
            filename: "src/main/java/refactoring/crawler/graph/MethodNode.java",
            status: "modified",
            additions: 10,
            deletions: 10,
            patch:
              "@@ -8,17 +8,17 @@\n \n public class MethodNode extends Node {\n \n-    @AllArgsConstructor\n-    public static class CalledMethod {\n-        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n+  @AllArgsConstructor\n+  public static class CalledMethod {\n+    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n \n-        @Getter @Setter private String fullyQualifiedNameWithSignature;\n-    }\n+    @Getter @Setter private String fullyQualifiedNameWithSignature;\n+  }\n \n-    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n+  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n \n-    /** @param fullyQualifiedName fullyQualifiedName */\n-    public MethodNode(String fullyQualifiedName) {\n-        super(fullyQualifiedName, Type.METHOD);\n-    }\n+  /** @param fullyQualifiedName fullyQualifiedName */\n+  public MethodNode(String fullyQualifiedName) {\n+    super(fullyQualifiedName, Type.METHOD);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n  @AllArgsConstructor\n  public static class CalledMethod {\n    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n    @Getter @Setter private String fullyQualifiedNameWithSignature;\n  }\n\n  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public MethodNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.METHOD);\n  }\n}\n"
          },
          {
            sha: "5c0ac895baf10b75181e22675a8b7840b08fb90d",
            filename:
              "src/main/java/refactoring/crawler/graph/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 24,
            deletions: 24,
            patch:
              "@@ -8,28 +8,28 @@\n \n public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n \n-    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n-\n-    public NamedDirectedMultigraph() {\n-        super(Edge.class);\n-    }\n-\n-    public NamedDirectedMultigraph(\n-            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-        super(vertexSupplier, edgeSupplier, weighted);\n-    }\n-\n-    public boolean addNamedVertex(Node v) {\n-        if (!addVertex(v)) return false;\n-        namedVertexMap.put(v.getFullyQualifiedName(), v);\n-        return true;\n-    }\n-\n-    public Node findNamedNode(String name) {\n-        return namedVertexMap.get(name);\n-    }\n-\n-    public boolean hasNamedNode(String name) {\n-        return namedVertexMap.containsKey(name);\n-    }\n+  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+  public NamedDirectedMultigraph() {\n+    super(Edge.class);\n+  }\n+\n+  public NamedDirectedMultigraph(\n+      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+    super(vertexSupplier, edgeSupplier, weighted);\n+  }\n+\n+  public boolean addNamedVertex(Node v) {\n+    if (!addVertex(v)) return false;\n+    namedVertexMap.put(v.getFullyQualifiedName(), v);\n+    return true;\n+  }\n+\n+  public Node findNamedNode(String name) {\n+    return namedVertexMap.get(name);\n+  }\n+\n+  public boolean hasNamedNode(String name) {\n+    return namedVertexMap.containsKey(name);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n  public NamedDirectedMultigraph() {\n    super(Edge.class);\n  }\n\n  public NamedDirectedMultigraph(\n      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n    super(vertexSupplier, edgeSupplier, weighted);\n  }\n\n  public boolean addNamedVertex(Node v) {\n    if (!addVertex(v)) return false;\n    namedVertexMap.put(v.getFullyQualifiedName(), v);\n    return true;\n  }\n\n  public Node findNamedNode(String name) {\n    return namedVertexMap.get(name);\n  }\n\n  public boolean hasNamedNode(String name) {\n    return namedVertexMap.containsKey(name);\n  }\n}\n"
          },
          {
            sha: "4397227e131372600696f0c613eaab9d7bf41229",
            filename: "src/main/java/refactoring/crawler/graph/Node.java",
            status: "modified",
            additions: 50,
            deletions: 50,
            patch:
              '@@ -5,70 +5,70 @@\n \n public class Node {\n \n-    public boolean hasCallGraph() {\n-        return false;\n-    }\n+  public boolean hasCallGraph() {\n+    return false;\n+  }\n \n-    public void setCreatedCallGraph() {}\n-\n-    public static enum Type {\n-        PROJECT,\n-        PACKAGE,\n-        CLASS,\n-        METHOD,\n-        FIELD,\n-        METHOD_CALL,\n-        IMPORT,\n-        CLASS_REFERENCE,\n-        FIELD_REFERENCE\n-    }\n+  public void setCreatedCallGraph() {}\n \n-    @Getter @Setter private String fullyQualifiedName;\n+  public static enum Type {\n+    PROJECT,\n+    PACKAGE,\n+    CLASS,\n+    METHOD,\n+    FIELD,\n+    METHOD_CALL,\n+    IMPORT,\n+    CLASS_REFERENCE,\n+    FIELD_REFERENCE\n+  }\n \n-    @Setter @Getter private Node.Type type;\n+  @Getter @Setter private String fullyQualifiedName;\n \n-    @Setter @Getter private int[] shingles;\n+  @Setter @Getter private Node.Type type;\n \n-    @Setter @Getter private boolean hasCallGraph;\n+  @Setter @Getter private int[] shingles;\n \n-    @Setter @Getter private String projectName;\n+  @Setter @Getter private boolean hasCallGraph;\n \n-    @Setter @Getter private boolean isAPI = false;\n+  @Setter @Getter private String projectName;\n \n-    @Setter @Getter private String signature;\n+  @Setter @Getter private boolean isAPI = false;\n \n-    @Setter @Getter private int flags;\n+  @Setter @Getter private String signature;\n \n-    @Setter @Getter private boolean deprecated = false;\n+  @Setter @Getter private int flags;\n \n-    @Setter @Getter private boolean isInterface = false;\n+  @Setter @Getter private boolean deprecated = false;\n \n-    @Getter @Setter private boolean isStatic = false;\n+  @Setter @Getter private boolean isInterface = false;\n \n-    /**\n-    * @param fullyQualifiedName fullyQualifiedName\n-    * @param type type\n-    */\n-    public Node(String fullyQualifiedName, Node.Type type) {\n-        this.fullyQualifiedName = fullyQualifiedName;\n-        this.type = type;\n-    }\n+  @Getter @Setter private boolean isStatic = false;\n \n-    public String getSimpleName() {\n-        int pos = fullyQualifiedName.lastIndexOf(".");\n-        if (pos != -1) {\n-            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n-        }\n-        return fullyQualifiedName;\n-    }\n+  /**\n+   * @param fullyQualifiedName fullyQualifiedName\n+   * @param type type\n+   */\n+  public Node(String fullyQualifiedName, Node.Type type) {\n+    this.fullyQualifiedName = fullyQualifiedName;\n+    this.type = type;\n+  }\n \n-    @Override\n-    public String toString() {\n-        if (getSignature() != null)\n-            return getType()\n-                    + "= "\n-                    + getFullyQualifiedName()\n-                    + getSignature().substring(getSignature().indexOf("("));\n-        else return getType() + "= " + getFullyQualifiedName();\n+  public String getSimpleName() {\n+    int pos = fullyQualifiedName.lastIndexOf(".");\n+    if (pos != -1) {\n+      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n     }\n+    return fullyQualifiedName;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    if (getSignature() != null)\n+      return getType()\n+          + "= "\n+          + getFullyQualifiedName()\n+          + getSignature().substring(getSignature().indexOf("("));\n+    else return getType() + "= " + getFullyQualifiedName();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n  public boolean hasCallGraph() {\n    return false;\n  }\n\n  public void setCreatedCallGraph() {}\n\n  public static enum Type {\n    PROJECT,\n    PACKAGE,\n    CLASS,\n    METHOD,\n    FIELD,\n    METHOD_CALL,\n    IMPORT,\n    CLASS_REFERENCE,\n    FIELD_REFERENCE\n  }\n\n  @Getter @Setter private String fullyQualifiedName;\n\n  @Setter @Getter private Node.Type type;\n\n  @Setter @Getter private int[] shingles;\n\n  @Setter @Getter private boolean hasCallGraph;\n\n  @Setter @Getter private String projectName;\n\n  @Setter @Getter private boolean isAPI = false;\n\n  @Setter @Getter private String signature;\n\n  @Setter @Getter private int flags;\n\n  @Setter @Getter private boolean deprecated = false;\n\n  @Setter @Getter private boolean isInterface = false;\n\n  @Getter @Setter private boolean isStatic = false;\n\n  /**\n   * @param fullyQualifiedName fullyQualifiedName\n   * @param type type\n   */\n  public Node(String fullyQualifiedName, Node.Type type) {\n    this.fullyQualifiedName = fullyQualifiedName;\n    this.type = type;\n  }\n\n  public String getSimpleName() {\n    int pos = fullyQualifiedName.lastIndexOf(".");\n    if (pos != -1) {\n      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n    }\n    return fullyQualifiedName;\n  }\n\n  @Override\n  public String toString() {\n    if (getSignature() != null)\n      return getType()\n          + "= "\n          + getFullyQualifiedName()\n          + getSignature().substring(getSignature().indexOf("("));\n    else return getType() + "= " + getFullyQualifiedName();\n  }\n}\n'
          },
          {
            sha: "98bf2210121031f53e8caf7f8f89645f6b1dcc86",
            filename:
              "src/main/java/refactoring/crawler/shingles/BloomFilter.java",
            status: "modified",
            additions: 464,
            deletions: 464,
            patch:
              '@@ -11,512 +11,512 @@\n import java.net.URL;\n \n /**\n-* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n-*\n-* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n-* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n-* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n-* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n-* can make a useful tool.\n-*\n-* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n-* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n-* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n-* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n-* checkers.\n-*\n-* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n-* vector of a given length. We choose the length of the bit vector and the number of hash functions\n-* depending on how many keys we want to add to the set and how high an error rate we are willing to\n-* put up with.\n-*\n-* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n-* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n-* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n-* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n-* function would increase our false-positive rate.\n-*\n-* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n-* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n-* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n-* a Bloom filter.\n-*\n-* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n-* key. We run the key through our set of hash functions, and then check to see whether the bits at\n-* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n-* the filter. If all of the bits are on, we know the key is probably there.\n-*\n-* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n-* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n-* bits we check will be on, unless the key actually exists in the filter. The relationship between\n-* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n-* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n-* will be very dense, increasing the probability of collisions. You can calculate the\n-* false-positive rate for any filter using the formula:\n-*\n-* <p><code>c = ( 1 - e(-kn/m) )k</code>\n-*\n-* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n-* in the filter, and m is the length of the filter in bits.\n-*\n-* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n-* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n-* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n-* our limit. The following equation will give us vector length from the error rate and number of\n-* keys:\n-*\n-* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n-*\n-* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n-* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n-* combinations of error rate, filter size, and number of hash functions at <a\n-* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n-* -- the math</a>.\n-*\n-* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n-* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n-* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n-* the case of JDK 1.4).\n-*\n-* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n-* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n-* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n-* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n-* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n-* even in this Java implementation the speed is reasonable.\n-*\n-* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n-* method" by Andrei Broder. See <a\n-* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n-* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n-* paper in PDF format.\n-*\n-* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n-* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n-* <code>URL</code>.\n-*\n-* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n-* initial value multiplied by a list of distinct values.\n-*\n-* @see java.lang.Object#hashCode()\n-* @see java.util.Map\n-* @author Bruno Martins\n-*/\n+ * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n+ *\n+ * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n+ * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n+ * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n+ * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n+ * can make a useful tool.\n+ *\n+ * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+ * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n+ * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n+ * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n+ * checkers.\n+ *\n+ * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n+ * vector of a given length. We choose the length of the bit vector and the number of hash functions\n+ * depending on how many keys we want to add to the set and how high an error rate we are willing to\n+ * put up with.\n+ *\n+ * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n+ * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n+ * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+ * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+ * function would increase our false-positive rate.\n+ *\n+ * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n+ * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+ * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n+ * a Bloom filter.\n+ *\n+ * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n+ * key. We run the key through our set of hash functions, and then check to see whether the bits at\n+ * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n+ * the filter. If all of the bits are on, we know the key is probably there.\n+ *\n+ * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n+ * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n+ * bits we check will be on, unless the key actually exists in the filter. The relationship between\n+ * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+ * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n+ * will be very dense, increasing the probability of collisions. You can calculate the\n+ * false-positive rate for any filter using the formula:\n+ *\n+ * <p><code>c = ( 1 - e(-kn/m) )k</code>\n+ *\n+ * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n+ * in the filter, and m is the length of the filter in bits.\n+ *\n+ * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n+ * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n+ * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n+ * our limit. The following equation will give us vector length from the error rate and number of\n+ * keys:\n+ *\n+ * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n+ *\n+ * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+ * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n+ * combinations of error rate, filter size, and number of hash functions at <a\n+ * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n+ * -- the math</a>.\n+ *\n+ * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n+ * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n+ * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n+ * the case of JDK 1.4).\n+ *\n+ * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n+ * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n+ * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n+ * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n+ * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n+ * even in this Java implementation the speed is reasonable.\n+ *\n+ * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+ * method" by Andrei Broder. See <a\n+ * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+ * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+ * paper in PDF format.\n+ *\n+ * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n+ * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n+ * <code>URL</code>.\n+ *\n+ * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+ * initial value multiplied by a list of distinct values.\n+ *\n+ * @see java.lang.Object#hashCode()\n+ * @see java.util.Map\n+ * @author Bruno Martins\n+ */\n public class BloomFilter implements Cloneable {\n \n-    /** A buffer for the Rabin fingerprinting algorithm. */\n-    private byte[] buffer;\n+  /** A buffer for the Rabin fingerprinting algorithm. */\n+  private byte[] buffer;\n \n-    /**\n-    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n-    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n-    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n-    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n-    * bit is the constant coefficient.\n-    *\n-    * <p>For example the integer 0x00000803, in binary, is:\n-    *\n-    * <p><code>00000000 00000000 00001000 00000011</code>\n-    *\n-    * <p>Therefore it correponds to the polynomial:\n-    *\n-    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n-    */\n-    private static int POLYNOMIAL = 0x000001C7;\n+  /**\n+   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n+   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n+   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n+   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+   * bit is the constant coefficient.\n+   *\n+   * <p>For example the integer 0x00000803, in binary, is:\n+   *\n+   * <p><code>00000000 00000000 00001000 00000011</code>\n+   *\n+   * <p>Therefore it correponds to the polynomial:\n+   *\n+   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+   */\n+  private static int POLYNOMIAL = 0x000001C7;\n \n-    /** Internal values for the Rabin fingerprinting algorithm. */\n-    private static int[] table32, table40, table48, table54;\n+  /** Internal values for the Rabin fingerprinting algorithm. */\n+  private static int[] table32, table40, table48, table54;\n \n-    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-    private static int P_DEGREE = 32;\n+  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+  private static int P_DEGREE = 32;\n \n-    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n-    private static int READ_BUFFER_SIZE = 2048;\n+  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n+  private static int READ_BUFFER_SIZE = 2048;\n \n-    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n \n-    /** The bit vector for the Bloom Filter. */\n-    private boolean keys[];\n+  /** The bit vector for the Bloom Filter. */\n+  private boolean keys[];\n \n-    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n-    private boolean useRabin = true;\n+  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+  private boolean useRabin = true;\n \n-    /** The number of hash functions. */\n-    private int numFunctions;\n+  /** The number of hash functions. */\n+  private int numFunctions;\n \n-    /**\n-    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n-    * length for the bit vector (1000).\n-    */\n-    public BloomFilter() {\n-        table32 = new int[256];\n-        table40 = new int[256];\n-        table48 = new int[256];\n-        table54 = new int[256];\n-        buffer = new byte[READ_BUFFER_SIZE];\n-        // We want to have mods[i] == x^(P_DEGREE+i)\n-        int[] mods = new int[P_DEGREE];\n-        mods[0] = POLYNOMIAL;\n-        for (int i = 1; i < P_DEGREE; i++) {\n-            // x^i == x(x^(i-1)) (mod P)\n-            mods[i] = mods[i - 1] << 1;\n-            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n-            // x^P_DEGREE term that \'fell off\' the top end.\n-            // Since x^P_DEGREE == P (mod P), we should add P\n-            // to account for this:\n-            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n-                mods[i] ^= POLYNOMIAL;\n-            }\n-        }\n-        for (int i = 0; i < 256; i++) {\n-            int c = i;\n-            for (int j = 0; j < 8 && c != 0; j++) {\n-                if ((c & 1) != 0) {\n-                    table32[i] ^= mods[j];\n-                    table40[i] ^= mods[j + 8];\n-                    table48[i] ^= mods[j + 16];\n-                    table54[i] ^= mods[j + 24];\n-                }\n-                c >>>= 1;\n-            }\n-        }\n-        mods = null;\n-        this.keys = new boolean[1000];\n-        this.numFunctions = 10;\n-        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+  /**\n+   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n+   * length for the bit vector (1000).\n+   */\n+  public BloomFilter() {\n+    table32 = new int[256];\n+    table40 = new int[256];\n+    table48 = new int[256];\n+    table54 = new int[256];\n+    buffer = new byte[READ_BUFFER_SIZE];\n+    // We want to have mods[i] == x^(P_DEGREE+i)\n+    int[] mods = new int[P_DEGREE];\n+    mods[0] = POLYNOMIAL;\n+    for (int i = 1; i < P_DEGREE; i++) {\n+      // x^i == x(x^(i-1)) (mod P)\n+      mods[i] = mods[i - 1] << 1;\n+      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+      // x^P_DEGREE term that \'fell off\' the top end.\n+      // Since x^P_DEGREE == P (mod P), we should add P\n+      // to account for this:\n+      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n+        mods[i] ^= POLYNOMIAL;\n+      }\n     }\n-\n-    /**\n-    * Constructs a Bloom Filter from a string representation.\n-    *\n-    * @see #toString()\n-    */\n-    public BloomFilter(String filter) {\n-        this();\n-        int index1 = filter.indexOf(":");\n-        int index2 = filter.lastIndexOf(":");\n-        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n-        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n-        for (int i = index2 + 1; i < filter.length(); i++) {\n-            if (filter.charAt(i) == \'1\') keys[i] = true;\n-            else keys[i] = false;\n+    for (int i = 0; i < 256; i++) {\n+      int c = i;\n+      for (int j = 0; j < 8 && c != 0; j++) {\n+        if ((c & 1) != 0) {\n+          table32[i] ^= mods[j];\n+          table40[i] ^= mods[j + 8];\n+          table48[i] ^= mods[j + 16];\n+          table54[i] ^= mods[j + 24];\n         }\n+        c >>>= 1;\n+      }\n     }\n+    mods = null;\n+    this.keys = new boolean[1000];\n+    this.numFunctions = 10;\n+    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n-    * error rate.\n-    *\n-    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n-    */\n-    public BloomFilter(int numKeys, double errorRate) {\n-        this();\n-        double lowest_m = Double.MAX_VALUE;\n-        int best_k = 1;\n-        for (int k = 1; k <= 100; k++) {\n-            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n-            if (m < lowest_m) {\n-                lowest_m = m;\n-                best_k = k;\n-            }\n-        }\n-        this.keys = new boolean[numKeys];\n-        this.numFunctions = best_k;\n-        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  /**\n+   * Constructs a Bloom Filter from a string representation.\n+   *\n+   * @see #toString()\n+   */\n+  public BloomFilter(String filter) {\n+    this();\n+    int index1 = filter.indexOf(":");\n+    int index2 = filter.lastIndexOf(":");\n+    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n+    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n+    for (int i = index2 + 1; i < filter.length(); i++) {\n+      if (filter.charAt(i) == \'1\') keys[i] = true;\n+      else keys[i] = false;\n     }\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n-    * length for the bit vector.\n-    *\n-    * @param numKeys The length of the bit vector.\n-    */\n-    public BloomFilter(int numKeys) {\n-        this(numKeys, 10);\n+  /**\n+   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n+   * error rate.\n+   *\n+   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n+   */\n+  public BloomFilter(int numKeys, double errorRate) {\n+    this();\n+    double lowest_m = Double.MAX_VALUE;\n+    int best_k = 1;\n+    for (int k = 1; k <= 100; k++) {\n+      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+      if (m < lowest_m) {\n+        lowest_m = m;\n+        best_k = k;\n+      }\n     }\n+    this.keys = new boolean[numKeys];\n+    this.numFunctions = best_k;\n+    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n-    * the bit vector.\n-    *\n-    * @param numKeys The length of the bit vector.\n-    * @param numHashFunctions The number of hash functions.\n-    */\n-    public BloomFilter(int numKeys, int numHashFunctions) {\n-        this();\n-        this.keys = new boolean[numKeys];\n-        this.numFunctions = numHashFunctions;\n-        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n-    }\n+  /**\n+   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n+   * length for the bit vector.\n+   *\n+   * @param numKeys The length of the bit vector.\n+   */\n+  public BloomFilter(int numKeys) {\n+    this(numKeys, 10);\n+  }\n \n-    /**\n-    * Internal method for producing the hash value for a given function number.\n-    *\n-    * @param fnum The number of the hash function.\n-    * @param original The original value for the hash of the object.\n-    * @see java.lang.Object#hashCode()\n-    * @return Returns the hash code value for the given function number.\n-    */\n-    private int getHash(int fnum, int original) {\n-        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n-        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n-        int hash[] = {original};\n-        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n-        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n-        hash[0] = hash[0] % keys.length;\n-        if (hash[0] < 0) hash[0] = -hash[0];\n-        return hash[0];\n-    }\n+  /**\n+   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n+   * the bit vector.\n+   *\n+   * @param numKeys The length of the bit vector.\n+   * @param numHashFunctions The number of hash functions.\n+   */\n+  public BloomFilter(int numKeys, int numHashFunctions) {\n+    this();\n+    this.keys = new boolean[numKeys];\n+    this.numFunctions = numHashFunctions;\n+    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+  }\n \n-    /**\n-    * Returns true if this Bloom Filter contains the specified key.\n-    *\n-    * @param obj The key whose presence in this Bloom Filter is to be tested.\n-    * @return true if this Bloom Filter contains a mapping for the specified key.\n-    */\n-    public boolean hasKey(Object obj) {\n-        boolean result = true;\n-        int hashCodeObject;\n-        if (!useRabin) hashCodeObject = obj.hashCode();\n-        else\n-            try {\n-                hashCodeObject = hashRabin(obj);\n-            } catch (Exception e) {\n-                useRabin = false;\n-                hashCodeObject = obj.hashCode();\n-            }\n-        for (int i = 0; i < numFunctions && result; i++) {\n-            result &= keys[getHash(i, hashCodeObject)];\n-        }\n-        return result;\n-    }\n+  /**\n+   * Internal method for producing the hash value for a given function number.\n+   *\n+   * @param fnum The number of the hash function.\n+   * @param original The original value for the hash of the object.\n+   * @see java.lang.Object#hashCode()\n+   * @return Returns the hash code value for the given function number.\n+   */\n+  private int getHash(int fnum, int original) {\n+    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n+    int hash[] = {original};\n+    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n+    hash[0] = hash[0] % keys.length;\n+    if (hash[0] < 0) hash[0] = -hash[0];\n+    return hash[0];\n+  }\n \n-    /**\n-    * Adds the specified key in this Bloom Filter.\n-    *\n-    * @param obj The key to be added to this Bloom Filter.\n-    */\n-    public void put(Object obj) {\n-        int hashCodeObject;\n-        if (!useRabin) hashCodeObject = obj.hashCode();\n-        else\n-            try {\n-                hashCodeObject = hashRabin(obj);\n-            } catch (Exception e) {\n-                useRabin = false;\n-                hashCodeObject = obj.hashCode();\n-            }\n-        for (int i = 0; i < numFunctions; i++) {\n-            keys[getHash(i, hashCodeObject)] = true;\n-        }\n+  /**\n+   * Returns true if this Bloom Filter contains the specified key.\n+   *\n+   * @param obj The key whose presence in this Bloom Filter is to be tested.\n+   * @return true if this Bloom Filter contains a mapping for the specified key.\n+   */\n+  public boolean hasKey(Object obj) {\n+    boolean result = true;\n+    int hashCodeObject;\n+    if (!useRabin) hashCodeObject = obj.hashCode();\n+    else\n+      try {\n+        hashCodeObject = hashRabin(obj);\n+      } catch (Exception e) {\n+        useRabin = false;\n+        hashCodeObject = obj.hashCode();\n+      }\n+    for (int i = 0; i < numFunctions && result; i++) {\n+      result &= keys[getHash(i, hashCodeObject)];\n     }\n+    return result;\n+  }\n \n-    /**\n-    * Returns a string representation of this Bloom Filter. The string representation consists of an\n-    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n-    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n-    * the character ":".\n-    *\n-    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n-    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n-    * returned.\n-    *\n-    * @return A string representation of this Bloom Filter.\n-    */\n-    public String toString() {\n-        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n-        for (int i = 0; i < keys.length; i++) {\n-            if (keys[i]) aux.append("1");\n-            else aux.append("0");\n-        }\n-        return aux.toString();\n+  /**\n+   * Adds the specified key in this Bloom Filter.\n+   *\n+   * @param obj The key to be added to this Bloom Filter.\n+   */\n+  public void put(Object obj) {\n+    int hashCodeObject;\n+    if (!useRabin) hashCodeObject = obj.hashCode();\n+    else\n+      try {\n+        hashCodeObject = hashRabin(obj);\n+      } catch (Exception e) {\n+        useRabin = false;\n+        hashCodeObject = obj.hashCode();\n+      }\n+    for (int i = 0; i < numFunctions; i++) {\n+      keys[getHash(i, hashCodeObject)] = true;\n     }\n+  }\n \n-    /**\n-    * Returns a copy of this Bloom Filter instance.\n-    *\n-    * @see java.lang.Object#clone()\n-    */\n-    public Object clone() {\n-        return new BloomFilter(this.toString());\n+  /**\n+   * Returns a string representation of this Bloom Filter. The string representation consists of an\n+   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n+   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n+   * the character ":".\n+   *\n+   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n+   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n+   * returned.\n+   *\n+   * @return A string representation of this Bloom Filter.\n+   */\n+  public String toString() {\n+    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n+    for (int i = 0; i < keys.length; i++) {\n+      if (keys[i]) aux.append("1");\n+      else aux.append("0");\n     }\n+    return aux.toString();\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of bytes.\n-    *\n-    * @param arr An array of bytes.\n-    * @return The Rabin hash value for the array of bytes.\n-    */\n-    public int hashRabin(byte[] arr) {\n-        return hashRabin(arr, 0, arr.length, 0);\n-    }\n+  /**\n+   * Returns a copy of this Bloom Filter instance.\n+   *\n+   * @see java.lang.Object#clone()\n+   */\n+  public Object clone() {\n+    return new BloomFilter(this.toString());\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of bytes.\n-    *\n-    * @param arr An array of bytes.\n-    * @param offset Index of the first byte of the array to hash.\n-    * @param length Number of bytes to hash.\n-    * @param ws ??\n-    * @return The Rabin hash value for the array of bytes.\n-    */\n-    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n-        int w = ws;\n-        int start = length % 4;\n-        for (int s = offset; s < offset + start; s++) {\n-            w = (w << 8) ^ (arr[s] & 0xFF);\n-        }\n-        for (int s = start + offset; s < length + offset; s += 4) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ (arr[s] << 24)\n-                            ^ ((arr[s + 1] & 0xFF) << 16)\n-                            ^ ((arr[s + 2] & 0xFF) << 8)\n-                            ^ (arr[s + 3] & 0xFF);\n-        }\n-        return w;\n-    }\n+  /**\n+   * Return the Rabin hash value of an array of bytes.\n+   *\n+   * @param arr An array of bytes.\n+   * @return The Rabin hash value for the array of bytes.\n+   */\n+  public int hashRabin(byte[] arr) {\n+    return hashRabin(arr, 0, arr.length, 0);\n+  }\n \n-    /**\n-    * Return the Rabin hash value of an array of chars.\n-    *\n-    * @param arr An array of chars.\n-    * @return The Rabin hash value for the array of chars.\n-    */\n-    public int hashRabin(char[] arr) {\n-        int w = 0;\n-        int start = 0;\n-        if (arr.length % 2 == 1) {\n-            w = arr[0] & 0xFFFF;\n-            start = 1;\n-        }\n-        for (int s = start; s < arr.length; s += 2) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ ((arr[s] & 0xFFFF) << 16)\n-                            ^ (arr[s + 1] & 0xFFFF);\n-        }\n-        return w;\n+  /**\n+   * Return the Rabin hash value of an array of bytes.\n+   *\n+   * @param arr An array of bytes.\n+   * @param offset Index of the first byte of the array to hash.\n+   * @param length Number of bytes to hash.\n+   * @param ws ??\n+   * @return The Rabin hash value for the array of bytes.\n+   */\n+  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n+    int w = ws;\n+    int start = length % 4;\n+    for (int s = offset; s < offset + start; s++) {\n+      w = (w << 8) ^ (arr[s] & 0xFF);\n     }\n-\n-    /**\n-    * Computes the Rabin hash value of the contents of a <code>File</code>.\n-    *\n-    * @param f A <code>File</code>.\n-    * @return The Rabin hash value for the contents of the File.\n-    * @throws FileNotFoundException If the file cannot be found.\n-    * @throws IOException If an error occurs while reading the file.\n-    */\n-    public int hashRabin(File f) throws FileNotFoundException, IOException {\n-        FileInputStream fis = new FileInputStream(f);\n-        try {\n-            return hashRabin(fis);\n-        } finally {\n-            fis.close();\n-        }\n+    for (int s = start + offset; s < length + offset; s += 4) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ (arr[s] << 24)\n+              ^ ((arr[s + 1] & 0xFF) << 16)\n+              ^ ((arr[s + 2] & 0xFF) << 8)\n+              ^ (arr[s + 3] & 0xFF);\n     }\n+    return w;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n-    *\n-    * @param is An InputStream.\n-    * @return The Rabin hash value for the contents read from the InputStream.\n-    * @throws IOException if an error occurs while reading from the InputStream.\n-    */\n-    public int hashRabin(InputStream is) throws IOException {\n-        int hashValue = 0;\n-        int bytesRead;\n-        synchronized (buffer) {\n-            while ((bytesRead = is.read(buffer)) > 0) {\n-                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n-            }\n-        }\n-        return hashValue;\n+  /**\n+   * Return the Rabin hash value of an array of chars.\n+   *\n+   * @param arr An array of chars.\n+   * @return The Rabin hash value for the array of chars.\n+   */\n+  public int hashRabin(char[] arr) {\n+    int w = 0;\n+    int start = 0;\n+    if (arr.length % 2 == 1) {\n+      w = arr[0] & 0xFFFF;\n+      start = 1;\n     }\n+    for (int s = start; s < arr.length; s += 2) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ ((arr[s] & 0xFFFF) << 16)\n+              ^ (arr[s + 1] & 0xFFFF);\n+    }\n+    return w;\n+  }\n \n-    /**\n-    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n-    * the hash methods, so it should be used when possible.\n-    *\n-    * @param arr An array of integers.\n-    * @return int The Rabin hash value for the array of integers.\n-    */\n-    public int hashRabin(int[] arr) {\n-        int w = 0;\n-        for (int s = 0; s < arr.length; s++) {\n-            w =\n-                    table32[w & 0xFF]\n-                            ^ table40[(w >>> 8) & 0xFF]\n-                            ^ table48[(w >>> 16) & 0xFF]\n-                            ^ table54[(w >>> 24) & 0xFF]\n-                            ^ arr[s];\n-        }\n-        return w;\n+  /**\n+   * Computes the Rabin hash value of the contents of a <code>File</code>.\n+   *\n+   * @param f A <code>File</code>.\n+   * @return The Rabin hash value for the contents of the File.\n+   * @throws FileNotFoundException If the file cannot be found.\n+   * @throws IOException If an error occurs while reading the file.\n+   */\n+  public int hashRabin(File f) throws FileNotFoundException, IOException {\n+    FileInputStream fis = new FileInputStream(f);\n+    try {\n+      return hashRabin(fis);\n+    } finally {\n+      fis.close();\n     }\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a given Object.\n-    *\n-    * @param obj An Object.\n-    * @return The Rabin hash value for the Object.\n-    * @throws IOException If Object serialization fails.\n-    */\n-    public int hashRabin(Object obj) throws IOException {\n-        return hashRabin((Serializable) obj);\n+  /**\n+   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+   *\n+   * @param is An InputStream.\n+   * @return The Rabin hash value for the contents read from the InputStream.\n+   * @throws IOException if an error occurs while reading from the InputStream.\n+   */\n+  public int hashRabin(InputStream is) throws IOException {\n+    int hashValue = 0;\n+    int bytesRead;\n+    synchronized (buffer) {\n+      while ((bytesRead = is.read(buffer)) > 0) {\n+        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+      }\n     }\n+    return hashValue;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a given serializable Object.\n-    *\n-    * @param obj An Object.\n-    * @return The Rabin hash value for the Object.\n-    * @throws IOException If serialization fails.\n-    */\n-    public int hashRabin(Serializable obj) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = null;\n-        try {\n-            oos = new ObjectOutputStream(baos);\n-            oos.writeObject(obj);\n-            return hashRabin(baos.toByteArray());\n-        } finally {\n-            oos.close();\n-            baos.close();\n-            oos = null;\n-            baos = null;\n-        }\n+  /**\n+   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n+   * the hash methods, so it should be used when possible.\n+   *\n+   * @param arr An array of integers.\n+   * @return int The Rabin hash value for the array of integers.\n+   */\n+  public int hashRabin(int[] arr) {\n+    int w = 0;\n+    for (int s = 0; s < arr.length; s++) {\n+      w =\n+          table32[w & 0xFF]\n+              ^ table40[(w >>> 8) & 0xFF]\n+              ^ table48[(w >>> 16) & 0xFF]\n+              ^ table54[(w >>> 24) & 0xFF]\n+              ^ arr[s];\n     }\n+    return w;\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of a String.\n-    *\n-    * @param s A <code>String</code>.\n-    * @return The Rabin hash value for the String.\n-    */\n-    public int hashRabin(String s) {\n-        return hashRabin(s.toCharArray());\n+  /**\n+   * Computes the Rabin hash value of a given Object.\n+   *\n+   * @param obj An Object.\n+   * @return The Rabin hash value for the Object.\n+   * @throws IOException If Object serialization fails.\n+   */\n+  public int hashRabin(Object obj) throws IOException {\n+    return hashRabin((Serializable) obj);\n+  }\n+\n+  /**\n+   * Computes the Rabin hash value of a given serializable Object.\n+   *\n+   * @param obj An Object.\n+   * @return The Rabin hash value for the Object.\n+   * @throws IOException If serialization fails.\n+   */\n+  public int hashRabin(Serializable obj) throws IOException {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    ObjectOutputStream oos = null;\n+    try {\n+      oos = new ObjectOutputStream(baos);\n+      oos.writeObject(obj);\n+      return hashRabin(baos.toByteArray());\n+    } finally {\n+      oos.close();\n+      baos.close();\n+      oos = null;\n+      baos = null;\n     }\n+  }\n \n-    /**\n-    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n-    *\n-    * @param url The URL of the document to be hashed.\n-    * @return The Rabin hash value for the document.\n-    * @throws IOException If an error occurs while reading the document.\n-    */\n-    public int hashRabin(URL url) throws IOException {\n-        InputStream is = url.openStream();\n-        try {\n-            return hashRabin(is);\n-        } finally {\n-            is.close();\n-        }\n+  /**\n+   * Computes the Rabin hash value of a String.\n+   *\n+   * @param s A <code>String</code>.\n+   * @return The Rabin hash value for the String.\n+   */\n+  public int hashRabin(String s) {\n+    return hashRabin(s.toCharArray());\n+  }\n+\n+  /**\n+   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n+   *\n+   * @param url The URL of the document to be hashed.\n+   * @return The Rabin hash value for the document.\n+   * @throws IOException If an error occurs while reading the document.\n+   */\n+  public int hashRabin(URL url) throws IOException {\n+    InputStream is = url.openStream();\n+    try {\n+      return hashRabin(is);\n+    } finally {\n+      is.close();\n     }\n+  }\n }',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n *\n * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n * can make a useful tool.\n *\n * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n * checkers.\n *\n * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n * vector of a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are willing to\n * put up with.\n *\n * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.\n *\n * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n * a Bloom filter.\n *\n * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n * key. We run the key through our set of hash functions, and then check to see whether the bits at\n * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n * the filter. If all of the bits are on, we know the key is probably there.\n *\n * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n * bits we check will be on, unless the key actually exists in the filter. The relationship between\n * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n * will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:\n *\n * <p><code>c = ( 1 - e(-kn/m) )k</code>\n *\n * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n * in the filter, and m is the length of the filter in bits.\n *\n * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n * our limit. The following equation will give us vector length from the error rate and number of\n * keys:\n *\n * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n *\n * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n * combinations of error rate, filter size, and number of hash functions at <a\n * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n * -- the math</a>.\n *\n * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n * the case of JDK 1.4).\n *\n * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n * even in this Java implementation the speed is reasonable.\n *\n * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a\n * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.\n *\n * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n * <code>URL</code>.\n *\n * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n *\n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n * @author Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n  /** A buffer for the Rabin fingerprinting algorithm. */\n  private byte[] buffer;\n\n  /**\n   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n   * bit is the constant coefficient.\n   *\n   * <p>For example the integer 0x00000803, in binary, is:\n   *\n   * <p><code>00000000 00000000 00001000 00000011</code>\n   *\n   * <p>Therefore it correponds to the polynomial:\n   *\n   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n   */\n  private static int POLYNOMIAL = 0x000001C7;\n\n  /** Internal values for the Rabin fingerprinting algorithm. */\n  private static int[] table32, table40, table48, table54;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int P_DEGREE = 32;\n\n  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n  private static int READ_BUFFER_SIZE = 2048;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n  /** The bit vector for the Bloom Filter. */\n  private boolean keys[];\n\n  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n  private boolean useRabin = true;\n\n  /** The number of hash functions. */\n  private int numFunctions;\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n   * length for the bit vector (1000).\n   */\n  public BloomFilter() {\n    table32 = new int[256];\n    table40 = new int[256];\n    table48 = new int[256];\n    table54 = new int[256];\n    buffer = new byte[READ_BUFFER_SIZE];\n    // We want to have mods[i] == x^(P_DEGREE+i)\n    int[] mods = new int[P_DEGREE];\n    mods[0] = POLYNOMIAL;\n    for (int i = 1; i < P_DEGREE; i++) {\n      // x^i == x(x^(i-1)) (mod P)\n      mods[i] = mods[i - 1] << 1;\n      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n      // x^P_DEGREE term that \'fell off\' the top end.\n      // Since x^P_DEGREE == P (mod P), we should add P\n      // to account for this:\n      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n        mods[i] ^= POLYNOMIAL;\n      }\n    }\n    for (int i = 0; i < 256; i++) {\n      int c = i;\n      for (int j = 0; j < 8 && c != 0; j++) {\n        if ((c & 1) != 0) {\n          table32[i] ^= mods[j];\n          table40[i] ^= mods[j + 8];\n          table48[i] ^= mods[j + 16];\n          table54[i] ^= mods[j + 24];\n        }\n        c >>>= 1;\n      }\n    }\n    mods = null;\n    this.keys = new boolean[1000];\n    this.numFunctions = 10;\n    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs a Bloom Filter from a string representation.\n   *\n   * @see #toString()\n   */\n  public BloomFilter(String filter) {\n    this();\n    int index1 = filter.indexOf(":");\n    int index2 = filter.lastIndexOf(":");\n    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n    for (int i = index2 + 1; i < filter.length(); i++) {\n      if (filter.charAt(i) == \'1\') keys[i] = true;\n      else keys[i] = false;\n    }\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n   * error rate.\n   *\n   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n   */\n  public BloomFilter(int numKeys, double errorRate) {\n    this();\n    double lowest_m = Double.MAX_VALUE;\n    int best_k = 1;\n    for (int k = 1; k <= 100; k++) {\n      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n      if (m < lowest_m) {\n        lowest_m = m;\n        best_k = k;\n      }\n    }\n    this.keys = new boolean[numKeys];\n    this.numFunctions = best_k;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n   * length for the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   */\n  public BloomFilter(int numKeys) {\n    this(numKeys, 10);\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n   * the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   * @param numHashFunctions The number of hash functions.\n   */\n  public BloomFilter(int numKeys, int numHashFunctions) {\n    this();\n    this.keys = new boolean[numKeys];\n    this.numFunctions = numHashFunctions;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Internal method for producing the hash value for a given function number.\n   *\n   * @param fnum The number of the hash function.\n   * @param original The original value for the hash of the object.\n   * @see java.lang.Object#hashCode()\n   * @return Returns the hash code value for the given function number.\n   */\n  private int getHash(int fnum, int original) {\n    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n    int hash[] = {original};\n    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n    hash[0] = hash[0] % keys.length;\n    if (hash[0] < 0) hash[0] = -hash[0];\n    return hash[0];\n  }\n\n  /**\n   * Returns true if this Bloom Filter contains the specified key.\n   *\n   * @param obj The key whose presence in this Bloom Filter is to be tested.\n   * @return true if this Bloom Filter contains a mapping for the specified key.\n   */\n  public boolean hasKey(Object obj) {\n    boolean result = true;\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions && result; i++) {\n      result &= keys[getHash(i, hashCodeObject)];\n    }\n    return result;\n  }\n\n  /**\n   * Adds the specified key in this Bloom Filter.\n   *\n   * @param obj The key to be added to this Bloom Filter.\n   */\n  public void put(Object obj) {\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions; i++) {\n      keys[getHash(i, hashCodeObject)] = true;\n    }\n  }\n\n  /**\n   * Returns a string representation of this Bloom Filter. The string representation consists of an\n   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n   * the character ":".\n   *\n   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n   * returned.\n   *\n   * @return A string representation of this Bloom Filter.\n   */\n  public String toString() {\n    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n    for (int i = 0; i < keys.length; i++) {\n      if (keys[i]) aux.append("1");\n      else aux.append("0");\n    }\n    return aux.toString();\n  }\n\n  /**\n   * Returns a copy of this Bloom Filter instance.\n   *\n   * @see java.lang.Object#clone()\n   */\n  public Object clone() {\n    return new BloomFilter(this.toString());\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @return The Rabin hash value for the array of bytes.\n   */\n  public int hashRabin(byte[] arr) {\n    return hashRabin(arr, 0, arr.length, 0);\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @param offset Index of the first byte of the array to hash.\n   * @param length Number of bytes to hash.\n   * @param ws ??\n   * @return The Rabin hash value for the array of bytes.\n   */\n  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n    int w = ws;\n    int start = length % 4;\n    for (int s = offset; s < offset + start; s++) {\n      w = (w << 8) ^ (arr[s] & 0xFF);\n    }\n    for (int s = start + offset; s < length + offset; s += 4) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ (arr[s] << 24)\n              ^ ((arr[s + 1] & 0xFF) << 16)\n              ^ ((arr[s + 2] & 0xFF) << 8)\n              ^ (arr[s + 3] & 0xFF);\n    }\n    return w;\n  }\n\n  /**\n   * Return the Rabin hash value of an array of chars.\n   *\n   * @param arr An array of chars.\n   * @return The Rabin hash value for the array of chars.\n   */\n  public int hashRabin(char[] arr) {\n    int w = 0;\n    int start = 0;\n    if (arr.length % 2 == 1) {\n      w = arr[0] & 0xFFFF;\n      start = 1;\n    }\n    for (int s = start; s < arr.length; s += 2) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ ((arr[s] & 0xFFFF) << 16)\n              ^ (arr[s + 1] & 0xFFFF);\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a <code>File</code>.\n   *\n   * @param f A <code>File</code>.\n   * @return The Rabin hash value for the contents of the File.\n   * @throws FileNotFoundException If the file cannot be found.\n   * @throws IOException If an error occurs while reading the file.\n   */\n  public int hashRabin(File f) throws FileNotFoundException, IOException {\n    FileInputStream fis = new FileInputStream(f);\n    try {\n      return hashRabin(fis);\n    } finally {\n      fis.close();\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n   *\n   * @param is An InputStream.\n   * @return The Rabin hash value for the contents read from the InputStream.\n   * @throws IOException if an error occurs while reading from the InputStream.\n   */\n  public int hashRabin(InputStream is) throws IOException {\n    int hashValue = 0;\n    int bytesRead;\n    synchronized (buffer) {\n      while ((bytesRead = is.read(buffer)) > 0) {\n        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n      }\n    }\n    return hashValue;\n  }\n\n  /**\n   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n   * the hash methods, so it should be used when possible.\n   *\n   * @param arr An array of integers.\n   * @return int The Rabin hash value for the array of integers.\n   */\n  public int hashRabin(int[] arr) {\n    int w = 0;\n    for (int s = 0; s < arr.length; s++) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ arr[s];\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of a given Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If Object serialization fails.\n   */\n  public int hashRabin(Object obj) throws IOException {\n    return hashRabin((Serializable) obj);\n  }\n\n  /**\n   * Computes the Rabin hash value of a given serializable Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If serialization fails.\n   */\n  public int hashRabin(Serializable obj) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = null;\n    try {\n      oos = new ObjectOutputStream(baos);\n      oos.writeObject(obj);\n      return hashRabin(baos.toByteArray());\n    } finally {\n      oos.close();\n      baos.close();\n      oos = null;\n      baos = null;\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of a String.\n   *\n   * @param s A <code>String</code>.\n   * @return The Rabin hash value for the String.\n   */\n  public int hashRabin(String s) {\n    return hashRabin(s.toCharArray());\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n   *\n   * @param url The URL of the document to be hashed.\n   * @return The Rabin hash value for the document.\n   * @throws IOException If an error occurs while reading the document.\n   */\n  public int hashRabin(URL url) throws IOException {\n    InputStream is = url.openStream();\n    try {\n      return hashRabin(is);\n    } finally {\n      is.close();\n    }\n  }\n}\n'
          },
          {
            sha: "3be706f1ea9ded9a332de32c31f99eedf4652de0",
            filename:
              "src/main/java/refactoring/crawler/shingles/DefaultStrategy.java",
            status: "modified",
            additions: 16,
            deletions: 16,
            patch:
              "@@ -3,23 +3,23 @@\n /** @author Can Comertoglu */\n public class DefaultStrategy implements ShinglesStrategy {\n \n-    /** */\n-    public DefaultStrategy() {\n-        super();\n-    }\n+  /** */\n+  public DefaultStrategy() {\n+    super();\n+  }\n \n-    /* (non-Javadoc)\n-    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-    */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base;\n-    }\n+  /* (non-Javadoc)\n+   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+   */\n+  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+    return s_base;\n+  }\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base;\n-    }\n+  public int upperBoundForClassShingles(int numMethods, int s_base) {\n+    return s_base;\n+  }\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base;\n-    }\n+  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+    return s_base;\n+  }\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n  /** */\n  public DefaultStrategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base;\n  }\n}\n"
          },
          {
            sha: "55e796c451fb63675bae1000f41dd15b720bbb42",
            filename:
              "src/main/java/refactoring/crawler/shingles/FactorOf2Strategy.java",
            status: "modified",
            additions: 17,
            deletions: 17,
            patch:
              "@@ -2,24 +2,24 @@\n \n public class FactorOf2Strategy implements ShinglesStrategy {\n \n-    /** */\n-    public FactorOf2Strategy() {\n-        super();\n-    }\n+  /** */\n+  public FactorOf2Strategy() {\n+    super();\n+  }\n \n-    /* (non-Javadoc)\n-    * @Override\n-    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-    */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base + (2 * loc);\n-    }\n+  /* (non-Javadoc)\n+   * @Override\n+   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+   */\n+  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+    return s_base + (2 * loc);\n+  }\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base + (2 * numMethods);\n-    }\n+  public int upperBoundForClassShingles(int numMethods, int s_base) {\n+    return s_base + (2 * numMethods);\n+  }\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base + (2 * numClasses);\n-    }\n+  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+    return s_base + (2 * numClasses);\n+  }\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n  /** */\n  public FactorOf2Strategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @Override\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base + (2 * loc);\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base + (2 * numMethods);\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base + (2 * numClasses);\n  }\n}\n"
          },
          {
            sha: "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesStrategy.java",
            status: "modified",
            additions: 3,
            deletions: 3,
            patch:
              "@@ -1,9 +1,9 @@\n package refactoring.crawler.shingles;\n \n public interface ShinglesStrategy {\n-    int upperBoundLimitForShinglesBag(int loc, int s_base);\n+  int upperBoundLimitForShinglesBag(int loc, int s_base);\n \n-    int upperBoundForClassShingles(int numMethods, int s_base);\n+  int upperBoundForClassShingles(int numMethods, int s_base);\n \n-    int upperBoundForPackageShingles(int numClasses, int s_base);\n+  int upperBoundForPackageShingles(int numClasses, int s_base);\n }",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n  int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n  int upperBoundForClassShingles(int numMethods, int s_base);\n\n  int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "0418f0db4600a32e90aa4732194cd3215844cb06",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "modified",
            additions: 260,
            deletions: 260,
            patch:
              '@@ -11,291 +11,291 @@\n \n public class ShinglesUtil {\n \n-    private int w = 2;\n-    private int sClass = 10;\n-    private int sMethod = 8;\n-    private double classThreshold = 0.0;\n+  private int w = 2;\n+  private int sClass = 10;\n+  private int sMethod = 8;\n+  private double classThreshold = 0.0;\n \n-    @Getter @Setter private double methodThreshold = 0.0;\n+  @Getter @Setter private double methodThreshold = 0.0;\n \n-    private ShinglesStrategy shinglesStrategy;\n+  private ShinglesStrategy shinglesStrategy;\n \n-    private NamedDirectedMultigraph oldVersionGraph;\n+  private NamedDirectedMultigraph oldVersionGraph;\n \n-    private NamedDirectedMultigraph newVersionGraph;\n+  private NamedDirectedMultigraph newVersionGraph;\n \n-    private List<Node[]> similarMethods = new LinkedList<>();\n-    private List<Node[]> similarClasses = new LinkedList<>();\n+  private List<Node[]> similarMethods = new LinkedList<>();\n+  private List<Node[]> similarClasses = new LinkedList<>();\n \n-    private List<Node> oldVersionPackageList;\n-    private List<Node> oldVersionClassList;\n-    private List<Node> oldVersionMethodList;\n-    private List<Node> oldVersionFieldList;\n+  private List<Node> oldVersionPackageList;\n+  private List<Node> oldVersionClassList;\n+  private List<Node> oldVersionMethodList;\n+  private List<Node> oldVersionFieldList;\n \n-    private List<Node> newVersionPackageList;\n-    private List<Node> newVersionClassList;\n-    private List<Node> newVersionMethodList;\n-    private List<Node> newVersionFieldList;\n+  private List<Node> newVersionPackageList;\n+  private List<Node> newVersionClassList;\n+  private List<Node> newVersionMethodList;\n+  private List<Node> newVersionFieldList;\n \n-    public ShinglesUtil() {\n-        this.shinglesStrategy = new DefaultStrategy();\n-        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n-    }\n-\n-    public List<String> tokenizer(String s) {\n-        List<String> list = new ArrayList<>();\n-        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n-        while (st.hasMoreElements()) {\n-            list.add(st.nextToken());\n-        }\n-        return list;\n-    }\n+  public ShinglesUtil() {\n+    this.shinglesStrategy = new DefaultStrategy();\n+    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+  }\n \n-    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n-\n-        List<List<String>> bagOfTokensList = new ArrayList<>();\n-        ListIterator<String> iter = tokenList.listIterator();\n-        while (iter.nextIndex() <= (tokenList.size() - w))\n-        // W=2, iterIndex = size - W identifies the last window\n-        {\n-            List<String> tempList = new ArrayList<>();\n-            for (int i = 1; i <= w; i++) // W=3\n-            {\n-                tempList.add(iter.next());\n-            }\n-            bagOfTokensList.add(tempList);\n-            for (int i = 1; i <= w - 1; i++)\n-                // i<= W-1\n-                iter.previous();\n-        }\n-        return bagOfTokensList;\n+  public List<String> tokenizer(String s) {\n+    List<String> list = new ArrayList<>();\n+    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+    while (st.hasMoreElements()) {\n+      list.add(st.nextToken());\n     }\n-\n-    private int findNumberOfLines(String str) {\n-        int retval = 0;\n-        char[] c = str.toCharArray();\n-        for (char value : c) {\n-            if (value == \'\\n\') retval++;\n-        }\n-        return retval;\n+    return list;\n+  }\n+\n+  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+    List<List<String>> bagOfTokensList = new ArrayList<>();\n+    ListIterator<String> iter = tokenList.listIterator();\n+    while (iter.nextIndex() <= (tokenList.size() - w))\n+    // W=2, iterIndex = size - W identifies the last window\n+    {\n+      List<String> tempList = new ArrayList<>();\n+      for (int i = 1; i <= w; i++) // W=3\n+      {\n+        tempList.add(iter.next());\n+      }\n+      bagOfTokensList.add(tempList);\n+      for (int i = 1; i <= w - 1; i++)\n+        // i<= W-1\n+        iter.previous();\n     }\n-\n-    public int[] computeMethodShingles(String str) {\n-        return computeMethodShingles(\n-                str,\n-                w,\n-                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+    return bagOfTokensList;\n+  }\n+\n+  private int findNumberOfLines(String str) {\n+    int retval = 0;\n+    char[] c = str.toCharArray();\n+    for (char value : c) {\n+      if (value == \'\\n\') retval++;\n     }\n-\n-    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n-        /*\n-        * We are now introducing the idea of finding the number of lines in the\n-        * method, and incorporate that into the calculation of shingles, so\n-        * that, if there are more lines, then there are going to be more\n-        * shingles associated with the method. However, a 1-1 correspondance\n-        * will be misleading, thus another method is required.\n-        */\n-        BloomFilter bloomFilter = new BloomFilter();\n-        List<String> tokenList = tokenizer(str);\n-        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n-\n-        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n-        int numberOfWindowedTokens = 0;\n-\n-        for (List<String> tempList : bagOfWindowedTokens) {\n-            StringBuilder tokensInOneWindow = new StringBuilder();\n-            for (int i = 0; i < window; i++) {\n-                tokensInOneWindow.append(tempList.get(i));\n-                if (i != window - 1) tokensInOneWindow.append(" ");\n-            }\n-            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n-            shinglesValues[numberOfWindowedTokens] = shingle;\n-            numberOfWindowedTokens++;\n-        }\n-\n-        Arrays.sort(shinglesValues);\n-\n-        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n-\n-        int[] retVal = new int[correctNumberOfShingles];\n-        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n-        return retVal;\n+    return retval;\n+  }\n+\n+  public int[] computeMethodShingles(String str) {\n+    return computeMethodShingles(\n+        str,\n+        w,\n+        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+  }\n+\n+  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+    /*\n+     * We are now introducing the idea of finding the number of lines in the\n+     * method, and incorporate that into the calculation of shingles, so\n+     * that, if there are more lines, then there are going to be more\n+     * shingles associated with the method. However, a 1-1 correspondance\n+     * will be misleading, thus another method is required.\n+     */\n+    BloomFilter bloomFilter = new BloomFilter();\n+    List<String> tokenList = tokenizer(str);\n+    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+    int numberOfWindowedTokens = 0;\n+\n+    for (List<String> tempList : bagOfWindowedTokens) {\n+      StringBuilder tokensInOneWindow = new StringBuilder();\n+      for (int i = 0; i < window; i++) {\n+        tokensInOneWindow.append(tempList.get(i));\n+        if (i != window - 1) tokensInOneWindow.append(" ");\n+      }\n+      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+      shinglesValues[numberOfWindowedTokens] = shingle;\n+      numberOfWindowedTokens++;\n     }\n \n-    public void initialize(\n-            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n-        this.oldVersionGraph = oldVersionGraph;\n-        this.newVersionGraph = newVersionGraph;\n-\n-        this.oldVersionPackageList = new ArrayList<>();\n-        this.oldVersionClassList = new ArrayList<>();\n-        this.oldVersionMethodList = new ArrayList<>();\n-        this.oldVersionFieldList = new ArrayList<>();\n-\n-        this.newVersionPackageList = new ArrayList<>();\n-        this.newVersionClassList = new ArrayList<>();\n-        this.newVersionMethodList = new ArrayList<>();\n-        this.newVersionFieldList = new ArrayList<>();\n-\n-        initializeElementsLists(\n-                oldVersionGraph,\n-                oldVersionMethodList,\n-                oldVersionClassList,\n-                oldVersionPackageList,\n-                oldVersionFieldList);\n-\n-        initializeElementsLists(\n-                newVersionGraph,\n-                newVersionMethodList,\n-                newVersionClassList,\n-                newVersionPackageList,\n-                newVersionFieldList);\n+    Arrays.sort(shinglesValues);\n+\n+    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n+\n+    int[] retVal = new int[correctNumberOfShingles];\n+    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+    return retVal;\n+  }\n+\n+  public void initialize(\n+      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+    this.oldVersionGraph = oldVersionGraph;\n+    this.newVersionGraph = newVersionGraph;\n+\n+    this.oldVersionPackageList = new ArrayList<>();\n+    this.oldVersionClassList = new ArrayList<>();\n+    this.oldVersionMethodList = new ArrayList<>();\n+    this.oldVersionFieldList = new ArrayList<>();\n+\n+    this.newVersionPackageList = new ArrayList<>();\n+    this.newVersionClassList = new ArrayList<>();\n+    this.newVersionMethodList = new ArrayList<>();\n+    this.newVersionFieldList = new ArrayList<>();\n+\n+    initializeElementsLists(\n+        oldVersionGraph,\n+        oldVersionMethodList,\n+        oldVersionClassList,\n+        oldVersionPackageList,\n+        oldVersionFieldList);\n+\n+    initializeElementsLists(\n+        newVersionGraph,\n+        newVersionMethodList,\n+        newVersionClassList,\n+        newVersionPackageList,\n+        newVersionFieldList);\n+  }\n+\n+  private void initializeElementsLists(\n+      DirectedMultigraph<Node, Edge> graph,\n+      List<Node> methods,\n+      List<Node> classes,\n+      List<Node> packages,\n+      List<Node> fields) {\n+    // Create a BreadthFirstIterator for the graph\n+    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+    while (bfi.hasNext()) {\n+      Node n = bfi.next();\n+      if (n.getType().equals(Node.Type.CLASS)) {\n+        classes.add(n);\n+      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+        packages.add(n);\n+      } else if (n.getType().equals(Node.Type.METHOD)) {\n+        methods.add(n);\n+      } else if (n.getType().equals(Node.Type.FIELD)) {\n+        fields.add(n);\n+      }\n     }\n-\n-    private void initializeElementsLists(\n-            DirectedMultigraph<Node, Edge> graph,\n-            List<Node> methods,\n-            List<Node> classes,\n-            List<Node> packages,\n-            List<Node> fields) {\n-        // Create a BreadthFirstIterator for the graph\n-        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-        while (bfi.hasNext()) {\n-            Node n = bfi.next();\n-            if (n.getType().equals(Node.Type.CLASS)) {\n-                classes.add(n);\n-            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n-                packages.add(n);\n-            } else if (n.getType().equals(Node.Type.METHOD)) {\n-                methods.add(n);\n-            } else if (n.getType().equals(Node.Type.FIELD)) {\n-                fields.add(n);\n-            }\n+  }\n+\n+  public List<Node[]> findSimilarMethods() {\n+    if (this.similarMethods.isEmpty()) {\n+      List<Node[]> similarMethods = new ArrayList<>();\n+      for (Node m : this.oldVersionMethodList) {\n+        if (!m.isAPI()) continue;\n+\n+        for (Node m2 : this.newVersionMethodList) {\n+          if (!m2.isAPI()) continue;\n+\n+          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+            Node[] arr = {m, m2};\n+            // if (!isThisArrayInTheList(simMet, arr))\n+            similarMethods.add(arr);\n+          }\n         }\n+      }\n+      this.similarMethods = similarMethods;\n     }\n-\n-    public List<Node[]> findSimilarMethods() {\n-        if (this.similarMethods.isEmpty()) {\n-            List<Node[]> similarMethods = new ArrayList<>();\n-            for (Node m : this.oldVersionMethodList) {\n-                if (!m.isAPI()) continue;\n-\n-                for (Node m2 : this.newVersionMethodList) {\n-                    if (!m2.isAPI()) continue;\n-\n-                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-                        Node[] arr = {m, m2};\n-                        // if (!isThisArrayInTheList(simMet, arr))\n-                        similarMethods.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarMethods = similarMethods;\n+    return this.similarMethods;\n+  }\n+\n+  public double howMuchAlike(int[] arr1, int[] arr2) {\n+    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+    return finalGrade;\n+  }\n+\n+  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+    int[] tempArr = arr2.clone();\n+    double grade = 0.0;\n+    for (int value : arr1) {\n+      for (int j = 0; j < tempArr.length; j++) {\n+        if (value == tempArr[j]) {\n+          grade += 1.0 / arr1.length;\n+          tempArr[j] = Integer.MIN_VALUE;\n+          break;\n         }\n-        return this.similarMethods;\n+      }\n     }\n+    return grade;\n+  }\n+\n+  /**\n+   * @param classes\n+   * @param graph <br>\n+   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n+   *     its subtree. The parameter s_class will determine the maximum size of shingles\n+   */\n+  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+    for (Node clasz : classes) {\n+      // We will keep the number of methods for the class with the\n+      // numberOfMethods variable.\n+      int numberOfMethods = 0;\n+      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+      int methodsTotalShingleSize = 0;\n+      for (Edge e : outEdges) {\n+        Node neighbor = e.oppositeVertex(clasz);\n+        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+          methodsTotalShingleSize += neighbor.getShingles().length;\n+          // Here we update the method count.\n+          numberOfMethods++;\n+        }\n+      }\n+\n+      // fill allShinglesFromMethods with shingles from all the methods in\n+      // the class\n+      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+      int index = 0;\n+      for (Edge e : outEdges) {\n+        Node neighbor = e.oppositeVertex(clasz);\n+        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+          for (int j = 0; j < neighbor.getShingles().length; j++) {\n+            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n+            index++;\n+          }\n+        }\n+      }\n \n-    public double howMuchAlike(int[] arr1, int[] arr2) {\n-        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-        return finalGrade;\n-    }\n+      int upperBoundForClassShingles =\n+          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n+      Arrays.sort(allShinglesFromMethods);\n \n-    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-        int[] tempArr = arr2.clone();\n-        double grade = 0.0;\n-        for (int value : arr1) {\n-            for (int j = 0; j < tempArr.length; j++) {\n-                if (value == tempArr[j]) {\n-                    grade += 1.0 / arr1.length;\n-                    tempArr[j] = Integer.MIN_VALUE;\n-                    break;\n-                }\n-            }\n-        }\n-        return grade;\n-    }\n+      upperBoundForClassShingles =\n+          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n \n-    /**\n-    * @param classes\n-    * @param graph <br>\n-    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n-    *     its subtree. The parameter s_class will determine the maximum size of shingles\n-    */\n-    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n-        for (Node clasz : classes) {\n-            // We will keep the number of methods for the class with the\n-            // numberOfMethods variable.\n-            int numberOfMethods = 0;\n-            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n-            int methodsTotalShingleSize = 0;\n-            for (Edge e : outEdges) {\n-                Node neighbor = e.oppositeVertex(clasz);\n-                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-                    methodsTotalShingleSize += neighbor.getShingles().length;\n-                    // Here we update the method count.\n-                    numberOfMethods++;\n-                }\n-            }\n-\n-            // fill allShinglesFromMethods with shingles from all the methods in\n-            // the class\n-            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n-            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n-            int index = 0;\n-            for (Edge e : outEdges) {\n-                Node neighbor = e.oppositeVertex(clasz);\n-                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n-                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n-                        index++;\n-                    }\n-                }\n-            }\n-\n-            int upperBoundForClassShingles =\n-                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n-            Arrays.sort(allShinglesFromMethods);\n-\n-            upperBoundForClassShingles =\n-                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n-\n-            int[] retVal = new int[upperBoundForClassShingles];\n-            if (upperBoundForClassShingles >= 0)\n-                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n-            clasz.setShingles(retVal);\n-        }\n+      int[] retVal = new int[upperBoundForClassShingles];\n+      if (upperBoundForClassShingles >= 0)\n+        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+      clasz.setShingles(retVal);\n     }\n-\n-    public List<Node[]> findSimilarClasses() {\n-        if (this.similarClasses.isEmpty()) {\n-            computeClassShingles(oldVersionClassList, oldVersionGraph);\n-            computeClassShingles(newVersionClassList, newVersionGraph);\n-            List<Node[]> simClass = new ArrayList<>();\n-            for (Node c : this.oldVersionClassList) {\n-                if (!c.isAPI()) continue;\n-\n-                for (Node c2 : this.oldVersionClassList) {\n-                    if (!c2.isAPI()) continue;\n-\n-                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n-                        Node[] arr = {c, c2};\n-                        simClass.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarClasses = simClass;\n+  }\n+\n+  public List<Node[]> findSimilarClasses() {\n+    if (this.similarClasses.isEmpty()) {\n+      computeClassShingles(oldVersionClassList, oldVersionGraph);\n+      computeClassShingles(newVersionClassList, newVersionGraph);\n+      List<Node[]> simClass = new ArrayList<>();\n+      for (Node c : this.oldVersionClassList) {\n+        if (!c.isAPI()) continue;\n+\n+        for (Node c2 : this.oldVersionClassList) {\n+          if (!c2.isAPI()) continue;\n+\n+          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+            Node[] arr = {c, c2};\n+            simClass.add(arr);\n+          }\n         }\n-        return this.similarClasses;\n+      }\n+      this.similarClasses = simClass;\n     }\n+    return this.similarClasses;\n+  }\n \n-    public List<Node[]> findPullUpMethodCandidates() {\n-        return findSimilarMethods();\n-    }\n+  public List<Node[]> findPullUpMethodCandidates() {\n+    return findSimilarMethods();\n+  }\n \n-    public List<Node[]> findPushDownMethodCandidates() {\n-        return findSimilarMethods();\n-    }\n+  public List<Node[]> findPushDownMethodCandidates() {\n+    return findSimilarMethods();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.oldVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n'
          },
          {
            sha: "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "modified",
            additions: 18,
            deletions: 18,
            patch:
              '@@ -7,28 +7,28 @@\n \n public class RefactoringCategory {\n \n-    @Getter @Setter private String name;\n+  @Getter @Setter private String name;\n \n-    @Getter @Setter private List<Node[]> refactoringPairs;\n+  @Getter @Setter private List<Node[]> refactoringPairs;\n \n-    public Node[][] getElements() {\n-        Node[][] elements = new Node[refactoringPairs.size()][];\n-        int i = 0;\n-        for (Node[] pair : refactoringPairs) {\n-            elements[i++] = pair;\n-        }\n-        return elements;\n+  public Node[][] getElements() {\n+    Node[][] elements = new Node[refactoringPairs.size()][];\n+    int i = 0;\n+    for (Node[] pair : refactoringPairs) {\n+      elements[i++] = pair;\n     }\n+    return elements;\n+  }\n \n-    public String toString() {\n-        return name + printElements(getElements());\n-    }\n+  public String toString() {\n+    return name + printElements(getElements());\n+  }\n \n-    private String printElements(Node[][] array) {\n-        StringBuilder res = new StringBuilder();\n-        for (Node[] nodes : array) {\n-            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n-        }\n-        return res.toString();\n+  private String printElements(Node[][] array) {\n+    StringBuilder res = new StringBuilder();\n+    for (Node[] nodes : array) {\n+      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n     }\n+    return res.toString();\n+  }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n  @Getter @Setter private String name;\n\n  @Getter @Setter private List<Node[]> refactoringPairs;\n\n  public Node[][] getElements() {\n    Node[][] elements = new Node[refactoringPairs.size()][];\n    int i = 0;\n    for (Node[] pair : refactoringPairs) {\n      elements[i++] = pair;\n    }\n    return elements;\n  }\n\n  public String toString() {\n    return name + printElements(getElements());\n  }\n\n  private String printElements(Node[][] array) {\n    StringBuilder res = new StringBuilder();\n    for (Node[] nodes : array) {\n      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n    }\n    return res.toString();\n  }\n}\n'
          },
          {
            sha: "15111aaeb3dee736e91cde79219e6eafa796ca62",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 323,
            deletions: 323,
            patch:
              '@@ -15,327 +15,327 @@\n \n public class SourceNavigator {\n \n-    @Getter private NamedDirectedMultigraph graph;\n-\n-    private ShinglesUtil shinglesUtil;\n-\n-    private String projectName;\n-\n-    private int packageCounter = 0;\n-\n-    private int allMethodsCounter = 0;\n-\n-    private int allClassCounter = 0;\n-\n-    private int apiClassCounter = 0;\n-\n-    private int apiMethodCounter = 0;\n-\n-    public static boolean useJavadocComments = false;\n-\n-    public SourceNavigator() {\n-        graph = new NamedDirectedMultigraph();\n-    }\n-\n-    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n-        this.shinglesUtil = shinglesUtil;\n-    }\n-\n-    public void browseProject(\n-            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n-        this.projectName = projectName;\n-        val projectNode = new Node(projectName, Node.Type.PROJECT);\n-        this.graph.addNamedVertex(projectNode);\n-        compilationUnits.forEach(\n-                cu -> {\n-                    val packageDeclaration = cu.getPackageDeclaration();\n-                    val importDeclarations = cu.getImports();\n-\n-                    val classesImported = new LinkedList<String>();\n-\n-                    importDeclarations.forEach(\n-                            importDeclaration -> {\n-                                classesImported.add(importDeclaration.getName().asString());\n-                            });\n-\n-                    if (packageDeclaration.isPresent()) {\n-                        val packageName = packageDeclaration.get().getNameAsString();\n-                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n-                        packageNode.setProjectName(projectName);\n-                        this.graph.addNamedVertex(packageNode);\n-                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-                        cu.getTypes()\n-                                .forEach(\n-                                        type -> {\n-                                            if (type.isClassOrInterfaceDeclaration()) {\n-                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n-                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n-                                                if (className.isPresent()) {\n-                                                    val classNode = new ClassNode(className.get());\n-                                                    classNode.setProjectName(projectName);\n-\n-                                                    List<String> extendedClasses =\n-                                                            classOrInterfaceDeclaration\n-                                                                    .getExtendedTypes()\n-                                                                    .stream()\n-                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n-                                                                    .collect(Collectors.toList());\n-\n-                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n-                                                    classNode.setSuperClasses(extendedClasses);\n-                                                    classNode.setClassesImported(classesImported);\n-                                                    classNode.setDeprecated(\n-                                                            classOrInterfaceDeclaration\n-                                                                    .getAnnotationByClass(Deprecated.class)\n-                                                                    .isPresent());\n-                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n-\n-                                                    this.allClassCounter += 1;\n-                                                    if (classOrInterfaceDeclaration.isProtected()\n-                                                            || classOrInterfaceDeclaration.isPublic()) {\n-                                                        classNode.setAPI(true);\n-                                                        this.apiClassCounter += 1;\n-                                                    }\n-                                                    graph.addNamedVertex(classNode);\n-                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\n-                                                    // methods\n-                                                    List<MethodDeclaration> methodDeclarations =\n-                                                            classOrInterfaceDeclaration.getMethods();\n-\n-                                                    // filed fqn -> methods fqn\n-                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n-\n-                                                    methodDeclarations.forEach(\n-                                                            method -> {\n-                                                                String statementBody = "";\n-                                                                val methodBody = method.getBody();\n-\n-                                                                if (methodBody.isPresent()) {\n-                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n-                                                                        statementBody = methodBody.get().toString().trim();\n-                                                                    } else\n-                                                                        statementBody =\n-                                                                                statementBody(methodBody.get().toString()).trim();\n-                                                                    int[] shingles =\n-                                                                            shinglesUtil.computeMethodShingles(statementBody);\n-                                                                    String qualifiedName =\n-                                                                            classNode.getFullyQualifiedName()\n-                                                                                    + "."\n-                                                                                    + method.getNameAsString();\n-                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n-\n-                                                                    List<String> methodReferencedFields =\n-                                                                            method\n-                                                                                    .findAll(FieldAccessExpr.class)\n-                                                                                    .stream()\n-                                                                                    .map(\n-                                                                                            fieldAccessExpr ->\n-                                                                                                    classNode.getFullyQualifiedName()\n-                                                                                                            + "."\n-                                                                                                            + fieldAccessExpr.resolve().getName())\n-                                                                                    .collect(Collectors.toList());\n-\n-                                                                    methodReferencedFields.forEach(\n-                                                                            field -> {\n-                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n-                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n-                                                                                    methods.add(qualifiedName);\n-                                                                                    fieldReferenceToMethods.put(field, methods);\n-                                                                                }\n-                                                                            });\n-\n-                                                                    List<MethodNode.CalledMethod> calledMethodList =\n-                                                                            method\n-                                                                                    .findAll(MethodCallExpr.class)\n-                                                                                    .stream()\n-                                                                                    .map(MethodCallExpr::resolve)\n-                                                                                    .map(\n-                                                                                            resolved ->\n-                                                                                                    new MethodNode.CalledMethod(\n-                                                                                                            resolved.getQualifiedName(),\n-                                                                                                            resolved.getQualifiedSignature()))\n-                                                                                    .collect(Collectors.toList());\n-\n-                                                                    methodNode.setCalledInside(calledMethodList);\n-\n-                                                                    allMethodsCounter += 1;\n-                                                                    if (method.isPublic() || method.isProtected()) {\n-                                                                        methodNode.setAPI(true);\n-                                                                        this.apiMethodCounter += 1;\n-                                                                    }\n-                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n-                                                                        methodNode.setDeprecated(true);\n-                                                                    methodNode.setStatic(method.isStatic());\n-                                                                    methodNode.setProjectName(projectName);\n-                                                                    methodNode.setShingles(shingles);\n-                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n-                                                                    methodNode.setSignature(method.getSignature().toString());\n-                                                                    graph.addNamedVertex(methodNode);\n-                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-                                                                }\n-                                                            });\n-\n-                                                    // fields\n-                                                    List<FieldDeclaration> fieldDeclarations =\n-                                                            classOrInterfaceDeclaration.getFields();\n-                                                    fieldDeclarations.forEach(\n-                                                            field -> {\n-                                                                int[] shingles =\n-                                                                        this.shinglesUtil.computeMethodShingles(\n-                                                                                field.getVariables().toString());\n-                                                                String fullyQualifiedName =\n-                                                                        classNode.getFullyQualifiedName()\n-                                                                                + "."\n-                                                                                + field.getVariables().toString();\n-                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n-                                                                fieldNode.setFieldReferenceToMethod(\n-                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n-                                                                fieldNode.setProjectName(this.projectName);\n-                                                                fieldNode.setShingles(shingles);\n-                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-                                                                fieldNode.setStatic(field.isStatic());\n-                                                                fieldNode.setSignature(field.getCommonType().asString());\n-                                                                fieldNode.setDeprecated(\n-                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n-                                                                graph.addNamedVertex(fieldNode);\n-                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-                                                            });\n-                                                }\n-                                            }\n-                                        });\n-                    }\n-                });\n-\n-        //\t\tval packages = compilationUnits.stream()\n-        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-        //\t\t\t.filter(Optional::isPresent)\n-        //\t\t\t.collect(Collectors.toList());\n-        ////        this.graph.addVertex(projectNode);\n-        //\t\tthis.graph.addNamedVertex(projectNode);\n-        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n-    }\n-\n-    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n-    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n-    //\t\tchildrenPackages.forEach(childrenPackage -> {\n-    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n-    //\t\t\tpackageNode.setProjectName(this.projectName);\n-    ////            graph.addVertex(packageNode);\n-    //\t\t\tgraph.addNamedVertex(packageNode);\n-    ////            graph.addEdge(projectNode, packageNode);\n-    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-    //\t\t\tthis.packageCounter += 1;\n-    //\t\t});\n-    //\t}\n-\n-    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-    //\t\tval classes = pckg.getClasses();\n-    //\t\tclasses.forEach(clz -> {\n-    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-    //\t\t\tclassNode.setProjectName(this.projectName);\n-    //\t\t\tclassNode.setFlags(clz.getFlags());\n-    ////            graph.addVertex(classNode);\n-    ////            graph.addEdge(packageNode, classNode);\n-    //\t\t\tgraph.addNamedVertex(classNode);\n-    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-    //\t\t\tthis.browseClass(clz, classNode);\n-    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n-    //\t\t\tthis.allClassCounter += 1;\n-    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-    //\t\t\t\tclassNode.setAPI(true);\n-    //\t\t\t\tthis.apiClassCounter += 1;\n-    //\t\t\t}\n-    //\t\t});\n-    //\t}\n-\n-    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-    //\t\tval methods = clz.getMethods();\n-    //\t\tbrowseMethods(methods, classNode);\n-    //\t\tval fields = clz.getFields();\n-    //\t\tbrowseFields(fields, classNode);\n-    //\t}\n-    //\n-    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-    //\t\tmethods.forEach(method -> {\n-    //\t\t\tString statementBody = "";\n-    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-    //\t\t\t\tstatementBody = method.getSource().trim();\n-    //\t\t\t} else\n-    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-    //\t\t\t\t+ method.getElementName();\n-    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-    //\n-    //\t\t\tallMethodsCounter += 1;\n-    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-    //\t\t\t\tmethodNode.setAPI(true);\n-    //\t\t\t\tthis.apiMethodCounter += 1;\n-    //\t\t\t}\n-    //\t\t\tif (method.getIsDeprecated())\n-    //\t\t\t\tmethodNode.setDeprecated(true);\n-    //\t\t\tmethodNode.setProjectName(projectName);\n-    //\t\t\tmethodNode.setShingles(shingles);\n-    //\t\t\tmethodNode.setFlags(method.getFlags());\n-    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-    ////            graph.addVertex(methodNode);\n-    ////            graph.addEdge(classNode, methodNode);\n-    //\t\t\tgraph.addNamedVertex(methodNode);\n-    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-    //\t\t});\n-    //\t}\n-    //\n-    //\n-    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-    //\t\tStringBuilder buffer = new StringBuilder();\n-    //\n-    //\t\tbuffer.append(\'(\');\n-    //\n-    //\t\tString[] types = method.getParameterTypes();\n-    //\t\tfor (int i = 0; i < types.length; i++) {\n-    //\t\t\tif (i > 0)\n-    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-    //\t\t\tString typeSig = Signature.toString(types[i]);\n-    //\t\t\tbuffer.append(typeSig);\n-    //\t\t}\n-    //\t\tbuffer.append(\')\');\n-    //\n-    //\t\treturn buffer.toString();\n-    //\t}\n-    //\n-    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-    //\t\tfields.forEach(field -> {\n-    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-    //\t\t\tfieldNode.setProjectName(this.projectName);\n-    //\t\t\tfieldNode.setShingles(shingles);\n-    //\t\t\tfieldNode.setFlags(field.getFlags());\n-    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-    ////            graph.addVertex(fieldNode);\n-    ////            graph.addEdge(classNode, fieldNode);\n-    //\t\t\tgraph.addNamedVertex(fieldNode);\n-    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-    //\t\t});\n-    //\t}\n-    //\n-\n-    /**\n-    * This prunes away the javadoc comments\n-    *\n-    * @param source\n-    * @return\n-    */\n-    private String statementBody(String source) {\n-        int lastAtChar = source.lastIndexOf("@");\n-        if (lastAtChar == -1) lastAtChar = 0;\n-        int openingBracket = source.indexOf("{", lastAtChar);\n-        int closingBracket = source.lastIndexOf("}");\n-        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n-        return source;\n-    }\n+  @Getter private NamedDirectedMultigraph graph;\n+\n+  private ShinglesUtil shinglesUtil;\n+\n+  private String projectName;\n+\n+  private int packageCounter = 0;\n+\n+  private int allMethodsCounter = 0;\n+\n+  private int allClassCounter = 0;\n+\n+  private int apiClassCounter = 0;\n+\n+  private int apiMethodCounter = 0;\n+\n+  public static boolean useJavadocComments = false;\n+\n+  public SourceNavigator() {\n+    graph = new NamedDirectedMultigraph();\n+  }\n+\n+  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+    this.shinglesUtil = shinglesUtil;\n+  }\n+\n+  public void browseProject(\n+      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+    this.projectName = projectName;\n+    val projectNode = new Node(projectName, Node.Type.PROJECT);\n+    this.graph.addNamedVertex(projectNode);\n+    compilationUnits.forEach(\n+        cu -> {\n+          val packageDeclaration = cu.getPackageDeclaration();\n+          val importDeclarations = cu.getImports();\n+\n+          val classesImported = new LinkedList<String>();\n+\n+          importDeclarations.forEach(\n+              importDeclaration -> {\n+                classesImported.add(importDeclaration.getName().asString());\n+              });\n+\n+          if (packageDeclaration.isPresent()) {\n+            val packageName = packageDeclaration.get().getNameAsString();\n+            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n+            packageNode.setProjectName(projectName);\n+            this.graph.addNamedVertex(packageNode);\n+            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+            cu.getTypes()\n+                .forEach(\n+                    type -> {\n+                      if (type.isClassOrInterfaceDeclaration()) {\n+                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+                        if (className.isPresent()) {\n+                          val classNode = new ClassNode(className.get());\n+                          classNode.setProjectName(projectName);\n+\n+                          List<String> extendedClasses =\n+                              classOrInterfaceDeclaration\n+                                  .getExtendedTypes()\n+                                  .stream()\n+                                  .map(extendType -> extendType.resolve().getQualifiedName())\n+                                  .collect(Collectors.toList());\n+\n+                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+                          classNode.setSuperClasses(extendedClasses);\n+                          classNode.setClassesImported(classesImported);\n+                          classNode.setDeprecated(\n+                              classOrInterfaceDeclaration\n+                                  .getAnnotationByClass(Deprecated.class)\n+                                  .isPresent());\n+                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n+                          this.allClassCounter += 1;\n+                          if (classOrInterfaceDeclaration.isProtected()\n+                              || classOrInterfaceDeclaration.isPublic()) {\n+                            classNode.setAPI(true);\n+                            this.apiClassCounter += 1;\n+                          }\n+                          graph.addNamedVertex(classNode);\n+                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\n+                          // methods\n+                          List<MethodDeclaration> methodDeclarations =\n+                              classOrInterfaceDeclaration.getMethods();\n+\n+                          // filed fqn -> methods fqn\n+                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n+                          methodDeclarations.forEach(\n+                              method -> {\n+                                String statementBody = "";\n+                                val methodBody = method.getBody();\n+\n+                                if (methodBody.isPresent()) {\n+                                  if (classNode.isInterface() || (useJavadocComments)) {\n+                                    statementBody = methodBody.get().toString().trim();\n+                                  } else\n+                                    statementBody =\n+                                        statementBody(methodBody.get().toString()).trim();\n+                                  int[] shingles =\n+                                      shinglesUtil.computeMethodShingles(statementBody);\n+                                  String qualifiedName =\n+                                      classNode.getFullyQualifiedName()\n+                                          + "."\n+                                          + method.getNameAsString();\n+                                  MethodNode methodNode = new MethodNode(qualifiedName);\n+\n+                                  List<String> methodReferencedFields =\n+                                      method\n+                                          .findAll(FieldAccessExpr.class)\n+                                          .stream()\n+                                          .map(\n+                                              fieldAccessExpr ->\n+                                                  classNode.getFullyQualifiedName()\n+                                                      + "."\n+                                                      + fieldAccessExpr.resolve().getName())\n+                                          .collect(Collectors.toList());\n+\n+                                  methodReferencedFields.forEach(\n+                                      field -> {\n+                                        if (fieldReferenceToMethods.containsKey(field)) {\n+                                          List<String> methods = fieldReferenceToMethods.get(field);\n+                                          methods.add(qualifiedName);\n+                                          fieldReferenceToMethods.put(field, methods);\n+                                        }\n+                                      });\n+\n+                                  List<MethodNode.CalledMethod> calledMethodList =\n+                                      method\n+                                          .findAll(MethodCallExpr.class)\n+                                          .stream()\n+                                          .map(MethodCallExpr::resolve)\n+                                          .map(\n+                                              resolved ->\n+                                                  new MethodNode.CalledMethod(\n+                                                      resolved.getQualifiedName(),\n+                                                      resolved.getQualifiedSignature()))\n+                                          .collect(Collectors.toList());\n+\n+                                  methodNode.setCalledInside(calledMethodList);\n+\n+                                  allMethodsCounter += 1;\n+                                  if (method.isPublic() || method.isProtected()) {\n+                                    methodNode.setAPI(true);\n+                                    this.apiMethodCounter += 1;\n+                                  }\n+                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n+                                    methodNode.setDeprecated(true);\n+                                  methodNode.setStatic(method.isStatic());\n+                                  methodNode.setProjectName(projectName);\n+                                  methodNode.setShingles(shingles);\n+                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+                                  methodNode.setSignature(method.getSignature().toString());\n+                                  graph.addNamedVertex(methodNode);\n+                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+                                }\n+                              });\n+\n+                          // fields\n+                          List<FieldDeclaration> fieldDeclarations =\n+                              classOrInterfaceDeclaration.getFields();\n+                          fieldDeclarations.forEach(\n+                              field -> {\n+                                int[] shingles =\n+                                    this.shinglesUtil.computeMethodShingles(\n+                                        field.getVariables().toString());\n+                                String fullyQualifiedName =\n+                                    classNode.getFullyQualifiedName()\n+                                        + "."\n+                                        + field.getVariables().toString();\n+                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+                                fieldNode.setFieldReferenceToMethod(\n+                                    fieldReferenceToMethods.get(fullyQualifiedName));\n+                                fieldNode.setProjectName(this.projectName);\n+                                fieldNode.setShingles(shingles);\n+                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+                                fieldNode.setStatic(field.isStatic());\n+                                fieldNode.setSignature(field.getCommonType().asString());\n+                                fieldNode.setDeprecated(\n+                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n+                                graph.addNamedVertex(fieldNode);\n+                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+                              });\n+                        }\n+                      }\n+                    });\n+          }\n+        });\n+\n+    //\t\tval packages = compilationUnits.stream()\n+    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+    //\t\t\t.filter(Optional::isPresent)\n+    //\t\t\t.collect(Collectors.toList());\n+    ////        this.graph.addVertex(projectNode);\n+    //\t\tthis.graph.addNamedVertex(projectNode);\n+    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+  }\n+\n+  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n+  //\t\tchildrenPackages.forEach(childrenPackage -> {\n+  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+  //\t\t\tpackageNode.setProjectName(this.projectName);\n+  ////            graph.addVertex(packageNode);\n+  //\t\t\tgraph.addNamedVertex(packageNode);\n+  ////            graph.addEdge(projectNode, packageNode);\n+  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+  //\t\t\tthis.packageCounter += 1;\n+  //\t\t});\n+  //\t}\n+\n+  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+  //\t\tval classes = pckg.getClasses();\n+  //\t\tclasses.forEach(clz -> {\n+  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+  //\t\t\tclassNode.setProjectName(this.projectName);\n+  //\t\t\tclassNode.setFlags(clz.getFlags());\n+  ////            graph.addVertex(classNode);\n+  ////            graph.addEdge(packageNode, classNode);\n+  //\t\t\tgraph.addNamedVertex(classNode);\n+  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+  //\t\t\tthis.browseClass(clz, classNode);\n+  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n+  //\t\t\tthis.allClassCounter += 1;\n+  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+  //\t\t\t\tclassNode.setAPI(true);\n+  //\t\t\t\tthis.apiClassCounter += 1;\n+  //\t\t\t}\n+  //\t\t});\n+  //\t}\n+\n+  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+  //\t\tval methods = clz.getMethods();\n+  //\t\tbrowseMethods(methods, classNode);\n+  //\t\tval fields = clz.getFields();\n+  //\t\tbrowseFields(fields, classNode);\n+  //\t}\n+  //\n+  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+  //\t\tmethods.forEach(method -> {\n+  //\t\t\tString statementBody = "";\n+  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+  //\t\t\t\tstatementBody = method.getSource().trim();\n+  //\t\t\t} else\n+  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+  //\t\t\t\t+ method.getElementName();\n+  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+  //\n+  //\t\t\tallMethodsCounter += 1;\n+  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+  //\t\t\t\tmethodNode.setAPI(true);\n+  //\t\t\t\tthis.apiMethodCounter += 1;\n+  //\t\t\t}\n+  //\t\t\tif (method.getIsDeprecated())\n+  //\t\t\t\tmethodNode.setDeprecated(true);\n+  //\t\t\tmethodNode.setProjectName(projectName);\n+  //\t\t\tmethodNode.setShingles(shingles);\n+  //\t\t\tmethodNode.setFlags(method.getFlags());\n+  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+  ////            graph.addVertex(methodNode);\n+  ////            graph.addEdge(classNode, methodNode);\n+  //\t\t\tgraph.addNamedVertex(methodNode);\n+  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+  //\t\t});\n+  //\t}\n+  //\n+  //\n+  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+  //\t\tStringBuilder buffer = new StringBuilder();\n+  //\n+  //\t\tbuffer.append(\'(\');\n+  //\n+  //\t\tString[] types = method.getParameterTypes();\n+  //\t\tfor (int i = 0; i < types.length; i++) {\n+  //\t\t\tif (i > 0)\n+  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+  //\t\t\tString typeSig = Signature.toString(types[i]);\n+  //\t\t\tbuffer.append(typeSig);\n+  //\t\t}\n+  //\t\tbuffer.append(\')\');\n+  //\n+  //\t\treturn buffer.toString();\n+  //\t}\n+  //\n+  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+  //\t\tfields.forEach(field -> {\n+  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+  //\t\t\tfieldNode.setProjectName(this.projectName);\n+  //\t\t\tfieldNode.setShingles(shingles);\n+  //\t\t\tfieldNode.setFlags(field.getFlags());\n+  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+  ////            graph.addVertex(fieldNode);\n+  ////            graph.addEdge(classNode, fieldNode);\n+  //\t\t\tgraph.addNamedVertex(fieldNode);\n+  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+  //\t\t});\n+  //\t}\n+  //\n+\n+  /**\n+   * This prunes away the javadoc comments\n+   *\n+   * @param source\n+   * @return\n+   */\n+  private String statementBody(String source) {\n+    int lastAtChar = source.lastIndexOf("@");\n+    if (lastAtChar == -1) lastAtChar = 0;\n+    int openingBracket = source.indexOf("{", lastAtChar);\n+    int closingBracket = source.lastIndexOf("}");\n+    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n+    return source;\n+  }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n  @Getter private NamedDirectedMultigraph graph;\n\n  private ShinglesUtil shinglesUtil;\n\n  private String projectName;\n\n  private int packageCounter = 0;\n\n  private int allMethodsCounter = 0;\n\n  private int allClassCounter = 0;\n\n  private int apiClassCounter = 0;\n\n  private int apiMethodCounter = 0;\n\n  public static boolean useJavadocComments = false;\n\n  public SourceNavigator() {\n    graph = new NamedDirectedMultigraph();\n  }\n\n  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n    this.shinglesUtil = shinglesUtil;\n  }\n\n  public void browseProject(\n      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n    this.projectName = projectName;\n    val projectNode = new Node(projectName, Node.Type.PROJECT);\n    this.graph.addNamedVertex(projectNode);\n    compilationUnits.forEach(\n        cu -> {\n          val packageDeclaration = cu.getPackageDeclaration();\n          val importDeclarations = cu.getImports();\n\n          val classesImported = new LinkedList<String>();\n\n          importDeclarations.forEach(\n              importDeclaration -> {\n                classesImported.add(importDeclaration.getName().asString());\n              });\n\n          if (packageDeclaration.isPresent()) {\n            val packageName = packageDeclaration.get().getNameAsString();\n            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n            packageNode.setProjectName(projectName);\n            this.graph.addNamedVertex(packageNode);\n            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n            cu.getTypes()\n                .forEach(\n                    type -> {\n                      if (type.isClassOrInterfaceDeclaration()) {\n                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                        if (className.isPresent()) {\n                          val classNode = new ClassNode(className.get());\n                          classNode.setProjectName(projectName);\n\n                          List<String> extendedClasses =\n                              classOrInterfaceDeclaration\n                                  .getExtendedTypes()\n                                  .stream()\n                                  .map(extendType -> extendType.resolve().getQualifiedName())\n                                  .collect(Collectors.toList());\n\n                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                          classNode.setSuperClasses(extendedClasses);\n                          classNode.setClassesImported(classesImported);\n                          classNode.setDeprecated(\n                              classOrInterfaceDeclaration\n                                  .getAnnotationByClass(Deprecated.class)\n                                  .isPresent());\n                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                          this.allClassCounter += 1;\n                          if (classOrInterfaceDeclaration.isProtected()\n                              || classOrInterfaceDeclaration.isPublic()) {\n                            classNode.setAPI(true);\n                            this.apiClassCounter += 1;\n                          }\n                          graph.addNamedVertex(classNode);\n                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                          // methods\n                          List<MethodDeclaration> methodDeclarations =\n                              classOrInterfaceDeclaration.getMethods();\n\n                          // filed fqn -> methods fqn\n                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                          methodDeclarations.forEach(\n                              method -> {\n                                String statementBody = "";\n                                val methodBody = method.getBody();\n\n                                if (methodBody.isPresent()) {\n                                  if (classNode.isInterface() || (useJavadocComments)) {\n                                    statementBody = methodBody.get().toString().trim();\n                                  } else\n                                    statementBody =\n                                        statementBody(methodBody.get().toString()).trim();\n                                  int[] shingles =\n                                      shinglesUtil.computeMethodShingles(statementBody);\n                                  String qualifiedName =\n                                      classNode.getFullyQualifiedName()\n                                          + "."\n                                          + method.getNameAsString();\n                                  MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                  List<String> methodReferencedFields =\n                                      method\n                                          .findAll(FieldAccessExpr.class)\n                                          .stream()\n                                          .map(\n                                              fieldAccessExpr ->\n                                                  classNode.getFullyQualifiedName()\n                                                      + "."\n                                                      + fieldAccessExpr.resolve().getName())\n                                          .collect(Collectors.toList());\n\n                                  methodReferencedFields.forEach(\n                                      field -> {\n                                        if (fieldReferenceToMethods.containsKey(field)) {\n                                          List<String> methods = fieldReferenceToMethods.get(field);\n                                          methods.add(qualifiedName);\n                                          fieldReferenceToMethods.put(field, methods);\n                                        }\n                                      });\n\n                                  List<MethodNode.CalledMethod> calledMethodList =\n                                      method\n                                          .findAll(MethodCallExpr.class)\n                                          .stream()\n                                          .map(MethodCallExpr::resolve)\n                                          .map(\n                                              resolved ->\n                                                  new MethodNode.CalledMethod(\n                                                      resolved.getQualifiedName(),\n                                                      resolved.getQualifiedSignature()))\n                                          .collect(Collectors.toList());\n\n                                  methodNode.setCalledInside(calledMethodList);\n\n                                  allMethodsCounter += 1;\n                                  if (method.isPublic() || method.isProtected()) {\n                                    methodNode.setAPI(true);\n                                    this.apiMethodCounter += 1;\n                                  }\n                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                    methodNode.setDeprecated(true);\n                                  methodNode.setStatic(method.isStatic());\n                                  methodNode.setProjectName(projectName);\n                                  methodNode.setShingles(shingles);\n                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                  methodNode.setSignature(method.getSignature().toString());\n                                  graph.addNamedVertex(methodNode);\n                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                }\n                              });\n\n                          // fields\n                          List<FieldDeclaration> fieldDeclarations =\n                              classOrInterfaceDeclaration.getFields();\n                          fieldDeclarations.forEach(\n                              field -> {\n                                int[] shingles =\n                                    this.shinglesUtil.computeMethodShingles(\n                                        field.getVariables().toString());\n                                String fullyQualifiedName =\n                                    classNode.getFullyQualifiedName()\n                                        + "."\n                                        + field.getVariables().toString();\n                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                fieldNode.setFieldReferenceToMethod(\n                                    fieldReferenceToMethods.get(fullyQualifiedName));\n                                fieldNode.setProjectName(this.projectName);\n                                fieldNode.setShingles(shingles);\n                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                fieldNode.setStatic(field.isStatic());\n                                fieldNode.setSignature(field.getCommonType().asString());\n                                fieldNode.setDeprecated(\n                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n                                graph.addNamedVertex(fieldNode);\n                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                              });\n                        }\n                      }\n                    });\n          }\n        });\n\n    //\t\tval packages = compilationUnits.stream()\n    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n    //\t\t\t.filter(Optional::isPresent)\n    //\t\t\t.collect(Collectors.toList());\n    ////        this.graph.addVertex(projectNode);\n    //\t\tthis.graph.addNamedVertex(projectNode);\n    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n  }\n\n  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n  //\t\tchildrenPackages.forEach(childrenPackage -> {\n  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n  //\t\t\tpackageNode.setProjectName(this.projectName);\n  ////            graph.addVertex(packageNode);\n  //\t\t\tgraph.addNamedVertex(packageNode);\n  ////            graph.addEdge(projectNode, packageNode);\n  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n  //\t\t\tthis.packageCounter += 1;\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n  //\t\tval classes = pckg.getClasses();\n  //\t\tclasses.forEach(clz -> {\n  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n  //\t\t\tclassNode.setProjectName(this.projectName);\n  //\t\t\tclassNode.setFlags(clz.getFlags());\n  ////            graph.addVertex(classNode);\n  ////            graph.addEdge(packageNode, classNode);\n  //\t\t\tgraph.addNamedVertex(classNode);\n  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n  //\t\t\tthis.browseClass(clz, classNode);\n  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n  //\t\t\tthis.allClassCounter += 1;\n  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n  //\t\t\t\tclassNode.setAPI(true);\n  //\t\t\t\tthis.apiClassCounter += 1;\n  //\t\t\t}\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n  //\t\tval methods = clz.getMethods();\n  //\t\tbrowseMethods(methods, classNode);\n  //\t\tval fields = clz.getFields();\n  //\t\tbrowseFields(fields, classNode);\n  //\t}\n  //\n  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n  //\t\tmethods.forEach(method -> {\n  //\t\t\tString statementBody = "";\n  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n  //\t\t\t\tstatementBody = method.getSource().trim();\n  //\t\t\t} else\n  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n  //\t\t\t\t+ method.getElementName();\n  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n  //\n  //\t\t\tallMethodsCounter += 1;\n  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n  //\t\t\t\tmethodNode.setAPI(true);\n  //\t\t\t\tthis.apiMethodCounter += 1;\n  //\t\t\t}\n  //\t\t\tif (method.getIsDeprecated())\n  //\t\t\t\tmethodNode.setDeprecated(true);\n  //\t\t\tmethodNode.setProjectName(projectName);\n  //\t\t\tmethodNode.setShingles(shingles);\n  //\t\t\tmethodNode.setFlags(method.getFlags());\n  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n  ////            graph.addVertex(methodNode);\n  ////            graph.addEdge(classNode, methodNode);\n  //\t\t\tgraph.addNamedVertex(methodNode);\n  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n  //\t\t});\n  //\t}\n  //\n  //\n  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n  //\t\tStringBuilder buffer = new StringBuilder();\n  //\n  //\t\tbuffer.append(\'(\');\n  //\n  //\t\tString[] types = method.getParameterTypes();\n  //\t\tfor (int i = 0; i < types.length; i++) {\n  //\t\t\tif (i > 0)\n  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n  //\t\t\tString typeSig = Signature.toString(types[i]);\n  //\t\t\tbuffer.append(typeSig);\n  //\t\t}\n  //\t\tbuffer.append(\')\');\n  //\n  //\t\treturn buffer.toString();\n  //\t}\n  //\n  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n  //\t\tfields.forEach(field -> {\n  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n  //\t\t\tfieldNode.setProjectName(this.projectName);\n  //\t\t\tfieldNode.setShingles(shingles);\n  //\t\t\tfieldNode.setFlags(field.getFlags());\n  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n  ////            graph.addVertex(fieldNode);\n  ////            graph.addEdge(classNode, fieldNode);\n  //\t\t\tgraph.addNamedVertex(fieldNode);\n  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n  //\t\t});\n  //\t}\n  //\n\n  /**\n   * This prunes away the javadoc comments\n   *\n   * @param source\n   * @return\n   */\n  private String statementBody(String source) {\n    int lastAtChar = source.lastIndexOf("@");\n    if (lastAtChar == -1) lastAtChar = 0;\n    int openingBracket = source.indexOf("{", lastAtChar);\n    int closingBracket = source.lastIndexOf("}");\n    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n    return source;\n  }\n}\n'
          },
          {
            sha: "8be634a324eb752a884f5bdb1485533113d36ac5",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 57,
            deletions: 57,
            patch:
              '@@ -1,6 +1,6 @@\n /*\n-* This Java source file was generated by the Gradle \'init\' task.\n-*/\n+ * This Java source file was generated by the Gradle \'init\' task.\n+ */\n package refactoring.crawler;\n \n import java.util.Dictionary;\n@@ -12,66 +12,66 @@\n \n class RefactoringCrawlerTest {\n \n-    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n \n-    private static RefactoringCrawler refactoringCrawler;\n+  private static RefactoringCrawler refactoringCrawler;\n \n-    @BeforeAll\n-    static void setUp() {\n-        settings = new Hashtable<>();\n+  @BeforeAll\n+  static void setUp() {\n+    settings = new Hashtable<>();\n \n-        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n-        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n \n-        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n-    }\n+    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n+  }\n \n-    @Test\n-    void testRenameMethod() {\n-        String source =\n-                "/*\\n"\n-                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-                        + " */\\n"\n-                        + "package refactoring.crawler;\\n"\n-                        + "\\n"\n-                        + "public class Library {\\n"\n-                        + "\\tprivate int a;\\n"\n-                        + "\\tprivate int b;\\n"\n-                        + "\\n"\n-                        + "\\tpublic void foo() {\\n"\n-                        + "\\t\\tSystem.out.println(11111);\\n"\n-                        + "\\t}\\n"\n-                        + "\\n"\n-                        + "\\tpublic void bar() {\\n"\n-                        + "\\t\\tthis.foo();\\n"\n-                        + "\\t}\\n"\n-                        + "}\\n";\n+  @Test\n+  void testRenameMethod() {\n+    String source =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n \n-        String newVersion =\n-                "/*\\n"\n-                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n-                        + " */\\n"\n-                        + "package refactoring.crawler;\\n"\n-                        + "\\n"\n-                        + "public class Library {\\n"\n-                        + "\\tprivate int a;\\n"\n-                        + "\\tprivate int b;\\n"\n-                        + "\\n"\n-                        + "\\tpublic void foo12() {\\n"\n-                        + "\\t\\tSystem.out.println(11111);\\n"\n-                        + "\\t}\\n"\n-                        + "\\n"\n-                        + "\\tpublic void bar() {\\n"\n-                        + "\\t\\tthis.foo12();\\n"\n-                        + "\\t}\\n"\n-                        + "}\\n";\n+    String newVersion =\n+        "/*\\n"\n+            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+            + " */\\n"\n+            + "package refactoring.crawler;\\n"\n+            + "\\n"\n+            + "public class Library {\\n"\n+            + "\\tprivate int a;\\n"\n+            + "\\tprivate int b;\\n"\n+            + "\\n"\n+            + "\\tpublic void foo12() {\\n"\n+            + "\\t\\tSystem.out.println(11111);\\n"\n+            + "\\t}\\n"\n+            + "\\n"\n+            + "\\tpublic void bar() {\\n"\n+            + "\\t\\tthis.foo12();\\n"\n+            + "\\t}\\n"\n+            + "}\\n";\n \n-        refactoringCrawler.detect(source, newVersion);\n-        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n-        System.out.println(categories);\n-    }\n+    refactoringCrawler.detect(source, newVersion);\n+    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+    System.out.println(categories);\n+  }\n }',
            rawContent:
              '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  private static RefactoringCrawler refactoringCrawler;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\n    refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    System.out.println(categories);\n  }\n}\n'
          }
        ]
      },
      {
        sha: "f38d6d29251fbdacab8f8a7a8390339bd60e65f2",
        message: "chore(*): clean code",
        stats: {
          total: 6706,
          additions: 2984,
          deletions: 3722
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "e730803e9a4a7b487df89013a8a6901f07100860"
          }
        ],
        committedAt: 1585221600000,
        changedFiles: [
          {
            sha: "dbed3f5159f19e4d213ce44a54fa6fdbfe39745c",
            filename: "build.gradle",
            status: "modified",
            additions: 17,
            deletions: 3,
            patch:
              "@@ -9,8 +9,25 @@\n plugins {\n     // Apply the java-library plugin to add support for Java Library\n     id 'java-library'\n+    id \"com.diffplug.gradle.spotless\" version \"3.16.0\"\n }\n \n+sourceCompatibility = 1.8\n+\n+spotless {\n+    java {\n+        googleJavaFormat()\n+        indentWithTabs(2)\n+        indentWithSpaces(4)\n+    }\n+}\n+\n+def hook = new File(\"$rootProject.projectDir/.git/hooks/pre-commit\")\n+hook.text = \"\"\"#!/bin/bash\n+echo \"will run nova code format\"\n+./gradlew spotlessApply\n+\"\"\"\n+\n repositories {\n     // Use jcenter for resolving dependencies.\n     // You can declare any Maven/Ivy/file repository here.\n@@ -35,9 +52,6 @@ dependencies {\n \n     testCompileOnly 'org.projectlombok:lombok:1.18.12'\n     testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n-    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n-\n-    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n \n     // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n     implementation 'com.google.guava:guava:27.1-jre'",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id \"com.diffplug.gradle.spotless\" version \"3.16.0\"\n}\n\nsourceCompatibility = 1.8\n\nspotless {\n    java {\n        googleJavaFormat()\n        indentWithTabs(2)\n        indentWithSpaces(4)\n    }\n}\n\ndef hook = new File(\"$rootProject.projectDir/.git/hooks/pre-commit\")\nhook.text = \"\"\"#!/bin/bash\necho \"will run nova code format\"\n./gradlew spotlessApply\n\"\"\"\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "83d2cfcf9d3fac2cb14ed33d480d729a23bc2d31",
            filename: "src/main/java/refactoring/crawler/Library.java",
            status: "removed",
            additions: 0,
            deletions: 10,
            patch:
              "@@ -1,10 +0,0 @@\n-/*\n- * This Java source file was generated by the Gradle 'init' task.\n- */\n-package refactoring.crawler;\n-\n-public class Library {\n-    public boolean someLibraryMethod() {\n-        return true;\n-    }\n-}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\npublic class Library {\n    public boolean someLibraryMethod() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "497ce77693eded861c3d868fd5dbc8f1fa2434e0",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 189,
            deletions: 159,
            patch:
              '@@ -5,170 +5,200 @@\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n+import java.util.*;\n import lombok.Getter;\n+import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.classDetection.RenameClassDetection;\n import refactoring.crawler.detection.methodDetection.*;\n-import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n+import refactoring.crawler.shingles.ShinglesUtil;\n import refactoring.crawler.util.*;\n \n-import java.util.*;\n-\n public class RefactoringCrawler {\n \n-\tpublic static enum Settings {\n-\t\tT_RENAME_METHOD,\n-\t\tT_RENAME_CLASS,\n-\t\tT_MOVE_METHOD,\n-\t\tT_PULL_UP_METHOD,\n-\t\tT_PUSH_DOWN_METHOD,\n-\t\tT_CHANGE_METHOD_SIGNATURE\n-\t}\n-\n-\tprivate String projectName;\n-\tprivate Dictionary<Settings, Double> settings;\n-\n-\t@Getter\n-\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n-\n-\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n-\t\tthis.projectName = projectName;\n-\t\tthis.settings = settings;\n-\t}\n-\n-\tprivate static List<CompilationUnit> parse(List<String> files) {\n-\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n-\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n-\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n-\n-\t\tList<CompilationUnit> resList = new LinkedList<>();\n-\t\tfor (String source : files) {\n-\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n-\t\t\tresList.add(cu);\n-\t\t}\n-\t\treturn resList;\n-\t}\n-\n-\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n-\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n-\n-\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n-\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n-\t\tSourceNavigator navigator = new SourceNavigator();\n-\t\tnavigator.setShinglesUtil(shinglesUtil);\n-\t\tnavigator.browseProject(projectName, oldVersionCU);\n-\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n-\n-\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n-\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n-\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n-\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n-\n-\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n-\n-\t\t// must in this order\n-\n-\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n-\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n-\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n-\n-\n-\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n-\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n-\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n-\t\t\toriginalGraph, versionGraph);\n-\n-\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n-\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n-\n-\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n-\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n-\t}\n-\n-\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n-\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tChangeMethodSignature);\n-\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n-\t\tif (changedMethodSignatures.size() > 0) {\n-\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n-\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n-\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n-\t\t}\n-\t}\n-\n-\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n-\t                                NamedDirectedMultigraph newVersionGraph) {\n-\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n-\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-\t\tdetector.setThreshold(tMethod);\n-\n-\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n-\t\tif (renamedMethods.size() > 0) {\n-\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n-\t\t\trenameMethodCategory.setName("RenamedMethods");\n-\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n-\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n-\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n-\t\t\tversionGraph);\n-\t\tdetector.setThreshold(tClass);\n-\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n-\t\tif (renamedClasses.size() > 0) {\n-\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n-\t\t\trenameClassCategory.setName("RenamedClasses");\n-\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n-\t\t\tthis.refactoringCategories.add(renameClassCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n-\t\tse.findSimilarClasses();\n-\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tMoveMethod);\n-\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n-\t\tif (movedMethods.size() > 0) {\n-\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n-\t\t\tmoveMethodCategory.setName("MovedMethods");\n-\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n-\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n-\t\tRefactoringDetection detector = new PullUpMethodDetection(\n-\t\t\toriginalGraph, versionGraph);\n-\t\tdetector.setThreshold(tPullUpMethod);\n-\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n-\t\tif (pullUpMethodResults.size() > 0) {\n-\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n-\t\t\tpullUpCategory.setName("PulledUpMethods");\n-\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n-\t\t\tthis.refactoringCategories.add(pullUpCategory);\n-\t\t}\n-\t}\n-\n-\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n-\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n-\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n-\t\tdetector.setThreshold(tPushDownMethod);\n-\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n-\t\tif (pushDownMethodResults.size() > 0) {\n-\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n-\t\t\tpushDownCategory.setName("PushedDownMethods");\n-\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n-\t\t\tthis.refactoringCategories.add(pushDownCategory);\n-\t\t}\n-\t}\n+    public static enum Settings {\n+        T_RENAME_METHOD,\n+        T_RENAME_CLASS,\n+        T_MOVE_METHOD,\n+        T_PULL_UP_METHOD,\n+        T_PUSH_DOWN_METHOD,\n+        T_CHANGE_METHOD_SIGNATURE\n+    }\n+\n+    private String projectName;\n+    private Dictionary<Settings, Double> settings;\n+\n+    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n+\n+    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n+        this.projectName = projectName;\n+        this.settings = settings;\n+    }\n+\n+    private static List<CompilationUnit> parse(List<String> files) {\n+        TypeSolver typeSolver = new ReflectionTypeSolver();\n+        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n+        List<CompilationUnit> resList = new LinkedList<>();\n+        for (String source : files) {\n+            CompilationUnit cu = StaticJavaParser.parse(source);\n+            resList.add(cu);\n+        }\n+        return resList;\n+    }\n+\n+    public void detect(String oldVersion, String newVersion) {\n+        List<String> oldVersionList = new LinkedList<>();\n+        List<String> newVersionList = new LinkedList<>();\n+\n+        oldVersionList.add(oldVersion);\n+        newVersionList.add(newVersion);\n+\n+        this.detect(oldVersionList, newVersionList);\n+    }\n+\n+    public void detect(List<String> oldVersion, List<String> newVersion) {\n+        ShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n+        List<CompilationUnit> newVersionCU = parse(newVersion);\n+        SourceNavigator navigator = new SourceNavigator();\n+        navigator.setShinglesUtil(shinglesUtil);\n+        navigator.browseProject(projectName, oldVersionCU);\n+        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+        SourceNavigator navigatorForVersion = new SourceNavigator();\n+        navigatorForVersion.setShinglesUtil(shinglesUtil);\n+        navigatorForVersion.browseProject(projectName, newVersionCU);\n+        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+        shinglesUtil.initialize(originalGraph, versionGraph);\n+\n+        // must in this order\n+\n+        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n+    }\n+\n+    private void detectChangeMethodSignature(\n+            double tChangeMethodSignature,\n+            ShinglesUtil shinglesUtil,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tChangeMethodSignature);\n+        List<Node[]> changedMethodSignatures =\n+                detector.detectRefactorings(candidateChangedMethodSignatures);\n+        if (changedMethodSignatures.size() > 0) {\n+            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+            changeSignatureCategory.setName("ChangedMethodSignatures");\n+            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+            this.refactoringCategories.add(changeSignatureCategory);\n+        }\n+    }\n+\n+    private void detectRenameMethod(\n+            double tMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph oldVersionGraph,\n+            NamedDirectedMultigraph newVersionGraph) {\n+        List<Node[]> candidateMethods = se.findSimilarMethods();\n+        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+        detector.setThreshold(tMethod);\n+\n+        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+        if (renamedMethods.size() > 0) {\n+            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+            renameMethodCategory.setName("RenamedMethods");\n+            renameMethodCategory.setRefactoringPairs(renamedMethods);\n+            this.refactoringCategories.add(renameMethodCategory);\n+        }\n+    }\n+\n+    public void detectRenameClass(\n+            double tClass,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidateClasses = se.findSimilarClasses();\n+        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tClass);\n+        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+        if (renamedClasses.size() > 0) {\n+            RefactoringCategory renameClassCategory = new RefactoringCategory();\n+            renameClassCategory.setName("RenamedClasses");\n+            renameClassCategory.setRefactoringPairs(renamedClasses);\n+            this.refactoringCategories.add(renameClassCategory);\n+        }\n+    }\n+\n+    public void detectMoveMethod(\n+            double tMoveMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> methodCandidates = se.findSimilarMethods();\n+        se.findSimilarClasses();\n+        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+        detector.setThreshold(tMoveMethod);\n+        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+        if (movedMethods.size() > 0) {\n+            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n+            moveMethodCategory.setName("MovedMethods");\n+            moveMethodCategory.setRefactoringPairs(movedMethods);\n+            this.refactoringCategories.add(moveMethodCategory);\n+        }\n+    }\n+\n+    public void detectPullUpMethod(\n+            double tPullUpMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tPullUpMethod);\n+        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+        if (pullUpMethodResults.size() > 0) {\n+            RefactoringCategory pullUpCategory = new RefactoringCategory();\n+            pullUpCategory.setName("PulledUpMethods");\n+            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+            this.refactoringCategories.add(pullUpCategory);\n+        }\n+    }\n+\n+    public void detectPushDownMethod(\n+            double tPushDownMethod,\n+            ShinglesUtil se,\n+            NamedDirectedMultigraph originalGraph,\n+            NamedDirectedMultigraph versionGraph) {\n+        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+        detector.setThreshold(tPushDownMethod);\n+        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+        if (pushDownMethodResults.size() > 0) {\n+            RefactoringCategory pushDownCategory = new RefactoringCategory();\n+            pushDownCategory.setName("PushedDownMethods");\n+            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+            this.refactoringCategories.add(pushDownCategory);\n+        }\n+    }\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n    public static enum Settings {\n        T_RENAME_METHOD,\n        T_RENAME_CLASS,\n        T_MOVE_METHOD,\n        T_PULL_UP_METHOD,\n        T_PUSH_DOWN_METHOD,\n        T_CHANGE_METHOD_SIGNATURE\n    }\n\n    private String projectName;\n    private Dictionary<Settings, Double> settings;\n\n    @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n    public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n        this.projectName = projectName;\n        this.settings = settings;\n    }\n\n    private static List<CompilationUnit> parse(List<String> files) {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n        List<CompilationUnit> resList = new LinkedList<>();\n        for (String source : files) {\n            CompilationUnit cu = StaticJavaParser.parse(source);\n            resList.add(cu);\n        }\n        return resList;\n    }\n\n    public void detect(String oldVersion, String newVersion) {\n        List<String> oldVersionList = new LinkedList<>();\n        List<String> newVersionList = new LinkedList<>();\n\n        oldVersionList.add(oldVersion);\n        newVersionList.add(newVersion);\n\n        this.detect(oldVersionList, newVersionList);\n    }\n\n    public void detect(List<String> oldVersion, List<String> newVersion) {\n        ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n        List<CompilationUnit> oldVersionCU = parse(oldVersion);\n        List<CompilationUnit> newVersionCU = parse(newVersion);\n        SourceNavigator navigator = new SourceNavigator();\n        navigator.setShinglesUtil(shinglesUtil);\n        navigator.browseProject(projectName, oldVersionCU);\n        NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n        SourceNavigator navigatorForVersion = new SourceNavigator();\n        navigatorForVersion.setShinglesUtil(shinglesUtil);\n        navigatorForVersion.browseProject(projectName, newVersionCU);\n        NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n        shinglesUtil.initialize(originalGraph, versionGraph);\n\n        // must in this order\n\n        double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n        this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n        detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n        double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n        detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n        detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n        detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n        double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n        detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n    }\n\n    private void detectChangeMethodSignature(\n            double tChangeMethodSignature,\n            ShinglesUtil shinglesUtil,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n        RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n        detector.setThreshold(tChangeMethodSignature);\n        List<Node[]> changedMethodSignatures =\n                detector.detectRefactorings(candidateChangedMethodSignatures);\n        if (changedMethodSignatures.size() > 0) {\n            RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n            changeSignatureCategory.setName("ChangedMethodSignatures");\n            changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n            this.refactoringCategories.add(changeSignatureCategory);\n        }\n    }\n\n    private void detectRenameMethod(\n            double tMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph oldVersionGraph,\n            NamedDirectedMultigraph newVersionGraph) {\n        List<Node[]> candidateMethods = se.findSimilarMethods();\n        RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n        detector.setThreshold(tMethod);\n\n        List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n        if (renamedMethods.size() > 0) {\n            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n            renameMethodCategory.setName("RenamedMethods");\n            renameMethodCategory.setRefactoringPairs(renamedMethods);\n            this.refactoringCategories.add(renameMethodCategory);\n        }\n    }\n\n    public void detectRenameClass(\n            double tClass,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidateClasses = se.findSimilarClasses();\n        RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n        detector.setThreshold(tClass);\n        List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n        if (renamedClasses.size() > 0) {\n            RefactoringCategory renameClassCategory = new RefactoringCategory();\n            renameClassCategory.setName("RenamedClasses");\n            renameClassCategory.setRefactoringPairs(renamedClasses);\n            this.refactoringCategories.add(renameClassCategory);\n        }\n    }\n\n    public void detectMoveMethod(\n            double tMoveMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> methodCandidates = se.findSimilarMethods();\n        se.findSimilarClasses();\n        RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n        detector.setThreshold(tMoveMethod);\n        List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n        if (movedMethods.size() > 0) {\n            RefactoringCategory moveMethodCategory = new RefactoringCategory();\n            moveMethodCategory.setName("MovedMethods");\n            moveMethodCategory.setRefactoringPairs(movedMethods);\n            this.refactoringCategories.add(moveMethodCategory);\n        }\n    }\n\n    public void detectPullUpMethod(\n            double tPullUpMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n        RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n        detector.setThreshold(tPullUpMethod);\n        List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n        if (pullUpMethodResults.size() > 0) {\n            RefactoringCategory pullUpCategory = new RefactoringCategory();\n            pullUpCategory.setName("PulledUpMethods");\n            pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n            this.refactoringCategories.add(pullUpCategory);\n        }\n    }\n\n    public void detectPushDownMethod(\n            double tPushDownMethod,\n            ShinglesUtil se,\n            NamedDirectedMultigraph originalGraph,\n            NamedDirectedMultigraph versionGraph) {\n        List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n        RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n        detector.setThreshold(tPushDownMethod);\n        List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n        if (pushDownMethodResults.size() > 0) {\n            RefactoringCategory pushDownCategory = new RefactoringCategory();\n            pushDownCategory.setName("PushedDownMethods");\n            pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n            this.refactoringCategories.add(pushDownCategory);\n        }\n    }\n}\n'
          },
          {
            sha: "a9cd858ea9df0f73bd311c9de0ef2f0e49c71832",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 417,
            deletions: 444,
            patch:
              '@@ -1,453 +1,426 @@\n package refactoring.crawler.detection;\n \n+import java.util.*;\n import lombok.Getter;\n import lombok.Setter;\n import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n-import refactoring.crawler.util.ClassNode;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n-import java.util.*;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public abstract class RefactoringDetection {\n \n-\n-\t@Getter\n-\t@Setter\n-\tprivate double threshold;\n-\n-\tprotected NamedDirectedMultigraph graph1;\n-\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\tprivate double lowerThreshold;\n-\n-\t/**\n-\t * Dictionary contains <Original, Version> pairs for the renaming.\n-\t */\n-\tprivate static Dictionary<String, String> renamingDictionary;\n-\n-\tpublic static Dictionary<String, String> getRenamingDictionary() {\n-\t\tif (renamingDictionary == null)\n-\t\t\trenamingDictionary = new Hashtable<>();\n-\t\treturn renamingDictionary;\n-\t}\n-\n-\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tthis.graph1 = graph;\n-\t\tthis.graph2 = graph2;\n-\t}\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n-\n-\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-\tpublic abstract boolean isRename();\n-\n-\t/**\n-\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n-\t * refactoring The original candidates are prunned (for getting rid of\n-\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n-\t * the end we eliminate FalsePositives. Subclasses must override\n-\t * computeLikeliness and pruneOriginalCandidates.\n-\t */\n-\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\n-\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n-\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-\t\treturn pruneFalsePositives(listWithFP);\n-\t}\n-\n-\tprotected String extractPotentialRename(String parentClassOriginal) {\n-\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n-\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n-\t}\n-\n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Node[] pair : prunedCandidates) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n-\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n-\t\t\t\t// detect those cases when two\n-\t\t\t\t// types of refactorings happened to the same node\n-\t\t\t}\n-\t\t}\n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n-\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n-\t\t\tif (originalInV2 != null) {\n-\t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n-\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t\t\t.incomingEdgesOf(version)));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t\t\t.incomingEdgesOf(original)));\n-\n-\n-\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n-\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n-\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n-\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Node node : verCallers) {\n-\t\t\t\t\tif (origInV2Callers.contains(node))\n-\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n-\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n-\t\t\t\t// should be different\n-\t\t\t\tfor (Node node : origInV1Callers) {\n-\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n-\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tlistWithFP.remove(pair);\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\n-\t\tpruneOverloadedMethodFP(listWithFP);\n-\n-\t\treturn listWithFP;\n-\t}\n-\n-\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<>();\n-\t\tfor (Edge edge : incomingEdges) {\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n-\n-\t/**\n-\t * This prunes cases like m(i) -> m\'(i)\n-\t * m(i) -> m\'(S)\n-\t * <p>\n-\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n-\t * generated because of a method overload.\n-\t * <p>\n-\t * This method is never called in the ChangeMethodSignature detection.\n-\t */\n-\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n-\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n-\t\t\tboolean hasSameNameAndSignature = false;\n-\t\t\tNode[] pair = listWithFP.get(i);\n-\t\t\tNode source = pair[0];\n-\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n-\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\thasSameNameAndSignature = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (hasSameNameAndSignature) {\n-\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n-\t\t\t\t\tNode source2 = pair2[0];\n-\t\t\t\t\tif (source.equals(source2)) {\n-\t\t\t\t\t\tNode target2 = pair2[1];\n-\t\t\t\t\t\tif (source.getSimpleName().equals(\n-\t\t\t\t\t\t\ttarget2.getSimpleName()))\n-\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n-\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n-\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t}\n-\t\tfor (Node[] pair : nodesToRemove) {\n-\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-\t\t\tlistWithFP.remove(pair);\n-\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This takes into account the possible renaming in the parent of the node\n-\t *\n-\t * @param g        is the Version2 graph\n-\t * @param original is a node from Version1\n-\t * @return\n-\t */\n-\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tString fqnParent = extractFullyQualifiedParentName(original);\n-\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n-\t\tif (possiblyRenamedFQN != null)\n-\t\t\tfqnParent = possiblyRenamedFQN;\n-\t\tNode parentNode = g.findNamedNode(fqnParent);\n-\n-\t\tif (parentNode != null) {\n-\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n-\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-\t\t\t\tEdge edge = (Edge) iter.next();\n-\t\t\t\tNode child = (Node) edge.getTarget();\n-\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n-\t\t\t\t\tif (original.getSignature() != null) {\n-\t\t\t\t\t\t// This handles the method nodes\n-\t\t\t\t\t\tif (original.getSignature()\n-\t\t\t\t\t\t\t.equals(child.getSignature()))\n-\t\t\t\t\t\t\treturn child;\n-\t\t\t\t\t} else\n-\t\t\t\t\t\t// Classes and packages\n-\t\t\t\t\t\treturn child;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (label.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\tprotected String extractFullyQualifiedParentName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\treturn extractFullyQualifiedParentName(originalName);\n-\t}\n-\n-\tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fq_parentName = "";\n-\t\tint lastIndex = originalName.lastIndexOf(".");\n-\t\tif (lastIndex > 0)\n-\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n-\t\treturn fq_parentName;\n-\t}\n-\n-\t/**\n-\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n-\t * IDE.openEditor(IWorkbenchPage, IFile)\n-\t */\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null)\n-\t\t\treturn false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n-\t\t\t\t\treturn false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n-\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/**\n-\t * This helper method takes a string containing the dot separated name of a\n-\t * node and it returns the substring from the beginning up to the last dot\n-\t * (e.g. for pack1.class1.method1 it returns class1)\n-\t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName\n-\t\t\t.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n-\t}\n-\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original)))\n-\t\t\treturn true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n-\t\t\tversion.substring(version.lastIndexOf("."))))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original),\n-\t\t\t\textractFullyQualifiedParentName(version));\n-\t\telse\n-\t\t\treturn false;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-\t\t\t\t.getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n-\t\t\t\t\t\t.getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t// TODO this is bug pruned\n-\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-//\t\ttry {\n-\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n-\t\tresults.forEach(result -> {\n-\t\t\tif (graph.hasNamedNode(result))\n-\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n-\t\t});\n-\t\t// Possible change to methods that instantiate classes\n-\t\t// from class -> class edges.\n-//\t\t\tfor (String result : results) {\n-////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n-//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n-//\t\t\t\tString callingNode = null;\n-//\t\t\t\tif (resultNode instanceof IMethod) {\n-//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof IType) {\n-//\t\t\t\t\tIType rst = (IType) resultNode;\n-//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n-//\t\t\t\t} else if (resultNode instanceof IField) {\n-//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n-//\t\t\t\t\t// Workaround\n-//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += ".";\n-//\t\t\t\t\tcallingNode += rsf1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n-//\t\t\t\t\t\t.getParent(initializer,\n-//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n-//\t\t\t\t\t\tIType.class);\n-//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n-//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n-//\t\t\t\t}\n-//\n-//\t\t\t\t// TODO treat the case when resultNode is instance of\n-//\t\t\t\t// ImportDeclaration\n-//\t\t\t\t// TODO treat the case when resultNode is instance of\n-//\t\t\t\t// Initializer\n-//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n-//\t\t\t\t// Level\n-//\t\t\t\tif (callingNode == null) {\n-//\t\t\t\t\tSystem.out.print("");\n-//\t\t\t\t}\n-//\t\t\t\tif (callingNode != null) {\n-//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n-//\t\t\t\t\tif (callerNode != null)\n-//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n-//\t\t\t\t}\n-//\n-//\t\t\t}\n-//\n-//\t\t} catch (CoreException e) {\n-//\t\t\tJavaPlugin.log(e);\n-//\t\t}\n-\t}\n+    @Getter @Setter private double threshold;\n+\n+    protected NamedDirectedMultigraph graph1;\n+\n+    protected NamedDirectedMultigraph graph2;\n+\n+    private double lowerThreshold;\n+\n+    /** Dictionary contains <Original, Version> pairs for the renaming. */\n+    private static Dictionary<String, String> renamingDictionary;\n+\n+    public static Dictionary<String, String> getRenamingDictionary() {\n+        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n+        return renamingDictionary;\n+    }\n+\n+    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        this.graph1 = graph;\n+        this.graph2 = graph2;\n+    }\n+\n+    public abstract double computeLikeliness(Node node1, Node node12);\n+\n+    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+    public abstract boolean isRename();\n+\n+    /**\n+    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n+    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n+    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n+    * computeLikeliness and pruneOriginalCandidates.\n+    */\n+    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\n+        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n+        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+        return pruneFalsePositives(listWithFP);\n+    }\n+\n+    protected String extractPotentialRename(String parentClassOriginal) {\n+        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n+        return renamedName == null ? parentClassOriginal : renamedName;\n+    }\n+\n+    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+        boolean foundNewRefactoring = false;\n+        for (Node[] pair : prunedCandidates) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            double likeliness = computeLikeliness(original, version);\n+            if (likeliness >= threshold) {\n+                if (!refactoredNodes.contains(pair)) {\n+                    refactoredNodes.add(pair);\n+                    foundNewRefactoring = true;\n+                }\n+                // candidates.remove(pair); acivating this line would fail to\n+                // detect those cases when two\n+                // types of refactorings happened to the same node\n+            }\n+        }\n+        if (foundNewRefactoring) {\n+            doDetectRefactorings(candidates, refactoredNodes);\n+        }\n+        return refactoredNodes;\n+    }\n+\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+        for (Node[] pair : listWithFP) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+            if (originalInV2 != null) {\n+                createCallGraph(originalInV2, graph2);\n+                List<Edge> origIncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n+                List<Edge> verIncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+                List<Edge> origInVer1IncomingEdges =\n+                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+\n+                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+                List<Node> verCallers = getCallers(verIncomingEdges);\n+                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+                // since a call site cannot be calling both the old and the new entity at the same time\n+                for (Node node : verCallers) {\n+                    if (origInV2Callers.contains(node))\n+                        if (!nodesToRemove.contains(pair)) {\n+                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+                            nodesToRemove.add(pair);\n+                        }\n+                }\n+\n+                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n+                // pair\n+                // is a false positive (since there should be either no more callers for N1inV2 or their\n+                // call sites\n+                // should be different\n+                for (Node node : origInV1Callers) {\n+                    for (Node callingNode : origInV2Callers) {\n+                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+                            if (!nodesToRemove.contains(pair)) {\n+                                nodesToRemove.add(pair);\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            listWithFP.remove(pair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+\n+        pruneOverloadedMethodFP(listWithFP);\n+\n+        return listWithFP;\n+    }\n+\n+    private List<Node> getCallers(List<Edge> incomingEdges) {\n+        List<Node> callers = new ArrayList<>();\n+        for (Edge edge : incomingEdges) {\n+            callers.add(edge.getSource());\n+        }\n+        return callers;\n+    }\n+\n+    /**\n+    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n+    *\n+    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n+    * because of a method overload.\n+    *\n+    * <p>This method is never called in the ChangeMethodSignature detection.\n+    */\n+    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<>();\n+        for (int i = 0; i < listWithFP.size(); i++) {\n+            boolean hasSameNameAndSignature = false;\n+            Node[] pair = listWithFP.get(i);\n+            Node source = pair[0];\n+            for (int j = i; j < listWithFP.size(); j++) {\n+                Node[] pair2 = listWithFP.get(j);\n+                Node source2 = pair2[0];\n+                if (source.equals(source2)) {\n+                    Node target2 = pair2[1];\n+                    if (source.getSimpleName().equals(target2.getSimpleName()))\n+                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n+                }\n+            }\n+            if (hasSameNameAndSignature) {\n+                for (int j = i; j < listWithFP.size(); j++) {\n+                    Node[] pair2 = listWithFP.get(j);\n+                    Node source2 = pair2[0];\n+                    if (source.equals(source2)) {\n+                        Node target2 = pair2[1];\n+                        if (source.getSimpleName().equals(target2.getSimpleName()))\n+                            if (!signatureEqualsModuloMoveMethod(source, target2))\n+                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+            listWithFP.remove(pair);\n+\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+    }\n+\n+    /**\n+    * This takes into account the possible renaming in the parent of the node\n+    *\n+    * @param g is the Version2 graph\n+    * @param original is a node from Version1\n+    * @return\n+    */\n+    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        String fqnParent = extractFullyQualifiedParentName(original);\n+        String possiblyRenamedFQN = dictionary.get(fqnParent);\n+        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n+        Node parentNode = g.findNamedNode(fqnParent);\n+\n+        if (parentNode != null) {\n+            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n+            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+                Edge edge = (Edge) iter.next();\n+                Node child = (Node) edge.getTarget();\n+                if (original.getSimpleName().equals(child.getSimpleName()))\n+                    if (original.getSignature() != null) {\n+                        // This handles the method nodes\n+                        if (original.getSignature().equals(child.getSignature())) return child;\n+                    } else\n+                        // Classes and packages\n+                        return child;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge edge : list) {\n+            if (label.equals(edge.getLabel())) {\n+                results.add(edge);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected String extractFullyQualifiedParentName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        return extractFullyQualifiedParentName(originalName);\n+    }\n+\n+    public String extractFullyQualifiedParentName(String originalName) {\n+        String fq_parentName = "";\n+        int lastIndex = originalName.lastIndexOf(".");\n+        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n+        return fq_parentName;\n+    }\n+\n+    /**\n+    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+    * IDE.openEditor(IWorkbenchPage, IFile)\n+    */\n+    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+        boolean retval = false;\n+\n+        if (source.getSignature() == null) return false;\n+\n+        retval = source.getSignature().equals(target.getSignature());\n+\n+        if (!retval && (this instanceof MoveMethodDetection)) {\n+            String sourceParent = extractParentSimpleName(source);\n+            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n+            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n+            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+            String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+            for (int i = 0; i < sourceTokens.length; i++) {\n+                sourceTokens[i] = sourceTokenizer.nextToken();\n+            }\n+\n+            for (int i = 0; i < targetTokens.length; i++) {\n+                targetTokens[i] = targetTokenizer.nextToken();\n+            }\n+\n+            if (targetTokens.length == sourceTokens.length + 1) {\n+                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n+                else {\n+                    for (int i = 0; i < sourceTokens.length; i++) {\n+                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n+                    }\n+                    retval = true;\n+                }\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    /**\n+    * This helper method takes a string containing the dot separated name of a node and it returns\n+    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n+    * class1)\n+    */\n+    protected String extractParentSimpleName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n+        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+        return parentName;\n+    }\n+\n+    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+        double count = 0;\n+\n+        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+        for (Edge edge1 : edges1) {\n+            Node node1 = edge1.getSource();\n+            for (int i = 0; i < arrEdge2.length; i++) {\n+                Edge edge2 = arrEdge2[i];\n+                if (edge2 != null) {\n+                    Node node2 = (Node) edge2.getSource();\n+                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n+                        count++;\n+                        // we mark this edge as already counted so that we don\'t\n+                        // count it\n+                        // twice when there are multiple edges between two nodes\n+                        arrEdge2[i] = null;\n+                    }\n+                }\n+            }\n+        }\n+\n+        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+        return (fraction1 + fraction2) / 2.0;\n+    }\n+\n+    protected boolean isTheSameModuloRename(String original, String version) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        if (version.equals(dictionary.get(original))) return true;\n+        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+            return original.equals(version);\n+        else if (original\n+                .substring(original.lastIndexOf("."))\n+                .equals(version.substring(version.lastIndexOf("."))))\n+            return isTheSameModuloRename(\n+                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n+        else return false;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n+\n+                if (pair[0].isAPI() && pair[1].isAPI()) {\n+                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n+\n+                    if ((n2inV1 == null)) {\n+                        prunedCandidates.add(pair);\n+                    }\n+                }\n+            }\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    // TODO this is bug pruned\n+    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+        //\t\ttry {\n+        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+        results.forEach(\n+                result -> {\n+                    if (graph.hasNamedNode(result))\n+                        graph.addEdge(\n+                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+                });\n+        // Possible change to methods that instantiate classes\n+        // from class -> class edges.\n+        //\t\t\tfor (String result : results) {\n+        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+        //\t\t\t\tString callingNode = null;\n+        //\t\t\t\tif (resultNode instanceof IMethod) {\n+        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+        //\t\t\t\t} else if (resultNode instanceof IType) {\n+        //\t\t\t\t\tIType rst = (IType) resultNode;\n+        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t} else if (resultNode instanceof IField) {\n+        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+        //\t\t\t\t\t// Workaround\n+        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += ".";\n+        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n+        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+        // ASTNodes\n+        //\t\t\t\t\t\t.getParent(initializer,\n+        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+        //\t\t\t\t\t\tIType.class);\n+        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+        //\t\t\t\t}\n+        //\n+        //\t\t\t\t// TODO treat the case when resultNode is instance of\n+        //\t\t\t\t// ImportDeclaration\n+        //\t\t\t\t// TODO treat the case when resultNode is instance of\n+        //\t\t\t\t// Initializer\n+        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+        //\t\t\t\t// Level\n+        //\t\t\t\tif (callingNode == null) {\n+        //\t\t\t\t\tSystem.out.print("");\n+        //\t\t\t\t}\n+        //\t\t\t\tif (callingNode != null) {\n+        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+        //\t\t\t\t\tif (callerNode != null)\n+        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+        //\t\t\t\t}\n+        //\n+        //\t\t\t}\n+        //\n+        //\t\t} catch (CoreException e) {\n+        //\t\t\tJavaPlugin.log(e);\n+        //\t\t}\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n    @Getter @Setter private double threshold;\n\n    protected NamedDirectedMultigraph graph1;\n\n    protected NamedDirectedMultigraph graph2;\n\n    private double lowerThreshold;\n\n    /** Dictionary contains <Original, Version> pairs for the renaming. */\n    private static Dictionary<String, String> renamingDictionary;\n\n    public static Dictionary<String, String> getRenamingDictionary() {\n        if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n        return renamingDictionary;\n    }\n\n    public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        this.graph1 = graph;\n        this.graph2 = graph2;\n    }\n\n    public abstract double computeLikeliness(Node node1, Node node12);\n\n    public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n    public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n    public abstract boolean isRename();\n\n    /**\n    * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n    * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n    * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n    * computeLikeliness and pruneOriginalCandidates.\n    */\n    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n        List<Node[]> refactoredNodes = new ArrayList<Node[]>();\n        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n        return pruneFalsePositives(listWithFP);\n    }\n\n    protected String extractPotentialRename(String parentClassOriginal) {\n        String renamedName = getRenamingDictionary().get(parentClassOriginal);\n        return renamedName == null ? parentClassOriginal : renamedName;\n    }\n\n    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n        // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n        boolean foundNewRefactoring = false;\n        for (Node[] pair : prunedCandidates) {\n            Node original = pair[0];\n            Node version = pair[1];\n            double likeliness = computeLikeliness(original, version);\n            if (likeliness >= threshold) {\n                if (!refactoredNodes.contains(pair)) {\n                    refactoredNodes.add(pair);\n                    foundNewRefactoring = true;\n                }\n                // candidates.remove(pair); acivating this line would fail to\n                // detect those cases when two\n                // types of refactorings happened to the same node\n            }\n        }\n        if (foundNewRefactoring) {\n            doDetectRefactorings(candidates, refactoredNodes);\n        }\n        return refactoredNodes;\n    }\n\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n        for (Node[] pair : listWithFP) {\n            Node original = pair[0];\n            Node version = pair[1];\n            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n            if (originalInV2 != null) {\n                createCallGraph(originalInV2, graph2);\n                List<Edge> origIncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n                List<Edge> verIncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n                List<Edge> origInVer1IncomingEdges =\n                        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n                List<Node> verCallers = getCallers(verIncomingEdges);\n                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n                // since a call site cannot be calling both the old and the new entity at the same time\n                for (Node node : verCallers) {\n                    if (origInV2Callers.contains(node))\n                        if (!nodesToRemove.contains(pair)) {\n                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n                            nodesToRemove.add(pair);\n                        }\n                }\n\n                // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n                // pair\n                // is a false positive (since there should be either no more callers for N1inV2 or their\n                // call sites\n                // should be different\n                for (Node node : origInV1Callers) {\n                    for (Node callingNode : origInV2Callers) {\n                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n                            if (!nodesToRemove.contains(pair)) {\n                                nodesToRemove.add(pair);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            listWithFP.remove(pair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n\n        pruneOverloadedMethodFP(listWithFP);\n\n        return listWithFP;\n    }\n\n    private List<Node> getCallers(List<Edge> incomingEdges) {\n        List<Node> callers = new ArrayList<>();\n        for (Edge edge : incomingEdges) {\n            callers.add(edge.getSource());\n        }\n        return callers;\n    }\n\n    /**\n    * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n    *\n    * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n    * because of a method overload.\n    *\n    * <p>This method is never called in the ChangeMethodSignature detection.\n    */\n    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<>();\n        for (int i = 0; i < listWithFP.size(); i++) {\n            boolean hasSameNameAndSignature = false;\n            Node[] pair = listWithFP.get(i);\n            Node source = pair[0];\n            for (int j = i; j < listWithFP.size(); j++) {\n                Node[] pair2 = listWithFP.get(j);\n                Node source2 = pair2[0];\n                if (source.equals(source2)) {\n                    Node target2 = pair2[1];\n                    if (source.getSimpleName().equals(target2.getSimpleName()))\n                        if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n                }\n            }\n            if (hasSameNameAndSignature) {\n                for (int j = i; j < listWithFP.size(); j++) {\n                    Node[] pair2 = listWithFP.get(j);\n                    Node source2 = pair2[0];\n                    if (source.equals(source2)) {\n                        Node target2 = pair2[1];\n                        if (source.getSimpleName().equals(target2.getSimpleName()))\n                            if (!signatureEqualsModuloMoveMethod(source, target2))\n                                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n                    }\n                }\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n            listWithFP.remove(pair);\n\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n    }\n\n    /**\n    * This takes into account the possible renaming in the parent of the node\n    *\n    * @param g is the Version2 graph\n    * @param original is a node from Version1\n    * @return\n    */\n    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        String fqnParent = extractFullyQualifiedParentName(original);\n        String possiblyRenamedFQN = dictionary.get(fqnParent);\n        if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n        Node parentNode = g.findNamedNode(fqnParent);\n\n        if (parentNode != null) {\n            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n            List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n                Edge edge = (Edge) iter.next();\n                Node child = (Node) edge.getTarget();\n                if (original.getSimpleName().equals(child.getSimpleName()))\n                    if (original.getSignature() != null) {\n                        // This handles the method nodes\n                        if (original.getSignature().equals(child.getSignature())) return child;\n                    } else\n                        // Classes and packages\n                        return child;\n            }\n        }\n        return null;\n    }\n\n    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge edge : list) {\n            if (label.equals(edge.getLabel())) {\n                results.add(edge);\n            }\n        }\n        return results;\n    }\n\n    protected String extractFullyQualifiedParentName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        return extractFullyQualifiedParentName(originalName);\n    }\n\n    public String extractFullyQualifiedParentName(String originalName) {\n        String fq_parentName = "";\n        int lastIndex = originalName.lastIndexOf(".");\n        if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n        return fq_parentName;\n    }\n\n    /**\n    * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n    * IDE.openEditor(IWorkbenchPage, IFile)\n    */\n    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n        boolean retval = false;\n\n        if (source.getSignature() == null) return false;\n\n        retval = source.getSignature().equals(target.getSignature());\n\n        if (!retval && (this instanceof MoveMethodDetection)) {\n            String sourceParent = extractParentSimpleName(source);\n            StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n            StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n            String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n            for (int i = 0; i < sourceTokens.length; i++) {\n                sourceTokens[i] = sourceTokenizer.nextToken();\n            }\n\n            for (int i = 0; i < targetTokens.length; i++) {\n                targetTokens[i] = targetTokenizer.nextToken();\n            }\n\n            if (targetTokens.length == sourceTokens.length + 1) {\n                if (!targetTokens[0].trim().equals(sourceParent)) return false;\n                else {\n                    for (int i = 0; i < sourceTokens.length; i++) {\n                        if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n                    }\n                    retval = true;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n    * This helper method takes a string containing the dot separated name of a node and it returns\n    * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n    * class1)\n    */\n    protected String extractParentSimpleName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n        return parentName;\n    }\n\n    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n        double count = 0;\n\n        Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n        for (Edge edge1 : edges1) {\n            Node node1 = edge1.getSource();\n            for (int i = 0; i < arrEdge2.length; i++) {\n                Edge edge2 = arrEdge2[i];\n                if (edge2 != null) {\n                    Node node2 = (Node) edge2.getSource();\n                    if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n                        count++;\n                        // we mark this edge as already counted so that we don\'t\n                        // count it\n                        // twice when there are multiple edges between two nodes\n                        arrEdge2[i] = null;\n                    }\n                }\n            }\n        }\n\n        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n        return (fraction1 + fraction2) / 2.0;\n    }\n\n    protected boolean isTheSameModuloRename(String original, String version) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        if (version.equals(dictionary.get(original))) return true;\n        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n            return original.equals(version);\n        else if (original\n                .substring(original.lastIndexOf("."))\n                .equals(version.substring(version.lastIndexOf("."))))\n            return isTheSameModuloRename(\n                    extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n        else return false;\n    }\n\n    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n                if (pair[0].isAPI() && pair[1].isAPI()) {\n                    Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n                    if ((n2inV1 == null)) {\n                        prunedCandidates.add(pair);\n                    }\n                }\n            }\n        }\n        return prunedCandidates;\n    }\n\n    // TODO this is bug pruned\n    protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n        //\t\ttry {\n        List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n        results.forEach(\n                result -> {\n                    if (graph.hasNamedNode(result))\n                        graph.addEdge(\n                                originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n                });\n        // Possible change to methods that instantiate classes\n        // from class -> class edges.\n        //\t\t\tfor (String result : results) {\n        ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n        //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n        //\t\t\t\tString callingNode = null;\n        //\t\t\t\tif (resultNode instanceof IMethod) {\n        //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n        //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n        //\t\t\t\t} else if (resultNode instanceof IType) {\n        //\t\t\t\t\tIType rst = (IType) resultNode;\n        //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n        //\t\t\t\t} else if (resultNode instanceof IField) {\n        //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n        //\t\t\t\t\t// Workaround\n        //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n        //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += ".";\n        //\t\t\t\t\tcallingNode += rsf1.getElementName();\n        //\t\t\t\t} else if (resultNode instanceof Initializer) {\n        //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n        //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n        // ASTNodes\n        //\t\t\t\t\t\t.getParent(initializer,\n        //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n        //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n        //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n        //\t\t\t\t\t\tIType.class);\n        //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n        //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n        //\t\t\t\t}\n        //\n        //\t\t\t\t// TODO treat the case when resultNode is instance of\n        //\t\t\t\t// ImportDeclaration\n        //\t\t\t\t// TODO treat the case when resultNode is instance of\n        //\t\t\t\t// Initializer\n        //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n        //\t\t\t\t// Level\n        //\t\t\t\tif (callingNode == null) {\n        //\t\t\t\t\tSystem.out.print("");\n        //\t\t\t\t}\n        //\t\t\t\tif (callingNode != null) {\n        //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n        //\t\t\t\t\tif (callerNode != null)\n        //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n        //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n        //\t\t\t\t}\n        //\n        //\t\t\t}\n        //\n        //\t\t} catch (CoreException e) {\n        //\t\t\tJavaPlugin.log(e);\n        //\t\t}\n    }\n}\n'
          },
          {
            sha: "953bfe0eb3583b4f5968a25ed810ba4f5c388a46",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 45,
            deletions: 35,
            patch:
              "@@ -1,45 +1,55 @@\n package refactoring.crawler.detection;\n \n-import com.github.javaparser.ast.body.MethodDeclaration;\n-import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n-import lombok.Getter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import refactoring.crawler.util.*;\n-\n import java.util.*;\n import java.util.stream.Collectors;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.FieldNode;\n+import refactoring.crawler.graph.MethodNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n \n public class SearchHelper {\n-\tpublic static List<String> findFieldReferences(FieldNode node) {\n-\t\treturn node.getFieldReferenceToMethod();\n-\t}\n-\n-\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n-\t\treturn node.getSuperClasses();\n-\t}\n+    public static List<String> findFieldReferences(FieldNode node) {\n+        return node.getFieldReferenceToMethod();\n+    }\n \n-\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n-\t\treturn node.getClassesImported();\n-\t}\n+    public static List<String> findSuperClassesOf(ClassNode node) {\n+        return node.getSuperClasses();\n+    }\n \n-\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n-\t\treturn graph.vertexSet()\n-\t\t\t.stream()\n-\t\t\t.filter(n -> (n instanceof MethodNode))\n-\t\t\t.map(methodNode -> (MethodNode) methodNode)\n-\t\t\t.filter(methodNode ->\n-\t\t\t\tmethodNode.getCalledInside()\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.anyMatch(calledMethod -> {\n-\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n-\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n-\t\t\t\t\t\treturn expect.equals(actual);\n-\t\t\t\t\t})\n-\t\t\t)\n-\t\t\t.map(methodNode -> {\n-\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n-\t\t\t})\n-\t\t\t.collect(Collectors.toList());\n-\t}\n+    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+        return node.getClassesImported();\n+    }\n \n+    public static List<String> findMethodCallers(\n+            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+        return graph\n+                .vertexSet()\n+                .stream()\n+                .filter(n -> (n instanceof MethodNode))\n+                .map(methodNode -> (MethodNode) methodNode)\n+                .filter(\n+                        methodNode ->\n+                                methodNode\n+                                        .getCalledInside()\n+                                        .stream()\n+                                        .anyMatch(\n+                                                calledMethod -> {\n+                                                    String expect =\n+                                                            withSignature\n+                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n+                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n+                                                    String actual =\n+                                                            withSignature\n+                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n+                                                                    : node.getFullyQualifiedName();\n+                                                    return expect.equals(actual);\n+                                                }))\n+                .map(\n+                        methodNode -> {\n+                            return withSignature\n+                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n+                                    : methodNode.getFullyQualifiedName();\n+                        })\n+                .collect(Collectors.toList());\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\n\npublic class SearchHelper {\n    public static List<String> findFieldReferences(FieldNode node) {\n        return node.getFieldReferenceToMethod();\n    }\n\n    public static List<String> findSuperClassesOf(ClassNode node) {\n        return node.getSuperClasses();\n    }\n\n    public static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n        return node.getClassesImported();\n    }\n\n    public static List<String> findMethodCallers(\n            NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n        return graph\n                .vertexSet()\n                .stream()\n                .filter(n -> (n instanceof MethodNode))\n                .map(methodNode -> (MethodNode) methodNode)\n                .filter(\n                        methodNode ->\n                                methodNode\n                                        .getCalledInside()\n                                        .stream()\n                                        .anyMatch(\n                                                calledMethod -> {\n                                                    String expect =\n                                                            withSignature\n                                                                    ? calledMethod.getFullyQualifiedNameWithSignature()\n                                                                    : calledMethod.getFullyQualifiedNameWithoutSignature();\n                                                    String actual =\n                                                            withSignature\n                                                                    ? node.getFullyQualifiedName() + node.getSignature()\n                                                                    : node.getFullyQualifiedName();\n                                                    return expect.equals(actual);\n                                                }))\n                .map(\n                        methodNode -> {\n                            return withSignature\n                                    ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                                    : methodNode.getFullyQualifiedName();\n                        })\n                .collect(Collectors.toList());\n    }\n}\n"
          },
          {
            sha: "525b7bf00b391ded7649ebbd22f97ae650637125",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "modified",
            additions: 62,
            deletions: 68,
            patch:
              "@@ -1,83 +1,77 @@\n package refactoring.crawler.detection.classDetection;\n \n-import org.eclipse.jdt.core.IType;\n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.ClassNode;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.ClassNode;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class ClassDetection extends RefactoringDetection {\n \n-\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n+    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn false;\n-\t}\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n \n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n \n-\t/**\n-\t * We need to find all the places that the original and version classes are\n-\t * instantiated. We will incorporate this into the likeliness grade.\n-\t */\n-\tprotected void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateCallGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateCallGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n+    @Override\n+    public boolean isRename() {\n+        // TODO Auto-generated method stub\n+        return false;\n+    }\n \n-\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tcreateClassReferenceGraph(node, graph);\n-\t\tnode.setCreatedCallGraph();\n-\t}\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n \n-\t/**\n-\t * Accepts two class nodes, and determines if first parameter is a\n-\t * superclass of the second parameter.\n-\t */\n-\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n-\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n-\t\tfor (String superClass : superClasses) {\n-\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n-\t\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-//\t\treturn false;\n-\t}\n+    /**\n+    * We need to find all the places that the original and version classes are instantiated. We will\n+    * incorporate this into the likeliness grade.\n+    */\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n \n+    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        createClassReferenceGraph(node, graph);\n+        node.setCreatedCallGraph();\n+    }\n \n+    /**\n+    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n+    * parameter.\n+    */\n+    public static boolean isSuperClassOf(Node node1, Node node2) {\n+        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+        for (String superClass : superClasses) {\n+            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n+        }\n+        return false;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n    public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isRename() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n    * We need to find all the places that the original and version classes are instantiated. We will\n    * incorporate this into the likeliness grade.\n    */\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        createClassReferenceGraph(node, graph);\n        node.setCreatedCallGraph();\n    }\n\n    /**\n    * Accepts two class nodes, and determines if first parameter is a superclass of the second\n    * parameter.\n    */\n    public static boolean isSuperClassOf(Node node1, Node node2) {\n        List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n        for (String superClass : superClasses) {\n            if (superClass.equals(node1.getFullyQualifiedName())) return true;\n        }\n        return false;\n    }\n}\n"
          },
          {
            sha: "a724f9169daef3acd6b63a8cd61d0f14525a5554",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "modified",
            additions: 34,
            deletions: 35,
            patch:
              "@@ -1,47 +1,46 @@\n package refactoring.crawler.detection.classDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class MoveClassDetection extends ClassDetection {\n \n-\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n+    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n+    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+        double edgeGrade;\n+        createCallGraph(nodeOriginal, nodeVersion);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return edgeGrade;\n+    }\n \n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedClasses) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n-\t\t\t\tparentPackageVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesInDifferentPackages.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesInDifferentPackages;\n-\t}\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+        for (Node[] pair : prePrunedClasses) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n+            String parentPackageVersion = extractFullyQualifiedParentName(version);\n+            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesInDifferentPackages.add(pair);\n+            }\n+        }\n+        return candidatesInDifferentPackages;\n+    }\n \n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+    public boolean isRename() {\n+        return false;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n    public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n        double edgeGrade;\n        createCallGraph(nodeOriginal, nodeVersion);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return edgeGrade;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n        for (Node[] pair : prePrunedClasses) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentPackageOriginal = extractFullyQualifiedParentName(original);\n            String parentPackageVersion = extractFullyQualifiedParentName(version);\n            if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesInDifferentPackages.add(pair);\n            }\n        }\n        return candidatesInDifferentPackages;\n    }\n\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "ee75e84569114b0c345231f5f203cb53f3dd8b06",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "modified",
            additions: 51,
            deletions: 52,
            patch:
              "@@ -1,60 +1,59 @@\n package refactoring.crawler.detection.classDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class RenameClassDetection extends ClassDetection {\n \n-\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n-\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n-\t}\n-\n-\t/**\n-\t * Calls createCallGraph in ClassDetection\n-\t * Calls filterNamedEdges in ClassDetection\n-\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n-\t *\n-\t * @param nodeOriginal\n-\t * @param nodeVersion\n-\t * @return\n-\t */\n-\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n-\t\tdouble edgeGrade;\n-\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n-\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn edgeGrade;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n-\t\tfor (Node[] pair : prePruned) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n-\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n-\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentPackage;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+        super(graph1, graph2);\n+    }\n+\n+    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n+    }\n+\n+    /**\n+    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n+    * computeLikelinessIncomingEdges in RefactoringDetection\n+    *\n+    * @param nodeOriginal\n+    * @param nodeVersion\n+    * @return\n+    */\n+    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+        double edgeGrade;\n+        createCallGraph(nodeOriginal, nodeVersion);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return edgeGrade;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+        for (Node[] pair : prePruned) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentPackageOriginal = extractParentSimpleName(original);\n+            String parentPackageVersion = extractParentSimpleName(version);\n+            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithSameParentPackage.add(pair);\n+            }\n+        }\n+\n+        return candidatesWithSameParentPackage;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return true;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n    public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n        super(graph1, graph2);\n    }\n\n    public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n        return doEdgeAnalysis(nodeOriginal, nodeVersion);\n    }\n\n    /**\n    * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n    * computeLikelinessIncomingEdges in RefactoringDetection\n    *\n    * @param nodeOriginal\n    * @param nodeVersion\n    * @return\n    */\n    private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n        double edgeGrade;\n        createCallGraph(nodeOriginal, nodeVersion);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n        edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return edgeGrade;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n        for (Node[] pair : prePruned) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentPackageOriginal = extractParentSimpleName(original);\n            String parentPackageVersion = extractParentSimpleName(version);\n            if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n                    && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithSameParentPackage.add(pair);\n            }\n        }\n\n        return candidatesWithSameParentPackage;\n    }\n\n    @Override\n    public boolean isRename() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "e7bddc9a625cdf0f9c28c95c1a7a66f5c0d33caa",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "modified",
            additions: 92,
            deletions: 111,
            patch:
              "@@ -1,119 +1,100 @@\n package refactoring.crawler.detection.fieldDetection;\n \n-import org.eclipse.core.runtime.CoreException;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.eclipse.core.runtime.NullProgressMonitor;\n-import org.eclipse.jdt.core.IMember;\n-import org.eclipse.jdt.core.IMethod;\n-import org.eclipse.jdt.core.dom.Initializer;\n-import org.eclipse.jdt.core.dom.SimpleName;\n-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n-import refactoring.crawler.RefactoringCrawler;\n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.FieldNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.FieldNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class FieldDetection extends RefactoringDetection {\n \n-\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t/*\n-\t * (non-Javadoc)\n-\t *\n-\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n-\t */\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n-\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n-\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n-\n-\t\tfor (String result : results) {\n-//\t\t\t\tIMember resultNode = (IMember) result;\n-//\t\t\t\tString callingNode = null;\n-//\t\t\t\tif (resultNode instanceof IMethod) {\n-//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n-//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n-//\t\t\t\t} else if (resultNode instanceof Initializer) {\n-//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n-//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n-//\t\t\t\t\t\t.getParent(initializer,\n-//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n-//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n-//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n-//\t\t\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n-//\t\t\t\t}\n-\n-\t\t\tNode callerNode = graph.findNamedNode(result);\n-\t\t\tif (callerNode != null)\n-\t\t\t\tgraph.addEdge(callerNode, originalNode,\n-\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n-\t\t}\n-\n-\t}\n-\n-\tpublic void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateFieldReferenceGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateFieldReferenceGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n-\n-\tpublic double analyzeIncomingEdges(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade;\n-\t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t.incomingEdgesOf(version)));\n-\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn incomingEdgesGrade;\n-\t}\n+    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n+\n+    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+\n+        for (String result : results) {\n+            //\t\t\t\tIMember resultNode = (IMember) result;\n+            //\t\t\t\tString callingNode = null;\n+            //\t\t\t\tif (resultNode instanceof IMethod) {\n+            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n+            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n+            // ASTNodes\n+            //\t\t\t\t\t\t.getParent(initializer,\n+            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n+            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+            //\t\t\t\t}\n+\n+            Node callerNode = graph.findNamedNode(result);\n+            if (callerNode != null)\n+                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n+        }\n+    }\n+\n+    public void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createFieldReferenceGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createFieldReferenceGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n+\n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n+        incomingEdgesGrade =\n+                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n    public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n\n    protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n        final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n        for (String result : results) {\n            //\t\t\t\tIMember resultNode = (IMember) result;\n            //\t\t\t\tString callingNode = null;\n            //\t\t\t\tif (resultNode instanceof IMethod) {\n            //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n            //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n            //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n            //\t\t\t\t} else if (resultNode instanceof Initializer) {\n            //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n            //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n            // ASTNodes\n            //\t\t\t\t\t\t.getParent(initializer,\n            //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n            //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n            //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n            //\t\t\t\t\t\t.getFullyQualifiedName('.');\n            //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n            //\t\t\t\t}\n\n            Node callerNode = graph.findNamedNode(result);\n            if (callerNode != null)\n                graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n        }\n    }\n\n    public void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createFieldReferenceGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createFieldReferenceGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        incomingEdgesGrade =\n                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "6c56650a6c570fd11124d662aea0f53fbe80386b",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "modified",
            additions: 32,
            deletions: 37,
            patch:
              "@@ -1,45 +1,40 @@\n package refactoring.crawler.detection.fieldDetection;\n \n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class MoveFieldDetection extends FieldDetection {\n \n-\t/*\n-\t * We already have Class - Field edges. So we need to make sure that they\n-\t * are different parents, and also make sure that their call graph is still\n-\t * the same.\n-\t */\n-\n-\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\treturn analyzeIncomingEdges(original, version);\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedFields) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n-\t\t\t\tparentClassVersion);\n-\n-\t\t\tif (!isModRen\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n+    /*\n+    * We already have Class - Field edges. So we need to make sure that they\n+    * are different parents, and also make sure that their call graph is still\n+    * the same.\n+    */\n+\n+    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        return analyzeIncomingEdges(original, version);\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedFields) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n+\n+            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+        return candidatesWithDifferentParentClass;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n    /*\n    * We already have Class - Field edges. So we need to make sure that they\n    * are different parents, and also make sure that their call graph is still\n    * the same.\n    */\n\n    public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        return analyzeIncomingEdges(original, version);\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedFields) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n            if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n        return candidatesWithDifferentParentClass;\n    }\n}\n"
          },
          {
            sha: "e4def2fd22214c6837b2678229bc8813a5d71701",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 122,
            deletions: 137,
            patch:
              '@@ -1,144 +1,129 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.*;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n \n-\t/**\n-\t * @param graph\n-\t * @param graph2\n-\t */\n-\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t/**\n-\t * We need to go from the node to the AST and get the actual method. Then we\n-\t * will call getSignature() on the IMethod to get the signature. We have to\n-\t * make sure the call graphs are checked, since we do not want to detect\n-\t * polymorphism as change method signature.\n-\t */\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\t// Need to find out if in V2 there is a node with the same signature\n-\t\t// as the original\n-\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n-\t\t\treturn 1.0;\n-\t\telse {\n-\t\t\t// This is when we have a method overload or deprecated. So when\n-\t\t\t// we can check deprecated methods we need to add it here\n-\t\t\treturn analyzeIncomingEdges(original, version);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will handle the same name condition, explained above.\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n-\n-\t\t\tif (hasSameNameAndSignature)\n-\t\t\t\tcontinue;\n-\n-\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n-\t\t\t\t.getFullyQualifiedName()))\n-\t\t\t\tprunedCandidates.add(pair);\n-\t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n-\t\t// TODO here we have to take into account the RenamigsDictionary\n-\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n-\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n-\n-\t\tboolean hasSameNameAndSignature = false;\n-\n-\t\tif (n2ParentInV1 != null) {\n-\t\t\t// Calling the overloaded method\n-\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n-\t\t\tfor (Edge methodEdge : allMethodEdges) {\n-\t\t\t\tNode targetMethod = methodEdge.getTarget();\n-\t\t\t\tif (targetMethod.getSimpleName()\n-\t\t\t\t\t.equals(pair[1].getSimpleName())\n-\t\t\t\t\t&& targetMethod.getSignature().equals(\n-\t\t\t\t\tpair[1].getSignature()))\n-\t\t\t\t\thasSameNameAndSignature = true;\n-\t\t\t}\n-\t\t}\n-\t\treturn hasSameNameAndSignature;\n-\t}\n-\n-\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n-\t\tNode source = pair[0];\n-\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n-\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n-\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n-\t\tboolean isDeprecated = false;\n-\t\tboolean isRemoved = true;\n-\t\tif (parentOfOriginalInV2 != null) {\n-\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n-\t\t\tfor (Edge edge : methodEdges) {\n-\t\t\t\tNode methodNode = edge.getTarget();\n-\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n-\t\t\t\t\t&& methodNode.getSignature().equals(\n-\t\t\t\t\tsource.getSignature())) {\n-\t\t\t\t\tisRemoved = false;\n-\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn isDeprecated || isRemoved;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n-\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n-\n-\t\tfor (Node[] pair : listWithFP) {\n-\t\t\tString signatureN1 = pair[0].getSignature();\n-\t\t\tString signatureN2 = pair[1].getSignature();\n-\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n-\t\t\t\tgoodResults.add(pair);\n-\t\t}\n-\t\treturn goodResults;\n-\t}\n-\n-\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n-\t\t// TODO filters out (IPluginDescriptor) with\n-\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n-\t\t// right now this is checked only for case when there is a one argument\n-\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n-\t\t\tsignatureN1.length() - 1));\n-\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n-\t\t\tsignatureN2.length() - 1));\n-\t\treturn simpleName1.equals(simpleName2);\n-\t}\n-\n-\tprivate String extractSimpleName(String fqn) {\n-\t\tint lastIndex = fqn.lastIndexOf(".");\n-\t\tif (lastIndex < 0)\n-\t\t\treturn fqn;\n-\t\telse\n-\t\t\treturn fqn.substring(lastIndex + 1);\n-\t}\n-\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n+    /**\n+    * @param graph\n+    * @param graph2\n+    */\n+    public ChangeMethodSignatureDetection(\n+            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    /**\n+    * We need to go from the node to the AST and get the actual method. Then we will call\n+    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n+    * checked, since we do not want to detect polymorphism as change method signature.\n+    */\n+    public double computeLikeliness(Node original, Node version) {\n+        // Need to find out if in V2 there is a node with the same signature\n+        // as the original\n+        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n+        else {\n+            // This is when we have a method overload or deprecated. So when\n+            // we can check deprecated methods we need to add it here\n+            return analyzeIncomingEdges(original, version);\n+        }\n+    }\n+\n+    /** This will handle the same name condition, explained above. */\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n+\n+            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n+\n+            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+\n+            if (hasSameNameAndSignature) continue;\n+\n+            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n+                prunedCandidates.add(pair);\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    private boolean hasTheSameSignatureAndName(Node[] pair) {\n+        // TODO here we have to take into account the RenamigsDictionary\n+        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+        boolean hasSameNameAndSignature = false;\n+\n+        if (n2ParentInV1 != null) {\n+            // Calling the overloaded method\n+            List<Edge> allMethodEdges =\n+                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+            for (Edge methodEdge : allMethodEdges) {\n+                Node targetMethod = methodEdge.getTarget();\n+                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n+                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n+                    hasSameNameAndSignature = true;\n+            }\n+        }\n+        return hasSameNameAndSignature;\n+    }\n+\n+    private boolean isDeprecatedOrRemoved(Node[] pair) {\n+        Node source = pair[0];\n+        String parentOfOriginal = extractFullyQualifiedParentName(source);\n+        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n+        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+        boolean isDeprecated = false;\n+        boolean isRemoved = true;\n+        if (parentOfOriginalInV2 != null) {\n+            List<Edge> methodEdges =\n+                    filterNamedEdges(\n+                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+            for (Edge edge : methodEdges) {\n+                Node methodNode = edge.getTarget();\n+                if (methodNode.getSimpleName().equals(source.getSimpleName())\n+                        && methodNode.getSignature().equals(source.getSignature())) {\n+                    isRemoved = false;\n+                    isDeprecated = methodNode.isDeprecated();\n+                }\n+            }\n+        }\n+\n+        return isDeprecated || isRemoved;\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+        List<Node[]> goodResults = new ArrayList<Node[]>();\n+\n+        for (Node[] pair : listWithFP) {\n+            String signatureN1 = pair[0].getSignature();\n+            String signatureN2 = pair[1].getSignature();\n+            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n+        }\n+        return goodResults;\n+    }\n+\n+    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+        // TODO filters out (IPluginDescriptor) with\n+        // (org.eclipse.core.runtime.IPluginDescriptor)\n+        // right now this is checked only for case when there is a one argument\n+        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n+        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n+        return simpleName1.equals(simpleName2);\n+    }\n+\n+    private String extractSimpleName(String fqn) {\n+        int lastIndex = fqn.lastIndexOf(".");\n+        if (lastIndex < 0) return fqn;\n+        else return fqn.substring(lastIndex + 1);\n+    }\n+\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n    /**\n    * @param graph\n    * @param graph2\n    */\n    public ChangeMethodSignatureDetection(\n            NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    /**\n    * We need to go from the node to the AST and get the actual method. Then we will call\n    * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n    * checked, since we do not want to detect polymorphism as change method signature.\n    */\n    public double computeLikeliness(Node original, Node version) {\n        // Need to find out if in V2 there is a node with the same signature\n        // as the original\n        if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n        else {\n            // This is when we have a method overload or deprecated. So when\n            // we can check deprecated methods we need to add it here\n            return analyzeIncomingEdges(original, version);\n        }\n    }\n\n    /** This will handle the same name condition, explained above. */\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n            if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n            boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n            if (hasSameNameAndSignature) continue;\n\n            if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n                prunedCandidates.add(pair);\n        }\n        return prunedCandidates;\n    }\n\n    private boolean hasTheSameSignatureAndName(Node[] pair) {\n        // TODO here we have to take into account the RenamigsDictionary\n        String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n        Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n        boolean hasSameNameAndSignature = false;\n\n        if (n2ParentInV1 != null) {\n            // Calling the overloaded method\n            List<Edge> allMethodEdges =\n                    filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n            for (Edge methodEdge : allMethodEdges) {\n                Node targetMethod = methodEdge.getTarget();\n                if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n                        && targetMethod.getSignature().equals(pair[1].getSignature()))\n                    hasSameNameAndSignature = true;\n            }\n        }\n        return hasSameNameAndSignature;\n    }\n\n    private boolean isDeprecatedOrRemoved(Node[] pair) {\n        Node source = pair[0];\n        String parentOfOriginal = extractFullyQualifiedParentName(source);\n        parentOfOriginal = extractPotentialRename(parentOfOriginal);\n        Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n        boolean isDeprecated = false;\n        boolean isRemoved = true;\n        if (parentOfOriginalInV2 != null) {\n            List<Edge> methodEdges =\n                    filterNamedEdges(\n                            new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n            for (Edge edge : methodEdges) {\n                Node methodNode = edge.getTarget();\n                if (methodNode.getSimpleName().equals(source.getSimpleName())\n                        && methodNode.getSignature().equals(source.getSignature())) {\n                    isRemoved = false;\n                    isDeprecated = methodNode.isDeprecated();\n                }\n            }\n        }\n\n        return isDeprecated || isRemoved;\n    }\n\n    @Override\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n        List<Node[]> goodResults = new ArrayList<Node[]>();\n\n        for (Node[] pair : listWithFP) {\n            String signatureN1 = pair[0].getSignature();\n            String signatureN2 = pair[1].getSignature();\n            if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n        }\n        return goodResults;\n    }\n\n    private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n        // TODO filters out (IPluginDescriptor) with\n        // (org.eclipse.core.runtime.IPluginDescriptor)\n        // right now this is checked only for case when there is a one argument\n        String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n        String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n        return simpleName1.equals(simpleName2);\n    }\n\n    private String extractSimpleName(String fqn) {\n        int lastIndex = fqn.lastIndexOf(".");\n        if (lastIndex < 0) return fqn;\n        else return fqn.substring(lastIndex + 1);\n    }\n\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "22d6567d6477384c180746c8c4fc18abb6096366",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "modified",
            additions: 67,
            deletions: 69,
            patch:
              "@@ -1,84 +1,82 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.MethodNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.MethodNode;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node node1, Node node12) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn null;\n-\t}\n+    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\t// TODO Auto-generated method stub\n-\t\treturn false;\n-\t}\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n \n-\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n-\t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge value : list) {\n-\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n-\t\t\t\tresults.add(value);\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n \n-\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tList<String> callers;\n-\t\tif (this instanceof ChangeMethodSignatureDetection)\n-\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n-\t\telse\n-\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n-\t\tfor (String s : callers) {\n-\t\t\tNode callerNode = graph.findNamedNode(s);\n-\t\t\tif (callerNode != null) {\n-\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n-\t\t\t}\n-\t\t}\n-\t\tnode.setCreatedCallGraph();\n+    @Override\n+    public boolean isRename() {\n+        // TODO Auto-generated method stub\n+        return false;\n+    }\n \n-\t}\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge value : list) {\n+            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+                results.add(value);\n+            }\n+        }\n+        return results;\n+    }\n \n-\tprotected void createCallGraph(Node original, Node version) {\n-\t\tif (!original.hasCallGraph()) {\n-\t\t\tcreateCallGraph(original, graph1);\n-\t\t\toriginal.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!version.hasCallGraph()) {\n-\t\t\tcreateCallGraph(version, graph2);\n-\t\t\tversion.setCreatedCallGraph();\n-\t\t}\n-\t}\n+    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        List<String> callers;\n+        if (this instanceof ChangeMethodSignatureDetection)\n+            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+        for (String s : callers) {\n+            Node callerNode = graph.findNamedNode(s);\n+            if (callerNode != null) {\n+                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+            }\n+        }\n+        node.setCreatedCallGraph();\n+    }\n \n-\tpublic double analyzeIncomingEdges(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade;\n-\t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n-\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn incomingEdgesGrade;\n-\t}\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n \n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        List<Edge> incomingEdgesOriginal =\n+                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+        List<Edge> incomingEdgesVersion =\n+                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+        incomingEdgesGrade =\n+                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n    public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isRename() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge value : list) {\n            if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n                results.add(value);\n            }\n        }\n        return results;\n    }\n\n    public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        List<String> callers;\n        if (this instanceof ChangeMethodSignatureDetection)\n            callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n        else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n        for (String s : callers) {\n            Node callerNode = graph.findNamedNode(s);\n            if (callerNode != null) {\n                graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n            }\n        }\n        node.setCreatedCallGraph();\n    }\n\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        List<Edge> incomingEdgesOriginal =\n                filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n        List<Edge> incomingEdgesVersion =\n                filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n        incomingEdgesGrade =\n                computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "e6ad69dba3d9b0400b7a54a0212510b747b388c5",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "modified",
            additions: 207,
            deletions: 232,
            patch:
              '@@ -1,241 +1,216 @@\n package refactoring.crawler.detection.methodDetection;\n \n+import java.util.*;\n import refactoring.crawler.RefactoringCrawler;\n import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n import refactoring.crawler.util.RefactoringCategory;\n \n-import java.util.*;\n-\n public class MoveMethodDetection extends MethodDetection {\n \n-\tprivate Node targetClassInVerGraph;\n-\n-\tprivate Node targetClassInOrigGraph;\n-\n-\tprivate RefactoringCrawler crawler;\n-\n-\t/**\n-\t * Checks for MoveMethod\n-\t * <p>\n-\t * 1. Check that from the old method, all the references to objects having\n-\t * the same type as the destination class were removed\n-\t * <p>\n-\t * 2. Check that the new target class is either a previous argument or a\n-\t * field in the old class\n-\t */\n-\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph1, graph2);\n-\t\tthis.crawler = crawler;\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tdouble edgeGrade = 0.0;\n-\n-\t\tdouble referenceGrade = 0.0;\n-\n-\t\tif (isTargetARenameOfSourceClass(original, version))\n-\t\t\treturn 0.0;\n-\n-\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n-\t\treferenceGrade = referencesRemoved(original, version);\n-\t\tedgeGrade = analyzeIncomingEdges(original, version);\n-\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n-\t}\n-\n-\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n-\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n-\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n-\t\t// treat case 1\n-\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n-\t}\n-\n-\t/**\n-\t * 1. Check that from the old method, all the references to objects having\n-\t * the same type as the destination class were removed\n-\t */\n-\tprivate double referencesRemoved(Node original, Node version) {\n-\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n-\n-\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n-\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n-\t\t// treat case 2\n-\t\tif (targetClassInOrigGraph == null) {\n-\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\tEnumeration<String> keys = dictionary.keys();\n-\t\t\tfor (; keys.hasMoreElements(); ) {\n-\t\t\t\tString aKey = keys.nextElement();\n-\t\t\t\tString aValue = dictionary.get(aKey);\n-\t\t\t\tif (targetInVersion.equals(aValue)) {\n-\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// treat case 3\n-\t\t\tif (targetClassInOrigGraph == null)\n-\t\t\t\treturn 1.0;\n-\n-\t\t}\n-\n-\t\t// treat case 2 and 4\n-\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n-\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n-\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n-\t\t}\n-\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n-\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n-\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n-\t\t}\n-\n-\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n-\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n-\t\t\ttargetClassInVerGraph));\n-\t\tif (originalClassReferences.size() == 0) {\n-\t\t\tif (original.isStatic())\n-\t\t\t\treturn 1.0;\n-\t\t\tif (isTargetClassAFieldInSourceClass(original,\n-\t\t\t\ttargetClassInOrigGraph))\n-\t\t\t\treturn 1.0;\n-\t\t\tif (versionClassReferences.size() == 0)\n-\t\t\t\treturn 1.0;\n-\t\t\treturn 0.0;\n-\t\t} else\n-\t\t\treturn Math\n-\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n-\t\t\t\t\t.size()) / originalClassReferences.size()));\n-\t}\n-\n-\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n-\t\tNode parentClass = graph1\n-\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n-\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n-\t\tList<Node> fields = new ArrayList<Node>();\n-\t\tfor (Edge value : edges) {\n-\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n-\t\t\t\tfields.add((Node) value.getTarget());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn fields.contains(theTargetClassInOrigGraph);\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\n-\t\t\t// Prune toString since the SearchEngine finds all the toString()\n-\t\t\t// methods, even those that are called from different classes\n-\t\t\tif ("toString".equals(original.getSimpleName()))\n-\t\t\t\tcontinue;\n-\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Overriden here to prune false positives due to overlapping PullUp and\n-\t * PushDown detection\n-\t */\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n-\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n-\t\treturn withoutFP;\n-\t}\n-\n-\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n-\t\tboolean needsOneMorePass = false;\n-\t\tList<Node[]> addToPUM = new ArrayList<>();\n-\t\tList<Node[]> addToPDM = new ArrayList<>();\n-\t\tfor (Node[] pair : withoutFP) {\n-\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n-\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n-\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n-\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n-\t\t\tif (sourceClass != null && destinationClass != null) {\n-\t\t\t\tif (ClassDetection\n-\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n-\t\t\t\t\taddToPDM.add(pair);\n-\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n-\t\t\t\t\tsourceClass))\n-\t\t\t\t\taddToPUM.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\n-\t\tRefactoringCategory pulledUpCategory = null;\n-\t\tRefactoringCategory pushedDownCategory = null;\n-\t\t// TODO this only checks whether we already have such a category\n-\t\t// created. It might be\n-\t\t// that such a category has not been created previously (because no\n-\t\t// results were found\n-\t\t// for that category. In this case, will need to create a brand new\n-\t\t// Category object.\n-\t\tfor (RefactoringCategory category : refactoringsList) {\n-\t\t\tif (category.getName().equals("PulledUpMethods"))\n-\t\t\t\tpulledUpCategory = category;\n-\n-\t\t\telse if (category.getName().equals("PushedDownMethods"))\n-\t\t\t\tpushedDownCategory = category;\n-\t\t}\n-\n-\t\tfor (Node[] pair : addToPDM) {\n-\t\t\tif (pushedDownCategory != null)\n-\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n-\t\t\twithoutFP.remove(pair);\n-\t\t\tneedsOneMorePass = true;\n-\t\t}\n-\n-\t\tfor (Node[] pair : addToPUM) {\n-\t\t\tif (pulledUpCategory != null)\n-\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n-\t\t\twithoutFP.remove(pair);\n-\t\t\tneedsOneMorePass = true;\n-\t\t}\n-\t\tif (needsOneMorePass)\n-\t\t\treturn pruneFalsePositives(withoutFP);\n-\t\telse return withoutFP;\n-\t}\n-\n-\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n-\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n-\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n-\t\tfor (RefactoringCategory category : refactoringsList) {\n-\t\t\tif (category.getName().equals("PulledUpMethods")\n-\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n-\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n-\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n-\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n-\t\t\t\t\t\t// overlappings\n-\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n-\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n-\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n-\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (Node[] pair : pairsToRemove) {\n-\t\t\tprunedList.remove(pair);\n-\t\t}\n-\t\treturn prunedList;\n-\t}\n+    private Node targetClassInVerGraph;\n+\n+    private Node targetClassInOrigGraph;\n+\n+    private RefactoringCrawler crawler;\n+\n+    /**\n+    * Checks for MoveMethod\n+    *\n+    * <p>1. Check that from the old method, all the references to objects having the same type as the\n+    * destination class were removed\n+    *\n+    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n+    */\n+    public MoveMethodDetection(\n+            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+        super(graph1, graph2);\n+        this.crawler = crawler;\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        double edgeGrade = 0.0;\n+\n+        double referenceGrade = 0.0;\n+\n+        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n+\n+        // FIXME: Potential problem when we subtract 0.01 from reference grade\n+        referenceGrade = referencesRemoved(original, version);\n+        edgeGrade = analyzeIncomingEdges(original, version);\n+        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+    }\n+\n+    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+        String sourceInOriginal = extractFullyQualifiedParentName(original);\n+        String targetInVersion = extractFullyQualifiedParentName(version);\n+        // treat case 1\n+        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+    }\n+\n+    /**\n+    * 1. Check that from the old method, all the references to objects having the same type as the\n+    * destination class were removed\n+    */\n+    private double referencesRemoved(Node original, Node version) {\n+        String targetInVersion = extractFullyQualifiedParentName(version);\n+\n+        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+        // treat case 2\n+        if (targetClassInOrigGraph == null) {\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            Enumeration<String> keys = dictionary.keys();\n+            for (; keys.hasMoreElements(); ) {\n+                String aKey = keys.nextElement();\n+                String aValue = dictionary.get(aKey);\n+                if (targetInVersion.equals(aValue)) {\n+                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n+                }\n+            }\n+\n+            // treat case 3\n+            if (targetClassInOrigGraph == null) return 1.0;\n+        }\n+\n+        // treat case 2 and 4\n+        if (!targetClassInVerGraph.hasCallGraph()) {\n+            createClassReferenceGraph(targetClassInVerGraph, graph2);\n+            targetClassInVerGraph.setCreatedCallGraph();\n+        }\n+        if (!targetClassInOrigGraph.hasCallGraph()) {\n+            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n+            targetClassInOrigGraph.setCreatedCallGraph();\n+        }\n+\n+        List<Edge> originalClassReferences =\n+                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+        List<Edge> versionClassReferences =\n+                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n+        if (originalClassReferences.size() == 0) {\n+            if (original.isStatic()) return 1.0;\n+            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n+            if (versionClassReferences.size() == 0) return 1.0;\n+            return 0.0;\n+        } else\n+            return Math.abs(\n+                    ((originalClassReferences.size() - versionClassReferences.size())\n+                            / originalClassReferences.size()));\n+    }\n+\n+    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n+        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+        List<Node> fields = new ArrayList<Node>();\n+        for (Edge value : edges) {\n+            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+                fields.add((Node) value.getTarget());\n+            }\n+        }\n+\n+        return fields.contains(theTargetClassInOrigGraph);\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+\n+            // Prune toString since the SearchEngine finds all the toString()\n+            // methods, even those that are called from different classes\n+            if ("toString".equals(original.getSimpleName())) continue;\n+\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+        return candidatesWithDifferentParentClass;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n+\n+    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+        return withoutFP;\n+    }\n+\n+    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+        boolean needsOneMorePass = false;\n+        List<Node[]> addToPUM = new ArrayList<>();\n+        List<Node[]> addToPDM = new ArrayList<>();\n+        for (Node[] pair : withoutFP) {\n+            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n+            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n+            if (sourceClass != null && destinationClass != null) {\n+                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n+                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n+            }\n+        }\n+\n+        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+        RefactoringCategory pulledUpCategory = null;\n+        RefactoringCategory pushedDownCategory = null;\n+        // TODO this only checks whether we already have such a category\n+        // created. It might be\n+        // that such a category has not been created previously (because no\n+        // results were found\n+        // for that category. In this case, will need to create a brand new\n+        // Category object.\n+        for (RefactoringCategory category : refactoringsList) {\n+            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n+            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n+        }\n+\n+        for (Node[] pair : addToPDM) {\n+            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n+            withoutFP.remove(pair);\n+            needsOneMorePass = true;\n+        }\n+\n+        for (Node[] pair : addToPUM) {\n+            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n+            withoutFP.remove(pair);\n+            needsOneMorePass = true;\n+        }\n+        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n+        else return withoutFP;\n+    }\n+\n+    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+        List<Node[]> pairsToRemove = new ArrayList<>();\n+        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+        for (RefactoringCategory category : refactoringsList) {\n+            if (category.getName().equals("PulledUpMethods")\n+                    || category.getName().equals("PushedDownMethods")) {\n+                for (Node[] pair : category.getRefactoringPairs()) {\n+                    for (Node[] prunedPair : prunedList) {\n+                        // The OR below takes care about n->1 and 1->n\n+                        // overlappings\n+                        // between PullUp/PushDown and MoveMethod\n+                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n+                    }\n+                }\n+            }\n+        }\n+        for (Node[] pair : pairsToRemove) {\n+            prunedList.remove(pair);\n+        }\n+        return prunedList;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n    private Node targetClassInVerGraph;\n\n    private Node targetClassInOrigGraph;\n\n    private RefactoringCrawler crawler;\n\n    /**\n    * Checks for MoveMethod\n    *\n    * <p>1. Check that from the old method, all the references to objects having the same type as the\n    * destination class were removed\n    *\n    * <p>2. Check that the new target class is either a previous argument or a field in the old class\n    */\n    public MoveMethodDetection(\n            RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n        super(graph1, graph2);\n        this.crawler = crawler;\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        double edgeGrade = 0.0;\n\n        double referenceGrade = 0.0;\n\n        if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n        // FIXME: Potential problem when we subtract 0.01 from reference grade\n        referenceGrade = referencesRemoved(original, version);\n        edgeGrade = analyzeIncomingEdges(original, version);\n        return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n    }\n\n    private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n        String sourceInOriginal = extractFullyQualifiedParentName(original);\n        String targetInVersion = extractFullyQualifiedParentName(version);\n        // treat case 1\n        return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n    }\n\n    /**\n    * 1. Check that from the old method, all the references to objects having the same type as the\n    * destination class were removed\n    */\n    private double referencesRemoved(Node original, Node version) {\n        String targetInVersion = extractFullyQualifiedParentName(version);\n\n        targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n        targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n        // treat case 2\n        if (targetClassInOrigGraph == null) {\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            Enumeration<String> keys = dictionary.keys();\n            for (; keys.hasMoreElements(); ) {\n                String aKey = keys.nextElement();\n                String aValue = dictionary.get(aKey);\n                if (targetInVersion.equals(aValue)) {\n                    targetClassInOrigGraph = graph1.findNamedNode(aKey);\n                }\n            }\n\n            // treat case 3\n            if (targetClassInOrigGraph == null) return 1.0;\n        }\n\n        // treat case 2 and 4\n        if (!targetClassInVerGraph.hasCallGraph()) {\n            createClassReferenceGraph(targetClassInVerGraph, graph2);\n            targetClassInVerGraph.setCreatedCallGraph();\n        }\n        if (!targetClassInOrigGraph.hasCallGraph()) {\n            createClassReferenceGraph(targetClassInOrigGraph, graph1);\n            targetClassInOrigGraph.setCreatedCallGraph();\n        }\n\n        List<Edge> originalClassReferences =\n                new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n        List<Edge> versionClassReferences =\n                new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n        if (originalClassReferences.size() == 0) {\n            if (original.isStatic()) return 1.0;\n            if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n            if (versionClassReferences.size() == 0) return 1.0;\n            return 0.0;\n        } else\n            return Math.abs(\n                    ((originalClassReferences.size() - versionClassReferences.size())\n                            / originalClassReferences.size()));\n    }\n\n    private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n        Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n        List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n        List<Node> fields = new ArrayList<Node>();\n        for (Edge value : edges) {\n            if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n                fields.add((Node) value.getTarget());\n            }\n        }\n\n        return fields.contains(theTargetClassInOrigGraph);\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n\n            // Prune toString since the SearchEngine finds all the toString()\n            // methods, even those that are called from different classes\n            if ("toString".equals(original.getSimpleName())) continue;\n\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n\n    /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n        withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n        return withoutFP;\n    }\n\n    private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n        boolean needsOneMorePass = false;\n        List<Node[]> addToPUM = new ArrayList<>();\n        List<Node[]> addToPDM = new ArrayList<>();\n        for (Node[] pair : withoutFP) {\n            String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n            String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n            Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n            Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n            if (sourceClass != null && destinationClass != null) {\n                if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n                else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n            }\n        }\n\n        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n        RefactoringCategory pulledUpCategory = null;\n        RefactoringCategory pushedDownCategory = null;\n        // TODO this only checks whether we already have such a category\n        // created. It might be\n        // that such a category has not been created previously (because no\n        // results were found\n        // for that category. In this case, will need to create a brand new\n        // Category object.\n        for (RefactoringCategory category : refactoringsList) {\n            if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n            else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n        }\n\n        for (Node[] pair : addToPDM) {\n            if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n            withoutFP.remove(pair);\n            needsOneMorePass = true;\n        }\n\n        for (Node[] pair : addToPUM) {\n            if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n            withoutFP.remove(pair);\n            needsOneMorePass = true;\n        }\n        if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n        else return withoutFP;\n    }\n\n    private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n        List<Node[]> pairsToRemove = new ArrayList<>();\n        List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n        for (RefactoringCategory category : refactoringsList) {\n            if (category.getName().equals("PulledUpMethods")\n                    || category.getName().equals("PushedDownMethods")) {\n                for (Node[] pair : category.getRefactoringPairs()) {\n                    for (Node[] prunedPair : prunedList) {\n                        // The OR below takes care about n->1 and 1->n\n                        // overlappings\n                        // between PullUp/PushDown and MoveMethod\n                        if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n                    }\n                }\n            }\n        }\n        for (Node[] pair : pairsToRemove) {\n            prunedList.remove(pair);\n        }\n        return prunedList;\n    }\n}\n'
          },
          {
            sha: "9a65c27dea4e74b026c3165812f7abe0280ff32d",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "modified",
            additions: 53,
            deletions: 60,
            patch:
              '@@ -1,73 +1,66 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class PullUpMethodDetection extends MethodDetection {\n \n-\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\t/**\n-\t * We should now check for the same method being in the parent class, thus\n-\t * for the two nodes, check if the version now resides in the superclass of\n-\t * the original method\'s parent class.\n-\t */\n-\t// TODO: Check why we get a null pointer exception with parentclassver and\n-\t// parent class orig)\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tdouble incomingEdgesGrade = 0.0;\n-\t\tboolean isSuperclass = false;\n-\t\t// TODO: Think about possible different cases that this might be\n-\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n-\t\t// find it.\n-\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n-\t\t// since clearly they are not "like" each other.\n-\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n-\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-\t\tif (parentClassOrig == null)\n-\t\t\treturn 0.0;\n-\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n-\t\t// Now we should check if parentClassOrig is a subclass of\n-\t\t// parentClassVer\n-\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n-\t\t\tisSuperclass = true;\n+    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n \n-\t\tif (isSuperclass) {\n-\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n-\t\t\treturn incomingEdgesGrade;\n-\t\t} else\n-\t\t\treturn 0.0;\n-\t}\n+    /**\n+    * We should now check for the same method being in the parent class, thus for the two nodes,\n+    * check if the version now resides in the superclass of the original method\'s parent class.\n+    */\n+    // TODO: Check why we get a null pointer exception with parentclassver and\n+    // parent class orig)\n+    public double computeLikeliness(Node original, Node version) {\n+        double incomingEdgesGrade = 0.0;\n+        boolean isSuperclass = false;\n+        // TODO: Think about possible different cases that this might be\n+        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+        // find it.\n+        // TODO: Think about the NULL case. Return 0.0 if you find null,\n+        // since clearly they are not "like" each other.\n+        String parentClassOriginal = extractFullyQualifiedParentName(original);\n+        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+        String parentClassVersion = extractFullyQualifiedParentName(version);\n+        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+        if (parentClassOrig == null) return 0.0;\n+        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+        // Now we should check if parentClassOrig is a subclass of\n+        // parentClassVer\n+        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n \n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n-\t\t\tString parentClassVersion = extractParentSimpleName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n+        if (isSuperclass) {\n+            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n+            return incomingEdgesGrade;\n+        } else return 0.0;\n+    }\n \n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractParentSimpleName(original);\n+            String parentClassVersion = extractParentSimpleName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+        return candidatesWithDifferentParentClass;\n+    }\n \n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n    public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    /**\n    * We should now check for the same method being in the parent class, thus for the two nodes,\n    * check if the version now resides in the superclass of the original method\'s parent class.\n    */\n    // TODO: Check why we get a null pointer exception with parentclassver and\n    // parent class orig)\n    public double computeLikeliness(Node original, Node version) {\n        double incomingEdgesGrade = 0.0;\n        boolean isSuperclass = false;\n        // TODO: Think about possible different cases that this might be\n        // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n        // find it.\n        // TODO: Think about the NULL case. Return 0.0 if you find null,\n        // since clearly they are not "like" each other.\n        String parentClassOriginal = extractFullyQualifiedParentName(original);\n        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n        String parentClassVersion = extractFullyQualifiedParentName(version);\n        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n        if (parentClassOrig == null) return 0.0;\n        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n        // Now we should check if parentClassOrig is a subclass of\n        // parentClassVer\n        if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n        if (isSuperclass) {\n            incomingEdgesGrade = analyzeIncomingEdges(original, version);\n            return incomingEdgesGrade;\n        } else return 0.0;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractParentSimpleName(original);\n            String parentClassVersion = extractParentSimpleName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "42f7911b558ea66066d1d087470193efa249633b",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "modified",
            additions: 46,
            deletions: 51,
            patch:
              '@@ -1,59 +1,54 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.detection.classDetection.ClassDetection;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.List;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class PushDownMethodDetection extends MethodDetection {\n \n-\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-\t\tsuper(graph, graph2);\n-\t}\n-\n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\tboolean superClassGrade = false;\n-\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n-\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n-\t\tif (parentClassOrig == null)\n-\t\t\treturn 0.0;\n-\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n-\t\t// Now we should check if parentClassVer is a subclass of\n-\t\t// parentClassOrig\n-\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n-\t\t\tSystem.out.println("stop");\n-\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n-\t\t\tsuperClassGrade = true;\n-\t\tif (superClassGrade) {\n-\t\t\treturn (analyzeIncomingEdges(original, version));\n-\t\t} else\n-\t\t\treturn 0.0;\n-\t}\n-\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n-\t\t\tString parentClassVersion = extractParentSimpleName(version);\n-\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& ((original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName())))) {\n-\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidatesWithDifferentParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn false;\n-\t}\n+    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n+    }\n+\n+    public double computeLikeliness(Node original, Node version) {\n+        boolean superClassGrade = false;\n+        String parentClassOriginal = extractFullyQualifiedParentName(original);\n+        String parentClassVersion = extractFullyQualifiedParentName(version);\n+        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n+        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+        if (parentClassOrig == null) return 0.0;\n+        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n+        // Now we should check if parentClassVer is a subclass of\n+        // parentClassOrig\n+        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+            System.out.println("stop");\n+        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n+        if (superClassGrade) {\n+            return (analyzeIncomingEdges(original, version));\n+        } else return 0.0;\n+    }\n+\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractParentSimpleName(original);\n+            String parentClassVersion = extractParentSimpleName(version);\n+            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n+                candidatesWithDifferentParentClass.add(pair);\n+            }\n+        }\n+\n+        return candidatesWithDifferentParentClass;\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n    public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        boolean superClassGrade = false;\n        String parentClassOriginal = extractFullyQualifiedParentName(original);\n        String parentClassVersion = extractFullyQualifiedParentName(version);\n        parentClassOriginal = extractPotentialRename(parentClassOriginal);\n        Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n        if (parentClassOrig == null) return 0.0;\n        Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n        // Now we should check if parentClassVer is a subclass of\n        // parentClassOrig\n        if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n            System.out.println("stop");\n        if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n        if (superClassGrade) {\n            return (analyzeIncomingEdges(original, version));\n        } else return 0.0;\n    }\n\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractParentSimpleName(original);\n            String parentClassVersion = extractParentSimpleName(version);\n            if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && ((original.getSimpleName().equals(version.getSimpleName())))) {\n                candidatesWithDifferentParentClass.add(pair);\n            }\n        }\n\n        return candidatesWithDifferentParentClass;\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n'
          },
          {
            sha: "35f126943b291e74fbe8c0be61f5210fc0c9d019",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "modified",
            additions: 64,
            deletions: 71,
            patch:
              "@@ -1,85 +1,78 @@\n package refactoring.crawler.detection.methodDetection;\n \n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n import java.util.ArrayList;\n import java.util.Dictionary;\n import java.util.List;\n-\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n \n public class RenameMethodDetection extends MethodDetection {\n \n-\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\t\tsuper(oldVersion, newVersion);\n-\t}\n-\n+    public RenameMethodDetection(\n+            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+        super(oldVersion, newVersion);\n+    }\n \n-\t/**\n-\t * @param candidates List containing clone methods\n-\t * @return A List containing only the candidate methods that are in the same\n-\t * class\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName()))))\n-\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-\t\t}\n+    /**\n+    * @param candidates List containing clone methods\n+    * @return A List containing only the candidate methods that are in the same class\n+    */\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n+                candidatesWithSameParentClass.add(pair);\n+        }\n \n-\t\treturn candidatesWithSameParentClass;\n-\t}\n+        return candidatesWithSameParentClass;\n+    }\n \n-\tpublic double computeLikeliness(Node original, Node version) {\n-\t\t// createCallGraph(original, version);\n-\t\t// return computeLikelinessConsideringEdges(original, version);\n-\t\treturn analyzeIncomingEdges(original, version);\n-\t}\n+    public double computeLikeliness(Node original, Node version) {\n+        // createCallGraph(original, version);\n+        // return computeLikelinessConsideringEdges(original, version);\n+        return analyzeIncomingEdges(original, version);\n+    }\n \n-\t@Override\n-\tpublic boolean isRename() {\n-\t\treturn true;\n-\t}\n+    @Override\n+    public boolean isRename() {\n+        return true;\n+    }\n \n-\t/**\n-\t * Prune further for cases that have n-to-1 mappings.\n-\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n-\t */\n-\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n-\t\tfor (int i = 0; i < prunedList.size(); i++) {\n-\t\t\tNode[] pair = prunedList.get(i);\n-\t\t\tNode target = pair[1];\n-\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n-\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n-\t\t\tfor (Node[] nodes : prunedList) {\n-\t\t\t\tNode potentialTarget = (nodes)[1];\n-\t\t\t\tif (target == potentialTarget)\n-\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n-\t\t\t}\n-\t\t\tif (allPairsWithSameTarget.size() > 1) {\n-\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n-\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n-\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n-\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n-\t\t\t\t\t\t.toLowerCase().trim();\n-\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n-\t\t\t\t\tif ((!targetName.contains(sourceName))\n-\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n-\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n-\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn prunedList;\n-\t}\n+    /**\n+    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n+    * getStartConnector) in JHD5.3 )\n+    */\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+        for (int i = 0; i < prunedList.size(); i++) {\n+            Node[] pair = prunedList.get(i);\n+            Node target = pair[1];\n+            String targetName = target.getSimpleName().toLowerCase().trim();\n+            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+            for (Node[] nodes : prunedList) {\n+                Node potentialTarget = (nodes)[1];\n+                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n+            }\n+            if (allPairsWithSameTarget.size() > 1) {\n+                for (Object o : allPairsWithSameTarget) {\n+                    Node[] sameTargetPair = (Node[]) o;\n+                    Node sourceNode = sameTargetPair[0];\n+                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n+                    // Changed from || to && and changed the !='s to =='s\n+                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n+                        prunedList.remove(sameTargetPair);\n+                        Dictionary<String, String> dictionary = getRenamingDictionary();\n+                        dictionary.remove(sourceNode.getFullyQualifiedName());\n+                    }\n+                }\n+            }\n+        }\n+        return prunedList;\n+    }\n }",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n    public RenameMethodDetection(\n            NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n        super(oldVersion, newVersion);\n    }\n\n    /**\n    * @param candidates List containing clone methods\n    * @return A List containing only the candidate methods that are in the same class\n    */\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentClass = new ArrayList();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && (!(original.getSimpleName().equals(version.getSimpleName()))))\n                candidatesWithSameParentClass.add(pair);\n        }\n\n        return candidatesWithSameParentClass;\n    }\n\n    public double computeLikeliness(Node original, Node version) {\n        // createCallGraph(original, version);\n        // return computeLikelinessConsideringEdges(original, version);\n        return analyzeIncomingEdges(original, version);\n    }\n\n    @Override\n    public boolean isRename() {\n        return true;\n    }\n\n    /**\n    * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n    * getStartConnector) in JHD5.3 )\n    */\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n        for (int i = 0; i < prunedList.size(); i++) {\n            Node[] pair = prunedList.get(i);\n            Node target = pair[1];\n            String targetName = target.getSimpleName().toLowerCase().trim();\n            List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n            for (Node[] nodes : prunedList) {\n                Node potentialTarget = (nodes)[1];\n                if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n            }\n            if (allPairsWithSameTarget.size() > 1) {\n                for (Object o : allPairsWithSameTarget) {\n                    Node[] sameTargetPair = (Node[]) o;\n                    Node sourceNode = sameTargetPair[0];\n                    String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n                    // Changed from || to && and changed the !='s to =='s\n                    if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n                        prunedList.remove(sameTargetPair);\n                        Dictionary<String, String> dictionary = getRenamingDictionary();\n                        dictionary.remove(sourceNode.getFullyQualifiedName());\n                    }\n                }\n            }\n        }\n        return prunedList;\n    }\n}\n"
          },
          {
            sha: "57d8e14adb21db33b91bda9b9596bead5ed00a95",
            filename: "src/main/java/refactoring/crawler/graph/ClassNode.java",
            status: "added",
            additions: 18,
            deletions: 0,
            patch:
              "@@ -0,0 +1,18 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class ClassNode extends Node {\n+\n+    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n+\n+    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public ClassNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.CLASS);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n    @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n    @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public ClassNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.CLASS);\n    }\n}\n"
          },
          {
            sha: "0a51f2cce0dd323822aef1eda7b82be5271d814c",
            filename: "src/main/java/refactoring/crawler/graph/Edge.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              '@@ -0,0 +1,35 @@\n+package refactoring.crawler.graph;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DefaultEdge;\n+\n+public class Edge extends DefaultEdge {\n+\n+    @Getter @Setter private Node.Type label;\n+\n+    public Edge(Node.Type label) {\n+        this.label = label;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+    }\n+\n+    @Override\n+    public Node getSource() {\n+        return (Node) super.getSource();\n+    }\n+\n+    @Override\n+    public Node getTarget() {\n+        return (Node) super.getTarget();\n+    }\n+\n+    public Node oppositeVertex(Node n) {\n+        Node source = this.getSource();\n+        Node target = this.getTarget();\n+        return n.equals(source) ? target : source;\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n    @Getter @Setter private Node.Type label;\n\n    public Edge(Node.Type label) {\n        this.label = label;\n    }\n\n    @Override\n    public String toString() {\n        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n    }\n\n    @Override\n    public Node getSource() {\n        return (Node) super.getSource();\n    }\n\n    @Override\n    public Node getTarget() {\n        return (Node) super.getTarget();\n    }\n\n    public Node oppositeVertex(Node n) {\n        Node source = this.getSource();\n        Node target = this.getTarget();\n        return n.equals(source) ? target : source;\n    }\n}\n'
          },
          {
            sha: "2b79bc6995c1dd3051b10d8cb540d984cb0ff4e7",
            filename: "src/main/java/refactoring/crawler/graph/FieldNode.java",
            status: "added",
            additions: 15,
            deletions: 0,
            patch:
              "@@ -0,0 +1,15 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FieldNode extends Node {\n+\n+    @Getter @Setter private List<String> fieldReferenceToMethod;\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public FieldNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.FIELD);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n    @Getter @Setter private List<String> fieldReferenceToMethod;\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public FieldNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.FIELD);\n    }\n}\n"
          },
          {
            sha: "3723ff5fff00d30204dcfe1049ea7e5f66d3b72e",
            filename: "src/main/java/refactoring/crawler/graph/MethodNode.java",
            status: "added",
            additions: 24,
            deletions: 0,
            patch:
              "@@ -0,0 +1,24 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class MethodNode extends Node {\n+\n+    @AllArgsConstructor\n+    public static class CalledMethod {\n+        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n+\n+        @Getter @Setter private String fullyQualifiedNameWithSignature;\n+    }\n+\n+    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n+\n+    /** @param fullyQualifiedName fullyQualifiedName */\n+    public MethodNode(String fullyQualifiedName) {\n+        super(fullyQualifiedName, Type.METHOD);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n    @AllArgsConstructor\n    public static class CalledMethod {\n        @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n        @Getter @Setter private String fullyQualifiedNameWithSignature;\n    }\n\n    @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n    /** @param fullyQualifiedName fullyQualifiedName */\n    public MethodNode(String fullyQualifiedName) {\n        super(fullyQualifiedName, Type.METHOD);\n    }\n}\n"
          },
          {
            sha: "95512f366ed1570e1bface854dab31a016f59a38",
            filename:
              "src/main/java/refactoring/crawler/graph/NamedDirectedMultigraph.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.graph;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import lombok.Getter;\n+import org.jgrapht.graph.DirectedMultigraph;\n+\n+public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n+\n+    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+    public NamedDirectedMultigraph() {\n+        super(Edge.class);\n+    }\n+\n+    public NamedDirectedMultigraph(\n+            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+        super(vertexSupplier, edgeSupplier, weighted);\n+    }\n+\n+    public boolean addNamedVertex(Node v) {\n+        if (!addVertex(v)) return false;\n+        namedVertexMap.put(v.getFullyQualifiedName(), v);\n+        return true;\n+    }\n+\n+    public Node findNamedNode(String name) {\n+        return namedVertexMap.get(name);\n+    }\n+\n+    public boolean hasNamedNode(String name) {\n+        return namedVertexMap.containsKey(name);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n    @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n    public NamedDirectedMultigraph() {\n        super(Edge.class);\n    }\n\n    public NamedDirectedMultigraph(\n            Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n        super(vertexSupplier, edgeSupplier, weighted);\n    }\n\n    public boolean addNamedVertex(Node v) {\n        if (!addVertex(v)) return false;\n        namedVertexMap.put(v.getFullyQualifiedName(), v);\n        return true;\n    }\n\n    public Node findNamedNode(String name) {\n        return namedVertexMap.get(name);\n    }\n\n    public boolean hasNamedNode(String name) {\n        return namedVertexMap.containsKey(name);\n    }\n}\n"
          },
          {
            sha: "b123fcf4966c594a330922d4f004967b16a1d96c",
            filename: "src/main/java/refactoring/crawler/graph/Node.java",
            status: "added",
            additions: 74,
            deletions: 0,
            patch:
              '@@ -0,0 +1,74 @@\n+package refactoring.crawler.graph;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class Node {\n+\n+    public boolean hasCallGraph() {\n+        return false;\n+    }\n+\n+    public void setCreatedCallGraph() {}\n+\n+    public static enum Type {\n+        PROJECT,\n+        PACKAGE,\n+        CLASS,\n+        METHOD,\n+        FIELD,\n+        METHOD_CALL,\n+        IMPORT,\n+        CLASS_REFERENCE,\n+        FIELD_REFERENCE\n+    }\n+\n+    @Getter @Setter private String fullyQualifiedName;\n+\n+    @Setter @Getter private Node.Type type;\n+\n+    @Setter @Getter private int[] shingles;\n+\n+    @Setter @Getter private boolean hasCallGraph;\n+\n+    @Setter @Getter private String projectName;\n+\n+    @Setter @Getter private boolean isAPI = false;\n+\n+    @Setter @Getter private String signature;\n+\n+    @Setter @Getter private int flags;\n+\n+    @Setter @Getter private boolean deprecated = false;\n+\n+    @Setter @Getter private boolean isInterface = false;\n+\n+    @Getter @Setter private boolean isStatic = false;\n+\n+    /**\n+    * @param fullyQualifiedName fullyQualifiedName\n+    * @param type type\n+    */\n+    public Node(String fullyQualifiedName, Node.Type type) {\n+        this.fullyQualifiedName = fullyQualifiedName;\n+        this.type = type;\n+    }\n+\n+    public String getSimpleName() {\n+        int pos = fullyQualifiedName.lastIndexOf(".");\n+        if (pos != -1) {\n+            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n+        }\n+        return fullyQualifiedName;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (getSignature() != null)\n+            return getType()\n+                    + "= "\n+                    + getFullyQualifiedName()\n+                    + getSignature().substring(getSignature().indexOf("("));\n+        else return getType() + "= " + getFullyQualifiedName();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {}\n\n    public static enum Type {\n        PROJECT,\n        PACKAGE,\n        CLASS,\n        METHOD,\n        FIELD,\n        METHOD_CALL,\n        IMPORT,\n        CLASS_REFERENCE,\n        FIELD_REFERENCE\n    }\n\n    @Getter @Setter private String fullyQualifiedName;\n\n    @Setter @Getter private Node.Type type;\n\n    @Setter @Getter private int[] shingles;\n\n    @Setter @Getter private boolean hasCallGraph;\n\n    @Setter @Getter private String projectName;\n\n    @Setter @Getter private boolean isAPI = false;\n\n    @Setter @Getter private String signature;\n\n    @Setter @Getter private int flags;\n\n    @Setter @Getter private boolean deprecated = false;\n\n    @Setter @Getter private boolean isInterface = false;\n\n    @Getter @Setter private boolean isStatic = false;\n\n    /**\n    * @param fullyQualifiedName fullyQualifiedName\n    * @param type type\n    */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType()\n                    + "= "\n                    + getFullyQualifiedName()\n                    + getSignature().substring(getSignature().indexOf("("));\n        else return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "d294a5f56dad1dba561bfd8d25bd70a7ccaa5d42",
            filename: "src/main/java/refactoring/crawler/project/IClass.java",
            status: "removed",
            additions: 0,
            deletions: 22,
            patch:
              "@@ -1,22 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import java.util.List;\n-\n-public interface IClass {\n-\n-    public List<IMethod> getMethods();\n-\n-    public List<IField> getFields();\n-\n-    public String getFullyQualifiedName();\n-\n-    public int getFlags();\n-\n-    public boolean getIsDeprecated();\n-\n-    public boolean getIsInterface();\n-\n-    public boolean isPublic();\n-\n-    public boolean isProtected();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IClass {\n\n    public List<IMethod> getMethods();\n\n    public List<IField> getFields();\n\n    public String getFullyQualifiedName();\n\n    public int getFlags();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsInterface();\n\n    public boolean isPublic();\n\n    public boolean isProtected();\n}\n"
          },
          {
            sha: "dbe2bf76763338d11712c8cb049d27ddc89620bb",
            filename: "src/main/java/refactoring/crawler/project/IField.java",
            status: "removed",
            additions: 0,
            deletions: 14,
            patch:
              "@@ -1,14 +0,0 @@\n-package refactoring.crawler.project;\n-\n-public interface IField {\n-\n-    public String getSource();\n-\n-    public String getElementName();\n-\n-    public int getFlags();\n-\n-    public String getTypeSignature();\n-\n-    public boolean getIsDeprecated();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IField {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public int getFlags();\n\n    public String getTypeSignature();\n\n    public boolean getIsDeprecated();\n}\n"
          },
          {
            sha: "aa5a6b80cb38b51776c717580c642edfd62ca7dd",
            filename: "src/main/java/refactoring/crawler/project/IMethod.java",
            status: "removed",
            additions: 0,
            deletions: 18,
            patch:
              "@@ -1,18 +0,0 @@\n-package refactoring.crawler.project;\n-\n-public interface IMethod {\n-\n-    public String getSource();\n-\n-    public String getElementName();\n-\n-    public boolean getIsPublic();\n-\n-    public boolean getIsDeprecated();\n-\n-    public boolean getIsProtected();\n-\n-    public int getFlags();\n-\n-    public String[] getParameterTypes();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IMethod {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public boolean getIsPublic();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsProtected();\n\n    public int getFlags();\n\n    public String[] getParameterTypes();\n}\n"
          },
          {
            sha: "dab45c8026bdcaef0dfeb04913e60d8153553ec3",
            filename: "src/main/java/refactoring/crawler/project/IPackage.java",
            status: "removed",
            additions: 0,
            deletions: 16,
            patch:
              "@@ -1,16 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import com.github.javaparser.ast.CompilationUnit;\n-\n-import java.util.List;\n-\n-public interface IPackage {\n-\n-    public List<IClass> getClasses();\n-\n-    public List<IPackage> getChildrenPackages();\n-\n-    public String getElementName();\n-\n-//    public List<CompilationUnit> getCompilationUnit();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport java.util.List;\n\npublic interface IPackage {\n\n    public List<IClass> getClasses();\n\n    public List<IPackage> getChildrenPackages();\n\n    public String getElementName();\n\n//    public List<CompilationUnit> getCompilationUnit();\n}\n"
          },
          {
            sha: "1757c698aee63ab8c2e194f2656032cf614d9f39",
            filename: "src/main/java/refactoring/crawler/project/IProject.java",
            status: "removed",
            additions: 0,
            deletions: 10,
            patch:
              "@@ -1,10 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import java.util.List;\n-\n-public interface IProject {\n-\n-    public List<IPackage> getPackages();\n-\n-    public String getProjectName();\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IProject {\n\n    public List<IPackage> getPackages();\n\n    public String getProjectName();\n}\n"
          },
          {
            sha: "448f7bcee55deabe401c3a889ce95bd377b9dfd5",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "removed",
            additions: 0,
            deletions: 35,
            patch:
              "@@ -1,35 +0,0 @@\n-package refactoring.crawler.project;\n-\n-import com.github.javaparser.StaticJavaParser;\n-import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.PackageDeclaration;\n-import lombok.Getter;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-public class RCProject implements IProject {\n-\n-\t@Getter\n-\tprivate String projectName;\n-\n-\tprivate List<CompilationUnit> units;\n-\n-\tprivate List<IPackage> packages;\n-\n-\tpublic RCProject(String projectName, List<String> fileSources) {\n-\t\tthis.projectName = projectName;\n-\t\tthis.units = new LinkedList<>();\n-\t\tfor (String source : fileSources) {\n-\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n-\t\t\tthis.units.add(compilationUnit);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<IPackage> getPackages() {\n-\t\treturn null;\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\treturn null;\n\t}\n}\n"
          },
          {
            sha: "b48189ccbf00559dc0d879ba4853cc613404310b",
            filename:
              "src/main/java/refactoring/crawler/shingles/BloomFilter.java",
            status: "added",
            additions: 522,
            deletions: 0,
            patch:
              '@@ -0,0 +1,522 @@\n+package refactoring.crawler.shingles;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.net.URL;\n+\n+/**\n+* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n+*\n+* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n+* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n+* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n+* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n+* can make a useful tool.\n+*\n+* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n+* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n+* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n+* checkers.\n+*\n+* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n+* vector of a given length. We choose the length of the bit vector and the number of hash functions\n+* depending on how many keys we want to add to the set and how high an error rate we are willing to\n+* put up with.\n+*\n+* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n+* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n+* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+* function would increase our false-positive rate.\n+*\n+* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n+* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n+* a Bloom filter.\n+*\n+* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n+* key. We run the key through our set of hash functions, and then check to see whether the bits at\n+* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n+* the filter. If all of the bits are on, we know the key is probably there.\n+*\n+* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n+* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n+* bits we check will be on, unless the key actually exists in the filter. The relationship between\n+* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n+* will be very dense, increasing the probability of collisions. You can calculate the\n+* false-positive rate for any filter using the formula:\n+*\n+* <p><code>c = ( 1 - e(-kn/m) )k</code>\n+*\n+* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n+* in the filter, and m is the length of the filter in bits.\n+*\n+* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n+* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n+* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n+* our limit. The following equation will give us vector length from the error rate and number of\n+* keys:\n+*\n+* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n+*\n+* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n+* combinations of error rate, filter size, and number of hash functions at <a\n+* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n+* -- the math</a>.\n+*\n+* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n+* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n+* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n+* the case of JDK 1.4).\n+*\n+* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n+* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n+* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n+* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n+* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n+* even in this Java implementation the speed is reasonable.\n+*\n+* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+* method" by Andrei Broder. See <a\n+* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+* paper in PDF format.\n+*\n+* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n+* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n+* <code>URL</code>.\n+*\n+* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+* initial value multiplied by a list of distinct values.\n+*\n+* @see java.lang.Object#hashCode()\n+* @see java.util.Map\n+* @author Bruno Martins\n+*/\n+public class BloomFilter implements Cloneable {\n+\n+    /** A buffer for the Rabin fingerprinting algorithm. */\n+    private byte[] buffer;\n+\n+    /**\n+    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n+    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n+    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n+    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+    * bit is the constant coefficient.\n+    *\n+    * <p>For example the integer 0x00000803, in binary, is:\n+    *\n+    * <p><code>00000000 00000000 00001000 00000011</code>\n+    *\n+    * <p>Therefore it correponds to the polynomial:\n+    *\n+    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+    */\n+    private static int POLYNOMIAL = 0x000001C7;\n+\n+    /** Internal values for the Rabin fingerprinting algorithm. */\n+    private static int[] table32, table40, table48, table54;\n+\n+    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+    private static int P_DEGREE = 32;\n+\n+    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n+    private static int READ_BUFFER_SIZE = 2048;\n+\n+    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+\n+    /** The bit vector for the Bloom Filter. */\n+    private boolean keys[];\n+\n+    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+    private boolean useRabin = true;\n+\n+    /** The number of hash functions. */\n+    private int numFunctions;\n+\n+    /**\n+    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n+    * length for the bit vector (1000).\n+    */\n+    public BloomFilter() {\n+        table32 = new int[256];\n+        table40 = new int[256];\n+        table48 = new int[256];\n+        table54 = new int[256];\n+        buffer = new byte[READ_BUFFER_SIZE];\n+        // We want to have mods[i] == x^(P_DEGREE+i)\n+        int[] mods = new int[P_DEGREE];\n+        mods[0] = POLYNOMIAL;\n+        for (int i = 1; i < P_DEGREE; i++) {\n+            // x^i == x(x^(i-1)) (mod P)\n+            mods[i] = mods[i - 1] << 1;\n+            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+            // x^P_DEGREE term that \'fell off\' the top end.\n+            // Since x^P_DEGREE == P (mod P), we should add P\n+            // to account for this:\n+            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n+                mods[i] ^= POLYNOMIAL;\n+            }\n+        }\n+        for (int i = 0; i < 256; i++) {\n+            int c = i;\n+            for (int j = 0; j < 8 && c != 0; j++) {\n+                if ((c & 1) != 0) {\n+                    table32[i] ^= mods[j];\n+                    table40[i] ^= mods[j + 8];\n+                    table48[i] ^= mods[j + 16];\n+                    table54[i] ^= mods[j + 24];\n+                }\n+                c >>>= 1;\n+            }\n+        }\n+        mods = null;\n+        this.keys = new boolean[1000];\n+        this.numFunctions = 10;\n+        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Constructs a Bloom Filter from a string representation.\n+    *\n+    * @see #toString()\n+    */\n+    public BloomFilter(String filter) {\n+        this();\n+        int index1 = filter.indexOf(":");\n+        int index2 = filter.lastIndexOf(":");\n+        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n+        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n+        for (int i = index2 + 1; i < filter.length(); i++) {\n+            if (filter.charAt(i) == \'1\') keys[i] = true;\n+            else keys[i] = false;\n+        }\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n+    * error rate.\n+    *\n+    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n+    */\n+    public BloomFilter(int numKeys, double errorRate) {\n+        this();\n+        double lowest_m = Double.MAX_VALUE;\n+        int best_k = 1;\n+        for (int k = 1; k <= 100; k++) {\n+            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+            if (m < lowest_m) {\n+                lowest_m = m;\n+                best_k = k;\n+            }\n+        }\n+        this.keys = new boolean[numKeys];\n+        this.numFunctions = best_k;\n+        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n+    * length for the bit vector.\n+    *\n+    * @param numKeys The length of the bit vector.\n+    */\n+    public BloomFilter(int numKeys) {\n+        this(numKeys, 10);\n+    }\n+\n+    /**\n+    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n+    * the bit vector.\n+    *\n+    * @param numKeys The length of the bit vector.\n+    * @param numHashFunctions The number of hash functions.\n+    */\n+    public BloomFilter(int numKeys, int numHashFunctions) {\n+        this();\n+        this.keys = new boolean[numKeys];\n+        this.numFunctions = numHashFunctions;\n+        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n+    }\n+\n+    /**\n+    * Internal method for producing the hash value for a given function number.\n+    *\n+    * @param fnum The number of the hash function.\n+    * @param original The original value for the hash of the object.\n+    * @see java.lang.Object#hashCode()\n+    * @return Returns the hash code value for the given function number.\n+    */\n+    private int getHash(int fnum, int original) {\n+        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n+        int hash[] = {original};\n+        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n+        hash[0] = hash[0] % keys.length;\n+        if (hash[0] < 0) hash[0] = -hash[0];\n+        return hash[0];\n+    }\n+\n+    /**\n+    * Returns true if this Bloom Filter contains the specified key.\n+    *\n+    * @param obj The key whose presence in this Bloom Filter is to be tested.\n+    * @return true if this Bloom Filter contains a mapping for the specified key.\n+    */\n+    public boolean hasKey(Object obj) {\n+        boolean result = true;\n+        int hashCodeObject;\n+        if (!useRabin) hashCodeObject = obj.hashCode();\n+        else\n+            try {\n+                hashCodeObject = hashRabin(obj);\n+            } catch (Exception e) {\n+                useRabin = false;\n+                hashCodeObject = obj.hashCode();\n+            }\n+        for (int i = 0; i < numFunctions && result; i++) {\n+            result &= keys[getHash(i, hashCodeObject)];\n+        }\n+        return result;\n+    }\n+\n+    /**\n+    * Adds the specified key in this Bloom Filter.\n+    *\n+    * @param obj The key to be added to this Bloom Filter.\n+    */\n+    public void put(Object obj) {\n+        int hashCodeObject;\n+        if (!useRabin) hashCodeObject = obj.hashCode();\n+        else\n+            try {\n+                hashCodeObject = hashRabin(obj);\n+            } catch (Exception e) {\n+                useRabin = false;\n+                hashCodeObject = obj.hashCode();\n+            }\n+        for (int i = 0; i < numFunctions; i++) {\n+            keys[getHash(i, hashCodeObject)] = true;\n+        }\n+    }\n+\n+    /**\n+    * Returns a string representation of this Bloom Filter. The string representation consists of an\n+    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n+    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n+    * the character ":".\n+    *\n+    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n+    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n+    * returned.\n+    *\n+    * @return A string representation of this Bloom Filter.\n+    */\n+    public String toString() {\n+        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n+        for (int i = 0; i < keys.length; i++) {\n+            if (keys[i]) aux.append("1");\n+            else aux.append("0");\n+        }\n+        return aux.toString();\n+    }\n+\n+    /**\n+    * Returns a copy of this Bloom Filter instance.\n+    *\n+    * @see java.lang.Object#clone()\n+    */\n+    public Object clone() {\n+        return new BloomFilter(this.toString());\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of bytes.\n+    *\n+    * @param arr An array of bytes.\n+    * @return The Rabin hash value for the array of bytes.\n+    */\n+    public int hashRabin(byte[] arr) {\n+        return hashRabin(arr, 0, arr.length, 0);\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of bytes.\n+    *\n+    * @param arr An array of bytes.\n+    * @param offset Index of the first byte of the array to hash.\n+    * @param length Number of bytes to hash.\n+    * @param ws ??\n+    * @return The Rabin hash value for the array of bytes.\n+    */\n+    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n+        int w = ws;\n+        int start = length % 4;\n+        for (int s = offset; s < offset + start; s++) {\n+            w = (w << 8) ^ (arr[s] & 0xFF);\n+        }\n+        for (int s = start + offset; s < length + offset; s += 4) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ (arr[s] << 24)\n+                            ^ ((arr[s + 1] & 0xFF) << 16)\n+                            ^ ((arr[s + 2] & 0xFF) << 8)\n+                            ^ (arr[s + 3] & 0xFF);\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Return the Rabin hash value of an array of chars.\n+    *\n+    * @param arr An array of chars.\n+    * @return The Rabin hash value for the array of chars.\n+    */\n+    public int hashRabin(char[] arr) {\n+        int w = 0;\n+        int start = 0;\n+        if (arr.length % 2 == 1) {\n+            w = arr[0] & 0xFFFF;\n+            start = 1;\n+        }\n+        for (int s = start; s < arr.length; s += 2) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ ((arr[s] & 0xFFFF) << 16)\n+                            ^ (arr[s + 1] & 0xFFFF);\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the contents of a <code>File</code>.\n+    *\n+    * @param f A <code>File</code>.\n+    * @return The Rabin hash value for the contents of the File.\n+    * @throws FileNotFoundException If the file cannot be found.\n+    * @throws IOException If an error occurs while reading the file.\n+    */\n+    public int hashRabin(File f) throws FileNotFoundException, IOException {\n+        FileInputStream fis = new FileInputStream(f);\n+        try {\n+            return hashRabin(fis);\n+        } finally {\n+            fis.close();\n+        }\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+    *\n+    * @param is An InputStream.\n+    * @return The Rabin hash value for the contents read from the InputStream.\n+    * @throws IOException if an error occurs while reading from the InputStream.\n+    */\n+    public int hashRabin(InputStream is) throws IOException {\n+        int hashValue = 0;\n+        int bytesRead;\n+        synchronized (buffer) {\n+            while ((bytesRead = is.read(buffer)) > 0) {\n+                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+            }\n+        }\n+        return hashValue;\n+    }\n+\n+    /**\n+    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n+    * the hash methods, so it should be used when possible.\n+    *\n+    * @param arr An array of integers.\n+    * @return int The Rabin hash value for the array of integers.\n+    */\n+    public int hashRabin(int[] arr) {\n+        int w = 0;\n+        for (int s = 0; s < arr.length; s++) {\n+            w =\n+                    table32[w & 0xFF]\n+                            ^ table40[(w >>> 8) & 0xFF]\n+                            ^ table48[(w >>> 16) & 0xFF]\n+                            ^ table54[(w >>> 24) & 0xFF]\n+                            ^ arr[s];\n+        }\n+        return w;\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a given Object.\n+    *\n+    * @param obj An Object.\n+    * @return The Rabin hash value for the Object.\n+    * @throws IOException If Object serialization fails.\n+    */\n+    public int hashRabin(Object obj) throws IOException {\n+        return hashRabin((Serializable) obj);\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a given serializable Object.\n+    *\n+    * @param obj An Object.\n+    * @return The Rabin hash value for the Object.\n+    * @throws IOException If serialization fails.\n+    */\n+    public int hashRabin(Serializable obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = null;\n+        try {\n+            oos = new ObjectOutputStream(baos);\n+            oos.writeObject(obj);\n+            return hashRabin(baos.toByteArray());\n+        } finally {\n+            oos.close();\n+            baos.close();\n+            oos = null;\n+            baos = null;\n+        }\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of a String.\n+    *\n+    * @param s A <code>String</code>.\n+    * @return The Rabin hash value for the String.\n+    */\n+    public int hashRabin(String s) {\n+        return hashRabin(s.toCharArray());\n+    }\n+\n+    /**\n+    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n+    *\n+    * @param url The URL of the document to be hashed.\n+    * @return The Rabin hash value for the document.\n+    * @throws IOException If an error occurs while reading the document.\n+    */\n+    public int hashRabin(URL url) throws IOException {\n+        InputStream is = url.openStream();\n+        try {\n+            return hashRabin(is);\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n* Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n*\n* <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n* need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n* you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n* you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n* can make a useful tool.\n*\n* <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n* <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n* in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n* prized primarily for their compactness; in fact, one of their earliest applications was in spell\n* checkers.\n*\n* <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n* vector of a given length. We choose the length of the bit vector and the number of hash functions\n* depending on how many keys we want to add to the set and how high an error rate we are willing to\n* put up with.\n*\n* <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n* length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n* value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n* guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n* function would increase our false-positive rate.\n*\n* <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n* treat the result as an offset into the bit vector, turning on whatever bit we find at that\n* position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n* a Bloom filter.\n*\n* <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n* key. We run the key through our set of hash functions, and then check to see whether the bits at\n* those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n* the filter. If all of the bits are on, we know the key is probably there.\n*\n* <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n* of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n* bits we check will be on, unless the key actually exists in the filter. The relationship between\n* the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n* functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n* will be very dense, increasing the probability of collisions. You can calculate the\n* false-positive rate for any filter using the formula:\n*\n* <p><code>c = ( 1 - e(-kn/m) )k</code>\n*\n* <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n* in the filter, and m is the length of the filter in bits.\n*\n* <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n* are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n* way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n* our limit. The following equation will give us vector length from the error rate and number of\n* keys:\n*\n* <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n*\n* <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n* possible to use calculus to find a minimum for k. You can also find lookup tables for various\n* combinations of error rate, filter size, and number of hash functions at <a\n* href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n* -- the math</a>.\n*\n* <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n* which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n* hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n* the case of JDK 1.4).\n*\n* <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n* fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n* so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n* reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n* very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n* even in this Java implementation the speed is reasonable.\n*\n* <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n* method" by Andrei Broder. See <a\n* href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n* http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n* paper in PDF format.\n*\n* <p>Included in this class are additional methods that can compute the Rabin hash value for any\n* serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n* <code>URL</code>.\n*\n* <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n* initial value multiplied by a list of distinct values.\n*\n* @see java.lang.Object#hashCode()\n* @see java.util.Map\n* @author Bruno Martins\n*/\npublic class BloomFilter implements Cloneable {\n\n    /** A buffer for the Rabin fingerprinting algorithm. */\n    private byte[] buffer;\n\n    /**\n    * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n    * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n    * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n    * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n    * bit is the constant coefficient.\n    *\n    * <p>For example the integer 0x00000803, in binary, is:\n    *\n    * <p><code>00000000 00000000 00001000 00000011</code>\n    *\n    * <p>Therefore it correponds to the polynomial:\n    *\n    * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n    */\n    private static int POLYNOMIAL = 0x000001C7;\n\n    /** Internal values for the Rabin fingerprinting algorithm. */\n    private static int[] table32, table40, table48, table54;\n\n    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n    private static int P_DEGREE = 32;\n\n    /** The size of the buffer for the Rabin fingerprinting algorithm. */\n    private static int READ_BUFFER_SIZE = 2048;\n\n    /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n    private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n    /** The bit vector for the Bloom Filter. */\n    private boolean keys[];\n\n    /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n    private boolean useRabin = true;\n\n    /** The number of hash functions. */\n    private int numFunctions;\n\n    /**\n    * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n    * length for the bit vector (1000).\n    */\n    public BloomFilter() {\n        table32 = new int[256];\n        table40 = new int[256];\n        table48 = new int[256];\n        table54 = new int[256];\n        buffer = new byte[READ_BUFFER_SIZE];\n        // We want to have mods[i] == x^(P_DEGREE+i)\n        int[] mods = new int[P_DEGREE];\n        mods[0] = POLYNOMIAL;\n        for (int i = 1; i < P_DEGREE; i++) {\n            // x^i == x(x^(i-1)) (mod P)\n            mods[i] = mods[i - 1] << 1;\n            // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n            // x^P_DEGREE term that \'fell off\' the top end.\n            // Since x^P_DEGREE == P (mod P), we should add P\n            // to account for this:\n            if ((mods[i - 1] & X_P_DEGREE) != 0) {\n                mods[i] ^= POLYNOMIAL;\n            }\n        }\n        for (int i = 0; i < 256; i++) {\n            int c = i;\n            for (int j = 0; j < 8 && c != 0; j++) {\n                if ((c & 1) != 0) {\n                    table32[i] ^= mods[j];\n                    table40[i] ^= mods[j + 8];\n                    table48[i] ^= mods[j + 16];\n                    table54[i] ^= mods[j + 24];\n                }\n                c >>>= 1;\n            }\n        }\n        mods = null;\n        this.keys = new boolean[1000];\n        this.numFunctions = 10;\n        for (int i = 0; i < 1000; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Constructs a Bloom Filter from a string representation.\n    *\n    * @see #toString()\n    */\n    public BloomFilter(String filter) {\n        this();\n        int index1 = filter.indexOf(":");\n        int index2 = filter.lastIndexOf(":");\n        numFunctions = new Integer(filter.substring(0, index1)).intValue();\n        keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n        for (int i = index2 + 1; i < filter.length(); i++) {\n            if (filter.charAt(i) == \'1\') keys[i] = true;\n            else keys[i] = false;\n        }\n    }\n\n    /**\n    * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n    * error rate.\n    *\n    * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n    */\n    public BloomFilter(int numKeys, double errorRate) {\n        this();\n        double lowest_m = Double.MAX_VALUE;\n        int best_k = 1;\n        for (int k = 1; k <= 100; k++) {\n            double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n            if (m < lowest_m) {\n                lowest_m = m;\n                best_k = k;\n            }\n        }\n        this.keys = new boolean[numKeys];\n        this.numFunctions = best_k;\n        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n    * length for the bit vector.\n    *\n    * @param numKeys The length of the bit vector.\n    */\n    public BloomFilter(int numKeys) {\n        this(numKeys, 10);\n    }\n\n    /**\n    * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n    * the bit vector.\n    *\n    * @param numKeys The length of the bit vector.\n    * @param numHashFunctions The number of hash functions.\n    */\n    public BloomFilter(int numKeys, int numHashFunctions) {\n        this();\n        this.keys = new boolean[numKeys];\n        this.numFunctions = numHashFunctions;\n        for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n    }\n\n    /**\n    * Internal method for producing the hash value for a given function number.\n    *\n    * @param fnum The number of the hash function.\n    * @param original The original value for the hash of the object.\n    * @see java.lang.Object#hashCode()\n    * @return Returns the hash code value for the given function number.\n    */\n    private int getHash(int fnum, int original) {\n        // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n        // int hash = ((fnum * fnum + 1) * original) % keys.length;\n        int hash[] = {original};\n        if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n        else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n        hash[0] = hash[0] % keys.length;\n        if (hash[0] < 0) hash[0] = -hash[0];\n        return hash[0];\n    }\n\n    /**\n    * Returns true if this Bloom Filter contains the specified key.\n    *\n    * @param obj The key whose presence in this Bloom Filter is to be tested.\n    * @return true if this Bloom Filter contains a mapping for the specified key.\n    */\n    public boolean hasKey(Object obj) {\n        boolean result = true;\n        int hashCodeObject;\n        if (!useRabin) hashCodeObject = obj.hashCode();\n        else\n            try {\n                hashCodeObject = hashRabin(obj);\n            } catch (Exception e) {\n                useRabin = false;\n                hashCodeObject = obj.hashCode();\n            }\n        for (int i = 0; i < numFunctions && result; i++) {\n            result &= keys[getHash(i, hashCodeObject)];\n        }\n        return result;\n    }\n\n    /**\n    * Adds the specified key in this Bloom Filter.\n    *\n    * @param obj The key to be added to this Bloom Filter.\n    */\n    public void put(Object obj) {\n        int hashCodeObject;\n        if (!useRabin) hashCodeObject = obj.hashCode();\n        else\n            try {\n                hashCodeObject = hashRabin(obj);\n            } catch (Exception e) {\n                useRabin = false;\n                hashCodeObject = obj.hashCode();\n            }\n        for (int i = 0; i < numFunctions; i++) {\n            keys[getHash(i, hashCodeObject)] = true;\n        }\n    }\n\n    /**\n    * Returns a string representation of this Bloom Filter. The string representation consists of an\n    * integer specifying the number of hash Functions, an integer specifying the length of the bit\n    * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n    * the character ":".\n    *\n    * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n    * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n    * returned.\n    *\n    * @return A string representation of this Bloom Filter.\n    */\n    public String toString() {\n        StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i]) aux.append("1");\n            else aux.append("0");\n        }\n        return aux.toString();\n    }\n\n    /**\n    * Returns a copy of this Bloom Filter instance.\n    *\n    * @see java.lang.Object#clone()\n    */\n    public Object clone() {\n        return new BloomFilter(this.toString());\n    }\n\n    /**\n    * Return the Rabin hash value of an array of bytes.\n    *\n    * @param arr An array of bytes.\n    * @return The Rabin hash value for the array of bytes.\n    */\n    public int hashRabin(byte[] arr) {\n        return hashRabin(arr, 0, arr.length, 0);\n    }\n\n    /**\n    * Return the Rabin hash value of an array of bytes.\n    *\n    * @param arr An array of bytes.\n    * @param offset Index of the first byte of the array to hash.\n    * @param length Number of bytes to hash.\n    * @param ws ??\n    * @return The Rabin hash value for the array of bytes.\n    */\n    private int hashRabin(byte[] arr, int offset, int length, int ws) {\n        int w = ws;\n        int start = length % 4;\n        for (int s = offset; s < offset + start; s++) {\n            w = (w << 8) ^ (arr[s] & 0xFF);\n        }\n        for (int s = start + offset; s < length + offset; s += 4) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ (arr[s] << 24)\n                            ^ ((arr[s + 1] & 0xFF) << 16)\n                            ^ ((arr[s + 2] & 0xFF) << 8)\n                            ^ (arr[s + 3] & 0xFF);\n        }\n        return w;\n    }\n\n    /**\n    * Return the Rabin hash value of an array of chars.\n    *\n    * @param arr An array of chars.\n    * @return The Rabin hash value for the array of chars.\n    */\n    public int hashRabin(char[] arr) {\n        int w = 0;\n        int start = 0;\n        if (arr.length % 2 == 1) {\n            w = arr[0] & 0xFFFF;\n            start = 1;\n        }\n        for (int s = start; s < arr.length; s += 2) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ ((arr[s] & 0xFFFF) << 16)\n                            ^ (arr[s + 1] & 0xFFFF);\n        }\n        return w;\n    }\n\n    /**\n    * Computes the Rabin hash value of the contents of a <code>File</code>.\n    *\n    * @param f A <code>File</code>.\n    * @return The Rabin hash value for the contents of the File.\n    * @throws FileNotFoundException If the file cannot be found.\n    * @throws IOException If an error occurs while reading the file.\n    */\n    public int hashRabin(File f) throws FileNotFoundException, IOException {\n        FileInputStream fis = new FileInputStream(f);\n        try {\n            return hashRabin(fis);\n        } finally {\n            fis.close();\n        }\n    }\n\n    /**\n    * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n    *\n    * @param is An InputStream.\n    * @return The Rabin hash value for the contents read from the InputStream.\n    * @throws IOException if an error occurs while reading from the InputStream.\n    */\n    public int hashRabin(InputStream is) throws IOException {\n        int hashValue = 0;\n        int bytesRead;\n        synchronized (buffer) {\n            while ((bytesRead = is.read(buffer)) > 0) {\n                hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n            }\n        }\n        return hashValue;\n    }\n\n    /**\n    * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n    * the hash methods, so it should be used when possible.\n    *\n    * @param arr An array of integers.\n    * @return int The Rabin hash value for the array of integers.\n    */\n    public int hashRabin(int[] arr) {\n        int w = 0;\n        for (int s = 0; s < arr.length; s++) {\n            w =\n                    table32[w & 0xFF]\n                            ^ table40[(w >>> 8) & 0xFF]\n                            ^ table48[(w >>> 16) & 0xFF]\n                            ^ table54[(w >>> 24) & 0xFF]\n                            ^ arr[s];\n        }\n        return w;\n    }\n\n    /**\n    * Computes the Rabin hash value of a given Object.\n    *\n    * @param obj An Object.\n    * @return The Rabin hash value for the Object.\n    * @throws IOException If Object serialization fails.\n    */\n    public int hashRabin(Object obj) throws IOException {\n        return hashRabin((Serializable) obj);\n    }\n\n    /**\n    * Computes the Rabin hash value of a given serializable Object.\n    *\n    * @param obj An Object.\n    * @return The Rabin hash value for the Object.\n    * @throws IOException If serialization fails.\n    */\n    public int hashRabin(Serializable obj) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = null;\n        try {\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            return hashRabin(baos.toByteArray());\n        } finally {\n            oos.close();\n            baos.close();\n            oos = null;\n            baos = null;\n        }\n    }\n\n    /**\n    * Computes the Rabin hash value of a String.\n    *\n    * @param s A <code>String</code>.\n    * @return The Rabin hash value for the String.\n    */\n    public int hashRabin(String s) {\n        return hashRabin(s.toCharArray());\n    }\n\n    /**\n    * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n    *\n    * @param url The URL of the document to be hashed.\n    * @return The Rabin hash value for the document.\n    * @throws IOException If an error occurs while reading the document.\n    */\n    public int hashRabin(URL url) throws IOException {\n        InputStream is = url.openStream();\n        try {\n            return hashRabin(is);\n        } finally {\n            is.close();\n        }\n    }\n}\n'
          },
          {
            sha: "71b9d58975181f2920de2f84bbf90a2be29c041a",
            filename:
              "src/main/java/refactoring/crawler/shingles/DefaultStrategy.java",
            status: "added",
            additions: 25,
            deletions: 0,
            patch:
              "@@ -0,0 +1,25 @@\n+package refactoring.crawler.shingles;\n+\n+/** @author Can Comertoglu */\n+public class DefaultStrategy implements ShinglesStrategy {\n+\n+    /** */\n+    public DefaultStrategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+    */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base;\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base;\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n    /** */\n    public DefaultStrategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n    */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base;\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base;\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base;\n    }\n}\n"
          },
          {
            sha: "6659640bccbd3ed85cea5d3f6b628fdb4ee58b0d",
            filename:
              "src/main/java/refactoring/crawler/shingles/FactorOf2Strategy.java",
            status: "added",
            additions: 25,
            deletions: 0,
            patch:
              "@@ -0,0 +1,25 @@\n+package refactoring.crawler.shingles;\n+\n+public class FactorOf2Strategy implements ShinglesStrategy {\n+\n+    /** */\n+    public FactorOf2Strategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+    * @Override\n+    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+    */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base + (2 * loc);\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base + (2 * numMethods);\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base + (2 * numClasses);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n    /** */\n    public FactorOf2Strategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n    * @Override\n    * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n    */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base + (2 * loc);\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base + (2 * numMethods);\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base + (2 * numClasses);\n    }\n}\n"
          },
          {
            sha: "3d02565f4d4ec4df212f23cfcadf087258466222",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesStrategy.java",
            status: "renamed",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,4 +1,4 @@\n-package refactoring.crawler.util;\n+package refactoring.crawler.shingles;\n \n public interface ShinglesStrategy {\n     int upperBoundLimitForShinglesBag(int loc, int s_base);",
            rawContent:
              "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n    int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n    int upperBoundForClassShingles(int numMethods, int s_base);\n\n    int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "38779039d33f0a3af17286c2834361ec112a6bea",
            filename:
              "src/main/java/refactoring/crawler/shingles/ShinglesUtil.java",
            status: "added",
            additions: 301,
            deletions: 0,
            patch:
              '@@ -0,0 +1,301 @@\n+package refactoring.crawler.shingles;\n+\n+import java.util.*;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DirectedMultigraph;\n+import org.jgrapht.traverse.BreadthFirstIterator;\n+import refactoring.crawler.graph.Edge;\n+import refactoring.crawler.graph.NamedDirectedMultigraph;\n+import refactoring.crawler.graph.Node;\n+\n+public class ShinglesUtil {\n+\n+    private int w = 2;\n+    private int sClass = 10;\n+    private int sMethod = 8;\n+    private double classThreshold = 0.0;\n+\n+    @Getter @Setter private double methodThreshold = 0.0;\n+\n+    private ShinglesStrategy shinglesStrategy;\n+\n+    private NamedDirectedMultigraph oldVersionGraph;\n+\n+    private NamedDirectedMultigraph newVersionGraph;\n+\n+    private List<Node[]> similarMethods = new LinkedList<>();\n+    private List<Node[]> similarClasses = new LinkedList<>();\n+\n+    private List<Node> oldVersionPackageList;\n+    private List<Node> oldVersionClassList;\n+    private List<Node> oldVersionMethodList;\n+    private List<Node> oldVersionFieldList;\n+\n+    private List<Node> newVersionPackageList;\n+    private List<Node> newVersionClassList;\n+    private List<Node> newVersionMethodList;\n+    private List<Node> newVersionFieldList;\n+\n+    public ShinglesUtil() {\n+        this.shinglesStrategy = new DefaultStrategy();\n+        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+    }\n+\n+    public List<String> tokenizer(String s) {\n+        List<String> list = new ArrayList<>();\n+        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+        while (st.hasMoreElements()) {\n+            list.add(st.nextToken());\n+        }\n+        return list;\n+    }\n+\n+    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+        List<List<String>> bagOfTokensList = new ArrayList<>();\n+        ListIterator<String> iter = tokenList.listIterator();\n+        while (iter.nextIndex() <= (tokenList.size() - w))\n+        // W=2, iterIndex = size - W identifies the last window\n+        {\n+            List<String> tempList = new ArrayList<>();\n+            for (int i = 1; i <= w; i++) // W=3\n+            {\n+                tempList.add(iter.next());\n+            }\n+            bagOfTokensList.add(tempList);\n+            for (int i = 1; i <= w - 1; i++)\n+                // i<= W-1\n+                iter.previous();\n+        }\n+        return bagOfTokensList;\n+    }\n+\n+    private int findNumberOfLines(String str) {\n+        int retval = 0;\n+        char[] c = str.toCharArray();\n+        for (char value : c) {\n+            if (value == \'\\n\') retval++;\n+        }\n+        return retval;\n+    }\n+\n+    public int[] computeMethodShingles(String str) {\n+        return computeMethodShingles(\n+                str,\n+                w,\n+                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+    }\n+\n+    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+        /*\n+        * We are now introducing the idea of finding the number of lines in the\n+        * method, and incorporate that into the calculation of shingles, so\n+        * that, if there are more lines, then there are going to be more\n+        * shingles associated with the method. However, a 1-1 correspondance\n+        * will be misleading, thus another method is required.\n+        */\n+        BloomFilter bloomFilter = new BloomFilter();\n+        List<String> tokenList = tokenizer(str);\n+        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+        int numberOfWindowedTokens = 0;\n+\n+        for (List<String> tempList : bagOfWindowedTokens) {\n+            StringBuilder tokensInOneWindow = new StringBuilder();\n+            for (int i = 0; i < window; i++) {\n+                tokensInOneWindow.append(tempList.get(i));\n+                if (i != window - 1) tokensInOneWindow.append(" ");\n+            }\n+            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+            shinglesValues[numberOfWindowedTokens] = shingle;\n+            numberOfWindowedTokens++;\n+        }\n+\n+        Arrays.sort(shinglesValues);\n+\n+        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n+\n+        int[] retVal = new int[correctNumberOfShingles];\n+        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+        return retVal;\n+    }\n+\n+    public void initialize(\n+            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+        this.oldVersionGraph = oldVersionGraph;\n+        this.newVersionGraph = newVersionGraph;\n+\n+        this.oldVersionPackageList = new ArrayList<>();\n+        this.oldVersionClassList = new ArrayList<>();\n+        this.oldVersionMethodList = new ArrayList<>();\n+        this.oldVersionFieldList = new ArrayList<>();\n+\n+        this.newVersionPackageList = new ArrayList<>();\n+        this.newVersionClassList = new ArrayList<>();\n+        this.newVersionMethodList = new ArrayList<>();\n+        this.newVersionFieldList = new ArrayList<>();\n+\n+        initializeElementsLists(\n+                oldVersionGraph,\n+                oldVersionMethodList,\n+                oldVersionClassList,\n+                oldVersionPackageList,\n+                oldVersionFieldList);\n+\n+        initializeElementsLists(\n+                newVersionGraph,\n+                newVersionMethodList,\n+                newVersionClassList,\n+                newVersionPackageList,\n+                newVersionFieldList);\n+    }\n+\n+    private void initializeElementsLists(\n+            DirectedMultigraph<Node, Edge> graph,\n+            List<Node> methods,\n+            List<Node> classes,\n+            List<Node> packages,\n+            List<Node> fields) {\n+        // Create a BreadthFirstIterator for the graph\n+        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+        while (bfi.hasNext()) {\n+            Node n = bfi.next();\n+            if (n.getType().equals(Node.Type.CLASS)) {\n+                classes.add(n);\n+            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+                packages.add(n);\n+            } else if (n.getType().equals(Node.Type.METHOD)) {\n+                methods.add(n);\n+            } else if (n.getType().equals(Node.Type.FIELD)) {\n+                fields.add(n);\n+            }\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarMethods() {\n+        if (this.similarMethods.isEmpty()) {\n+            List<Node[]> similarMethods = new ArrayList<>();\n+            for (Node m : this.oldVersionMethodList) {\n+                if (!m.isAPI()) continue;\n+\n+                for (Node m2 : this.newVersionMethodList) {\n+                    if (!m2.isAPI()) continue;\n+\n+                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+                        Node[] arr = {m, m2};\n+                        // if (!isThisArrayInTheList(simMet, arr))\n+                        similarMethods.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarMethods = similarMethods;\n+        }\n+        return this.similarMethods;\n+    }\n+\n+    public double howMuchAlike(int[] arr1, int[] arr2) {\n+        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+        return finalGrade;\n+    }\n+\n+    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+        int[] tempArr = arr2.clone();\n+        double grade = 0.0;\n+        for (int value : arr1) {\n+            for (int j = 0; j < tempArr.length; j++) {\n+                if (value == tempArr[j]) {\n+                    grade += 1.0 / arr1.length;\n+                    tempArr[j] = Integer.MIN_VALUE;\n+                    break;\n+                }\n+            }\n+        }\n+        return grade;\n+    }\n+\n+    /**\n+    * @param classes\n+    * @param graph <br>\n+    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n+    *     its subtree. The parameter s_class will determine the maximum size of shingles\n+    */\n+    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+        for (Node clasz : classes) {\n+            // We will keep the number of methods for the class with the\n+            // numberOfMethods variable.\n+            int numberOfMethods = 0;\n+            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+            int methodsTotalShingleSize = 0;\n+            for (Edge e : outEdges) {\n+                Node neighbor = e.oppositeVertex(clasz);\n+                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+                    methodsTotalShingleSize += neighbor.getShingles().length;\n+                    // Here we update the method count.\n+                    numberOfMethods++;\n+                }\n+            }\n+\n+            // fill allShinglesFromMethods with shingles from all the methods in\n+            // the class\n+            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+            int index = 0;\n+            for (Edge e : outEdges) {\n+                Node neighbor = e.oppositeVertex(clasz);\n+                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n+                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n+                        index++;\n+                    }\n+                }\n+            }\n+\n+            int upperBoundForClassShingles =\n+                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n+            Arrays.sort(allShinglesFromMethods);\n+\n+            upperBoundForClassShingles =\n+                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n+\n+            int[] retVal = new int[upperBoundForClassShingles];\n+            if (upperBoundForClassShingles >= 0)\n+                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+            clasz.setShingles(retVal);\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarClasses() {\n+        if (this.similarClasses.isEmpty()) {\n+            computeClassShingles(oldVersionClassList, oldVersionGraph);\n+            computeClassShingles(newVersionClassList, newVersionGraph);\n+            List<Node[]> simClass = new ArrayList<>();\n+            for (Node c : this.oldVersionClassList) {\n+                if (!c.isAPI()) continue;\n+\n+                for (Node c2 : this.oldVersionClassList) {\n+                    if (!c2.isAPI()) continue;\n+\n+                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+                        Node[] arr = {c, c2};\n+                        simClass.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarClasses = simClass;\n+        }\n+        return this.similarClasses;\n+    }\n+\n+    public List<Node[]> findPullUpMethodCandidates() {\n+        return findSimilarMethods();\n+    }\n+\n+    public List<Node[]> findPushDownMethodCandidates() {\n+        return findSimilarMethods();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n    private int w = 2;\n    private int sClass = 10;\n    private int sMethod = 8;\n    private double classThreshold = 0.0;\n\n    @Getter @Setter private double methodThreshold = 0.0;\n\n    private ShinglesStrategy shinglesStrategy;\n\n    private NamedDirectedMultigraph oldVersionGraph;\n\n    private NamedDirectedMultigraph newVersionGraph;\n\n    private List<Node[]> similarMethods = new LinkedList<>();\n    private List<Node[]> similarClasses = new LinkedList<>();\n\n    private List<Node> oldVersionPackageList;\n    private List<Node> oldVersionClassList;\n    private List<Node> oldVersionMethodList;\n    private List<Node> oldVersionFieldList;\n\n    private List<Node> newVersionPackageList;\n    private List<Node> newVersionClassList;\n    private List<Node> newVersionMethodList;\n    private List<Node> newVersionFieldList;\n\n    public ShinglesUtil() {\n        this.shinglesStrategy = new DefaultStrategy();\n        //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n    }\n\n    public List<String> tokenizer(String s) {\n        List<String> list = new ArrayList<>();\n        StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n        while (st.hasMoreElements()) {\n            list.add(st.nextToken());\n        }\n        return list;\n    }\n\n    private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n        List<List<String>> bagOfTokensList = new ArrayList<>();\n        ListIterator<String> iter = tokenList.listIterator();\n        while (iter.nextIndex() <= (tokenList.size() - w))\n        // W=2, iterIndex = size - W identifies the last window\n        {\n            List<String> tempList = new ArrayList<>();\n            for (int i = 1; i <= w; i++) // W=3\n            {\n                tempList.add(iter.next());\n            }\n            bagOfTokensList.add(tempList);\n            for (int i = 1; i <= w - 1; i++)\n                // i<= W-1\n                iter.previous();\n        }\n        return bagOfTokensList;\n    }\n\n    private int findNumberOfLines(String str) {\n        int retval = 0;\n        char[] c = str.toCharArray();\n        for (char value : c) {\n            if (value == \'\\n\') retval++;\n        }\n        return retval;\n    }\n\n    public int[] computeMethodShingles(String str) {\n        return computeMethodShingles(\n                str,\n                w,\n                this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n    }\n\n    public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n        /*\n        * We are now introducing the idea of finding the number of lines in the\n        * method, and incorporate that into the calculation of shingles, so\n        * that, if there are more lines, then there are going to be more\n        * shingles associated with the method. However, a 1-1 correspondance\n        * will be misleading, thus another method is required.\n        */\n        BloomFilter bloomFilter = new BloomFilter();\n        List<String> tokenList = tokenizer(str);\n        List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n        int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n        int numberOfWindowedTokens = 0;\n\n        for (List<String> tempList : bagOfWindowedTokens) {\n            StringBuilder tokensInOneWindow = new StringBuilder();\n            for (int i = 0; i < window; i++) {\n                tokensInOneWindow.append(tempList.get(i));\n                if (i != window - 1) tokensInOneWindow.append(" ");\n            }\n            int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n            shinglesValues[numberOfWindowedTokens] = shingle;\n            numberOfWindowedTokens++;\n        }\n\n        Arrays.sort(shinglesValues);\n\n        int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n        int[] retVal = new int[correctNumberOfShingles];\n        System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n        return retVal;\n    }\n\n    public void initialize(\n            NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n        this.oldVersionGraph = oldVersionGraph;\n        this.newVersionGraph = newVersionGraph;\n\n        this.oldVersionPackageList = new ArrayList<>();\n        this.oldVersionClassList = new ArrayList<>();\n        this.oldVersionMethodList = new ArrayList<>();\n        this.oldVersionFieldList = new ArrayList<>();\n\n        this.newVersionPackageList = new ArrayList<>();\n        this.newVersionClassList = new ArrayList<>();\n        this.newVersionMethodList = new ArrayList<>();\n        this.newVersionFieldList = new ArrayList<>();\n\n        initializeElementsLists(\n                oldVersionGraph,\n                oldVersionMethodList,\n                oldVersionClassList,\n                oldVersionPackageList,\n                oldVersionFieldList);\n\n        initializeElementsLists(\n                newVersionGraph,\n                newVersionMethodList,\n                newVersionClassList,\n                newVersionPackageList,\n                newVersionFieldList);\n    }\n\n    private void initializeElementsLists(\n            DirectedMultigraph<Node, Edge> graph,\n            List<Node> methods,\n            List<Node> classes,\n            List<Node> packages,\n            List<Node> fields) {\n        // Create a BreadthFirstIterator for the graph\n        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n        while (bfi.hasNext()) {\n            Node n = bfi.next();\n            if (n.getType().equals(Node.Type.CLASS)) {\n                classes.add(n);\n            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n                packages.add(n);\n            } else if (n.getType().equals(Node.Type.METHOD)) {\n                methods.add(n);\n            } else if (n.getType().equals(Node.Type.FIELD)) {\n                fields.add(n);\n            }\n        }\n    }\n\n    public List<Node[]> findSimilarMethods() {\n        if (this.similarMethods.isEmpty()) {\n            List<Node[]> similarMethods = new ArrayList<>();\n            for (Node m : this.oldVersionMethodList) {\n                if (!m.isAPI()) continue;\n\n                for (Node m2 : this.newVersionMethodList) {\n                    if (!m2.isAPI()) continue;\n\n                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n                        Node[] arr = {m, m2};\n                        // if (!isThisArrayInTheList(simMet, arr))\n                        similarMethods.add(arr);\n                    }\n                }\n            }\n            this.similarMethods = similarMethods;\n        }\n        return this.similarMethods;\n    }\n\n    public double howMuchAlike(int[] arr1, int[] arr2) {\n        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n        return finalGrade;\n    }\n\n    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n        int[] tempArr = arr2.clone();\n        double grade = 0.0;\n        for (int value : arr1) {\n            for (int j = 0; j < tempArr.length; j++) {\n                if (value == tempArr[j]) {\n                    grade += 1.0 / arr1.length;\n                    tempArr[j] = Integer.MIN_VALUE;\n                    break;\n                }\n            }\n        }\n        return grade;\n    }\n\n    /**\n    * @param classes\n    * @param graph <br>\n    *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n    *     its subtree. The parameter s_class will determine the maximum size of shingles\n    */\n    private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n        for (Node clasz : classes) {\n            // We will keep the number of methods for the class with the\n            // numberOfMethods variable.\n            int numberOfMethods = 0;\n            List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n            int methodsTotalShingleSize = 0;\n            for (Edge e : outEdges) {\n                Node neighbor = e.oppositeVertex(clasz);\n                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n                    methodsTotalShingleSize += neighbor.getShingles().length;\n                    // Here we update the method count.\n                    numberOfMethods++;\n                }\n            }\n\n            // fill allShinglesFromMethods with shingles from all the methods in\n            // the class\n            int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n            Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n            int index = 0;\n            for (Edge e : outEdges) {\n                Node neighbor = e.oppositeVertex(clasz);\n                if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n                    for (int j = 0; j < neighbor.getShingles().length; j++) {\n                        allShinglesFromMethods[index] = neighbor.getShingles()[j];\n                        index++;\n                    }\n                }\n            }\n\n            int upperBoundForClassShingles =\n                    this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n            Arrays.sort(allShinglesFromMethods);\n\n            upperBoundForClassShingles =\n                    Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n            int[] retVal = new int[upperBoundForClassShingles];\n            if (upperBoundForClassShingles >= 0)\n                System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n            clasz.setShingles(retVal);\n        }\n    }\n\n    public List<Node[]> findSimilarClasses() {\n        if (this.similarClasses.isEmpty()) {\n            computeClassShingles(oldVersionClassList, oldVersionGraph);\n            computeClassShingles(newVersionClassList, newVersionGraph);\n            List<Node[]> simClass = new ArrayList<>();\n            for (Node c : this.oldVersionClassList) {\n                if (!c.isAPI()) continue;\n\n                for (Node c2 : this.oldVersionClassList) {\n                    if (!c2.isAPI()) continue;\n\n                    if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n                        Node[] arr = {c, c2};\n                        simClass.add(arr);\n                    }\n                }\n            }\n            this.similarClasses = simClass;\n        }\n        return this.similarClasses;\n    }\n\n    public List<Node[]> findPullUpMethodCandidates() {\n        return findSimilarMethods();\n    }\n\n    public List<Node[]> findPushDownMethodCandidates() {\n        return findSimilarMethods();\n    }\n}\n'
          },
          {
            sha: "fe676e94ebfb94cc6e342fed1ffd6bc08ecda4d1",
            filename: "src/main/java/refactoring/crawler/util/BloomFilter.java",
            status: "removed",
            additions: 0,
            deletions: 544,
            patch:
              '@@ -1,544 +0,0 @@\n-package refactoring.crawler.util;\n-\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-import java.net.URL;\n-\n-/**\n- * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n- * hash table.</p> <p>\n- * \n- * Bloom filters allow you to perform membership tests in just a fraction of the memory \n- * you\'d need to store a full list of keys. As you might suspect, the savings in space \n- * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n- * key from a filter once you\'ve added it in. But in the many cases where those constraints\n- * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n- * \n- * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n- * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n- * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n- * filters were prized primarily for their compactness; in fact, one of their earliest applications\n- *  was in spell checkers.</p> <p>\n- * \n- * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n- * a given length. We choose the length of the bit vector and the number of hash functions\n- * depending on how many keys we want to add to the set and how high an error rate we are\n- * willing to put up with. </p> <p>\n- * \n- * All of the hash functions in a Bloom filter are configured so that their range matches the\n- * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n- * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n- * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n- * function would increase our false-positive rate.</p> <p>\n- * \n- * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n- * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n- * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n- * in a Bloom filter.</p> <p>\n- * \n- * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n- * new key. We run the key through our set of hash functions, and then check to see whether\n- * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n- * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n- * \n- * As you might expect, the false-positive rate depends on the bit vector length and the number\n- * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n- * we check will be on, unless the key actually exists in the filter. The relationship between the\n- * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n- * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n- * filter will be very dense, increasing the probability of collisions. You can calculate the\n- * false-positive rate for any filter using the formula:</p> <p>\n- * \n- * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n- *\n- * Where c is the false positive rate, k is the number of hash functions, n is the number of\n- * keys in the filter, and m is the length of the filter in bits.</p> <p>\n- *\n- * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n- * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n- * need some way of finding out how large a bit vector is to make sure the false-positive rate\n- * never exceeds our limit. The following equation will give us vector length from the error rate\n- * and number of keys:</p> <p>\n- * \n- *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n- *\n- * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n- * possible to use calculus to find a minimum for k. You can also find lookup tables for \n- * various combinations of error rate, filter size, and number of hash functions at \n- * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n- *  \n- * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n- * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n- * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n- *\n- * Alternatively, this class can also use an implementation of a hash function based on Rabin\n- * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n- * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n- * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n- * function with very satisfactory properties. In addition the polynomial operations are fast in\n- * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n- *\n- * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n- * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n- * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n- * paper in PDF format.</p> <p>\n- *\n- * Included in this class are additional methods that can compute the Rabin hash value\n- * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n- *\n- * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n- * initial value multiplied by a list of distinct values.\n- * \n- * @see java.lang.Object#hashCode()\n- * @see java.util.Map\n- *\n- * @author      Bruno Martins\n- */\n-public class BloomFilter implements Cloneable {\n-\n-\t/** A buffer for the Rabin fingerprinting algorithm. */\n-\tprivate byte[] buffer;\n-\t\n-\t/**\n-\t *  The 32 bits of this integer represent the coefficients of the degree 32\n-\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n-\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n-\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n-\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n-\t *  bit is the constant coefficient.</p> <p>\n-\t *\n-\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n-\t *\n-\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n-\t *\n-\t *  Therefore it correponds to the polynomial:</p> <p>\n-\t *\n-\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n-\t */\n-\tprivate static int POLYNOMIAL = 0x000001C7;\n-\n-\t/** Internal values for the Rabin fingerprinting algorithm. */\n-\tprivate static int[] table32, table40, table48, table54;\n-\t\n-\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-\tprivate static int P_DEGREE = 32;\n-\t\n-\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n-\tprivate static int READ_BUFFER_SIZE = 2048;\n-\t\n-\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n-\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n-\n-\t/** The bit vector for the Bloom Filter. */\n-\tprivate boolean keys[];\n-\n-\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n-\tprivate boolean useRabin = true;\n-\t\n-\t/** The number of hash functions. */\n-\tprivate int numFunctions;\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n-\t * and the default length for the bit vector (1000).\n-\t */\n-\tpublic BloomFilter() {\n-\t\ttable32 = new int[256];\n-\t\ttable40 = new int[256];\n-\t\ttable48 = new int[256];\n-\t\ttable54 = new int[256];\n-\t\tbuffer = new byte[READ_BUFFER_SIZE];\n-\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n-\t\tint[] mods = new int[P_DEGREE];\n-\t\tmods[0] = POLYNOMIAL;\n-\t\tfor (int i = 1; i < P_DEGREE; i++) {\n-\t\t\t// x^i == x(x^(i-1)) (mod P)\n-\t\t\tmods[i] = mods[i - 1] << 1;\n-\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n-\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n-\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n-\t\t\t// to account for this:\n-\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n-\t\t\t\tmods[i] ^= POLYNOMIAL;\n-\t\t\t}\n-\t\t}\n-\t\tfor (int i = 0; i < 256; i++) {\n-\t\t\tint c = i;\n-\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n-\t\t\t\tif ((c & 1) != 0) {\n-\t\t\t\t\ttable32[i] ^= mods[j];\n-\t\t\t\t\ttable40[i] ^= mods[j + 8];\n-\t\t\t\t\ttable48[i] ^= mods[j + 16];\n-\t\t\t\t\ttable54[i] ^= mods[j + 24];\n-\t\t\t\t}\n-\t\t\t\tc >>>= 1;\n-\t\t\t}\n-\t\t}\n-\t\tmods = null;\n-\t\tthis.keys = new boolean[1000];\n-\t\tthis.numFunctions = 10;\n-\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t * Constructs a Bloom Filter from a string representation.\n-\t *\n-\t * @see #toString()\n-\t */\n-\tpublic BloomFilter(String filter) {\n-\t\tthis();\n-\t\tint index1 = filter.indexOf(":");\n-\t\tint index2 = filter.lastIndexOf(":");\n-\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n-\t\tkeys =\n-\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n-\t\t\t\t.intValue()];\n-\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n-\t\t\tif (filter.charAt(i) == \'1\')\n-\t\t\t\tkeys[i] = true;\n-\t\t\telse\n-\t\t\t\tkeys[i] = false;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with a given length for the bit vector,\n-\t * guarenteeing a maximum error rate.  \n-\t *\n-\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n-\t */\n-\tpublic BloomFilter(int numKeys, double errorRate) {\n-\t\tthis();\n-\t\tdouble lowest_m = Double.MAX_VALUE;\n-\t\tint best_k = 1;\n-\t\tfor (int k = 1; k <= 100; k++) {\n-\t\t\tdouble m =\n-\t\t\t\t(-1 * k * numKeys)\n-\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n-\t\t\tif (m < lowest_m) {\n-\t\t\t\tlowest_m = m;\n-\t\t\t\tbest_k = k;\n-\t\t\t}\n-\t\t}\n-\t\tthis.keys = new boolean[numKeys];\n-\t\tthis.numFunctions = best_k;\n-\t\tfor (int i = 0; i < numKeys; i++)\n-\t\t\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n-\t * and a given length for the bit vector.\n-\t *\n-\t *@param  numKeys           The length of the bit vector.\n-\t */\n-\tpublic BloomFilter(int numKeys) {\n-\t\tthis(numKeys, 10);\n-\t}\n-\n-\t/**\n-\t * Constructs an empty BloomFilter with a given number of hash functions\n-\t * and a given length for the bit vector.\n-\t *\n-\t *@param  numKeys                The length of the bit vector.\n-\t *@param  numHashFunctions  The number of hash functions.\n-\t */\n-\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n-\t\tthis();\n-\t\tthis.keys = new boolean[numKeys];\n-\t\tthis.numFunctions = numHashFunctions;\n-\t\tfor (int i = 0; i < numKeys; i++)\n-\t\t\tthis.keys[i] = false;\n-\t}\n-\n-\t/**\n-\t *  Internal method for producing the hash value for a given function number.\n-\t *\n-\t * @param  fnum      The number of the hash function.\n-\t * @param  original   The original value for the hash of the object. \n-\t * @see java.lang.Object#hashCode() \n-\t * @return   Returns the hash code value for the given function number.\n-\t */\n-\tprivate int getHash(int fnum, int original) {\n-\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n-\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n-\t\tint hash[] = { original };\n-\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n-\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n-\t\thash[0] = hash[0] % keys.length;\n-\t\tif (hash[0] < 0) hash[0] = -hash[0];\n-\t\treturn hash[0];\n-\t}\n-\n-\t/**\n-\t *  Returns true if this Bloom Filter contains the specified key.\n-\t *\n-\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n-\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n-\t */\n-\tpublic boolean hasKey(Object obj) {\n-\t\tboolean result = true;\n-\t\tint hashCodeObject;\n-\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n-\t\t\thashCodeObject = hashRabin(obj);\n-\t\t} catch ( Exception e ) {\n-\t\t\tuseRabin = false;\n-\t\t\thashCodeObject = obj.hashCode();\n-\t\t}\n-\t\tfor (int i = 0; i < numFunctions && result; i++) {\n-\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t/**\n-\t *  Adds the specified key in this Bloom Filter.\n-\t *\n-\t *@param  obj  The key to be added to this Bloom Filter.\n-\t */\n-\tpublic void put(Object obj) {\n-\t\tint hashCodeObject;\n-\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n-\t\t\thashCodeObject = hashRabin(obj);\n-\t\t} catch ( Exception e ) {\n-\t\t\tuseRabin = false;\n-\t\t\thashCodeObject = obj.hashCode();\n-\t\t}\n-\t\tfor (int i = 0; i < numFunctions; i++) {\n-\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *\n-\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n-\t * integer specifying the number of hash Functions, an integer specifying the length of the\n-\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n-\t * separated by the character ":".\n-\t * \n-\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n-\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n-\t * \n-\t * @return A string representation of this Bloom Filter.\n-\t */\n-\tpublic String toString() {\n-\t\tStringBuffer aux =\n-\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n-\t\tfor (int i = 0; i < keys.length; i++) {\n-\t\t\tif (keys[i])\n-\t\t\t\taux.append("1");\n-\t\t\telse\n-\t\t\t\taux.append("0");\n-\t\t}\n-\t\treturn aux.toString();\n-\t}\n-\n-\t/**\n-\t * Returns a copy of this Bloom Filter instance.\n-\t *\n-\t * @see java.lang.Object#clone()\n-\t */\n-\tpublic Object clone() {\n-\t\treturn new BloomFilter(this.toString());\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of bytes.\n-\t *\n-\t *@param  arr  An array of bytes.\n-\t *@return    The Rabin hash value for the array of bytes.\n-\t */\n-\tpublic int hashRabin(byte[] arr) {\n-\t\treturn hashRabin(arr, 0, arr.length, 0);\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of bytes.\n-\t *\n-\t *@param  arr        An array of bytes.\n-\t *@param  offset    Index of the first byte of the array to hash.\n-\t *@param  length   Number of bytes to hash.\n-\t *@param  ws          ??         \n-\t *@return  The Rabin hash value for the array of bytes.\n-\t */\n-\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n-\t\tint w = ws;\n-\t\tint start = length % 4;\n-\t\tfor (int s = offset; s < offset + start; s++) {\n-\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n-\t\t}\n-\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ (arr[s] << 24)\n-\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n-\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n-\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Return the Rabin hash value of an array of chars.\n-\t *\n-\t *@param  arr  An array of chars.\n-\t *@return   The Rabin hash value for the array of chars.\n-\t */\n-\tpublic int hashRabin(char[] arr) {\n-\t\tint w = 0;\n-\t\tint start = 0;\n-\t\tif (arr.length % 2 == 1) {\n-\t\t\tw = arr[0] & 0xFFFF;\n-\t\t\tstart = 1;\n-\t\t}\n-\t\tfor (int s = start; s < arr.length; s += 2) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n-\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n-\t *\n-\t *@param  f                       A <code>File</code>.\n-\t *@return                          The Rabin hash value for the contents of the File.\n-\t *@throws  FileNotFoundException  If the file cannot be found.\n-\t *@throws  IOException            If an error occurs while reading the file.\n-\t */\n-\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n-\t\tFileInputStream fis = new FileInputStream(f);\n-\t\ttry {\n-\t\t\treturn hashRabin(fis);\n-\t\t} finally {\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n-\t *\n-\t *@param  is          An InputStream.\n-\t *@return               The Rabin hash value for the contents read from the InputStream.\n-\t *@throws  IOException  if an error occurs while reading from the InputStream.\n-\t */\n-\tpublic int hashRabin(InputStream is) throws IOException {\n-\t\tint hashValue = 0;\n-\t\tint bytesRead;\n-\t\tsynchronized (buffer) {\n-\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n-\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n-\t\t\t}\n-\t\t}\n-\t\treturn hashValue;\n-\t}\n-\n-\t/**\n-\t *  Returns the Rabin hash value of an array of integers. This method is the\n-\t *  most efficient of all the hash methods, so it should be used when\n-\t *  possible.\n-\t *\n-\t *@param   arr  An array of integers.\n-\t *@return    int The Rabin hash value for the array of integers.\n-\t */\n-\tpublic int hashRabin(int[] arr) {\n-\t\tint w = 0;\n-\t\tfor (int s = 0; s < arr.length; s++) {\n-\t\t\tw =\n-\t\t\t\ttable32[w\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table40[(w >>> 8)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table48[(w >>> 16)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ table54[(w >>> 24)\n-\t\t\t\t\t& 0xFF]\n-\t\t\t\t\t^ arr[s];\n-\t\t}\n-\t\treturn w;\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a given Object.\n-\t *\n-\t *@param  obj            An Object.\n-\t *@return                   The Rabin hash value for the Object.\n-\t *@throws  IOException  If Object serialization fails.\n-\t */\n-\tpublic int hashRabin(Object obj) throws IOException {\n-\t\treturn hashRabin((Serializable) obj);\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a given serializable Object.\n-\t *\n-\t *@param  obj             An Object.\n-\t *@return                   The Rabin hash value for the Object.\n-\t *@throws  IOException  If serialization fails.\n-\t */\n-\tpublic int hashRabin(Serializable obj) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\t\tObjectOutputStream oos = null;\n-\t\ttry {\n-\t\t\toos = new ObjectOutputStream(baos);\n-\t\t\toos.writeObject(obj);\n-\t\t\treturn hashRabin(baos.toByteArray());\n-\t\t} finally {\n-\t\t\toos.close();\n-\t\t\tbaos.close();\n-\t\t\toos = null;\n-\t\t\tbaos = null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of a String.\n-\t *\n-\t *@param  s  A <code>String</code>.\n-\t *@return   The Rabin hash value for the String.\n-\t */\n-\tpublic int hashRabin(String s) {\n-\t\treturn hashRabin(s.toCharArray());\n-\t}\n-\n-\t/**\n-\t *  Computes the Rabin hash value of the contents of a Web document,\n-\t *  specified by an URL.\n-\t *\n-\t *@param  url         The URL of the document to be hashed.\n-\t *@return               The Rabin hash value for the document.\n-\t *@throws  IOException If an error occurs while reading the document.\n-\t */\n-\tpublic int hashRabin(URL url) throws IOException {\n-\t\tInputStream is = url.openStream();\n-\t\ttry {\n-\t\t\treturn hashRabin(is);\n-\t\t} finally {\n-\t\t\tis.close();\n-\t\t}\n-\t}\n-\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n * hash table.</p> <p>\n * \n * Bloom filters allow you to perform membership tests in just a fraction of the memory \n * you\'d need to store a full list of keys. As you might suspect, the savings in space \n * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n * key from a filter once you\'ve added it in. But in the many cases where those constraints\n * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n * \n * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n * filters were prized primarily for their compactness; in fact, one of their earliest applications\n *  was in spell checkers.</p> <p>\n * \n * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n * a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are\n * willing to put up with. </p> <p>\n * \n * All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.</p> <p>\n * \n * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n * in a Bloom filter.</p> <p>\n * \n * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n * new key. We run the key through our set of hash functions, and then check to see whether\n * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n * \n * As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n * we check will be on, unless the key actually exists in the filter. The relationship between the\n * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n * filter will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:</p> <p>\n * \n * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n *\n * Where c is the false positive rate, k is the number of hash functions, n is the number of\n * keys in the filter, and m is the length of the filter in bits.</p> <p>\n *\n * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n * need some way of finding out how large a bit vector is to make sure the false-positive rate\n * never exceeds our limit. The following equation will give us vector length from the error rate\n * and number of keys:</p> <p>\n * \n *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n *\n * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for \n * various combinations of error rate, filter size, and number of hash functions at \n * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n *  \n * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n *\n * Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n * function with very satisfactory properties. In addition the polynomial operations are fast in\n * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n *\n * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.</p> <p>\n *\n * Included in this class are additional methods that can compute the Rabin hash value\n * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n *\n * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n * \n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n *\n * @author      Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n\t/** A buffer for the Rabin fingerprinting algorithm. */\n\tprivate byte[] buffer;\n\t\n\t/**\n\t *  The 32 bits of this integer represent the coefficients of the degree 32\n\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n\t *  bit is the constant coefficient.</p> <p>\n\t *\n\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n\t *\n\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n\t *\n\t *  Therefore it correponds to the polynomial:</p> <p>\n\t *\n\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n\t */\n\tprivate static int POLYNOMIAL = 0x000001C7;\n\n\t/** Internal values for the Rabin fingerprinting algorithm. */\n\tprivate static int[] table32, table40, table48, table54;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int P_DEGREE = 32;\n\t\n\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n\tprivate static int READ_BUFFER_SIZE = 2048;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n\t/** The bit vector for the Bloom Filter. */\n\tprivate boolean keys[];\n\n\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n\tprivate boolean useRabin = true;\n\t\n\t/** The number of hash functions. */\n\tprivate int numFunctions;\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and the default length for the bit vector (1000).\n\t */\n\tpublic BloomFilter() {\n\t\ttable32 = new int[256];\n\t\ttable40 = new int[256];\n\t\ttable48 = new int[256];\n\t\ttable54 = new int[256];\n\t\tbuffer = new byte[READ_BUFFER_SIZE];\n\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n\t\tint[] mods = new int[P_DEGREE];\n\t\tmods[0] = POLYNOMIAL;\n\t\tfor (int i = 1; i < P_DEGREE; i++) {\n\t\t\t// x^i == x(x^(i-1)) (mod P)\n\t\t\tmods[i] = mods[i - 1] << 1;\n\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n\t\t\t// to account for this:\n\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n\t\t\t\tmods[i] ^= POLYNOMIAL;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tint c = i;\n\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n\t\t\t\tif ((c & 1) != 0) {\n\t\t\t\t\ttable32[i] ^= mods[j];\n\t\t\t\t\ttable40[i] ^= mods[j + 8];\n\t\t\t\t\ttable48[i] ^= mods[j + 16];\n\t\t\t\t\ttable54[i] ^= mods[j + 24];\n\t\t\t\t}\n\t\t\t\tc >>>= 1;\n\t\t\t}\n\t\t}\n\t\tmods = null;\n\t\tthis.keys = new boolean[1000];\n\t\tthis.numFunctions = 10;\n\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs a Bloom Filter from a string representation.\n\t *\n\t * @see #toString()\n\t */\n\tpublic BloomFilter(String filter) {\n\t\tthis();\n\t\tint index1 = filter.indexOf(":");\n\t\tint index2 = filter.lastIndexOf(":");\n\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n\t\tkeys =\n\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n\t\t\t\t.intValue()];\n\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n\t\t\tif (filter.charAt(i) == \'1\')\n\t\t\t\tkeys[i] = true;\n\t\t\telse\n\t\t\t\tkeys[i] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given length for the bit vector,\n\t * guarenteeing a maximum error rate.  \n\t *\n\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n\t */\n\tpublic BloomFilter(int numKeys, double errorRate) {\n\t\tthis();\n\t\tdouble lowest_m = Double.MAX_VALUE;\n\t\tint best_k = 1;\n\t\tfor (int k = 1; k <= 100; k++) {\n\t\t\tdouble m =\n\t\t\t\t(-1 * k * numKeys)\n\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n\t\t\tif (m < lowest_m) {\n\t\t\t\tlowest_m = m;\n\t\t\t\tbest_k = k;\n\t\t\t}\n\t\t}\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = best_k;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys           The length of the bit vector.\n\t */\n\tpublic BloomFilter(int numKeys) {\n\t\tthis(numKeys, 10);\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given number of hash functions\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys                The length of the bit vector.\n\t *@param  numHashFunctions  The number of hash functions.\n\t */\n\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n\t\tthis();\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = numHashFunctions;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t *  Internal method for producing the hash value for a given function number.\n\t *\n\t * @param  fnum      The number of the hash function.\n\t * @param  original   The original value for the hash of the object. \n\t * @see java.lang.Object#hashCode() \n\t * @return   Returns the hash code value for the given function number.\n\t */\n\tprivate int getHash(int fnum, int original) {\n\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n\t\tint hash[] = { original };\n\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n\t\thash[0] = hash[0] % keys.length;\n\t\tif (hash[0] < 0) hash[0] = -hash[0];\n\t\treturn hash[0];\n\t}\n\n\t/**\n\t *  Returns true if this Bloom Filter contains the specified key.\n\t *\n\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n\t */\n\tpublic boolean hasKey(Object obj) {\n\t\tboolean result = true;\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions && result; i++) {\n\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t *  Adds the specified key in this Bloom Filter.\n\t *\n\t *@param  obj  The key to be added to this Bloom Filter.\n\t */\n\tpublic void put(Object obj) {\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions; i++) {\n\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n\t * integer specifying the number of hash Functions, an integer specifying the length of the\n\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n\t * separated by the character ":".\n\t * \n\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n\t * \n\t * @return A string representation of this Bloom Filter.\n\t */\n\tpublic String toString() {\n\t\tStringBuffer aux =\n\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i])\n\t\t\t\taux.append("1");\n\t\t\telse\n\t\t\t\taux.append("0");\n\t\t}\n\t\treturn aux.toString();\n\t}\n\n\t/**\n\t * Returns a copy of this Bloom Filter instance.\n\t *\n\t * @see java.lang.Object#clone()\n\t */\n\tpublic Object clone() {\n\t\treturn new BloomFilter(this.toString());\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr  An array of bytes.\n\t *@return    The Rabin hash value for the array of bytes.\n\t */\n\tpublic int hashRabin(byte[] arr) {\n\t\treturn hashRabin(arr, 0, arr.length, 0);\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr        An array of bytes.\n\t *@param  offset    Index of the first byte of the array to hash.\n\t *@param  length   Number of bytes to hash.\n\t *@param  ws          ??         \n\t *@return  The Rabin hash value for the array of bytes.\n\t */\n\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n\t\tint w = ws;\n\t\tint start = length % 4;\n\t\tfor (int s = offset; s < offset + start; s++) {\n\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n\t\t}\n\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ (arr[s] << 24)\n\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of chars.\n\t *\n\t *@param  arr  An array of chars.\n\t *@return   The Rabin hash value for the array of chars.\n\t */\n\tpublic int hashRabin(char[] arr) {\n\t\tint w = 0;\n\t\tint start = 0;\n\t\tif (arr.length % 2 == 1) {\n\t\t\tw = arr[0] & 0xFFFF;\n\t\t\tstart = 1;\n\t\t}\n\t\tfor (int s = start; s < arr.length; s += 2) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n\t *\n\t *@param  f                       A <code>File</code>.\n\t *@return                          The Rabin hash value for the contents of the File.\n\t *@throws  FileNotFoundException  If the file cannot be found.\n\t *@throws  IOException            If an error occurs while reading the file.\n\t */\n\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n\t\tFileInputStream fis = new FileInputStream(f);\n\t\ttry {\n\t\t\treturn hashRabin(fis);\n\t\t} finally {\n\t\t\tfis.close();\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n\t *\n\t *@param  is          An InputStream.\n\t *@return               The Rabin hash value for the contents read from the InputStream.\n\t *@throws  IOException  if an error occurs while reading from the InputStream.\n\t */\n\tpublic int hashRabin(InputStream is) throws IOException {\n\t\tint hashValue = 0;\n\t\tint bytesRead;\n\t\tsynchronized (buffer) {\n\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n\t\t\t}\n\t\t}\n\t\treturn hashValue;\n\t}\n\n\t/**\n\t *  Returns the Rabin hash value of an array of integers. This method is the\n\t *  most efficient of all the hash methods, so it should be used when\n\t *  possible.\n\t *\n\t *@param   arr  An array of integers.\n\t *@return    int The Rabin hash value for the array of integers.\n\t */\n\tpublic int hashRabin(int[] arr) {\n\t\tint w = 0;\n\t\tfor (int s = 0; s < arr.length; s++) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ arr[s];\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given Object.\n\t *\n\t *@param  obj            An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If Object serialization fails.\n\t */\n\tpublic int hashRabin(Object obj) throws IOException {\n\t\treturn hashRabin((Serializable) obj);\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given serializable Object.\n\t *\n\t *@param  obj             An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If serialization fails.\n\t */\n\tpublic int hashRabin(Serializable obj) throws IOException {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = null;\n\t\ttry {\n\t\t\toos = new ObjectOutputStream(baos);\n\t\t\toos.writeObject(obj);\n\t\t\treturn hashRabin(baos.toByteArray());\n\t\t} finally {\n\t\t\toos.close();\n\t\t\tbaos.close();\n\t\t\toos = null;\n\t\t\tbaos = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a String.\n\t *\n\t *@param  s  A <code>String</code>.\n\t *@return   The Rabin hash value for the String.\n\t */\n\tpublic int hashRabin(String s) {\n\t\treturn hashRabin(s.toCharArray());\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a Web document,\n\t *  specified by an URL.\n\t *\n\t *@param  url         The URL of the document to be hashed.\n\t *@return               The Rabin hash value for the document.\n\t *@throws  IOException If an error occurs while reading the document.\n\t */\n\tpublic int hashRabin(URL url) throws IOException {\n\t\tInputStream is = url.openStream();\n\t\ttry {\n\t\t\treturn hashRabin(is);\n\t\t} finally {\n\t\t\tis.close();\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "00cee96d44bda296bedd8ace9164f49a11748191",
            filename: "src/main/java/refactoring/crawler/util/ClassNode.java",
            status: "removed",
            additions: 0,
            deletions: 28,
            patch:
              "@@ -1,28 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.List;\n-import java.util.LinkedList;\n-\n-public class ClassNode extends Node {\n-\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> classesImported = new LinkedList<>();\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> superClasses = new LinkedList<>();\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic ClassNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.CLASS);\n-\t}\n-\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\nimport java.util.LinkedList;\n\npublic class ClassNode extends Node {\n\n\n\t@Getter\n\t@Setter\n\tprivate List<String> classesImported = new LinkedList<>();\n\n\t@Getter\n\t@Setter\n\tprivate List<String> superClasses = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic ClassNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.CLASS);\n\t}\n\n\n}\n"
          },
          {
            sha: "12047025139d93dc12dde8e522729241033a06b8",
            filename:
              "src/main/java/refactoring/crawler/util/DefaultStrategy.java",
            status: "removed",
            additions: 0,
            deletions: 30,
            patch:
              "@@ -1,30 +0,0 @@\n-package refactoring.crawler.util;\n-\n-/**\n- * @author Can Comertoglu\n- */\n-public class DefaultStrategy implements ShinglesStrategy {\n-\n-\t/**\n-\t *\n-\t */\n-\tpublic DefaultStrategy() {\n-\t\tsuper();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-\t */\n-\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n-\t\treturn s_base;\n-\t}\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\n/**\n * @author Can Comertoglu\n */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic DefaultStrategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base;\n\t}\n\n}\n"
          },
          {
            sha: "d6fae800777369e76bd1270cd1dc09563d8cd0cd",
            filename:
              "src/main/java/refactoring/crawler/util/DirectedEdge.java",
            status: "removed",
            additions: 0,
            deletions: 4,
            patch:
              "@@ -1,4 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class DirectedEdge {\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class DirectedEdge {\n}\n"
          },
          {
            sha: "6cebaf36c9c7009584cf32c1ff857cdfb7f4813d",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "removed",
            additions: 0,
            deletions: 37,
            patch:
              '@@ -1,37 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import org.jgrapht.graph.DefaultEdge;\n-\n-public class Edge extends DefaultEdge {\n-\n-\t@Getter\n-\t@Setter\n-\tprivate Node.Type label;\n-\n-\tpublic Edge(Node.Type label) {\n-\t\tthis.label = label;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-\t}\n-\n-\t@Override\n-\tpublic Node getSource() {\n-\t\treturn (Node) super.getSource();\n-\t}\n-\n-\t@Override\n-\tpublic Node getTarget() {\n-\t\treturn (Node) super.getTarget();\n-\t}\n-\n-\tpublic Node oppositeVertex(Node n) {\n-\t\tNode source = this.getSource();\n-\t\tNode target = this.getTarget();\n-\t\treturn n.equals(source) ? target : source;\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n\t@Getter\n\t@Setter\n\tprivate Node.Type label;\n\n\tpublic Edge(Node.Type label) {\n\t\tthis.label = label;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n\t}\n\n\t@Override\n\tpublic Node getSource() {\n\t\treturn (Node) super.getSource();\n\t}\n\n\t@Override\n\tpublic Node getTarget() {\n\t\treturn (Node) super.getTarget();\n\t}\n\n\tpublic Node oppositeVertex(Node n) {\n\t\tNode source = this.getSource();\n\t\tNode target = this.getTarget();\n\t\treturn n.equals(source) ? target : source;\n\t}\n}\n'
          },
          {
            sha: "5e4173ffc4ab3d1c31902027268e6658fe26be2f",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "removed",
            additions: 0,
            deletions: 28,
            patch:
              "@@ -1,28 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class FactorOf2Strategy implements ShinglesStrategy {\n-\n-\t/**\n-\t *\n-\t */\n-\tpublic FactorOf2Strategy() {\n-\t\tsuper();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @Override\n-\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-\t */\n-\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-\t\treturn s_base + (2 * loc);\n-\t}\n-\n-\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n-\t\treturn s_base + (2 * numMethods);\n-\t}\n-\n-\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n-\t\treturn s_base + (2 * numClasses);\n-\t}\n-\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic FactorOf2Strategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @Override\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base + (2 * loc);\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base + (2 * numMethods);\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base + (2 * numClasses);\n\t}\n\n}\n"
          },
          {
            sha: "3edd7e34e34292cefdbea31e40877cd476a0c10b",
            filename: "src/main/java/refactoring/crawler/util/FieldNode.java",
            status: "removed",
            additions: 0,
            deletions: 20,
            patch:
              "@@ -1,20 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.List;\n-\n-public class FieldNode extends Node {\n-\n-\t@Getter\n-\t@Setter\n-\tprivate List<String> fieldReferenceToMethod;\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic FieldNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.FIELD);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\npublic class FieldNode extends Node {\n\n\t@Getter\n\t@Setter\n\tprivate List<String> fieldReferenceToMethod;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic FieldNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.FIELD);\n\t}\n}\n"
          },
          {
            sha: "5e95b415b9c2ed14017572d7f3eb2cb290726203",
            filename: "src/main/java/refactoring/crawler/util/MethodNode.java",
            status: "removed",
            additions: 0,
            deletions: 35,
            patch:
              "@@ -1,35 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import jdk.nashorn.internal.codegen.CompilerConstants;\n-import lombok.AllArgsConstructor;\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class MethodNode extends Node {\n-\n-\t@AllArgsConstructor\n-\tpublic static class CalledMethod {\n-\t\t@Getter\n-\t\t@Setter\n-\t\tprivate String fullyQualifiedNameWithoutSignature;\n-\n-\t\t@Getter\n-\t\t@Setter\n-\t\tprivate String fullyQualifiedNameWithSignature;\n-\t}\n-\n-\t@Setter\n-\t@Getter\n-\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t */\n-\tpublic MethodNode(String fullyQualifiedName) {\n-\t\tsuper(fullyQualifiedName, Type.METHOD);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport jdk.nashorn.internal.codegen.CompilerConstants;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MethodNode extends Node {\n\n\t@AllArgsConstructor\n\tpublic static class CalledMethod {\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithoutSignature;\n\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithSignature;\n\t}\n\n\t@Setter\n\t@Getter\n\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic MethodNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.METHOD);\n\t}\n}\n"
          },
          {
            sha: "b88943178596cfa00a23eb9dfea16003b1d12e03",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "removed",
            additions: 0,
            deletions: 38,
            patch:
              "@@ -1,38 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import org.jgrapht.graph.DirectedMultigraph;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Supplier;\n-\n-public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n-\n-\t@Getter\n-\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n-\n-\tpublic NamedDirectedMultigraph() {\n-\t\tsuper(Edge.class);\n-\t}\n-\n-\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n-\t}\n-\n-\tpublic boolean addNamedVertex(Node v) {\n-\t\tif (!addVertex(v))\n-\t\t\treturn false;\n-\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n-\t\treturn true;\n-\t}\n-\n-\tpublic Node findNamedNode(String name) {\n-\t\treturn namedVertexMap.get(name);\n-\t}\n-\n-\n-\tpublic boolean hasNamedNode(String name) {\n-\t\treturn namedVertexMap.containsKey(name);\n-\t}\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n\n\n\tpublic boolean hasNamedNode(String name) {\n\t\treturn namedVertexMap.containsKey(name);\n\t}\n}\n"
          },
          {
            sha: "4b07c12c621dc8ab22d3c950d6c1f96229b7f0e6",
            filename: "src/main/java/refactoring/crawler/util/NamedGraph.java",
            status: "removed",
            additions: 0,
            deletions: 8,
            patch:
              "@@ -1,8 +0,0 @@\n-package refactoring.crawler.util;\n-\n-public class NamedGraph {\n-\n-    public Node findNamedNode(String name) {\n-        return null;\n-    }\n-}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class NamedGraph {\n\n    public Node findNamedNode(String name) {\n        return null;\n    }\n}\n"
          },
          {
            sha: "b31e4580aad57d3fb656e5bed35e174040baacd4",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "removed",
            additions: 0,
            deletions: 94,
            patch:
              '@@ -1,94 +0,0 @@\n-package refactoring.crawler.util;\n-\n-\n-import lombok.Getter;\n-import lombok.RequiredArgsConstructor;\n-import lombok.Setter;\n-\n-import java.awt.*;\n-\n-\n-public class Node {\n-\n-\tpublic boolean hasCallGraph() {\n-\t\treturn false;\n-\t}\n-\n-\tpublic void setCreatedCallGraph() {\n-\t}\n-\n-\tpublic static enum Type {\n-\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n-\t}\n-\n-\n-\t@Getter\n-\t@Setter\n-\tprivate String fullyQualifiedName;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate Node.Type type;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate int[] shingles;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean hasCallGraph;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate String projectName;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean isAPI = false;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate String signature;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate int flags;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean deprecated = false;\n-\n-\t@Setter\n-\t@Getter\n-\tprivate boolean isInterface = false;\n-\n-\t@Getter\n-\t@Setter\n-\tprivate boolean isStatic = false;\n-\n-\t/**\n-\t * @param fullyQualifiedName fullyQualifiedName\n-\t * @param type               type\n-\t */\n-\tpublic Node(String fullyQualifiedName, Node.Type type) {\n-\t\tthis.fullyQualifiedName = fullyQualifiedName;\n-\t\tthis.type = type;\n-\t}\n-\n-\tpublic String getSimpleName() {\n-\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n-\t\tif (pos != -1) {\n-\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n-\t\t\t\t.length());\n-\t\t}\n-\t\treturn fullyQualifiedName;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tif (getSignature() != null)\n-\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n-\t\telse\n-\t\t\treturn getType() + "= " + getFullyQualifiedName();\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isStatic = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "2f92af410009b7345543ded2ab02091f76f920c2",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "modified",
            additions: 22,
            deletions: 25,
            patch:
              '@@ -1,37 +1,34 @@\n package refactoring.crawler.util;\n \n+import java.util.List;\n import lombok.Getter;\n import lombok.Setter;\n-import java.util.List;\n+import refactoring.crawler.graph.Node;\n \n public class RefactoringCategory {\n \n-\t@Getter\n-\t@Setter\n-\tprivate String name;\n+    @Getter @Setter private String name;\n \n-\t@Getter\n-\t@Setter\n-\tprivate List<Node[]> refactoringPairs;\n+    @Getter @Setter private List<Node[]> refactoringPairs;\n \n-\tpublic Node[][] getElements() {\n-\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n-\t\tint i = 0;\n-\t\tfor (Node[] pair : refactoringPairs) {\n-\t\t\telements[i++] = pair;\n-\t\t}\n-\t\treturn elements;\n-\t}\n+    public Node[][] getElements() {\n+        Node[][] elements = new Node[refactoringPairs.size()][];\n+        int i = 0;\n+        for (Node[] pair : refactoringPairs) {\n+            elements[i++] = pair;\n+        }\n+        return elements;\n+    }\n \n-\tpublic String toString() {\n-\t\treturn name + printElements(getElements());\n-\t}\n+    public String toString() {\n+        return name + printElements(getElements());\n+    }\n \n-\tprivate String printElements(Node[][] array) {\n-\t\tStringBuilder res = new StringBuilder();\n-\t\tfor (Node[] nodes : array) {\n-\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n-\t\t}\n-\t\treturn res.toString();\n-\t}\n+    private String printElements(Node[][] array) {\n+        StringBuilder res = new StringBuilder();\n+        for (Node[] nodes : array) {\n+            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n+        }\n+        return res.toString();\n+    }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n    @Getter @Setter private String name;\n\n    @Getter @Setter private List<Node[]> refactoringPairs;\n\n    public Node[][] getElements() {\n        Node[][] elements = new Node[refactoringPairs.size()][];\n        int i = 0;\n        for (Node[] pair : refactoringPairs) {\n            elements[i++] = pair;\n        }\n        return elements;\n    }\n\n    public String toString() {\n        return name + printElements(getElements());\n    }\n\n    private String printElements(Node[][] array) {\n        StringBuilder res = new StringBuilder();\n        for (Node[] nodes : array) {\n            res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n        }\n        return res.toString();\n    }\n}\n'
          },
          {
            sha: "9801e24b80c70d9b0bb8d32c20ec878e51851ca6",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "removed",
            additions: 0,
            deletions: 297,
            patch:
              '@@ -1,297 +0,0 @@\n-package refactoring.crawler.util;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.jgrapht.graph.DirectedMultigraph;\n-import org.jgrapht.traverse.BreadthFirstIterator;\n-\n-import java.util.*;\n-\n-public class ShinglesUtil {\n-\n-\tprivate int w = 2;\n-\tprivate int sClass = 10;\n-\tprivate int sMethod = 8;\n-\tprivate double classThreshold = 0.0;\n-\n-\t@Getter\n-\t@Setter\n-\tprivate double methodThreshold = 0.0;\n-\n-\n-\tprivate ShinglesStrategy shinglesStrategy;\n-\n-\tprivate NamedDirectedMultigraph oldVersionGraph;\n-\n-\tprivate NamedDirectedMultigraph newVersionGraph;\n-\n-\tprivate List<Node[]> similarMethods = new LinkedList<>();\n-\tprivate List<Node[]> similarClasses = new LinkedList<>();\n-\n-\n-\tprivate List<Node> oldVersionPackageList;\n-\tprivate List<Node> oldVersionClassList;\n-\tprivate List<Node> oldVersionMethodList;\n-\tprivate List<Node> oldVersionFieldList;\n-\n-\tprivate List<Node> newVersionPackageList;\n-\tprivate List<Node> newVersionClassList;\n-\tprivate List<Node> newVersionMethodList;\n-\tprivate List<Node> newVersionFieldList;\n-\n-\tpublic ShinglesUtil() {\n-\t\tthis.shinglesStrategy = new DefaultStrategy();\n-//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n-\t}\n-\n-\tpublic List<String> tokenizer(String s) {\n-\t\tList<String> list = new ArrayList<>();\n-\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n-\t\twhile (st.hasMoreElements()) {\n-\t\t\tlist.add(st.nextToken());\n-\t\t}\n-\t\treturn list;\n-\t}\n-\n-\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n-\n-\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n-\t\tListIterator<String> iter = tokenList.listIterator();\n-\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n-\t\t// W=2, iterIndex = size - W identifies the last window\n-\t\t{\n-\t\t\tList<String> tempList = new ArrayList<>();\n-\t\t\tfor (int i = 1; i <= w; i++) // W=3\n-\t\t\t{\n-\t\t\t\ttempList.add(iter.next());\n-\t\t\t}\n-\t\t\tbagOfTokensList.add(tempList);\n-\t\t\tfor (int i = 1; i <= w - 1; i++)\n-\t\t\t\t// i<= W-1\n-\t\t\t\titer.previous();\n-\t\t}\n-\t\treturn bagOfTokensList;\n-\t}\n-\n-\tprivate int findNumberOfLines(String str) {\n-\t\tint retval = 0;\n-\t\tchar[] c = str.toCharArray();\n-\t\tfor (char value : c) {\n-\t\t\tif (value == \'\\n\')\n-\t\t\t\tretval++;\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\tpublic int[] computeMethodShingles(String str) {\n-\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n-\t}\n-\n-\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n-\t\t/*\n-\t\t * We are now introducing the idea of finding the number of lines in the\n-\t\t * method, and incorporate that into the calculation of shingles, so\n-\t\t * that, if there are more lines, then there are going to be more\n-\t\t * shingles associated with the method. However, a 1-1 correspondance\n-\t\t * will be misleading, thus another method is required.\n-\t\t */\n-\t\tBloomFilter bloomFilter = new BloomFilter();\n-\t\tList<String> tokenList = tokenizer(str);\n-\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n-\n-\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n-\t\tint numberOfWindowedTokens = 0;\n-\n-\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n-\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n-\t\t\tfor (int i = 0; i < window; i++) {\n-\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n-\t\t\t\tif (i != window - 1)\n-\t\t\t\t\ttokensInOneWindow.append(" ");\n-\t\t\t}\n-\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n-\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n-\t\t\tnumberOfWindowedTokens++;\n-\t\t}\n-\n-\t\tArrays.sort(shinglesValues);\n-\n-\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n-\t\t\tnumberOfWindowedTokens);\n-\n-\t\tint[] retVal = new int[correctNumberOfShingles];\n-\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n-\t\treturn retVal;\n-\t}\n-\n-\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n-\t\tthis.oldVersionGraph = oldVersionGraph;\n-\t\tthis.newVersionGraph = newVersionGraph;\n-\n-\t\tthis.oldVersionPackageList = new ArrayList<>();\n-\t\tthis.oldVersionClassList = new ArrayList<>();\n-\t\tthis.oldVersionMethodList = new ArrayList<>();\n-\t\tthis.oldVersionFieldList = new ArrayList<>();\n-\n-\t\tthis.newVersionPackageList = new ArrayList<>();\n-\t\tthis.newVersionClassList = new ArrayList<>();\n-\t\tthis.newVersionMethodList = new ArrayList<>();\n-\t\tthis.newVersionFieldList = new ArrayList<>();\n-\n-\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n-\t\t\toldVersionPackageList, oldVersionFieldList);\n-\n-\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-\t}\n-\n-\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n-\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n-\t\t// Create a BreadthFirstIterator for the graph\n-\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-\t\twhile (bfi.hasNext()) {\n-\t\t\tNode n = bfi.next();\n-\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n-\t\t\t\tclasses.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n-\t\t\t\tpackages.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n-\t\t\t\tmethods.add(n);\n-\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n-\t\t\t\tfields.add(n);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic List<Node[]> findSimilarMethods() {\n-\t\tif (this.similarMethods.isEmpty()) {\n-\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n-\t\t\tfor (Node m : this.oldVersionMethodList) {\n-\t\t\t\tif (!m.isAPI())\n-\t\t\t\t\tcontinue;\n-\n-\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n-\t\t\t\t\tif (!m2.isAPI())\n-\t\t\t\t\t\tcontinue;\n-\n-\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-\t\t\t\t\t\tNode[] arr = {m, m2};\n-\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n-\t\t\t\t\t\tsimilarMethods.add(arr);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthis.similarMethods = similarMethods;\n-\t\t}\n-\t\treturn this.similarMethods;\n-\t}\n-\n-\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n-\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-\t\treturn finalGrade;\n-\t}\n-\n-\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-\t\tint[] tempArr = arr2.clone();\n-\t\tdouble grade = 0.0;\n-\t\tfor (int value : arr1) {\n-\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n-\t\t\t\tif (value == tempArr[j]) {\n-\t\t\t\t\tgrade += 1.0 / arr1.length;\n-\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn grade;\n-\t}\n-\n-\n-\t/**\n-\t * @param classes\n-\t * @param graph   <br>\n-\t *                For each class nodes in classes, find the shingles by\n-\t *                concatenating shingles in methods of its subtree. The\n-\t *                parameter s_class will determine the maximum size of shingles\n-\t */\n-\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n-\t\tfor (Node clasz : classes) {\n-\t\t\t// We will keep the number of methods for the class with the\n-\t\t\t// numberOfMethods variable.\n-\t\t\tint numberOfMethods = 0;\n-\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n-\t\t\tint methodsTotalShingleSize = 0;\n-\t\t\tfor (Edge e : outEdges) {\n-\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n-\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n-\t\t\t\t\t// Here we update the method count.\n-\t\t\t\t\tnumberOfMethods++;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n-\t\t\t// the class\n-\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n-\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n-\t\t\tint index = 0;\n-\t\t\tfor (Edge e : outEdges) {\n-\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n-\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n-\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n-\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n-\t\t\t\t\t\tindex++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n-\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n-\t\t\tArrays.sort(allShinglesFromMethods);\n-\n-\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n-\t\t\t\tallShinglesFromMethods.length);\n-\n-\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n-\t\t\tif (upperBoundForClassShingles >= 0)\n-\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n-\t\t\tclasz.setShingles(retVal);\n-\t\t}\n-\t}\n-\n-\n-\tpublic List<Node[]> findSimilarClasses() {\n-\t\tif (this.similarClasses.isEmpty()) {\n-\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n-\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n-\t\t\tList<Node[]> simClass = new ArrayList<>();\n-\t\t\tfor (Node c : this.oldVersionClassList) {\n-\t\t\t\tif (!c.isAPI())\n-\t\t\t\t\tcontinue;\n-\n-\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n-\t\t\t\t\tif (!c2.isAPI())\n-\t\t\t\t\t\tcontinue;\n-\n-\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n-\t\t\t\t\t\tNode[] arr = {c, c2};\n-\t\t\t\t\t\tsimClass.add(arr);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthis.similarClasses = simClass;\n-\t\t}\n-\t\treturn this.similarClasses;\n-\t}\n-\n-\tpublic List<Node[]> findPullUpMethodCandidates() {\n-\t\treturn findSimilarMethods();\n-\t}\n-\n-\tpublic List<Node[]> findPushDownMethodCandidates() {\n-\t\treturn findSimilarMethods();\n-\t}\n-}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 2;\n\tprivate int sClass = 10;\n\tprivate int sMethod = 8;\n\tprivate double classThreshold = 0.0;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate NamedDirectedMultigraph oldVersionGraph;\n\n\tprivate NamedDirectedMultigraph newVersionGraph;\n\n\tprivate List<Node[]> similarMethods = new LinkedList<>();\n\tprivate List<Node[]> similarClasses = new LinkedList<>();\n\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n\n\n\t/**\n\t * @param classes\n\t * @param graph   <br>\n\t *                For each class nodes in classes, find the shingles by\n\t *                concatenating shingles in methods of its subtree. The\n\t *                parameter s_class will determine the maximum size of shingles\n\t */\n\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n\t\tfor (Node clasz : classes) {\n\t\t\t// We will keep the number of methods for the class with the\n\t\t\t// numberOfMethods variable.\n\t\t\tint numberOfMethods = 0;\n\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n\t\t\tint methodsTotalShingleSize = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n\t\t\t\t\t// Here we update the method count.\n\t\t\t\t\tnumberOfMethods++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n\t\t\t// the class\n\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n\t\t\tint index = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n\t\t\tArrays.sort(allShinglesFromMethods);\n\n\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n\t\t\t\tallShinglesFromMethods.length);\n\n\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n\t\t\tif (upperBoundForClassShingles >= 0)\n\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n\t\t\tclasz.setShingles(retVal);\n\t\t}\n\t}\n\n\n\tpublic List<Node[]> findSimilarClasses() {\n\t\tif (this.similarClasses.isEmpty()) {\n\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n\t\t\tList<Node[]> simClass = new ArrayList<>();\n\t\t\tfor (Node c : this.oldVersionClassList) {\n\t\t\t\tif (!c.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n\t\t\t\t\tif (!c2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n\t\t\t\t\t\tNode[] arr = {c, c2};\n\t\t\t\t\t\tsimClass.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarClasses = simClass;\n\t\t}\n\t\treturn this.similarClasses;\n\t}\n\n\tpublic List<Node[]> findPullUpMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n\n\tpublic List<Node[]> findPushDownMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n}\n'
          },
          {
            sha: "c1a320e6235857a843f5df0f924b580d890979c5",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 327,
            deletions: 295,
            patch:
              '@@ -1,309 +1,341 @@\n package refactoring.crawler.util;\n \n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n import com.github.javaparser.ast.CompilationUnit;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n import com.github.javaparser.ast.expr.FieldAccessExpr;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n+import java.util.*;\n+import java.util.stream.Collectors;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n+import refactoring.crawler.graph.*;\n+import refactoring.crawler.shingles.ShinglesUtil;\n \n public class SourceNavigator {\n \n-\t@Getter\n-\tprivate NamedDirectedMultigraph graph;\n-\n-\tprivate ShinglesUtil shinglesUtil;\n-\n-\tprivate String projectName;\n-\n-\tprivate int packageCounter = 0;\n-\n-\tprivate int allMethodsCounter = 0;\n-\n-\tprivate int allClassCounter = 0;\n-\n-\tprivate int apiClassCounter = 0;\n-\n-\tprivate int apiMethodCounter = 0;\n-\n-\tpublic static boolean useJavadocComments = false;\n-\n-\tpublic SourceNavigator() {\n-\t\tgraph = new NamedDirectedMultigraph();\n-\t}\n-\n-\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n-\t\tthis.shinglesUtil = shinglesUtil;\n-\t}\n-\n-\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n-\t\tthis.projectName = projectName;\n-\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n-\t\tthis.graph.addNamedVertex(projectNode);\n-\t\tcompilationUnits.forEach(cu -> {\n-\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n-\t\t\tval importDeclarations = cu.getImports();\n-\n-\t\t\tval classesImported = new LinkedList<String>();\n-\n-\t\t\timportDeclarations.forEach(importDeclaration -> {\n-\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n-\t\t\t});\n-\n-\t\t\tif (packageDeclaration.isPresent()) {\n-\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n-\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n-\t\t\t\tpackageNode.setProjectName(projectName);\n-\t\t\t\tthis.graph.addNamedVertex(packageNode);\n-\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-\t\t\t\tcu.getTypes().forEach(type -> {\n-\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n-\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n-\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n-\t\t\t\t\t\tif (className.isPresent()) {\n-\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n-\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n-\n-\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n-\t\t\t\t\t\t\t\t.getExtendedTypes()\n-\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n-\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n-\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n-\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n-\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n-\n-\t\t\t\t\t\t\tthis.allClassCounter += 1;\n-\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n-\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n-\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n-\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\n-\t\t\t\t\t\t\t// methods\n-\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n-\n-\t\t\t\t\t\t\t// filed fqn -> methods fqn\n-\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n-\n-\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n-\t\t\t\t\t\t\t\tString statementBody = "";\n-\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n-\n-\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n-\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n-\t\t\t\t\t\t\t\t\t} else\n-\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n-\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n-\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n-\n-\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n-\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n-\t\t\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n-\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n-\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n-\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n-\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n-\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n-\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n-\t\t\t\t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n-\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n-\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n-\n-\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n-\n-\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n-\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n-\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n-\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n-\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n-\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n-\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n-\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n-\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n-\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n-\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t\t// fields\n-\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n-\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n-\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n-\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n-\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n-\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n-\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n-\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n-\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\n-\t\t});\n-\n-//\t\tval packages = compilationUnits.stream()\n-//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-//\t\t\t.filter(Optional::isPresent)\n-//\t\t\t.collect(Collectors.toList());\n-////        this.graph.addVertex(projectNode);\n-//\t\tthis.graph.addNamedVertex(projectNode);\n-//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n-\t}\n-\n-//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n-//\t\tval childrenPackages = iPackage.getChildrenPackages();\n-//\t\tchildrenPackages.forEach(childrenPackage -> {\n-//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n-//\t\t\tpackageNode.setProjectName(this.projectName);\n-////            graph.addVertex(packageNode);\n-//\t\t\tgraph.addNamedVertex(packageNode);\n-////            graph.addEdge(projectNode, packageNode);\n-//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-//\t\t\tthis.packageCounter += 1;\n-//\t\t});\n-//\t}\n-\n-//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-//\t\tval classes = pckg.getClasses();\n-//\t\tclasses.forEach(clz -> {\n-//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-//\t\t\tclassNode.setProjectName(this.projectName);\n-//\t\t\tclassNode.setFlags(clz.getFlags());\n-////            graph.addVertex(classNode);\n-////            graph.addEdge(packageNode, classNode);\n-//\t\t\tgraph.addNamedVertex(classNode);\n-//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-//\t\t\tthis.browseClass(clz, classNode);\n-//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-//\t\t\tclassNode.setInterface(clz.getIsInterface());\n-//\t\t\tthis.allClassCounter += 1;\n-//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-//\t\t\t\tclassNode.setAPI(true);\n-//\t\t\t\tthis.apiClassCounter += 1;\n-//\t\t\t}\n-//\t\t});\n-//\t}\n-\n-//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-//\t\tval methods = clz.getMethods();\n-//\t\tbrowseMethods(methods, classNode);\n-//\t\tval fields = clz.getFields();\n-//\t\tbrowseFields(fields, classNode);\n-//\t}\n-//\n-//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-//\t\tmethods.forEach(method -> {\n-//\t\t\tString statementBody = "";\n-//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-//\t\t\t\tstatementBody = method.getSource().trim();\n-//\t\t\t} else\n-//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-//\t\t\t\t+ method.getElementName();\n-//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-//\n-//\t\t\tallMethodsCounter += 1;\n-//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-//\t\t\t\tmethodNode.setAPI(true);\n-//\t\t\t\tthis.apiMethodCounter += 1;\n-//\t\t\t}\n-//\t\t\tif (method.getIsDeprecated())\n-//\t\t\t\tmethodNode.setDeprecated(true);\n-//\t\t\tmethodNode.setProjectName(projectName);\n-//\t\t\tmethodNode.setShingles(shingles);\n-//\t\t\tmethodNode.setFlags(method.getFlags());\n-//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-////            graph.addVertex(methodNode);\n-////            graph.addEdge(classNode, methodNode);\n-//\t\t\tgraph.addNamedVertex(methodNode);\n-//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-//\t\t});\n-//\t}\n-//\n-//\n-//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-//\t\tStringBuilder buffer = new StringBuilder();\n-//\n-//\t\tbuffer.append(\'(\');\n-//\n-//\t\tString[] types = method.getParameterTypes();\n-//\t\tfor (int i = 0; i < types.length; i++) {\n-//\t\t\tif (i > 0)\n-//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-//\t\t\tString typeSig = Signature.toString(types[i]);\n-//\t\t\tbuffer.append(typeSig);\n-//\t\t}\n-//\t\tbuffer.append(\')\');\n-//\n-//\t\treturn buffer.toString();\n-//\t}\n-//\n-//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-//\t\tfields.forEach(field -> {\n-//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-//\t\t\tfieldNode.setProjectName(this.projectName);\n-//\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\tfieldNode.setFlags(field.getFlags());\n-//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-////            graph.addVertex(fieldNode);\n-////            graph.addEdge(classNode, fieldNode);\n-//\t\t\tgraph.addNamedVertex(fieldNode);\n-//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-//\t\t});\n-//\t}\n-//\n-\n-\t/**\n-\t * This prunes away the javadoc comments\n-\t *\n-\t * @param source\n-\t * @return\n-\t */\n-\tprivate String statementBody(String source) {\n-\t\tint lastAtChar = source.lastIndexOf("@");\n-\t\tif (lastAtChar == -1)\n-\t\t\tlastAtChar = 0;\n-\t\tint openingBracket = source.indexOf("{", lastAtChar);\n-\t\tint closingBracket = source.lastIndexOf("}");\n-\t\tif (openingBracket != -1)\n-\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n-\t\treturn source;\n-\t}\n+    @Getter private NamedDirectedMultigraph graph;\n+\n+    private ShinglesUtil shinglesUtil;\n+\n+    private String projectName;\n+\n+    private int packageCounter = 0;\n+\n+    private int allMethodsCounter = 0;\n+\n+    private int allClassCounter = 0;\n+\n+    private int apiClassCounter = 0;\n+\n+    private int apiMethodCounter = 0;\n+\n+    public static boolean useJavadocComments = false;\n+\n+    public SourceNavigator() {\n+        graph = new NamedDirectedMultigraph();\n+    }\n+\n+    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+        this.shinglesUtil = shinglesUtil;\n+    }\n+\n+    public void browseProject(\n+            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+        this.projectName = projectName;\n+        val projectNode = new Node(projectName, Node.Type.PROJECT);\n+        this.graph.addNamedVertex(projectNode);\n+        compilationUnits.forEach(\n+                cu -> {\n+                    val packageDeclaration = cu.getPackageDeclaration();\n+                    val importDeclarations = cu.getImports();\n+\n+                    val classesImported = new LinkedList<String>();\n+\n+                    importDeclarations.forEach(\n+                            importDeclaration -> {\n+                                classesImported.add(importDeclaration.getName().asString());\n+                            });\n+\n+                    if (packageDeclaration.isPresent()) {\n+                        val packageName = packageDeclaration.get().getNameAsString();\n+                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n+                        packageNode.setProjectName(projectName);\n+                        this.graph.addNamedVertex(packageNode);\n+                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+                        cu.getTypes()\n+                                .forEach(\n+                                        type -> {\n+                                            if (type.isClassOrInterfaceDeclaration()) {\n+                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+                                                if (className.isPresent()) {\n+                                                    val classNode = new ClassNode(className.get());\n+                                                    classNode.setProjectName(projectName);\n+\n+                                                    List<String> extendedClasses =\n+                                                            classOrInterfaceDeclaration\n+                                                                    .getExtendedTypes()\n+                                                                    .stream()\n+                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n+                                                                    .collect(Collectors.toList());\n+\n+                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+                                                    classNode.setSuperClasses(extendedClasses);\n+                                                    classNode.setClassesImported(classesImported);\n+                                                    classNode.setDeprecated(\n+                                                            classOrInterfaceDeclaration\n+                                                                    .getAnnotationByClass(Deprecated.class)\n+                                                                    .isPresent());\n+                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n+                                                    this.allClassCounter += 1;\n+                                                    if (classOrInterfaceDeclaration.isProtected()\n+                                                            || classOrInterfaceDeclaration.isPublic()) {\n+                                                        classNode.setAPI(true);\n+                                                        this.apiClassCounter += 1;\n+                                                    }\n+                                                    graph.addNamedVertex(classNode);\n+                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\n+                                                    // methods\n+                                                    List<MethodDeclaration> methodDeclarations =\n+                                                            classOrInterfaceDeclaration.getMethods();\n+\n+                                                    // filed fqn -> methods fqn\n+                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n+                                                    methodDeclarations.forEach(\n+                                                            method -> {\n+                                                                String statementBody = "";\n+                                                                val methodBody = method.getBody();\n+\n+                                                                if (methodBody.isPresent()) {\n+                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n+                                                                        statementBody = methodBody.get().toString().trim();\n+                                                                    } else\n+                                                                        statementBody =\n+                                                                                statementBody(methodBody.get().toString()).trim();\n+                                                                    int[] shingles =\n+                                                                            shinglesUtil.computeMethodShingles(statementBody);\n+                                                                    String qualifiedName =\n+                                                                            classNode.getFullyQualifiedName()\n+                                                                                    + "."\n+                                                                                    + method.getNameAsString();\n+                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n+\n+                                                                    List<String> methodReferencedFields =\n+                                                                            method\n+                                                                                    .findAll(FieldAccessExpr.class)\n+                                                                                    .stream()\n+                                                                                    .map(\n+                                                                                            fieldAccessExpr ->\n+                                                                                                    classNode.getFullyQualifiedName()\n+                                                                                                            + "."\n+                                                                                                            + fieldAccessExpr.resolve().getName())\n+                                                                                    .collect(Collectors.toList());\n+\n+                                                                    methodReferencedFields.forEach(\n+                                                                            field -> {\n+                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n+                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n+                                                                                    methods.add(qualifiedName);\n+                                                                                    fieldReferenceToMethods.put(field, methods);\n+                                                                                }\n+                                                                            });\n+\n+                                                                    List<MethodNode.CalledMethod> calledMethodList =\n+                                                                            method\n+                                                                                    .findAll(MethodCallExpr.class)\n+                                                                                    .stream()\n+                                                                                    .map(MethodCallExpr::resolve)\n+                                                                                    .map(\n+                                                                                            resolved ->\n+                                                                                                    new MethodNode.CalledMethod(\n+                                                                                                            resolved.getQualifiedName(),\n+                                                                                                            resolved.getQualifiedSignature()))\n+                                                                                    .collect(Collectors.toList());\n+\n+                                                                    methodNode.setCalledInside(calledMethodList);\n+\n+                                                                    allMethodsCounter += 1;\n+                                                                    if (method.isPublic() || method.isProtected()) {\n+                                                                        methodNode.setAPI(true);\n+                                                                        this.apiMethodCounter += 1;\n+                                                                    }\n+                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n+                                                                        methodNode.setDeprecated(true);\n+                                                                    methodNode.setStatic(method.isStatic());\n+                                                                    methodNode.setProjectName(projectName);\n+                                                                    methodNode.setShingles(shingles);\n+                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+                                                                    methodNode.setSignature(method.getSignature().toString());\n+                                                                    graph.addNamedVertex(methodNode);\n+                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+                                                                }\n+                                                            });\n+\n+                                                    // fields\n+                                                    List<FieldDeclaration> fieldDeclarations =\n+                                                            classOrInterfaceDeclaration.getFields();\n+                                                    fieldDeclarations.forEach(\n+                                                            field -> {\n+                                                                int[] shingles =\n+                                                                        this.shinglesUtil.computeMethodShingles(\n+                                                                                field.getVariables().toString());\n+                                                                String fullyQualifiedName =\n+                                                                        classNode.getFullyQualifiedName()\n+                                                                                + "."\n+                                                                                + field.getVariables().toString();\n+                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+                                                                fieldNode.setFieldReferenceToMethod(\n+                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n+                                                                fieldNode.setProjectName(this.projectName);\n+                                                                fieldNode.setShingles(shingles);\n+                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+                                                                fieldNode.setStatic(field.isStatic());\n+                                                                fieldNode.setSignature(field.getCommonType().asString());\n+                                                                fieldNode.setDeprecated(\n+                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n+                                                                graph.addNamedVertex(fieldNode);\n+                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+                                                            });\n+                                                }\n+                                            }\n+                                        });\n+                    }\n+                });\n+\n+        //\t\tval packages = compilationUnits.stream()\n+        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+        //\t\t\t.filter(Optional::isPresent)\n+        //\t\t\t.collect(Collectors.toList());\n+        ////        this.graph.addVertex(projectNode);\n+        //\t\tthis.graph.addNamedVertex(projectNode);\n+        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+    }\n+\n+    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n+    //\t\tchildrenPackages.forEach(childrenPackage -> {\n+    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+    //\t\t\tpackageNode.setProjectName(this.projectName);\n+    ////            graph.addVertex(packageNode);\n+    //\t\t\tgraph.addNamedVertex(packageNode);\n+    ////            graph.addEdge(projectNode, packageNode);\n+    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+    //\t\t\tthis.packageCounter += 1;\n+    //\t\t});\n+    //\t}\n+\n+    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+    //\t\tval classes = pckg.getClasses();\n+    //\t\tclasses.forEach(clz -> {\n+    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+    //\t\t\tclassNode.setProjectName(this.projectName);\n+    //\t\t\tclassNode.setFlags(clz.getFlags());\n+    ////            graph.addVertex(classNode);\n+    ////            graph.addEdge(packageNode, classNode);\n+    //\t\t\tgraph.addNamedVertex(classNode);\n+    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+    //\t\t\tthis.browseClass(clz, classNode);\n+    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n+    //\t\t\tthis.allClassCounter += 1;\n+    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+    //\t\t\t\tclassNode.setAPI(true);\n+    //\t\t\t\tthis.apiClassCounter += 1;\n+    //\t\t\t}\n+    //\t\t});\n+    //\t}\n+\n+    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+    //\t\tval methods = clz.getMethods();\n+    //\t\tbrowseMethods(methods, classNode);\n+    //\t\tval fields = clz.getFields();\n+    //\t\tbrowseFields(fields, classNode);\n+    //\t}\n+    //\n+    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+    //\t\tmethods.forEach(method -> {\n+    //\t\t\tString statementBody = "";\n+    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+    //\t\t\t\tstatementBody = method.getSource().trim();\n+    //\t\t\t} else\n+    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+    //\t\t\t\t+ method.getElementName();\n+    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+    //\n+    //\t\t\tallMethodsCounter += 1;\n+    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+    //\t\t\t\tmethodNode.setAPI(true);\n+    //\t\t\t\tthis.apiMethodCounter += 1;\n+    //\t\t\t}\n+    //\t\t\tif (method.getIsDeprecated())\n+    //\t\t\t\tmethodNode.setDeprecated(true);\n+    //\t\t\tmethodNode.setProjectName(projectName);\n+    //\t\t\tmethodNode.setShingles(shingles);\n+    //\t\t\tmethodNode.setFlags(method.getFlags());\n+    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+    ////            graph.addVertex(methodNode);\n+    ////            graph.addEdge(classNode, methodNode);\n+    //\t\t\tgraph.addNamedVertex(methodNode);\n+    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+    //\t\t});\n+    //\t}\n+    //\n+    //\n+    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+    //\t\tStringBuilder buffer = new StringBuilder();\n+    //\n+    //\t\tbuffer.append(\'(\');\n+    //\n+    //\t\tString[] types = method.getParameterTypes();\n+    //\t\tfor (int i = 0; i < types.length; i++) {\n+    //\t\t\tif (i > 0)\n+    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+    //\t\t\tString typeSig = Signature.toString(types[i]);\n+    //\t\t\tbuffer.append(typeSig);\n+    //\t\t}\n+    //\t\tbuffer.append(\')\');\n+    //\n+    //\t\treturn buffer.toString();\n+    //\t}\n+    //\n+    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+    //\t\tfields.forEach(field -> {\n+    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+    //\t\t\tfieldNode.setProjectName(this.projectName);\n+    //\t\t\tfieldNode.setShingles(shingles);\n+    //\t\t\tfieldNode.setFlags(field.getFlags());\n+    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+    ////            graph.addVertex(fieldNode);\n+    ////            graph.addEdge(classNode, fieldNode);\n+    //\t\t\tgraph.addNamedVertex(fieldNode);\n+    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+    //\t\t});\n+    //\t}\n+    //\n+\n+    /**\n+    * This prunes away the javadoc comments\n+    *\n+    * @param source\n+    * @return\n+    */\n+    private String statementBody(String source) {\n+        int lastAtChar = source.lastIndexOf("@");\n+        if (lastAtChar == -1) lastAtChar = 0;\n+        int openingBracket = source.indexOf("{", lastAtChar);\n+        int closingBracket = source.lastIndexOf("}");\n+        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n+        return source;\n+    }\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n    @Getter private NamedDirectedMultigraph graph;\n\n    private ShinglesUtil shinglesUtil;\n\n    private String projectName;\n\n    private int packageCounter = 0;\n\n    private int allMethodsCounter = 0;\n\n    private int allClassCounter = 0;\n\n    private int apiClassCounter = 0;\n\n    private int apiMethodCounter = 0;\n\n    public static boolean useJavadocComments = false;\n\n    public SourceNavigator() {\n        graph = new NamedDirectedMultigraph();\n    }\n\n    public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n        this.shinglesUtil = shinglesUtil;\n    }\n\n    public void browseProject(\n            @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n        this.projectName = projectName;\n        val projectNode = new Node(projectName, Node.Type.PROJECT);\n        this.graph.addNamedVertex(projectNode);\n        compilationUnits.forEach(\n                cu -> {\n                    val packageDeclaration = cu.getPackageDeclaration();\n                    val importDeclarations = cu.getImports();\n\n                    val classesImported = new LinkedList<String>();\n\n                    importDeclarations.forEach(\n                            importDeclaration -> {\n                                classesImported.add(importDeclaration.getName().asString());\n                            });\n\n                    if (packageDeclaration.isPresent()) {\n                        val packageName = packageDeclaration.get().getNameAsString();\n                        val packageNode = new Node(packageName, Node.Type.PACKAGE);\n                        packageNode.setProjectName(projectName);\n                        this.graph.addNamedVertex(packageNode);\n                        this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n                        cu.getTypes()\n                                .forEach(\n                                        type -> {\n                                            if (type.isClassOrInterfaceDeclaration()) {\n                                                val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                                                val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                                                if (className.isPresent()) {\n                                                    val classNode = new ClassNode(className.get());\n                                                    classNode.setProjectName(projectName);\n\n                                                    List<String> extendedClasses =\n                                                            classOrInterfaceDeclaration\n                                                                    .getExtendedTypes()\n                                                                    .stream()\n                                                                    .map(extendType -> extendType.resolve().getQualifiedName())\n                                                                    .collect(Collectors.toList());\n\n                                                    classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                                                    classNode.setSuperClasses(extendedClasses);\n                                                    classNode.setClassesImported(classesImported);\n                                                    classNode.setDeprecated(\n                                                            classOrInterfaceDeclaration\n                                                                    .getAnnotationByClass(Deprecated.class)\n                                                                    .isPresent());\n                                                    classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                                                    this.allClassCounter += 1;\n                                                    if (classOrInterfaceDeclaration.isProtected()\n                                                            || classOrInterfaceDeclaration.isPublic()) {\n                                                        classNode.setAPI(true);\n                                                        this.apiClassCounter += 1;\n                                                    }\n                                                    graph.addNamedVertex(classNode);\n                                                    graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                                                    // methods\n                                                    List<MethodDeclaration> methodDeclarations =\n                                                            classOrInterfaceDeclaration.getMethods();\n\n                                                    // filed fqn -> methods fqn\n                                                    Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                                                    methodDeclarations.forEach(\n                                                            method -> {\n                                                                String statementBody = "";\n                                                                val methodBody = method.getBody();\n\n                                                                if (methodBody.isPresent()) {\n                                                                    if (classNode.isInterface() || (useJavadocComments)) {\n                                                                        statementBody = methodBody.get().toString().trim();\n                                                                    } else\n                                                                        statementBody =\n                                                                                statementBody(methodBody.get().toString()).trim();\n                                                                    int[] shingles =\n                                                                            shinglesUtil.computeMethodShingles(statementBody);\n                                                                    String qualifiedName =\n                                                                            classNode.getFullyQualifiedName()\n                                                                                    + "."\n                                                                                    + method.getNameAsString();\n                                                                    MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                                                    List<String> methodReferencedFields =\n                                                                            method\n                                                                                    .findAll(FieldAccessExpr.class)\n                                                                                    .stream()\n                                                                                    .map(\n                                                                                            fieldAccessExpr ->\n                                                                                                    classNode.getFullyQualifiedName()\n                                                                                                            + "."\n                                                                                                            + fieldAccessExpr.resolve().getName())\n                                                                                    .collect(Collectors.toList());\n\n                                                                    methodReferencedFields.forEach(\n                                                                            field -> {\n                                                                                if (fieldReferenceToMethods.containsKey(field)) {\n                                                                                    List<String> methods = fieldReferenceToMethods.get(field);\n                                                                                    methods.add(qualifiedName);\n                                                                                    fieldReferenceToMethods.put(field, methods);\n                                                                                }\n                                                                            });\n\n                                                                    List<MethodNode.CalledMethod> calledMethodList =\n                                                                            method\n                                                                                    .findAll(MethodCallExpr.class)\n                                                                                    .stream()\n                                                                                    .map(MethodCallExpr::resolve)\n                                                                                    .map(\n                                                                                            resolved ->\n                                                                                                    new MethodNode.CalledMethod(\n                                                                                                            resolved.getQualifiedName(),\n                                                                                                            resolved.getQualifiedSignature()))\n                                                                                    .collect(Collectors.toList());\n\n                                                                    methodNode.setCalledInside(calledMethodList);\n\n                                                                    allMethodsCounter += 1;\n                                                                    if (method.isPublic() || method.isProtected()) {\n                                                                        methodNode.setAPI(true);\n                                                                        this.apiMethodCounter += 1;\n                                                                    }\n                                                                    if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                                                        methodNode.setDeprecated(true);\n                                                                    methodNode.setStatic(method.isStatic());\n                                                                    methodNode.setProjectName(projectName);\n                                                                    methodNode.setShingles(shingles);\n                                                                    //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                                                    methodNode.setSignature(method.getSignature().toString());\n                                                                    graph.addNamedVertex(methodNode);\n                                                                    graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                                                }\n                                                            });\n\n                                                    // fields\n                                                    List<FieldDeclaration> fieldDeclarations =\n                                                            classOrInterfaceDeclaration.getFields();\n                                                    fieldDeclarations.forEach(\n                                                            field -> {\n                                                                int[] shingles =\n                                                                        this.shinglesUtil.computeMethodShingles(\n                                                                                field.getVariables().toString());\n                                                                String fullyQualifiedName =\n                                                                        classNode.getFullyQualifiedName()\n                                                                                + "."\n                                                                                + field.getVariables().toString();\n                                                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                                                fieldNode.setFieldReferenceToMethod(\n                                                                        fieldReferenceToMethods.get(fullyQualifiedName));\n                                                                fieldNode.setProjectName(this.projectName);\n                                                                fieldNode.setShingles(shingles);\n                                                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                                                fieldNode.setStatic(field.isStatic());\n                                                                fieldNode.setSignature(field.getCommonType().asString());\n                                                                fieldNode.setDeprecated(\n                                                                        field.getAnnotationByClass(Deprecated.class).isPresent());\n                                                                graph.addNamedVertex(fieldNode);\n                                                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                                                            });\n                                                }\n                                            }\n                                        });\n                    }\n                });\n\n        //\t\tval packages = compilationUnits.stream()\n        //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n        //\t\t\t.filter(Optional::isPresent)\n        //\t\t\t.collect(Collectors.toList());\n        ////        this.graph.addVertex(projectNode);\n        //\t\tthis.graph.addNamedVertex(projectNode);\n        //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n    }\n\n    //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n    //\t\tval childrenPackages = iPackage.getChildrenPackages();\n    //\t\tchildrenPackages.forEach(childrenPackage -> {\n    //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n    //\t\t\tpackageNode.setProjectName(this.projectName);\n    ////            graph.addVertex(packageNode);\n    //\t\t\tgraph.addNamedVertex(packageNode);\n    ////            graph.addEdge(projectNode, packageNode);\n    //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n    //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n    //\t\t\tthis.packageCounter += 1;\n    //\t\t});\n    //\t}\n\n    //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n    //\t\tval classes = pckg.getClasses();\n    //\t\tclasses.forEach(clz -> {\n    //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n    //\t\t\tclassNode.setProjectName(this.projectName);\n    //\t\t\tclassNode.setFlags(clz.getFlags());\n    ////            graph.addVertex(classNode);\n    ////            graph.addEdge(packageNode, classNode);\n    //\t\t\tgraph.addNamedVertex(classNode);\n    //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n    //\t\t\tthis.browseClass(clz, classNode);\n    //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n    //\t\t\tclassNode.setInterface(clz.getIsInterface());\n    //\t\t\tthis.allClassCounter += 1;\n    //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n    //\t\t\t\tclassNode.setAPI(true);\n    //\t\t\t\tthis.apiClassCounter += 1;\n    //\t\t\t}\n    //\t\t});\n    //\t}\n\n    //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n    //\t\tval methods = clz.getMethods();\n    //\t\tbrowseMethods(methods, classNode);\n    //\t\tval fields = clz.getFields();\n    //\t\tbrowseFields(fields, classNode);\n    //\t}\n    //\n    //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n    //\t\tmethods.forEach(method -> {\n    //\t\t\tString statementBody = "";\n    //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n    //\t\t\t\tstatementBody = method.getSource().trim();\n    //\t\t\t} else\n    //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n    //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n    //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n    //\t\t\t\t+ method.getElementName();\n    //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n    //\n    //\t\t\tallMethodsCounter += 1;\n    //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n    //\t\t\t\tmethodNode.setAPI(true);\n    //\t\t\t\tthis.apiMethodCounter += 1;\n    //\t\t\t}\n    //\t\t\tif (method.getIsDeprecated())\n    //\t\t\t\tmethodNode.setDeprecated(true);\n    //\t\t\tmethodNode.setProjectName(projectName);\n    //\t\t\tmethodNode.setShingles(shingles);\n    //\t\t\tmethodNode.setFlags(method.getFlags());\n    //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n    ////            graph.addVertex(methodNode);\n    ////            graph.addEdge(classNode, methodNode);\n    //\t\t\tgraph.addNamedVertex(methodNode);\n    //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n    //\t\t});\n    //\t}\n    //\n    //\n    //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n    //\t\tStringBuilder buffer = new StringBuilder();\n    //\n    //\t\tbuffer.append(\'(\');\n    //\n    //\t\tString[] types = method.getParameterTypes();\n    //\t\tfor (int i = 0; i < types.length; i++) {\n    //\t\t\tif (i > 0)\n    //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n    //\t\t\tString typeSig = Signature.toString(types[i]);\n    //\t\t\tbuffer.append(typeSig);\n    //\t\t}\n    //\t\tbuffer.append(\')\');\n    //\n    //\t\treturn buffer.toString();\n    //\t}\n    //\n    //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n    //\t\tfields.forEach(field -> {\n    //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n    //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n    //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n    //\t\t\tfieldNode.setProjectName(this.projectName);\n    //\t\t\tfieldNode.setShingles(shingles);\n    //\t\t\tfieldNode.setFlags(field.getFlags());\n    //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n    //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n    ////            graph.addVertex(fieldNode);\n    ////            graph.addEdge(classNode, fieldNode);\n    //\t\t\tgraph.addNamedVertex(fieldNode);\n    //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n    //\t\t});\n    //\t}\n    //\n\n    /**\n    * This prunes away the javadoc comments\n    *\n    * @param source\n    * @return\n    */\n    private String statementBody(String source) {\n        int lastAtChar = source.lastIndexOf("@");\n        if (lastAtChar == -1) lastAtChar = 0;\n        int openingBracket = source.indexOf("{", lastAtChar);\n        int closingBracket = source.lastIndexOf("}");\n        if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n        return source;\n    }\n}\n'
          },
          {
            sha: "725ef3d6de620acbc3d0eeed586e1bc21cc5f2b6",
            filename:
              "src/main/java/refactoring/crawler/visitor/ClassVisitor.java",
            status: "removed",
            additions: 0,
            deletions: 8,
            patch:
              "@@ -1,8 +0,0 @@\n-package refactoring.crawler.visitor;\n-\n-import com.github.javaparser.ast.body.MethodDeclaration;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-\n-public class ClassVisitor extends VoidVisitorAdapter<Object> {\n-\n-}",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class ClassVisitor extends VoidVisitorAdapter<Object> {\n\n}\n"
          },
          {
            sha: "da212c011daa35711a7bc770b3a8647fd26e91a3",
            filename:
              "src/main/java/refactoring/crawler/visitor/MethodVisitor.java",
            status: "removed",
            additions: 0,
            deletions: 518,
            patch:
              "@@ -1,518 +0,0 @@\n-package refactoring.crawler.visitor;\n-\n-import com.github.javaparser.ast.*;\n-import com.github.javaparser.ast.body.*;\n-import com.github.javaparser.ast.comments.*;\n-import com.github.javaparser.ast.expr.*;\n-import com.github.javaparser.ast.modules.*;\n-import com.github.javaparser.ast.stmt.*;\n-import com.github.javaparser.ast.type.*;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-\n-public class MethodVisitor extends VoidVisitorAdapter<Object> {\n-\n-    public void visit(MethodDeclaration n, Object arg) {\n-        System.out.println(n.getBody());\n-        System.out.println(n.getName());\n-    }\n-\n-    @Override\n-    public void visit(AnnotationDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AnnotationMemberDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayAccessExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayCreationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayInitializerExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AssertStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(AssignExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BinaryExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BlockComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BlockStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BooleanLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(BreakStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CastExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CatchClause n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CharLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ClassOrInterfaceType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(CompilationUnit n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ConditionalExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ConstructorDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ContinueStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(DoStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(DoubleLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EmptyStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnclosedExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnumConstantDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(EnumDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ExpressionStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(FieldAccessExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(FieldDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ForEachStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ForStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IfStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(InitializerDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(InstanceOfExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IntegerLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LabeledStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LineComment n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LongLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MarkerAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MemberValuePair n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MethodCallExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NameExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NormalAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NullLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ObjectCreationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(PackageDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Parameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(PrimitiveType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Name n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SimpleName n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ArrayCreationLevel n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(IntersectionType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnionType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ReturnStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(StringLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SuperExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchEntry n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SynchronizedStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ThisExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ThrowStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TryStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LocalClassDeclarationStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TypeParameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnaryExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnknownType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VariableDeclarationExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VariableDeclarator n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VoidType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(WhileStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(WildcardType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(LambdaExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(MethodReferenceExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TypeExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(NodeList n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ImportDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleDeclaration n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleRequiresDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleExportsDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleProvidesDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleUsesDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ModuleOpensDirective n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(UnparsableStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(ReceiverParameter n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(VarType n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(Modifier n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(SwitchExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(TextBlockLiteralExpr n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(YieldStmt n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocBlockTag n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocContent n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocDescription n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocInlineTag n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-\n-    @Override\n-    public void visit(JavadocSnippet n, Object arg) {\n-        super.visit(n, arg);\n-    }\n-}\n\\ No newline at end of file",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.modules.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class MethodVisitor extends VoidVisitorAdapter<Object> {\n\n    public void visit(MethodDeclaration n, Object arg) {\n        System.out.println(n.getBody());\n        System.out.println(n.getName());\n    }\n\n    @Override\n    public void visit(AnnotationDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AnnotationMemberDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayInitializerExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssertStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssignExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BinaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BooleanLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BreakStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CastExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CatchClause n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CharLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CompilationUnit n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConditionalExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConstructorDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ContinueStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoubleLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EmptyStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnclosedExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumConstantDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExpressionStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForEachStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IfStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InitializerDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InstanceOfExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntegerLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LabeledStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LineComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LongLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MarkerAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MemberValuePair n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodCallExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NameExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NormalAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NullLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ObjectCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PackageDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Parameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PrimitiveType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Name n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SimpleName n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntersectionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReturnStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(StringLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SuperExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchEntry n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SynchronizedStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThisExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThrowStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TryStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LocalClassDeclarationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarator n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VoidType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WhileStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WildcardType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NodeList n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ImportDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleRequiresDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleExportsDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleProvidesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleUsesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleOpensDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnparsableStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReceiverParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VarType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Modifier n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TextBlockLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(YieldStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocBlockTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocContent n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocDescription n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocInlineTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocSnippet n, Object arg) {\n        super.visit(n, arg);\n    }\n}"
          },
          {
            sha: "9ab5119f95a2b259504fd1325a9c3933e09bedec",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "modified",
            additions: 62,
            deletions: 23,
            patch:
              '@@ -1,38 +1,77 @@\n /*\n- * This Java source file was generated by the Gradle \'init\' task.\n- */\n+* This Java source file was generated by the Gradle \'init\' task.\n+*/\n package refactoring.crawler;\n \n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-\n import java.util.Dictionary;\n-import java.util.HashMap;\n import java.util.Hashtable;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import refactoring.crawler.util.RefactoringCategory;\n \n class RefactoringCrawlerTest {\n \n-\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+    private static RefactoringCrawler refactoringCrawler;\n \n-\tprivate static RefactoringCrawler refactoringCrawler;\n+    @BeforeAll\n+    static void setUp() {\n+        settings = new Hashtable<>();\n \n-\t@BeforeAll\n-\tstatic void setUp() {\n-\t\tsettings = new Hashtable<>();\n+        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n+        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n \n-\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n-\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n+    }\n \n-\t\trefactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n-\t}\n+    @Test\n+    void testRenameMethod() {\n+        String source =\n+                "/*\\n"\n+                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+                        + " */\\n"\n+                        + "package refactoring.crawler;\\n"\n+                        + "\\n"\n+                        + "public class Library {\\n"\n+                        + "\\tprivate int a;\\n"\n+                        + "\\tprivate int b;\\n"\n+                        + "\\n"\n+                        + "\\tpublic void foo() {\\n"\n+                        + "\\t\\tSystem.out.println(11111);\\n"\n+                        + "\\t}\\n"\n+                        + "\\n"\n+                        + "\\tpublic void bar() {\\n"\n+                        + "\\t\\tthis.foo();\\n"\n+                        + "\\t}\\n"\n+                        + "}\\n";\n \n+        String newVersion =\n+                "/*\\n"\n+                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n+                        + " */\\n"\n+                        + "package refactoring.crawler;\\n"\n+                        + "\\n"\n+                        + "public class Library {\\n"\n+                        + "\\tprivate int a;\\n"\n+                        + "\\tprivate int b;\\n"\n+                        + "\\n"\n+                        + "\\tpublic void foo12() {\\n"\n+                        + "\\t\\tSystem.out.println(11111);\\n"\n+                        + "\\t}\\n"\n+                        + "\\n"\n+                        + "\\tpublic void bar() {\\n"\n+                        + "\\t\\tthis.foo12();\\n"\n+                        + "\\t}\\n"\n+                        + "}\\n";\n \n-\t@Test\n-\tvoid testSomeLibraryMethod() {\n-\t}\n+        refactoringCrawler.detect(source, newVersion);\n+        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n+        System.out.println(categories);\n+    }\n }',
            rawContent:
              '/*\n* This Java source file was generated by the Gradle \'init\' task.\n*/\npackage refactoring.crawler;\n\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n    private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n    private static RefactoringCrawler refactoringCrawler;\n\n    @BeforeAll\n    static void setUp() {\n        settings = new Hashtable<>();\n\n        settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 1.0);\n        settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 1.0);\n\n        refactoringCrawler = new RefactoringCrawler("TEST_PROJECT_NAME", settings);\n    }\n\n    @Test\n    void testRenameMethod() {\n        String source =\n                "/*\\n"\n                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n                        + " */\\n"\n                        + "package refactoring.crawler;\\n"\n                        + "\\n"\n                        + "public class Library {\\n"\n                        + "\\tprivate int a;\\n"\n                        + "\\tprivate int b;\\n"\n                        + "\\n"\n                        + "\\tpublic void foo() {\\n"\n                        + "\\t\\tSystem.out.println(11111);\\n"\n                        + "\\t}\\n"\n                        + "\\n"\n                        + "\\tpublic void bar() {\\n"\n                        + "\\t\\tthis.foo();\\n"\n                        + "\\t}\\n"\n                        + "}\\n";\n\n        String newVersion =\n                "/*\\n"\n                        + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n                        + " */\\n"\n                        + "package refactoring.crawler;\\n"\n                        + "\\n"\n                        + "public class Library {\\n"\n                        + "\\tprivate int a;\\n"\n                        + "\\tprivate int b;\\n"\n                        + "\\n"\n                        + "\\tpublic void foo12() {\\n"\n                        + "\\t\\tSystem.out.println(11111);\\n"\n                        + "\\t}\\n"\n                        + "\\n"\n                        + "\\tpublic void bar() {\\n"\n                        + "\\t\\tthis.foo12();\\n"\n                        + "\\t}\\n"\n                        + "}\\n";\n\n        refactoringCrawler.detect(source, newVersion);\n        List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n        System.out.println(categories);\n    }\n}\n'
          }
        ]
      },
      {
        sha: "e730803e9a4a7b487df89013a8a6901f07100860",
        message: "chore(*): wait test",
        stats: {
          total: 1438,
          additions: 1231,
          deletions: 207
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "c3f3ef6c45dd1b13fda0b507cc62de4301cc58de"
          }
        ],
        committedAt: 1585207166000,
        changedFiles: [
          {
            sha: "1498e33720ff8e6f5f1ed0dacefa4d33b293101d",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 106,
            deletions: 79,
            patch:
              '@@ -2,66 +2,40 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.expr.MethodCallExpr;\n import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n-import lombok.val;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.jgrapht.nio.dot.DOTExporter;\n-import refactoring.crawler.detection.ChangeMethodSignatureDetection;\n+import lombok.Getter;\n+import refactoring.crawler.detection.classDetection.RenameClassDetection;\n+import refactoring.crawler.detection.methodDetection.*;\n import refactoring.crawler.detection.RefactoringDetection;\n-import refactoring.crawler.detection.RenameMethodDetection;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n-import java.io.IOException;\n-import java.rmi.server.ExportException;\n import java.util.*;\n \n public class RefactoringCrawler {\n \n-\tprivate String projectName;\n+\tpublic static enum Settings {\n+\t\tT_RENAME_METHOD,\n+\t\tT_RENAME_CLASS,\n+\t\tT_MOVE_METHOD,\n+\t\tT_PULL_UP_METHOD,\n+\t\tT_PUSH_DOWN_METHOD,\n+\t\tT_CHANGE_METHOD_SIGNATURE\n+\t}\n \n-\tpublic static void main(String[] args) throws IOException {\n-\t\tval crawler = new RefactoringCrawler("project name");\n-\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n-\t\t\t"public class A{" +\n-\t\t\t"   public void foo(){" +\n-\t\t\t"       System.out.println(1);" +\n-\t\t\t"   }" +\n-\t\t\t"   " +\n-\t\t\t"   public void bar(){" +\n-\t\t\t"       this.foo();" +\n-\t\t\t"   }" +\n-\t\t\t"}";\n-\t\tval newSource = "package com.MyCourses.dao.impl;" +\n-\t\t\t"public class A{" +\n-\t\t\t"   public void foo(int i){" +\n-\t\t\t"       System.out.println(i);" +\n-\t\t\t"   }" +\n-\t\t\t"   public void bar(){" +\n-\t\t\t"       this.foo(10);" +\n-\t\t\t"   }" +\n-\t\t\t"}";\n-\n-\t\tval oldList = new ArrayList<String>();\n-\t\tval newList = new ArrayList<String>();\n-\n-\t\toldList.add(oldSource);\n-\t\tnewList.add(newSource);\n-\n-\t\tcrawler.detect(oldList, newList);\n+\tprivate String projectName;\n+\tprivate Dictionary<Settings, Double> settings;\n \n-\t}\n+\t@Getter\n+\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n \n-\tpublic RefactoringCrawler(String projectName) {\n+\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n \t\tthis.projectName = projectName;\n+\t\tthis.settings = settings;\n \t}\n \n-\tprivate List<CompilationUnit> parse(List<String> files) {\n+\tprivate static List<CompilationUnit> parse(List<String> files) {\n \t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n \t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n \t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n@@ -77,8 +51,8 @@ public RefactoringCrawler(String projectName) {\n \tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n \n-\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n-\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n+\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n+\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n \t\tSourceNavigator navigator = new SourceNavigator();\n \t\tnavigator.setShinglesUtil(shinglesUtil);\n \t\tnavigator.browseProject(projectName, oldVersionCU);\n@@ -90,37 +64,41 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n-//\n-//\t\tSystem.out.println("-----original graph-----");\n-//\t\tfor (Edge e : originalGraph.edgeSet()) {\n-//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n-//\t\t}\n-//\n-//\t\tSystem.out.println("-----new version graph-----");\n-//\t\tfor (Edge e : versionGraph.edgeSet()) {\n-//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n-//\t\t}\n-\n-\n-//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n-//\t\tshinglesUtil.setMethodThreshold(0.5);\n-\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\t// must in this order\n+\n+\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n+\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n+\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n+\n+\n+\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n+\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n+\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n+\t\t\toriginalGraph, versionGraph);\n+\n+\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n+\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n+\n+\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n+\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n \t}\n \n-\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n+\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n \t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n-\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n \t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n \t\tdetector.setThreshold(tChangeMethodSignature);\n \t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n \t\tif (changedMethodSignatures.size() > 0) {\n-\t\t\tSystem.out.println("-----change method signature result-----");\n-\t\t\tSystem.out.println(changedMethodSignatures);\n-//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n-//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n-//\t\t\tchangeSignatureCategory\n-//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n-//\t\t\trefactoringList.add(changeSignatureCategory);\n+\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n+\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n+\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n \t\t}\n \t}\n \n@@ -132,16 +110,65 @@ private void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMu\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {\n-\t\t\tSystem.out.println("-----result below-----");\n-\t\t\trenamedMethods.forEach(r -> {\n-\t\t\t\tSystem.out.println(r[0]);\n-\t\t\t\tSystem.out.println(r[1]);\n-\t\t\t});\n-//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n-//            renameMethodCategory.setName("RenamedMethods");\n-//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n-//            refactoringList.add(renameMethodCategory);\n+\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n+\t\t\trenameMethodCategory.setName("RenamedMethods");\n+\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n+\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n \t\t}\n \t}\n \n+\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n+\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n+\t\t\tversionGraph);\n+\t\tdetector.setThreshold(tClass);\n+\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n+\t\tif (renamedClasses.size() > 0) {\n+\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n+\t\t\trenameClassCategory.setName("RenamedClasses");\n+\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n+\t\t\tthis.refactoringCategories.add(renameClassCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n+\t\tse.findSimilarClasses();\n+\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tMoveMethod);\n+\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n+\t\tif (movedMethods.size() > 0) {\n+\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n+\t\t\tmoveMethodCategory.setName("MovedMethods");\n+\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n+\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n+\t\tRefactoringDetection detector = new PullUpMethodDetection(\n+\t\t\toriginalGraph, versionGraph);\n+\t\tdetector.setThreshold(tPullUpMethod);\n+\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n+\t\tif (pullUpMethodResults.size() > 0) {\n+\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n+\t\t\tpullUpCategory.setName("PulledUpMethods");\n+\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n+\t\t\tthis.refactoringCategories.add(pullUpCategory);\n+\t\t}\n+\t}\n+\n+\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n+\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tPushDownMethod);\n+\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n+\t\tif (pushDownMethodResults.size() > 0) {\n+\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n+\t\t\tpushDownCategory.setName("PushedDownMethods");\n+\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n+\t\t\tthis.refactoringCategories.add(pushDownCategory);\n+\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.Getter;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.util.*;\n\nimport java.util.*;\n\npublic class RefactoringCrawler {\n\n\tpublic static enum Settings {\n\t\tT_RENAME_METHOD,\n\t\tT_RENAME_CLASS,\n\t\tT_MOVE_METHOD,\n\t\tT_PULL_UP_METHOD,\n\t\tT_PUSH_DOWN_METHOD,\n\t\tT_CHANGE_METHOD_SIGNATURE\n\t}\n\n\tprivate String projectName;\n\tprivate Dictionary<Settings, Double> settings;\n\n\t@Getter\n\tprivate List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n\tpublic RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n\t\tthis.projectName = projectName;\n\t\tthis.settings = settings;\n\t}\n\n\tprivate static List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\t// must in this order\n\n\t\tdouble tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n\t\tthis.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n\t\tdetectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n\n\t\tdouble tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n\t\tdetectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n\t\tdetectPullUpMethod(tPullUpMethod, shinglesUtil,\n\t\t\toriginalGraph, versionGraph);\n\n\t\tdouble tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n\t\tdetectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n\t\tdouble tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n\t\tdetectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil\n\t\tshinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tChangeMethodSignature);\n\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n\t\tif (changedMethodSignatures.size() > 0) {\n\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n\t\t\tchangeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n\t\t\tthis.refactoringCategories.add(changeSignatureCategory);\n\t\t}\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tRefactoringCategory renameMethodCategory = new RefactoringCategory();\n\t\t\trenameMethodCategory.setName("RenamedMethods");\n\t\t\trenameMethodCategory.setRefactoringPairs(renamedMethods);\n\t\t\tthis.refactoringCategories.add(renameMethodCategory);\n\t\t}\n\t}\n\n\tpublic void detectRenameClass(double tClass, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateClasses = se.findSimilarClasses();\n\t\tRefactoringDetection detector = new RenameClassDetection(originalGraph,\n\t\t\tversionGraph);\n\t\tdetector.setThreshold(tClass);\n\t\tList<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n\t\tif (renamedClasses.size() > 0) {\n\t\t\tRefactoringCategory renameClassCategory = new RefactoringCategory();\n\t\t\trenameClassCategory.setName("RenamedClasses");\n\t\t\trenameClassCategory.setRefactoringPairs(renamedClasses);\n\t\t\tthis.refactoringCategories.add(renameClassCategory);\n\t\t}\n\t}\n\n\tpublic void detectMoveMethod(double tMoveMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> methodCandidates = se.findSimilarMethods();\n\t\tse.findSimilarClasses();\n\t\tRefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n\t\tdetector.setThreshold(tMoveMethod);\n\t\tList<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n\t\tif (movedMethods.size() > 0) {\n\t\t\tRefactoringCategory moveMethodCategory = new RefactoringCategory();\n\t\t\tmoveMethodCategory.setName("MovedMethods");\n\t\t\tmoveMethodCategory.setRefactoringPairs(movedMethods);\n\t\t\tthis.refactoringCategories.add(moveMethodCategory);\n\t\t}\n\t}\n\n\tpublic void detectPullUpMethod(double tPullUpMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n\t\tRefactoringDetection detector = new PullUpMethodDetection(\n\t\t\toriginalGraph, versionGraph);\n\t\tdetector.setThreshold(tPullUpMethod);\n\t\tList<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n\t\tif (pullUpMethodResults.size() > 0) {\n\t\t\tRefactoringCategory pullUpCategory = new RefactoringCategory();\n\t\t\tpullUpCategory.setName("PulledUpMethods");\n\t\t\tpullUpCategory.setRefactoringPairs(pullUpMethodResults);\n\t\t\tthis.refactoringCategories.add(pullUpCategory);\n\t\t}\n\t}\n\n\tpublic void detectPushDownMethod(double tPushDownMethod, ShinglesUtil se, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n\t\tRefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tPushDownMethod);\n\t\tList<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n\t\tif (pushDownMethodResults.size() > 0) {\n\t\t\tRefactoringCategory pushDownCategory = new RefactoringCategory();\n\t\t\tpushDownCategory.setName("PushedDownMethods");\n\t\t\tpushDownCategory.setRefactoringPairs(pushDownMethodResults);\n\t\t\tthis.refactoringCategories.add(pushDownCategory);\n\t\t}\n\t}\n}\n'
          },
          {
            sha: "e04923c393be759d113e51b42ec573aa46e4095a",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "removed",
            additions: 0,
            deletions: 39,
            patch:
              "@@ -1,39 +0,0 @@\n-package refactoring.crawler.detection;\n-\n-import refactoring.crawler.util.Edge;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-public class MoveMethodDetection extends RefactoringDetection {\n-    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n-        super(graph, graph2);\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public List<Edge> filterNamedEdges(List<Edge> list) {\n-        return null;\n-    }\n-\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n-    }\n-\n-    @Override\n-    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-    }\n-\n-    @Override\n-    public boolean isRename() {\n-        return false;\n-    }\n-}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        return null;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "0b960fc4680ca705d13f9126e0e4cfd015fbbcd1",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 66,
            deletions: 3,
            patch:
              '@@ -2,14 +2,13 @@\n \n import lombok.Getter;\n import lombok.Setter;\n-import org.eclipse.core.runtime.IProgressMonitor;\n-import org.eclipse.core.runtime.SubProgressMonitor;\n+import refactoring.crawler.detection.methodDetection.MoveMethodDetection;\n+import refactoring.crawler.util.ClassNode;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.*;\n-import java.util.stream.Collectors;\n \n public abstract class RefactoringDetection {\n \n@@ -387,4 +386,68 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t}\n \t\treturn prunedCandidates;\n \t}\n+\n+\t// TODO this is bug pruned\n+\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+//\t\ttry {\n+\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n+\t\tresults.forEach(result -> {\n+\t\t\tif (graph.hasNamedNode(result))\n+\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n+\t\t});\n+\t\t// Possible change to methods that instantiate classes\n+\t\t// from class -> class edges.\n+//\t\t\tfor (String result : results) {\n+////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n+//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n+//\t\t\t\tString callingNode = null;\n+//\t\t\t\tif (resultNode instanceof IMethod) {\n+//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof IType) {\n+//\t\t\t\t\tIType rst = (IType) resultNode;\n+//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n+//\t\t\t\t} else if (resultNode instanceof IField) {\n+//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n+//\t\t\t\t\t// Workaround\n+//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += ".";\n+//\t\t\t\t\tcallingNode += rsf1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n+//\t\t\t\t\t\t.getParent(initializer,\n+//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n+//\t\t\t\t\t\tIType.class);\n+//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n+//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n+//\t\t\t\t}\n+//\n+//\t\t\t\t// TODO treat the case when resultNode is instance of\n+//\t\t\t\t// ImportDeclaration\n+//\t\t\t\t// TODO treat the case when resultNode is instance of\n+//\t\t\t\t// Initializer\n+//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n+//\t\t\t\t// Level\n+//\t\t\t\tif (callingNode == null) {\n+//\t\t\t\t\tSystem.out.print("");\n+//\t\t\t\t}\n+//\t\t\t\tif (callingNode != null) {\n+//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n+//\t\t\t\t\tif (callerNode != null)\n+//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n+//\t\t\t\t}\n+//\n+//\t\t\t}\n+//\n+//\t\t} catch (CoreException e) {\n+//\t\t\tJavaPlugin.log(e);\n+//\t\t}\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.util.ClassNode;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t// TODO this is bug pruned\n\tprotected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n//\t\ttry {\n\t\tList<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n\t\tresults.forEach(result -> {\n\t\t\tif (graph.hasNamedNode(result))\n\t\t\t\tgraph.addEdge(originalNode, graph.findNamedNode(result), new Edge(Node.Type.CLASS_REFERENCE));\n\t\t});\n\t\t// Possible change to methods that instantiate classes\n\t\t// from class -> class edges.\n//\t\t\tfor (String result : results) {\n////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n//\t\t\t\tNode resultNode = graph.findNamedNode(result);\n//\t\t\t\tString callingNode = null;\n//\t\t\t\tif (resultNode instanceof IMethod) {\n//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof IType) {\n//\t\t\t\t\tIType rst = (IType) resultNode;\n//\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n//\t\t\t\t} else if (resultNode instanceof IField) {\n//\t\t\t\t\tIField rsf1 = (IField) resultNode;\n//\t\t\t\t\t// Workaround\n//\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += ".";\n//\t\t\t\t\tcallingNode += rsf1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof Initializer) {\n//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n//\t\t\t\t\t\t.getParent(initializer,\n//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n//\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n//\t\t\t\t\t\tIType.class);\n//\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n//\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n//\t\t\t\t}\n//\n//\t\t\t\t// TODO treat the case when resultNode is instance of\n//\t\t\t\t// ImportDeclaration\n//\t\t\t\t// TODO treat the case when resultNode is instance of\n//\t\t\t\t// Initializer\n//\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n//\t\t\t\t// Level\n//\t\t\t\tif (callingNode == null) {\n//\t\t\t\t\tSystem.out.print("");\n//\t\t\t\t}\n//\t\t\t\tif (callingNode != null) {\n//\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n//\t\t\t\t\tif (callerNode != null)\n//\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n//\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n//\t\t\t\t}\n//\n//\t\t\t}\n//\n//\t\t} catch (CoreException e) {\n//\t\t\tJavaPlugin.log(e);\n//\t\t}\n\t}\n}\n'
          },
          {
            sha: "1696bc3d11c7a90c2912eaeeb1b69012438fb710",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 13,
            deletions: 3,
            patch:
              "@@ -4,14 +4,24 @@\n import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import org.eclipse.core.runtime.IProgressMonitor;\n-import refactoring.crawler.util.MethodNode;\n-import refactoring.crawler.util.NamedDirectedMultigraph;\n-import refactoring.crawler.util.Node;\n+import refactoring.crawler.util.*;\n \n import java.util.*;\n import java.util.stream.Collectors;\n \n public class SearchHelper {\n+\tpublic static List<String> findFieldReferences(FieldNode node) {\n+\t\treturn node.getFieldReferenceToMethod();\n+\t}\n+\n+\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n+\t\treturn node.getSuperClasses();\n+\t}\n+\n+\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n+\t\treturn node.getClassesImported();\n+\t}\n+\n \tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n \t\treturn graph.vertexSet()\n \t\t\t.stream()",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SearchHelper {\n\tpublic static List<String> findFieldReferences(FieldNode node) {\n\t\treturn node.getFieldReferenceToMethod();\n\t}\n\n\tpublic static List<String> findSuperClassesOf(ClassNode node) {\n\t\treturn node.getSuperClasses();\n\t}\n\n\tpublic static List<String> findClassReferences(NamedDirectedMultigraph graph, ClassNode node) {\n\t\treturn node.getClassesImported();\n\t}\n\n\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(methodNode ->\n\t\t\t\tmethodNode.getCalledInside()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.anyMatch(calledMethod -> {\n\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.map(methodNode -> {\n\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n\n}\n"
          },
          {
            sha: "0d1a80e9a16088e7355f78676f2bfb2a8a051b38",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/ClassDetection.java",
            status: "added",
            additions: 83,
            deletions: 0,
            patch:
              "@@ -0,0 +1,83 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import org.eclipse.jdt.core.IType;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.util.ClassNode;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ClassDetection extends RefactoringDetection {\n+\n+\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn false;\n+\t}\n+\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t/**\n+\t * We need to find all the places that the original and version classes are\n+\t * instantiated. We will incorporate this into the likeliness grade.\n+\t */\n+\tprotected void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateCallGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateCallGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+\t\tcreateClassReferenceGraph(node, graph);\n+\t\tnode.setCreatedCallGraph();\n+\t}\n+\n+\t/**\n+\t * Accepts two class nodes, and determines if first parameter is a\n+\t * superclass of the second parameter.\n+\t */\n+\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n+\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n+\t\tfor (String superClass : superClasses) {\n+\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+//\t\treturn false;\n+\t}\n+\n+\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport org.eclipse.jdt.core.IType;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.ClassNode;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassDetection extends RefactoringDetection {\n\n\tpublic ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * We need to find all the places that the original and version classes are\n\t * instantiated. We will incorporate this into the likeliness grade.\n\t */\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tcreateClassReferenceGraph(node, graph);\n\t\tnode.setCreatedCallGraph();\n\t}\n\n\t/**\n\t * Accepts two class nodes, and determines if first parameter is a\n\t * superclass of the second parameter.\n\t */\n\tpublic static boolean isSuperClassOf(Node node1, Node node2) {\n\t\tList<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n\t\tfor (String superClass : superClasses) {\n\t\t\tif (superClass.equals(node1.getFullyQualifiedName()))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n//\t\treturn false;\n\t}\n\n\n}\n"
          },
          {
            sha: "ec623de6153010a38b7292c76fd34a0ab7df7bfb",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/MoveClassDetection.java",
            status: "added",
            additions: 47,
            deletions: 0,
            patch:
              "@@ -0,0 +1,47 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class MoveClassDetection extends ClassDetection {\n+\n+\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedClasses) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n+\t\t\t\tparentPackageVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesInDifferentPackages.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesInDifferentPackages;\n+\t}\n+\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MoveClassDetection extends ClassDetection {\n\n\tpublic MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedClasses) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentPackageVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (!isTheSameModuloRename(parentPackageOriginal,\n\t\t\t\tparentPackageVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesInDifferentPackages.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesInDifferentPackages;\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n}\n"
          },
          {
            sha: "954ff3cbdaaa548f8eb95410c1b37bfbb84730f6",
            filename:
              "src/main/java/refactoring/crawler/detection/classDetection/RenameClassDetection.java",
            status: "added",
            additions: 60,
            deletions: 0,
            patch:
              "@@ -0,0 +1,60 @@\n+package refactoring.crawler.detection.classDetection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class RenameClassDetection extends ClassDetection {\n+\n+\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n+\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n+\t}\n+\n+\t/**\n+\t * Calls createCallGraph in ClassDetection\n+\t * Calls filterNamedEdges in ClassDetection\n+\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n+\t *\n+\t * @param nodeOriginal\n+\t * @param nodeVersion\n+\t * @return\n+\t */\n+\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n+\t\tdouble edgeGrade;\n+\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n+\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn edgeGrade;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n+\t\tfor (Node[] pair : prePruned) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n+\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n+\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentPackage;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.classDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RenameClassDetection extends ClassDetection {\n\n\tpublic RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n\t\treturn doEdgeAnalysis(nodeOriginal, nodeVersion);\n\t}\n\n\t/**\n\t * Calls createCallGraph in ClassDetection\n\t * Calls filterNamedEdges in ClassDetection\n\t * Calls computeLikelinessIncomingEdges in RefactoringDetection\n\t *\n\t * @param nodeOriginal\n\t * @param nodeVersion\n\t * @return\n\t */\n\tprivate double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n\t\tdouble edgeGrade;\n\t\tcreateCallGraph(nodeOriginal, nodeVersion);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n\t\tedgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn edgeGrade;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n\t\tfor (Node[] pair : prePruned) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentPackageOriginal = extractParentSimpleName(original);\n\t\t\tString parentPackageVersion = extractParentSimpleName(version);\n\t\t\tif (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithSameParentPackage.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithSameParentPackage;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n}\n"
          },
          {
            sha: "cc703c79cea5583d04d007cba3f37490cd1c7ac5",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/FieldDetection.java",
            status: "added",
            additions: 119,
            deletions: 0,
            patch:
              "@@ -0,0 +1,119 @@\n+package refactoring.crawler.detection.fieldDetection;\n+\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.NullProgressMonitor;\n+import org.eclipse.jdt.core.IMember;\n+import org.eclipse.jdt.core.IMethod;\n+import org.eclipse.jdt.core.dom.Initializer;\n+import org.eclipse.jdt.core.dom.SimpleName;\n+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n+import refactoring.crawler.RefactoringCrawler;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.FieldNode;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class FieldDetection extends RefactoringDetection {\n+\n+\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * (non-Javadoc)\n+\t *\n+\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n+\t */\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+\t}\n+\n+\t@Override\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n+\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n+\n+\t\tfor (String result : results) {\n+//\t\t\t\tIMember resultNode = (IMember) result;\n+//\t\t\t\tString callingNode = null;\n+//\t\t\t\tif (resultNode instanceof IMethod) {\n+//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n+//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n+//\t\t\t\t} else if (resultNode instanceof Initializer) {\n+//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n+//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n+//\t\t\t\t\t\t.getParent(initializer,\n+//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n+//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n+//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n+//\t\t\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n+//\t\t\t\t}\n+\n+\t\t\tNode callerNode = graph.findNamedNode(result);\n+\t\t\tif (callerNode != null)\n+\t\t\t\tgraph.addEdge(callerNode, originalNode,\n+\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n+\t\t}\n+\n+\t}\n+\n+\tpublic void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateFieldReferenceGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateFieldReferenceGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic double analyzeIncomingEdges(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade;\n+\t\tcreateCallGraph(original, version);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t.incomingEdgesOf(version)));\n+\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn incomingEdgesGrade;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport org.eclipse.jdt.core.IMethod;\nimport org.eclipse.jdt.core.dom.Initializer;\nimport org.eclipse.jdt.core.dom.SimpleName;\nimport org.eclipse.jdt.core.dom.VariableDeclarationFragment;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.FieldNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class FieldDetection extends RefactoringDetection {\n\n\tpublic FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see edu.uiuc.detectRefactorings.detection.RefactoringDetection#pruneOriginalCandidates(java.util.List)\n\t */\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n\t}\n\n\t@Override\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n\tprotected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n\t\tfinal List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n\t\tfor (String result : results) {\n//\t\t\t\tIMember resultNode = (IMember) result;\n//\t\t\t\tString callingNode = null;\n//\t\t\t\tif (resultNode instanceof IMethod) {\n//\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n//\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n//\t\t\t\t} else if (resultNode instanceof Initializer) {\n//\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n//\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment) ASTNodes\n//\t\t\t\t\t\t.getParent(initializer,\n//\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n//\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n//\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n//\t\t\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n//\t\t\t\t}\n\n\t\t\tNode callerNode = graph.findNamedNode(result);\n\t\t\tif (callerNode != null)\n\t\t\t\tgraph.addEdge(callerNode, originalNode,\n\t\t\t\t\tnew Edge(Node.Type.FIELD_REFERENCE));\n\t\t}\n\n\t}\n\n\tpublic void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateFieldReferenceGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateFieldReferenceGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n}\n"
          },
          {
            sha: "6d0db189d5bc88a34786d8472ae246a5afd787c1",
            filename:
              "src/main/java/refactoring/crawler/detection/fieldDetection/MoveFieldDetection.java",
            status: "added",
            additions: 45,
            deletions: 0,
            patch:
              "@@ -0,0 +1,45 @@\n+package refactoring.crawler.detection.fieldDetection;\n+\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class MoveFieldDetection extends FieldDetection {\n+\n+\t/*\n+\t * We already have Class - Field edges. So we need to make sure that they\n+\t * are different parents, and also make sure that their call graph is still\n+\t * the same.\n+\t */\n+\n+\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\treturn analyzeIncomingEdges(original, version);\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedFields) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n+\t\t\t\tparentClassVersion);\n+\n+\t\t\tif (!isModRen\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.detection.fieldDetection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n\t/*\n\t * We already have Class - Field edges. So we need to make sure that they\n\t * are different parents, and also make sure that their call graph is still\n\t * the same.\n\t */\n\n\tpublic MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedFields) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tboolean isModRen = isTheSameModuloRename(parentClassOriginal,\n\t\t\t\tparentClassVersion);\n\n\t\t\tif (!isModRen\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n}\n"
          },
          {
            sha: "8af3d221dea4962b6009868d3896457e7d5747a8",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/ChangeMethodSignatureDetection.java",
            status: "renamed",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,4 +1,4 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;",
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n\t/**\n\t * @param graph\n\t * @param graph2\n\t */\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We need to go from the node to the AST and get the actual method. Then we\n\t * will call getSignature() on the IMethod to get the signature. We have to\n\t * make sure the call graphs are checked, since we do not want to detect\n\t * polymorphism as change method signature.\n\t */\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// Need to find out if in V2 there is a node with the same signature\n\t\t// as the original\n\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n\t\t\treturn 1.0;\n\t\telse {\n\t\t\t// This is when we have a method overload or deprecated. So when\n\t\t\t// we can check deprecated methods we need to add it here\n\t\t\treturn analyzeIncomingEdges(original, version);\n\t\t}\n\t}\n\n\t/**\n\t * This will handle the same name condition, explained above.\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n\t\t\t\tcontinue;\n\n\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n\t\t\tif (hasSameNameAndSignature)\n\t\t\t\tcontinue;\n\n\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n\t\t\t\t.getFullyQualifiedName()))\n\t\t\t\tprunedCandidates.add(pair);\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n\t\t// TODO here we have to take into account the RenamigsDictionary\n\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n\t\tboolean hasSameNameAndSignature = false;\n\n\t\tif (n2ParentInV1 != null) {\n\t\t\t// Calling the overloaded method\n\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n\t\t\tfor (Edge methodEdge : allMethodEdges) {\n\t\t\t\tNode targetMethod = methodEdge.getTarget();\n\t\t\t\tif (targetMethod.getSimpleName()\n\t\t\t\t\t.equals(pair[1].getSimpleName())\n\t\t\t\t\t&& targetMethod.getSignature().equals(\n\t\t\t\t\tpair[1].getSignature()))\n\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t}\n\t\t}\n\t\treturn hasSameNameAndSignature;\n\t}\n\n\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n\t\tNode source = pair[0];\n\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n\t\tboolean isDeprecated = false;\n\t\tboolean isRemoved = true;\n\t\tif (parentOfOriginalInV2 != null) {\n\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n\t\t\tfor (Edge edge : methodEdges) {\n\t\t\t\tNode methodNode = edge.getTarget();\n\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n\t\t\t\t\t&& methodNode.getSignature().equals(\n\t\t\t\t\tsource.getSignature())) {\n\t\t\t\t\tisRemoved = false;\n\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn isDeprecated || isRemoved;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tString signatureN1 = pair[0].getSignature();\n\t\t\tString signatureN2 = pair[1].getSignature();\n\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n\t\t\t\tgoodResults.add(pair);\n\t\t}\n\t\treturn goodResults;\n\t}\n\n\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n\t\t// TODO filters out (IPluginDescriptor) with\n\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n\t\t// right now this is checked only for case when there is a one argument\n\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n\t\t\tsignatureN1.length() - 1));\n\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n\t\t\tsignatureN2.length() - 1));\n\t\treturn simpleName1.equals(simpleName2);\n\t}\n\n\tprivate String extractSimpleName(String fqn) {\n\t\tint lastIndex = fqn.lastIndexOf(".");\n\t\tif (lastIndex < 0)\n\t\t\treturn fqn;\n\t\telse\n\t\t\treturn fqn.substring(lastIndex + 1);\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "625c336a140152a6da8374c3d12899e16aa92a5d",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MethodDetection.java",
            status: "renamed",
            additions: 3,
            deletions: 4,
            patch:
              "@@ -1,14 +1,13 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n-import org.eclipse.core.runtime.NullProgressMonitor;\n-import org.eclipse.jdt.core.IMember;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.MethodNode;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n ",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList<String> callers;\n\t\tif (this instanceof ChangeMethodSignatureDetection)\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n\t\telse\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n\t\tfor (String s : callers) {\n\t\t\tNode callerNode = graph.findNamedNode(s);\n\t\t\tif (callerNode != null) {\n\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n\t\t\t}\n\t\t}\n\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n\n}\n"
          },
          {
            sha: "97ca243b42ca519b8d59cc5665fe7de3f91aba96",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/MoveMethodDetection.java",
            status: "added",
            additions: 241,
            deletions: 0,
            patch:
              '@@ -0,0 +1,241 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.RefactoringCrawler;\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+import refactoring.crawler.util.RefactoringCategory;\n+\n+import java.util.*;\n+\n+public class MoveMethodDetection extends MethodDetection {\n+\n+\tprivate Node targetClassInVerGraph;\n+\n+\tprivate Node targetClassInOrigGraph;\n+\n+\tprivate RefactoringCrawler crawler;\n+\n+\t/**\n+\t * Checks for MoveMethod\n+\t * <p>\n+\t * 1. Check that from the old method, all the references to objects having\n+\t * the same type as the destination class were removed\n+\t * <p>\n+\t * 2. Check that the new target class is either a previous argument or a\n+\t * field in the old class\n+\t */\n+\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph1, graph2);\n+\t\tthis.crawler = crawler;\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tdouble edgeGrade = 0.0;\n+\n+\t\tdouble referenceGrade = 0.0;\n+\n+\t\tif (isTargetARenameOfSourceClass(original, version))\n+\t\t\treturn 0.0;\n+\n+\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n+\t\treferenceGrade = referencesRemoved(original, version);\n+\t\tedgeGrade = analyzeIncomingEdges(original, version);\n+\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n+\t}\n+\n+\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n+\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n+\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n+\t\t// treat case 1\n+\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n+\t}\n+\n+\t/**\n+\t * 1. Check that from the old method, all the references to objects having\n+\t * the same type as the destination class were removed\n+\t */\n+\tprivate double referencesRemoved(Node original, Node version) {\n+\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n+\n+\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n+\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n+\t\t// treat case 2\n+\t\tif (targetClassInOrigGraph == null) {\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tEnumeration<String> keys = dictionary.keys();\n+\t\t\tfor (; keys.hasMoreElements(); ) {\n+\t\t\t\tString aKey = keys.nextElement();\n+\t\t\t\tString aValue = dictionary.get(aKey);\n+\t\t\t\tif (targetInVersion.equals(aValue)) {\n+\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// treat case 3\n+\t\t\tif (targetClassInOrigGraph == null)\n+\t\t\t\treturn 1.0;\n+\n+\t\t}\n+\n+\t\t// treat case 2 and 4\n+\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n+\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n+\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n+\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n+\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n+\t\t}\n+\n+\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n+\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n+\t\t\ttargetClassInVerGraph));\n+\t\tif (originalClassReferences.size() == 0) {\n+\t\t\tif (original.isStatic())\n+\t\t\t\treturn 1.0;\n+\t\t\tif (isTargetClassAFieldInSourceClass(original,\n+\t\t\t\ttargetClassInOrigGraph))\n+\t\t\t\treturn 1.0;\n+\t\t\tif (versionClassReferences.size() == 0)\n+\t\t\t\treturn 1.0;\n+\t\t\treturn 0.0;\n+\t\t} else\n+\t\t\treturn Math\n+\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n+\t\t\t\t\t.size()) / originalClassReferences.size()));\n+\t}\n+\n+\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n+\t\tNode parentClass = graph1\n+\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n+\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n+\t\tList<Node> fields = new ArrayList<Node>();\n+\t\tfor (Edge value : edges) {\n+\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n+\t\t\t\tfields.add((Node) value.getTarget());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn fields.contains(theTargetClassInOrigGraph);\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\n+\t\t\t// Prune toString since the SearchEngine finds all the toString()\n+\t\t\t// methods, even those that are called from different classes\n+\t\t\tif ("toString".equals(original.getSimpleName()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Overriden here to prune false positives due to overlapping PullUp and\n+\t * PushDown detection\n+\t */\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n+\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n+\t\treturn withoutFP;\n+\t}\n+\n+\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n+\t\tboolean needsOneMorePass = false;\n+\t\tList<Node[]> addToPUM = new ArrayList<>();\n+\t\tList<Node[]> addToPDM = new ArrayList<>();\n+\t\tfor (Node[] pair : withoutFP) {\n+\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n+\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n+\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n+\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n+\t\t\tif (sourceClass != null && destinationClass != null) {\n+\t\t\t\tif (ClassDetection\n+\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n+\t\t\t\t\taddToPDM.add(pair);\n+\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n+\t\t\t\t\tsourceClass))\n+\t\t\t\t\taddToPUM.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\n+\t\tRefactoringCategory pulledUpCategory = null;\n+\t\tRefactoringCategory pushedDownCategory = null;\n+\t\t// TODO this only checks whether we already have such a category\n+\t\t// created. It might be\n+\t\t// that such a category has not been created previously (because no\n+\t\t// results were found\n+\t\t// for that category. In this case, will need to create a brand new\n+\t\t// Category object.\n+\t\tfor (RefactoringCategory category : refactoringsList) {\n+\t\t\tif (category.getName().equals("PulledUpMethods"))\n+\t\t\t\tpulledUpCategory = category;\n+\n+\t\t\telse if (category.getName().equals("PushedDownMethods"))\n+\t\t\t\tpushedDownCategory = category;\n+\t\t}\n+\n+\t\tfor (Node[] pair : addToPDM) {\n+\t\t\tif (pushedDownCategory != null)\n+\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n+\t\t\twithoutFP.remove(pair);\n+\t\t\tneedsOneMorePass = true;\n+\t\t}\n+\n+\t\tfor (Node[] pair : addToPUM) {\n+\t\t\tif (pulledUpCategory != null)\n+\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n+\t\t\twithoutFP.remove(pair);\n+\t\t\tneedsOneMorePass = true;\n+\t\t}\n+\t\tif (needsOneMorePass)\n+\t\t\treturn pruneFalsePositives(withoutFP);\n+\t\telse return withoutFP;\n+\t}\n+\n+\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n+\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n+\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n+\t\tfor (RefactoringCategory category : refactoringsList) {\n+\t\t\tif (category.getName().equals("PulledUpMethods")\n+\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n+\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n+\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n+\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n+\t\t\t\t\t\t// overlappings\n+\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n+\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n+\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n+\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : pairsToRemove) {\n+\t\t\tprunedList.remove(pair);\n+\t\t}\n+\t\treturn prunedList;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nimport java.util.*;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n\tprivate Node targetClassInVerGraph;\n\n\tprivate Node targetClassInOrigGraph;\n\n\tprivate RefactoringCrawler crawler;\n\n\t/**\n\t * Checks for MoveMethod\n\t * <p>\n\t * 1. Check that from the old method, all the references to objects having\n\t * the same type as the destination class were removed\n\t * <p>\n\t * 2. Check that the new target class is either a previous argument or a\n\t * field in the old class\n\t */\n\tpublic MoveMethodDetection(RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph1, graph2);\n\t\tthis.crawler = crawler;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tdouble edgeGrade = 0.0;\n\n\t\tdouble referenceGrade = 0.0;\n\n\t\tif (isTargetARenameOfSourceClass(original, version))\n\t\t\treturn 0.0;\n\n\t\t// FIXME: Potential problem when we subtract 0.01 from reference grade\n\t\treferenceGrade = referencesRemoved(original, version);\n\t\tedgeGrade = analyzeIncomingEdges(original, version);\n\t\treturn (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n\t}\n\n\tprivate boolean isTargetARenameOfSourceClass(Node original, Node version) {\n\t\tString sourceInOriginal = extractFullyQualifiedParentName(original);\n\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n\t\t// treat case 1\n\t\treturn (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n\t}\n\n\t/**\n\t * 1. Check that from the old method, all the references to objects having\n\t * the same type as the destination class were removed\n\t */\n\tprivate double referencesRemoved(Node original, Node version) {\n\t\tString targetInVersion = extractFullyQualifiedParentName(version);\n\n\t\ttargetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n\t\ttargetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n\t\t// treat case 2\n\t\tif (targetClassInOrigGraph == null) {\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tEnumeration<String> keys = dictionary.keys();\n\t\t\tfor (; keys.hasMoreElements(); ) {\n\t\t\t\tString aKey = keys.nextElement();\n\t\t\t\tString aValue = dictionary.get(aKey);\n\t\t\t\tif (targetInVersion.equals(aValue)) {\n\t\t\t\t\ttargetClassInOrigGraph = graph1.findNamedNode(aKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// treat case 3\n\t\t\tif (targetClassInOrigGraph == null)\n\t\t\t\treturn 1.0;\n\n\t\t}\n\n\t\t// treat case 2 and 4\n\t\tif (!targetClassInVerGraph.hasCallGraph()) {\n\t\t\tcreateClassReferenceGraph(targetClassInVerGraph, graph2);\n\t\t\ttargetClassInVerGraph.setCreatedCallGraph();\n\t\t}\n\t\tif (!targetClassInOrigGraph.hasCallGraph()) {\n\t\t\tcreateClassReferenceGraph(targetClassInOrigGraph, graph1);\n\t\t\ttargetClassInOrigGraph.setCreatedCallGraph();\n\t\t}\n\n\t\tList<Edge> originalClassReferences = new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n\t\tList<Edge> versionClassReferences = new ArrayList<>(graph2.getAllEdges(version,\n\t\t\ttargetClassInVerGraph));\n\t\tif (originalClassReferences.size() == 0) {\n\t\t\tif (original.isStatic())\n\t\t\t\treturn 1.0;\n\t\t\tif (isTargetClassAFieldInSourceClass(original,\n\t\t\t\ttargetClassInOrigGraph))\n\t\t\t\treturn 1.0;\n\t\t\tif (versionClassReferences.size() == 0)\n\t\t\t\treturn 1.0;\n\t\t\treturn 0.0;\n\t\t} else\n\t\t\treturn Math\n\t\t\t\t.abs(((originalClassReferences.size() - versionClassReferences\n\t\t\t\t\t.size()) / originalClassReferences.size()));\n\t}\n\n\tprivate boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n\t\tNode parentClass = graph1\n\t\t\t.findNamedNode(extractFullyQualifiedParentName(original));\n\t\tList<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n\t\tList<Node> fields = new ArrayList<Node>();\n\t\tfor (Edge value : edges) {\n\t\t\tif (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n\t\t\t\tfields.add((Node) value.getTarget());\n\t\t\t}\n\t\t}\n\n\t\treturn fields.contains(theTargetClassInOrigGraph);\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\n\t\t\t// Prune toString since the SearchEngine finds all the toString()\n\t\t\t// methods, even those that are called from different classes\n\t\t\tif ("toString".equals(original.getSimpleName()))\n\t\t\t\tcontinue;\n\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Overriden here to prune false positives due to overlapping PullUp and\n\t * PushDown detection\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n\t\twithoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n\t\treturn withoutFP;\n\t}\n\n\tprivate List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n\t\tboolean needsOneMorePass = false;\n\t\tList<Node[]> addToPUM = new ArrayList<>();\n\t\tList<Node[]> addToPDM = new ArrayList<>();\n\t\tfor (Node[] pair : withoutFP) {\n\t\t\tString parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n\t\t\tString parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n\t\t\tNode sourceClass = graph2.findNamedNode(parentClassOfM1);\n\t\t\tNode destinationClass = graph2.findNamedNode(parentClassOfM2);\n\t\t\tif (sourceClass != null && destinationClass != null) {\n\t\t\t\tif (ClassDetection\n\t\t\t\t\t.isSuperClassOf(sourceClass, destinationClass))\n\t\t\t\t\taddToPDM.add(pair);\n\t\t\t\telse if (ClassDetection.isSuperClassOf(destinationClass,\n\t\t\t\t\tsourceClass))\n\t\t\t\t\taddToPUM.add(pair);\n\t\t\t}\n\t\t}\n\n\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n\t\tRefactoringCategory pulledUpCategory = null;\n\t\tRefactoringCategory pushedDownCategory = null;\n\t\t// TODO this only checks whether we already have such a category\n\t\t// created. It might be\n\t\t// that such a category has not been created previously (because no\n\t\t// results were found\n\t\t// for that category. In this case, will need to create a brand new\n\t\t// Category object.\n\t\tfor (RefactoringCategory category : refactoringsList) {\n\t\t\tif (category.getName().equals("PulledUpMethods"))\n\t\t\t\tpulledUpCategory = category;\n\n\t\t\telse if (category.getName().equals("PushedDownMethods"))\n\t\t\t\tpushedDownCategory = category;\n\t\t}\n\n\t\tfor (Node[] pair : addToPDM) {\n\t\t\tif (pushedDownCategory != null)\n\t\t\t\tpushedDownCategory.getRefactoringPairs().add(pair);\n\t\t\twithoutFP.remove(pair);\n\t\t\tneedsOneMorePass = true;\n\t\t}\n\n\t\tfor (Node[] pair : addToPUM) {\n\t\t\tif (pulledUpCategory != null)\n\t\t\t\tpulledUpCategory.getRefactoringPairs().add(pair);\n\t\t\twithoutFP.remove(pair);\n\t\t\tneedsOneMorePass = true;\n\t\t}\n\t\tif (needsOneMorePass)\n\t\t\treturn pruneFalsePositives(withoutFP);\n\t\telse return withoutFP;\n\t}\n\n\tprivate List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> pairsToRemove = new ArrayList<>();\n\t\tList<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\t\tfor (RefactoringCategory category : refactoringsList) {\n\t\t\tif (category.getName().equals("PulledUpMethods")\n\t\t\t\t|| category.getName().equals("PushedDownMethods")) {\n\t\t\t\tfor (Node[] pair : category.getRefactoringPairs()) {\n\t\t\t\t\tfor (Node[] prunedPair : prunedList) {\n\t\t\t\t\t\t// The OR below takes care about n->1 and 1->n\n\t\t\t\t\t\t// overlappings\n\t\t\t\t\t\t// between PullUp/PushDown and MoveMethod\n\t\t\t\t\t\tif (prunedPair[0] == pair[0]\n\t\t\t\t\t\t\t|| prunedPair[1] == pair[1])\n\t\t\t\t\t\t\tpairsToRemove.add(prunedPair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : pairsToRemove) {\n\t\t\tprunedList.remove(pair);\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n'
          },
          {
            sha: "e178089dc36897c0f9c159a716f4084ed0731325",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PullUpMethodDetection.java",
            status: "added",
            additions: 73,
            deletions: 0,
            patch:
              '@@ -0,0 +1,73 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PullUpMethodDetection extends MethodDetection {\n+\n+\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\t/**\n+\t * We should now check for the same method being in the parent class, thus\n+\t * for the two nodes, check if the version now resides in the superclass of\n+\t * the original method\'s parent class.\n+\t */\n+\t// TODO: Check why we get a null pointer exception with parentclassver and\n+\t// parent class orig)\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade = 0.0;\n+\t\tboolean isSuperclass = false;\n+\t\t// TODO: Think about possible different cases that this might be\n+\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n+\t\t// find it.\n+\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n+\t\t// since clearly they are not "like" each other.\n+\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n+\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+\t\tif (parentClassOrig == null)\n+\t\t\treturn 0.0;\n+\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n+\t\t// Now we should check if parentClassOrig is a subclass of\n+\t\t// parentClassVer\n+\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n+\t\t\tisSuperclass = true;\n+\n+\t\tif (isSuperclass) {\n+\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n+\t\t\treturn incomingEdgesGrade;\n+\t\t} else\n+\t\t\treturn 0.0;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n+\t\t\tString parentClassVersion = extractParentSimpleName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n\tpublic PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We should now check for the same method being in the parent class, thus\n\t * for the two nodes, check if the version now resides in the superclass of\n\t * the original method\'s parent class.\n\t */\n\t// TODO: Check why we get a null pointer exception with parentclassver and\n\t// parent class orig)\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tdouble incomingEdgesGrade = 0.0;\n\t\tboolean isSuperclass = false;\n\t\t// TODO: Think about possible different cases that this might be\n\t\t// an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n\t\t// find it.\n\t\t// TODO: Think about the NULL case. Return 0.0 if you find null,\n\t\t// since clearly they are not "like" each other.\n\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n\t\tif (parentClassOrig == null)\n\t\t\treturn 0.0;\n\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n\t\t// Now we should check if parentClassOrig is a subclass of\n\t\t// parentClassVer\n\t\tif (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig))\n\t\t\tisSuperclass = true;\n\n\t\tif (isSuperclass) {\n\t\t\tincomingEdgesGrade = analyzeIncomingEdges(original, version);\n\t\t\treturn incomingEdgesGrade;\n\t\t} else\n\t\t\treturn 0.0;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n\t\t\tString parentClassVersion = extractParentSimpleName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "b294ba304e0b455f8e8b43f0d0e623d7b6dd2a76",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/PushDownMethodDetection.java",
            status: "added",
            additions: 59,
            deletions: 0,
            patch:
              '@@ -0,0 +1,59 @@\n+package refactoring.crawler.detection.methodDetection;\n+\n+import refactoring.crawler.detection.classDetection.ClassDetection;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PushDownMethodDetection extends MethodDetection {\n+\n+\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\tboolean superClassGrade = false;\n+\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n+\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n+\t\tif (parentClassOrig == null)\n+\t\t\treturn 0.0;\n+\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n+\t\t// Now we should check if parentClassVer is a subclass of\n+\t\t// parentClassOrig\n+\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n+\t\t\tSystem.out.println("stop");\n+\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n+\t\t\tsuperClassGrade = true;\n+\t\tif (superClassGrade) {\n+\t\t\treturn (analyzeIncomingEdges(original, version));\n+\t\t} else\n+\t\t\treturn 0.0;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n+\t\t\tString parentClassVersion = extractParentSimpleName(version);\n+\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& ((original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName())))) {\n+\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn candidatesWithDifferentParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n\tpublic PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\tboolean superClassGrade = false;\n\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\tparentClassOriginal = extractPotentialRename(parentClassOriginal);\n\t\tNode parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n\t\tif (parentClassOrig == null)\n\t\t\treturn 0.0;\n\t\tNode parentClassVer = graph2.findNamedNode(parentClassVersion);\n\t\t// Now we should check if parentClassVer is a subclass of\n\t\t// parentClassOrig\n\t\tif (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n\t\t\tSystem.out.println("stop");\n\t\tif (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer))\n\t\t\tsuperClassGrade = true;\n\t\tif (superClassGrade) {\n\t\t\treturn (analyzeIncomingEdges(original, version));\n\t\t} else\n\t\t\treturn 0.0;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractParentSimpleName(original);\n\t\t\tString parentClassVersion = extractParentSimpleName(version);\n\t\t\tif (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& ((original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName())))) {\n\t\t\t\tcandidatesWithDifferentParentClass.add(pair);\n\t\t\t}\n\t\t}\n\n\t\treturn candidatesWithDifferentParentClass;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n}\n'
          },
          {
            sha: "94f098d51ee0471f28ac6927bcb59e39fdcb7761",
            filename:
              "src/main/java/refactoring/crawler/detection/methodDetection/RenameMethodDetection.java",
            status: "renamed",
            additions: 2,
            deletions: 3,
            patch:
              "@@ -1,11 +1,10 @@\n-package refactoring.crawler.detection;\n+package refactoring.crawler.detection.methodDetection;\n \n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n import java.util.Dictionary;\n-import java.util.Iterator;\n import java.util.List;\n \n \n@@ -56,7 +55,7 @@ public boolean isRename() {\n \tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n \t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n \t\tfor (int i = 0; i < prunedList.size(); i++) {\n-\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n+\t\t\tNode[] pair = prunedList.get(i);\n \t\t\tNode target = pair[1];\n \t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n \t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();",
            rawContent:
              "package refactoring.crawler.detection.methodDetection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\n\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n\n\t/**\n\t * @param candidates List containing clone methods\n\t * @return A List containing only the candidate methods that are in the same\n\t * class\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// createCallGraph(original, version);\n\t\t// return computeLikelinessConsideringEdges(original, version);\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prune further for cases that have n-to-1 mappings.\n\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tfor (int i = 0; i < prunedList.size(); i++) {\n\t\t\tNode[] pair = prunedList.get(i);\n\t\t\tNode target = pair[1];\n\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n\t\t\tfor (Node[] nodes : prunedList) {\n\t\t\t\tNode potentialTarget = (nodes)[1];\n\t\t\t\tif (target == potentialTarget)\n\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n\t\t\t}\n\t\t\tif (allPairsWithSameTarget.size() > 1) {\n\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n\t\t\t\t\t\t.toLowerCase().trim();\n\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n\t\t\t\t\tif ((!targetName.contains(sourceName))\n\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n"
          },
          {
            sha: "00cee96d44bda296bedd8ace9164f49a11748191",
            filename: "src/main/java/refactoring/crawler/util/ClassNode.java",
            status: "added",
            additions: 28,
            deletions: 0,
            patch:
              "@@ -0,0 +1,28 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.List;\n+import java.util.LinkedList;\n+\n+public class ClassNode extends Node {\n+\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> classesImported = new LinkedList<>();\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> superClasses = new LinkedList<>();\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic ClassNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.CLASS);\n+\t}\n+\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\nimport java.util.LinkedList;\n\npublic class ClassNode extends Node {\n\n\n\t@Getter\n\t@Setter\n\tprivate List<String> classesImported = new LinkedList<>();\n\n\t@Getter\n\t@Setter\n\tprivate List<String> superClasses = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic ClassNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.CLASS);\n\t}\n\n\n}\n"
          },
          {
            sha: "6cebaf36c9c7009584cf32c1ff857cdfb7f4813d",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "modified",
            additions: 28,
            deletions: 22,
            patch:
              '@@ -6,26 +6,32 @@\n \n public class Edge extends DefaultEdge {\n \n-    @Getter\n-    @Setter\n-    private Node.Type label;\n-\n-    public Edge(Node.Type label) {\n-        this.label = label;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n-    }\n-\n-    @Override\n-    public Node getSource() {\n-        return (Node) super.getSource();\n-    }\n-\n-    @Override\n-    public Node getTarget() {\n-        return (Node) super.getTarget();\n-    }\n+\t@Getter\n+\t@Setter\n+\tprivate Node.Type label;\n+\n+\tpublic Edge(Node.Type label) {\n+\t\tthis.label = label;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+\t}\n+\n+\t@Override\n+\tpublic Node getSource() {\n+\t\treturn (Node) super.getSource();\n+\t}\n+\n+\t@Override\n+\tpublic Node getTarget() {\n+\t\treturn (Node) super.getTarget();\n+\t}\n+\n+\tpublic Node oppositeVertex(Node n) {\n+\t\tNode source = this.getSource();\n+\t\tNode target = this.getTarget();\n+\t\treturn n.equals(source) ? target : source;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n\t@Getter\n\t@Setter\n\tprivate Node.Type label;\n\n\tpublic Edge(Node.Type label) {\n\t\tthis.label = label;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n\t}\n\n\t@Override\n\tpublic Node getSource() {\n\t\treturn (Node) super.getSource();\n\t}\n\n\t@Override\n\tpublic Node getTarget() {\n\t\treturn (Node) super.getTarget();\n\t}\n\n\tpublic Node oppositeVertex(Node n) {\n\t\tNode source = this.getSource();\n\t\tNode target = this.getTarget();\n\t\treturn n.equals(source) ? target : source;\n\t}\n}\n'
          },
          {
            sha: "3edd7e34e34292cefdbea31e40877cd476a0c10b",
            filename: "src/main/java/refactoring/crawler/util/FieldNode.java",
            status: "added",
            additions: 20,
            deletions: 0,
            patch:
              "@@ -0,0 +1,20 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.List;\n+\n+public class FieldNode extends Node {\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<String> fieldReferenceToMethod;\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic FieldNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.FIELD);\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\npublic class FieldNode extends Node {\n\n\t@Getter\n\t@Setter\n\tprivate List<String> fieldReferenceToMethod;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic FieldNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.FIELD);\n\t}\n}\n"
          },
          {
            sha: "b88943178596cfa00a23eb9dfea16003b1d12e03",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 5,
            deletions: 0,
            patch:
              "@@ -30,4 +30,9 @@ public boolean addNamedVertex(Node v) {\n \tpublic Node findNamedNode(String name) {\n \t\treturn namedVertexMap.get(name);\n \t}\n+\n+\n+\tpublic boolean hasNamedNode(String name) {\n+\t\treturn namedVertexMap.containsKey(name);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n\n\n\tpublic boolean hasNamedNode(String name) {\n\t\treturn namedVertexMap.containsKey(name);\n\t}\n}\n"
          },
          {
            sha: "b31e4580aad57d3fb656e5bed35e174040baacd4",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -62,6 +62,10 @@ public void setCreatedCallGraph() {\n \t@Getter\n \tprivate boolean isInterface = false;\n \n+\t@Getter\n+\t@Setter\n+\tprivate boolean isStatic = false;\n+\n \t/**\n \t * @param fullyQualifiedName fullyQualifiedName\n \t * @param type               type",
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isStatic = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "6b5c0fa502f84f849ff6181575c63b6abf816148",
            filename:
              "src/main/java/refactoring/crawler/util/RefactoringCategory.java",
            status: "added",
            additions: 37,
            deletions: 0,
            patch:
              '@@ -0,0 +1,37 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import java.util.List;\n+\n+public class RefactoringCategory {\n+\n+\t@Getter\n+\t@Setter\n+\tprivate String name;\n+\n+\t@Getter\n+\t@Setter\n+\tprivate List<Node[]> refactoringPairs;\n+\n+\tpublic Node[][] getElements() {\n+\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n+\t\tint i = 0;\n+\t\tfor (Node[] pair : refactoringPairs) {\n+\t\t\telements[i++] = pair;\n+\t\t}\n+\t\treturn elements;\n+\t}\n+\n+\tpublic String toString() {\n+\t\treturn name + printElements(getElements());\n+\t}\n+\n+\tprivate String printElements(Node[][] array) {\n+\t\tStringBuilder res = new StringBuilder();\n+\t\tfor (Node[] nodes : array) {\n+\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n+\t\t}\n+\t\treturn res.toString();\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.util.List;\n\npublic class RefactoringCategory {\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate List<Node[]> refactoringPairs;\n\n\tpublic Node[][] getElements() {\n\t\tNode[][] elements = new Node[refactoringPairs.size()][];\n\t\tint i = 0;\n\t\tfor (Node[] pair : refactoringPairs) {\n\t\t\telements[i++] = pair;\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic String toString() {\n\t\treturn name + printElements(getElements());\n\t}\n\n\tprivate String printElements(Node[][] array) {\n\t\tStringBuilder res = new StringBuilder();\n\t\tfor (Node[] nodes : array) {\n\t\t\tres.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n\t\t}\n\t\treturn res.toString();\n\t}\n}\n'
          },
          {
            sha: "9801e24b80c70d9b0bb8d32c20ec878e51851ca6",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 95,
            deletions: 6,
            patch:
              "@@ -2,15 +2,18 @@\n \n import lombok.Getter;\n import lombok.Setter;\n+import org.eclipse.core.runtime.IProgressMonitor;\n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n \n import java.util.*;\n \n public class ShinglesUtil {\n \n-\tprivate int w = 3;\n+\tprivate int w = 2;\n+\tprivate int sClass = 10;\n \tprivate int sMethod = 8;\n+\tprivate double classThreshold = 0.0;\n \n \t@Getter\n \t@Setter\n@@ -19,11 +22,13 @@\n \n \tprivate ShinglesStrategy shinglesStrategy;\n \n-\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\tprivate NamedDirectedMultigraph oldVersionGraph;\n \n-\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n+\tprivate NamedDirectedMultigraph newVersionGraph;\n+\n+\tprivate List<Node[]> similarMethods = new LinkedList<>();\n+\tprivate List<Node[]> similarClasses = new LinkedList<>();\n \n-\tprivate List<Node[]> similarMethods;\n \n \tprivate List<Node> oldVersionPackageList;\n \tprivate List<Node> oldVersionClassList;\n@@ -124,8 +129,6 @@ public void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMul\n \t\tthis.oldVersionGraph = oldVersionGraph;\n \t\tthis.newVersionGraph = newVersionGraph;\n \n-\t\tthis.similarMethods = new LinkedList<>();\n-\n \t\tthis.oldVersionPackageList = new ArrayList<>();\n \t\tthis.oldVersionClassList = new ArrayList<>();\n \t\tthis.oldVersionMethodList = new ArrayList<>();\n@@ -205,4 +208,90 @@ private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n \t\t}\n \t\treturn grade;\n \t}\n+\n+\n+\t/**\n+\t * @param classes\n+\t * @param graph   <br>\n+\t *                For each class nodes in classes, find the shingles by\n+\t *                concatenating shingles in methods of its subtree. The\n+\t *                parameter s_class will determine the maximum size of shingles\n+\t */\n+\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n+\t\tfor (Node clasz : classes) {\n+\t\t\t// We will keep the number of methods for the class with the\n+\t\t\t// numberOfMethods variable.\n+\t\t\tint numberOfMethods = 0;\n+\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n+\t\t\tint methodsTotalShingleSize = 0;\n+\t\t\tfor (Edge e : outEdges) {\n+\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n+\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n+\t\t\t\t\t// Here we update the method count.\n+\t\t\t\t\tnumberOfMethods++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n+\t\t\t// the class\n+\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n+\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n+\t\t\tint index = 0;\n+\t\t\tfor (Edge e : outEdges) {\n+\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n+\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n+\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n+\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n+\t\t\t\t\t\tindex++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n+\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n+\t\t\tArrays.sort(allShinglesFromMethods);\n+\n+\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n+\t\t\t\tallShinglesFromMethods.length);\n+\n+\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n+\t\t\tif (upperBoundForClassShingles >= 0)\n+\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n+\t\t\tclasz.setShingles(retVal);\n+\t\t}\n+\t}\n+\n+\n+\tpublic List<Node[]> findSimilarClasses() {\n+\t\tif (this.similarClasses.isEmpty()) {\n+\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n+\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n+\t\t\tList<Node[]> simClass = new ArrayList<>();\n+\t\t\tfor (Node c : this.oldVersionClassList) {\n+\t\t\t\tif (!c.isAPI())\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n+\t\t\t\t\tif (!c2.isAPI())\n+\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n+\t\t\t\t\t\tNode[] arr = {c, c2};\n+\t\t\t\t\t\tsimClass.add(arr);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.similarClasses = simClass;\n+\t\t}\n+\t\treturn this.similarClasses;\n+\t}\n+\n+\tpublic List<Node[]> findPullUpMethodCandidates() {\n+\t\treturn findSimilarMethods();\n+\t}\n+\n+\tpublic List<Node[]> findPushDownMethodCandidates() {\n+\t\treturn findSimilarMethods();\n+\t}\n }",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 2;\n\tprivate int sClass = 10;\n\tprivate int sMethod = 8;\n\tprivate double classThreshold = 0.0;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate NamedDirectedMultigraph oldVersionGraph;\n\n\tprivate NamedDirectedMultigraph newVersionGraph;\n\n\tprivate List<Node[]> similarMethods = new LinkedList<>();\n\tprivate List<Node[]> similarClasses = new LinkedList<>();\n\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n\n\n\t/**\n\t * @param classes\n\t * @param graph   <br>\n\t *                For each class nodes in classes, find the shingles by\n\t *                concatenating shingles in methods of its subtree. The\n\t *                parameter s_class will determine the maximum size of shingles\n\t */\n\tprivate void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n\t\tfor (Node clasz : classes) {\n\t\t\t// We will keep the number of methods for the class with the\n\t\t\t// numberOfMethods variable.\n\t\t\tint numberOfMethods = 0;\n\t\t\tList<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n\t\t\tint methodsTotalShingleSize = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tmethodsTotalShingleSize += neighbor.getShingles().length;\n\t\t\t\t\t// Here we update the method count.\n\t\t\t\t\tnumberOfMethods++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fill allShinglesFromMethods with shingles from all the methods in\n\t\t\t// the class\n\t\t\tint[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n\t\t\tArrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n\t\t\tint index = 0;\n\t\t\tfor (Edge e : outEdges) {\n\t\t\t\tNode neighbor = e.oppositeVertex(clasz);\n\t\t\t\tif (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n\t\t\t\t\tfor (int j = 0; j < neighbor.getShingles().length; j++) {\n\t\t\t\t\t\tallShinglesFromMethods[index] = neighbor.getShingles()[j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint upperBoundForClassShingles = this.shinglesStrategy\n\t\t\t\t.upperBoundForClassShingles(numberOfMethods, sClass);\n\t\t\tArrays.sort(allShinglesFromMethods);\n\n\t\t\tupperBoundForClassShingles = Math.min(upperBoundForClassShingles,\n\t\t\t\tallShinglesFromMethods.length);\n\n\t\t\tint[] retVal = new int[upperBoundForClassShingles];\n\t\t\tif (upperBoundForClassShingles >= 0)\n\t\t\t\tSystem.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n\t\t\tclasz.setShingles(retVal);\n\t\t}\n\t}\n\n\n\tpublic List<Node[]> findSimilarClasses() {\n\t\tif (this.similarClasses.isEmpty()) {\n\t\t\tcomputeClassShingles(oldVersionClassList, oldVersionGraph);\n\t\t\tcomputeClassShingles(newVersionClassList, newVersionGraph);\n\t\t\tList<Node[]> simClass = new ArrayList<>();\n\t\t\tfor (Node c : this.oldVersionClassList) {\n\t\t\t\tif (!c.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node c2 : this.oldVersionClassList) {\n\t\t\t\t\tif (!c2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n\t\t\t\t\t\tNode[] arr = {c, c2};\n\t\t\t\t\t\tsimClass.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarClasses = simClass;\n\t\t}\n\t\treturn this.similarClasses;\n\t}\n\n\tpublic List<Node[]> findPullUpMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n\n\tpublic List<Node[]> findPushDownMethodCandidates() {\n\t\treturn findSimilarMethods();\n\t}\n}\n'
          },
          {
            sha: "f7a4e3eb7036c93426ffa654744d6420ca8eadbf",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 58,
            deletions: 33,
            patch:
              '@@ -1,28 +1,16 @@\n package refactoring.crawler.util;\n \n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Optional;\n+import java.util.*;\n import java.util.stream.Collectors;\n \n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.NodeList;\n-import com.github.javaparser.ast.PackageDeclaration;\n-import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n-import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n-import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n-import org.eclipse.jdt.core.Signature;\n-import refactoring.crawler.detection.SearchHelper;\n-import refactoring.crawler.project.*;\n-\n-import javax.annotation.Nonnull;\n \n public class SourceNavigator {\n \n@@ -59,6 +47,14 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\tthis.graph.addNamedVertex(projectNode);\n \t\tcompilationUnits.forEach(cu -> {\n \t\t\tval packageDeclaration = cu.getPackageDeclaration();\n+\t\t\tval importDeclarations = cu.getImports();\n+\n+\t\t\tval classesImported = new LinkedList<String>();\n+\n+\t\t\timportDeclarations.forEach(importDeclaration -> {\n+\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n+\t\t\t});\n+\n \t\t\tif (packageDeclaration.isPresent()) {\n \t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n \t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n@@ -70,8 +66,18 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n \t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n \t\t\t\t\t\tif (className.isPresent()) {\n-\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n+\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n \t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n+\n+\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n+\t\t\t\t\t\t\t\t.getExtendedTypes()\n+\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n+\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n+\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n+\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n \t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n \t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n \n@@ -83,40 +89,40 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n \t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n \n-\t\t\t\t\t\t\t// fields\n-\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n-\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n-\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n-\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n-\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n-//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n-\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n-\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t\t\t\t\t\t});\n-\n \t\t\t\t\t\t\t// methods\n \t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n \n+\t\t\t\t\t\t\t// filed fqn -> methods fqn\n+\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n+\n \t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n \t\t\t\t\t\t\t\tString statementBody = "";\n \t\t\t\t\t\t\t\tval methodBody = method.getBody();\n+\n \t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n \t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n \t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n \t\t\t\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n-\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n-\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n \t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n \n+\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n+\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n+\t\t\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n+\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n+\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n+\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n+\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n+\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t});\n+\n \t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n \t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n \t\t\t\t\t\t\t\t\t\t.stream()\n@@ -133,6 +139,7 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n \t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n \t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n \t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n@@ -141,6 +148,24 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t});\n+\n+\t\t\t\t\t\t\t// fields\n+\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n+\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n+\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n+\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n+\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n+\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n+\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n+\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n+\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t\t\t\t\t\t});\n+\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t});',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tval importDeclarations = cu.getImports();\n\n\t\t\tval classesImported = new LinkedList<String>();\n\n\t\t\timportDeclarations.forEach(importDeclaration -> {\n\t\t\t\tclassesImported.add(importDeclaration.getName().asString());\n\t\t\t});\n\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new ClassNode(className.get());\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\n\t\t\t\t\t\t\tList<String> extendedClasses = classOrInterfaceDeclaration\n\t\t\t\t\t\t\t\t.getExtendedTypes()\n\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t.map(extendType -> extendType.resolve().getQualifiedName())\n\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\tclassNode.setStatic(classOrInterfaceDeclaration.isStatic());\n\t\t\t\t\t\t\tclassNode.setSuperClasses(extendedClasses);\n\t\t\t\t\t\t\tclassNode.setClassesImported(classesImported);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\t// filed fqn -> methods fqn\n\t\t\t\t\t\t\tMap<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<String> methodReferencedFields = method\n\t\t\t\t\t\t\t\t\t\t.findAll(FieldAccessExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(fieldAccessExpr -> classNode.getFullyQualifiedName() + "." + fieldAccessExpr.resolve().getName())\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodReferencedFields.forEach(field -> {\n\t\t\t\t\t\t\t\t\t\tif (fieldReferenceToMethods.containsKey(field)) {\n\t\t\t\t\t\t\t\t\t\t\tList<String> methods = fieldReferenceToMethods.get(field);\n\t\t\t\t\t\t\t\t\t\t\tmethods.add(qualifiedName);\n\t\t\t\t\t\t\t\t\t\t\tfieldReferenceToMethods.put(field, methods);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setStatic(method.isStatic());\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tFieldNode fieldNode = new FieldNode(fullyQualifiedName);\n\t\t\t\t\t\t\t\tfieldNode.setFieldReferenceToMethod(fieldReferenceToMethods.get(fullyQualifiedName));\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setStatic(field.isStatic());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          },
          {
            sha: "1f2ec2d8c7de952487f2f8c7cf6e125976d6ad20",
            filename: "src/test/java/refactoring/crawler/LibraryTest.java",
            status: "removed",
            additions: 0,
            deletions: 14,
            patch:
              "@@ -1,14 +0,0 @@\n-/*\n- * This Java source file was generated by the Gradle 'init' task.\n- */\n-package refactoring.crawler;\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class LibraryTest {\n-    @Test void testSomeLibraryMethod() {\n-        Library classUnderTest = new Library();\n-        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n-    }\n-}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LibraryTest {\n    @Test void testSomeLibraryMethod() {\n        Library classUnderTest = new Library();\n        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n    }\n}\n"
          },
          {
            sha: "69398cea4eb28ca2b13d692fc180459eb1e14de7",
            filename:
              "src/test/java/refactoring/crawler/RefactoringCrawlerTest.java",
            status: "added",
            additions: 38,
            deletions: 0,
            patch:
              "@@ -0,0 +1,38 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Dictionary;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RefactoringCrawlerTest {\n+\n+\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n+\n+\tprivate static RefactoringCrawler refactoringCrawler;\n+\n+\t@BeforeAll\n+\tstatic void setUp() {\n+\t\tsettings = new Hashtable<>();\n+\n+\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n+\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n+\n+\t\trefactoringCrawler = new RefactoringCrawler(\"TEST_PROJECT_NAME\", settings);\n+\t}\n+\n+\n+\t@Test\n+\tvoid testSomeLibraryMethod() {\n+\t}\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass RefactoringCrawlerTest {\n\n\tprivate static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n\tprivate static RefactoringCrawler refactoringCrawler;\n\n\t@BeforeAll\n\tstatic void setUp() {\n\t\tsettings = new Hashtable<>();\n\n\t\tsettings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n\t\tsettings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n\n\t\trefactoringCrawler = new RefactoringCrawler(\"TEST_PROJECT_NAME\", settings);\n\t}\n\n\n\t@Test\n\tvoid testSomeLibraryMethod() {\n\t}\n}\n"
          }
        ]
      },
      {
        sha: "c3f3ef6c45dd1b13fda0b507cc62de4301cc58de",
        message: "chore(*): change method signature done",
        stats: {
          total: 75,
          additions: 55,
          deletions: 20
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ed8cc549a4696b0c444297b28762620e0afa48cc"
          }
        ],
        committedAt: 1585140539000,
        changedFiles: [
          {
            sha: "12047025139d93dc12dde8e522729241033a06b8",
            filename:
              "src/main/java/refactoring/crawler/util/DefaultStrategy.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.util;\n+\n+/**\n+ * @author Can Comertoglu\n+ */\n+public class DefaultStrategy implements ShinglesStrategy {\n+\n+\t/**\n+\t *\n+\t */\n+\tpublic DefaultStrategy() {\n+\t\tsuper();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+\t */\n+\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n+\t\treturn s_base;\n+\t}\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\n/**\n * @author Can Comertoglu\n */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic DefaultStrategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base;\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base;\n\t}\n\n}\n"
          },
          {
            sha: "5e4173ffc4ab3d1c31902027268e6658fe26be2f",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "modified",
            additions: 19,
            deletions: 19,
            patch:
              "@@ -2,27 +2,27 @@\n \n public class FactorOf2Strategy implements ShinglesStrategy {\n \n-    /**\n-     *\n-     */\n-    public FactorOf2Strategy() {\n-        super();\n-    }\n+\t/**\n+\t *\n+\t */\n+\tpublic FactorOf2Strategy() {\n+\t\tsuper();\n+\t}\n \n-    /* (non-Javadoc)\n-     * @Override\n-     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n-     */\n-    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n-        return s_base + (2 * loc);\n-    }\n+\t/* (non-Javadoc)\n+\t * @Override\n+\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+\t */\n+\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+\t\treturn s_base + (2 * loc);\n+\t}\n \n-    public int upperBoundForClassShingles(int numMethods, int s_base) {\n-        return s_base + (2 * numMethods);\n-    }\n+\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n+\t\treturn s_base + (2 * numMethods);\n+\t}\n \n-    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n-        return s_base + (2 * numClasses);\n-    }\n+\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n+\t\treturn s_base + (2 * numClasses);\n+\t}\n \n }",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n\t/**\n\t *\n\t */\n\tpublic FactorOf2Strategy() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @Override\n\t * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n\t */\n\tpublic int upperBoundLimitForShinglesBag(int loc, int s_base) {\n\t\treturn s_base + (2 * loc);\n\t}\n\n\tpublic int upperBoundForClassShingles(int numMethods, int s_base) {\n\t\treturn s_base + (2 * numMethods);\n\t}\n\n\tpublic int upperBoundForPackageShingles(int numClasses, int s_base) {\n\t\treturn s_base + (2 * numClasses);\n\t}\n\n}\n"
          },
          {
            sha: "53a045b17a633fbf52372607e489349c0d9047ca",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 2,
            deletions: 1,
            patch:
              "@@ -36,7 +36,8 @@\n \tprivate List<Node> newVersionFieldList;\n \n \tpublic ShinglesUtil() {\n-\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+\t\tthis.shinglesStrategy = new DefaultStrategy();\n+//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n \t}\n \n \tpublic List<String> tokenizer(String s) {",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new DefaultStrategy();\n//\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "629e5440838db0a76f7127c8defbfb8eb5c0abce",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 4,
            deletions: 0,
            patch:
              '@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Optional;\n@@ -108,7 +109,10 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n \t\t\t\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n+\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n+\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n \t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tSystem.out.println(String.format("----%s method body-----", method.getName().toString()));\n\t\t\t\t\t\t\t\t\tSystem.out.println(statementBody);\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tSystem.out.println(Arrays.toString(shingles));\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "ed8cc549a4696b0c444297b28762620e0afa48cc",
        message: "chore(*): rename method done",
        stats: {
          total: 585,
          additions: 422,
          deletions: 163
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "ec166d65d12437ff89774c5db554e23f66c83c5c"
          }
        ],
        committedAt: 1585139513000,
        changedFiles: [
          {
            sha: "27dbe5826813d518e4e9c1c0ab98f42303748c25",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 42,
            deletions: 23,
            patch:
              '@@ -8,7 +8,9 @@\n import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import lombok.val;\n+import org.eclipse.core.runtime.IProgressMonitor;\n import org.jgrapht.nio.dot.DOTExporter;\n+import refactoring.crawler.detection.ChangeMethodSignatureDetection;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n import refactoring.crawler.detection.SearchHelper;\n@@ -17,10 +19,7 @@\n \n import java.io.IOException;\n import java.rmi.server.ExportException;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class RefactoringCrawler {\n \n@@ -40,11 +39,11 @@ public static void main(String[] args) throws IOException {\n \t\t\t"}";\n \t\tval newSource = "package com.MyCourses.dao.impl;" +\n \t\t\t"public class A{" +\n-\t\t\t"   public void fooA(){" +\n-\t\t\t"       System.out.println(1);" +\n+\t\t\t"   public void foo(int i){" +\n+\t\t\t"       System.out.println(i);" +\n \t\t\t"   }" +\n \t\t\t"   public void bar(){" +\n-\t\t\t"       this.fooA();" +\n+\t\t\t"       this.foo(10);" +\n \t\t\t"   }" +\n \t\t\t"}";\n \n@@ -91,33 +90,53 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n+//\n+//\t\tSystem.out.println("-----original graph-----");\n+//\t\tfor (Edge e : originalGraph.edgeSet()) {\n+//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n+//\t\t}\n+//\n+//\t\tSystem.out.println("-----new version graph-----");\n+//\t\tfor (Edge e : versionGraph.edgeSet()) {\n+//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+//\t\t}\n+\n+\n+//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+//\t\tshinglesUtil.setMethodThreshold(0.5);\n+\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n+\t}\n \n-\t\tSystem.out.println("-----original graph-----");\n-\t\tfor (Edge e : originalGraph.edgeSet()) {\n-\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n-\t\t}\n-\n-\t\tSystem.out.println("-----new version graph-----");\n-\t\tfor (Edge e : versionGraph.edgeSet()) {\n-\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n+\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n+\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n+\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n+\t\tdetector.setThreshold(tChangeMethodSignature);\n+\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n+\t\tif (changedMethodSignatures.size() > 0) {\n+\t\t\tSystem.out.println("-----change method signature result-----");\n+\t\t\tSystem.out.println(changedMethodSignatures);\n+//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n+//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n+//\t\t\tchangeSignatureCategory\n+//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n+//\t\t\trefactoringList.add(changeSignatureCategory);\n \t\t}\n-\n-\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n-\n-\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n-\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n-\t\tSystem.out.println(res);\n \t}\n \n \tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n \t                                NamedDirectedMultigraph newVersionGraph) {\n \t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n \t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-//\t\tdetector.setThreshold(tMethod);\n+\t\tdetector.setThreshold(tMethod);\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {\n-\t\t\tSystem.out.println(renamedMethods);\n+\t\t\tSystem.out.println("-----result below-----");\n+\t\t\trenamedMethods.forEach(r -> {\n+\t\t\t\tSystem.out.println(r[0]);\n+\t\t\t\tSystem.out.println(r[1]);\n+\t\t\t});\n //            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n //            renameMethodCategory.setName("RenamedMethods");\n //            renameMethodCategory.setRefactoringPairs(renamedMethods);',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.val;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.ChangeMethodSignatureDetection;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.*;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   " +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(int i){" +\n\t\t\t"       System.out.println(i);" +\n\t\t\t"   }" +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo(10);" +\n\t\t\t"   }" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n//\n//\t\tSystem.out.println("-----original graph-----");\n//\t\tfor (Edge e : originalGraph.edgeSet()) {\n//\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n//\t\t}\n//\n//\t\tSystem.out.println("-----new version graph-----");\n//\t\tfor (Edge e : versionGraph.edgeSet()) {\n//\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n//\t\t}\n\n\n//\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n//\t\tshinglesUtil.setMethodThreshold(0.5);\n\t\tdetectChangeMethodSignature(0.5, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectChangeMethodSignature(double tChangeMethodSignature, ShinglesUtil shinglesUtil, NamedDirectedMultigraph originalGraph, NamedDirectedMultigraph versionGraph) {\n\t\tList<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n\t\tSystem.out.println(candidateChangedMethodSignatures.size());\n\t\tRefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n\t\tdetector.setThreshold(tChangeMethodSignature);\n\t\tList<Node[]> changedMethodSignatures = detector.detectRefactorings(candidateChangedMethodSignatures);\n\t\tif (changedMethodSignatures.size() > 0) {\n\t\t\tSystem.out.println("-----change method signature result-----");\n\t\t\tSystem.out.println(changedMethodSignatures);\n//\t\t\tRefactoringCategory changeSignatureCategory = new RefactoringCategory();\n//\t\t\tchangeSignatureCategory.setName("ChangedMethodSignatures");\n//\t\t\tchangeSignatureCategory\n//\t\t\t\t.setRefactoringPairs(changedMethodSignatures);\n//\t\t\trefactoringList.add(changeSignatureCategory);\n\t\t}\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println("-----result below-----");\n\t\t\trenamedMethods.forEach(r -> {\n\t\t\t\tSystem.out.println(r[0]);\n\t\t\t\tSystem.out.println(r[1]);\n\t\t\t});\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "34fccc1f16d30f2566aef991638bf54a7d781af7",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 132,
            deletions: 2,
            patch:
              '@@ -4,11 +4,141 @@\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n+\n+\t/**\n+\t * @param graph\n+\t * @param graph2\n+\t */\n \tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n \t\tsuper(graph, graph2);\n \t}\n+\n+\t/**\n+\t * We need to go from the node to the AST and get the actual method. Then we\n+\t * will call getSignature() on the IMethod to get the signature. We have to\n+\t * make sure the call graphs are checked, since we do not want to detect\n+\t * polymorphism as change method signature.\n+\t */\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\t// Need to find out if in V2 there is a node with the same signature\n+\t\t// as the original\n+\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n+\t\t\treturn 1.0;\n+\t\telse {\n+\t\t\t// This is when we have a method overload or deprecated. So when\n+\t\t\t// we can check deprecated methods we need to add it here\n+\t\t\treturn analyzeIncomingEdges(original, version);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This will handle the same name condition, explained above.\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n+\t\t\t\tcontinue;\n+\n+\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n+\n+\t\t\tif (hasSameNameAndSignature)\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n+\t\t\t\t.getFullyQualifiedName()))\n+\t\t\t\tprunedCandidates.add(pair);\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n+\t\t// TODO here we have to take into account the RenamigsDictionary\n+\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n+\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n+\n+\t\tboolean hasSameNameAndSignature = false;\n+\n+\t\tif (n2ParentInV1 != null) {\n+\t\t\t// Calling the overloaded method\n+\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n+\t\t\tfor (Edge methodEdge : allMethodEdges) {\n+\t\t\t\tNode targetMethod = methodEdge.getTarget();\n+\t\t\t\tif (targetMethod.getSimpleName()\n+\t\t\t\t\t.equals(pair[1].getSimpleName())\n+\t\t\t\t\t&& targetMethod.getSignature().equals(\n+\t\t\t\t\tpair[1].getSignature()))\n+\t\t\t\t\thasSameNameAndSignature = true;\n+\t\t\t}\n+\t\t}\n+\t\treturn hasSameNameAndSignature;\n+\t}\n+\n+\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n+\t\tNode source = pair[0];\n+\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n+\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n+\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n+\t\tboolean isDeprecated = false;\n+\t\tboolean isRemoved = true;\n+\t\tif (parentOfOriginalInV2 != null) {\n+\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n+\t\t\tfor (Edge edge : methodEdges) {\n+\t\t\t\tNode methodNode = edge.getTarget();\n+\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n+\t\t\t\t\t&& methodNode.getSignature().equals(\n+\t\t\t\t\tsource.getSignature())) {\n+\t\t\t\t\tisRemoved = false;\n+\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn isDeprecated || isRemoved;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n+\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n+\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tString signatureN1 = pair[0].getSignature();\n+\t\t\tString signatureN2 = pair[1].getSignature();\n+\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n+\t\t\t\tgoodResults.add(pair);\n+\t\t}\n+\t\treturn goodResults;\n+\t}\n+\n+\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n+\t\t// TODO filters out (IPluginDescriptor) with\n+\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n+\t\t// right now this is checked only for case when there is a one argument\n+\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n+\t\t\tsignatureN1.length() - 1));\n+\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n+\t\t\tsignatureN2.length() - 1));\n+\t\treturn simpleName1.equals(simpleName2);\n+\t}\n+\n+\tprivate String extractSimpleName(String fqn) {\n+\t\tint lastIndex = fqn.lastIndexOf(".");\n+\t\tif (lastIndex < 0)\n+\t\t\treturn fqn;\n+\t\telse\n+\t\t\treturn fqn.substring(lastIndex + 1);\n+\t}\n+\n+\tpublic boolean isRename() {\n+\t\treturn false;\n+\t}\n+\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n\t/**\n\t * @param graph\n\t * @param graph2\n\t */\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t/**\n\t * We need to go from the node to the AST and get the actual method. Then we\n\t * will call getSignature() on the IMethod to get the signature. We have to\n\t * make sure the call graphs are checked, since we do not want to detect\n\t * polymorphism as change method signature.\n\t */\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// Need to find out if in V2 there is a node with the same signature\n\t\t// as the original\n\t\tif (isDeprecatedOrRemoved(new Node[]{original, version}))\n\t\t\treturn 1.0;\n\t\telse {\n\t\t\t// This is when we have a method overload or deprecated. So when\n\t\t\t// we can check deprecated methods we need to add it here\n\t\t\treturn analyzeIncomingEdges(original, version);\n\t\t}\n\t}\n\n\t/**\n\t * This will handle the same name condition, explained above.\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (pair[0].getSignature().equals(pair[1].getSignature()))\n\t\t\t\tcontinue;\n\n\t\t\tif (!(pair[0].isAPI() && pair[1].isAPI()))\n\t\t\t\tcontinue;\n\n\t\t\tboolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n\t\t\tif (hasSameNameAndSignature)\n\t\t\t\tcontinue;\n\n\t\t\tif (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1]\n\t\t\t\t.getFullyQualifiedName()))\n\t\t\t\tprunedCandidates.add(pair);\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\tprivate boolean hasTheSameSignatureAndName(Node[] pair) {\n\t\t// TODO here we have to take into account the RenamigsDictionary\n\t\tString parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n\t\tNode n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n\t\tboolean hasSameNameAndSignature = false;\n\n\t\tif (n2ParentInV1 != null) {\n\t\t\t// Calling the overloaded method\n\t\t\tList<Edge> allMethodEdges = filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n\t\t\tfor (Edge methodEdge : allMethodEdges) {\n\t\t\t\tNode targetMethod = methodEdge.getTarget();\n\t\t\t\tif (targetMethod.getSimpleName()\n\t\t\t\t\t.equals(pair[1].getSimpleName())\n\t\t\t\t\t&& targetMethod.getSignature().equals(\n\t\t\t\t\tpair[1].getSignature()))\n\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t}\n\t\t}\n\t\treturn hasSameNameAndSignature;\n\t}\n\n\tprivate boolean isDeprecatedOrRemoved(Node[] pair) {\n\t\tNode source = pair[0];\n\t\tString parentOfOriginal = extractFullyQualifiedParentName(source);\n\t\tparentOfOriginal = extractPotentialRename(parentOfOriginal);\n\t\tNode parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n\t\tboolean isDeprecated = false;\n\t\tboolean isRemoved = true;\n\t\tif (parentOfOriginalInV2 != null) {\n\t\t\tList<Edge> methodEdges = filterNamedEdges(new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n\t\t\tfor (Edge edge : methodEdges) {\n\t\t\t\tNode methodNode = edge.getTarget();\n\t\t\t\tif (methodNode.getSimpleName().equals(source.getSimpleName())\n\t\t\t\t\t&& methodNode.getSignature().equals(\n\t\t\t\t\tsource.getSignature())) {\n\t\t\t\t\tisRemoved = false;\n\t\t\t\t\tisDeprecated = methodNode.isDeprecated();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn isDeprecated || isRemoved;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\t//  List prunedInParent= super.pruneFalsePositives(listWithFP);\n\t\tList<Node[]> goodResults = new ArrayList<Node[]>();\n\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tString signatureN1 = pair[0].getSignature();\n\t\t\tString signatureN2 = pair[1].getSignature();\n\t\t\tif (!isTheSameSignature(signatureN1, signatureN2))\n\t\t\t\tgoodResults.add(pair);\n\t\t}\n\t\treturn goodResults;\n\t}\n\n\tprivate boolean isTheSameSignature(String signatureN1, String signatureN2) {\n\t\t// TODO filters out (IPluginDescriptor) with\n\t\t// (org.eclipse.core.runtime.IPluginDescriptor)\n\t\t// right now this is checked only for case when there is a one argument\n\t\tString simpleName1 = extractSimpleName(signatureN1.substring(1,\n\t\t\tsignatureN1.length() - 1));\n\t\tString simpleName2 = extractSimpleName(signatureN2.substring(1,\n\t\t\tsignatureN2.length() - 1));\n\t\treturn simpleName1.equals(simpleName2);\n\t}\n\n\tprivate String extractSimpleName(String fqn) {\n\t\tint lastIndex = fqn.lastIndexOf(".");\n\t\tif (lastIndex < 0)\n\t\t\treturn fqn;\n\t\telse\n\t\t\treturn fqn.substring(lastIndex + 1);\n\t}\n\n\tpublic boolean isRename() {\n\t\treturn false;\n\t}\n\n}\n'
          },
          {
            sha: "10ce3b52ecb7246b266a6b9e8cc53f9d04108ebe",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "modified",
            additions: 23,
            deletions: 34,
            patch:
              "@@ -1,20 +1,18 @@\n package refactoring.crawler.detection;\n \n-import lombok.val;\n import org.eclipse.core.runtime.NullProgressMonitor;\n import org.eclipse.jdt.core.IMember;\n-import refactoring.crawler.project.IMethod;\n import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.MethodNode;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n \n public abstract class MethodDetection extends RefactoringDetection {\n-\n \tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n \t\tsuper(graph, graph2);\n \t}\n@@ -26,7 +24,7 @@ public double computeLikeliness(Node node1, Node node12) {\n \t}\n \n \t@Override\n-\tpublic List pruneOriginalCandidates(List candidates) {\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n \t\t// TODO Auto-generated method stub\n \t\treturn null;\n \t}\n@@ -39,34 +37,27 @@ public boolean isRename() {\n \n \tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n \t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge edge : list) {\n-\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n-\t\t\t\tresults.add(edge);\n+\t\tfor (Edge value : list) {\n+\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n+\t\t\t\tresults.add(value);\n \t\t\t}\n \t\t}\n \t\treturn results;\n \t}\n \n \tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-\t\tList callers;\n-//\t\tif (this instanceof ChangeMethodSignatureDetection)\n-//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n-//\t\t\t\tnew NullProgressMonitor(), true);\n-//\t\telse\n-//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n-//\t\t\t\tnew NullProgressMonitor(), false);\n-//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n-//\t\t\tIMember element = (IMember) iter.next();\n-//\t\t\tString nodeName = element.getElementName();\n-//\t\t\tString qualifiername = element.getDeclaringType()\n-//\t\t\t\t.getFullyQualifiedName('.');\n-//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n-//\t\t\tif (caller != null) {\n-//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n-//\t\t\t\tgraph.addEdge(edge);\n-//\t\t\t}\n-//\t\t}\n-//\t\tnode.setCreatedCallGraph();\n+\t\tList<String> callers;\n+\t\tif (this instanceof ChangeMethodSignatureDetection)\n+\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n+\t\telse\n+\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n+\t\tfor (String s : callers) {\n+\t\t\tNode callerNode = graph.findNamedNode(s);\n+\t\t\tif (callerNode != null) {\n+\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n+\t\t\t}\n+\t\t}\n+\t\tnode.setCreatedCallGraph();\n \n \t}\n \n@@ -84,13 +75,11 @@ protected void createCallGraph(Node original, Node version) {\n \tpublic double analyzeIncomingEdges(Node original, Node version) {\n \t\tdouble incomingEdgesGrade;\n \t\tcreateCallGraph(original, version);\n-\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n-\t\t\t.incomingEdgesOf(original)));\n-\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n-\t\t\t.incomingEdgesOf(version)));\n-//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n-//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n-\t\treturn 0;\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n+\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn incomingEdgesGrade;\n \t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge value : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n\t\t\t\tresults.add(value);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList<String> callers;\n\t\tif (this instanceof ChangeMethodSignatureDetection)\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n\t\telse\n\t\t\tcallers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n\t\tfor (String s : callers) {\n\t\t\tNode callerNode = graph.findNamedNode(s);\n\t\t\tif (callerNode != null) {\n\t\t\t\tgraph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n\t\t\t}\n\t\t}\n\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn incomingEdgesGrade;\n\t}\n\n}\n"
          },
          {
            sha: "371a3be9c3b244c46853753f69922e2f051ecbe4",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 69,
            deletions: 0,
            patch:
              '@@ -13,6 +13,9 @@\n \n public abstract class RefactoringDetection {\n \n+\n+\t@Getter\n+\t@Setter\n \tprivate double threshold;\n \n \tprotected NamedDirectedMultigraph graph1;\n@@ -61,6 +64,11 @@ public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigra\n \t\treturn pruneFalsePositives(listWithFP);\n \t}\n \n+\tprotected String extractPotentialRename(String parentClassOriginal) {\n+\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n+\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n+\t}\n+\n \tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n \t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n \t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n@@ -317,5 +325,66 @@ protected String extractParentSimpleName(Node original) {\n \t\treturn parentName;\n \t}\n \n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n \n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n+\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original)))\n+\t\t\treturn true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n+\t\t\tversion.substring(version.lastIndexOf("."))))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original),\n+\t\t\t\textractFullyQualifiedParentName(version));\n+\t\telse\n+\t\t\treturn false;\n+\t}\n+\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+\t\t\t\t.getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n+\t\t\t\t\t\t.getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.SubProgressMonitor;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic abstract class RefactoringDetection {\n\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprotected String extractPotentialRename(String parentClassOriginal) {\n\t\tString renamedName = getRenamingDictionary().get(parentClassOriginal);\n\t\treturn renamedName == null ? parentClassOriginal : renamedName;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."))))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n}\n'
          },
          {
            sha: "7fbafeccdf5e8625c8206b10f80b0d9bc6795b3d",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 72,
            deletions: 25,
            patch:
              "@@ -1,39 +1,86 @@\n package refactoring.crawler.detection;\n \n-import org.jgrapht.graph.AbstractBaseGraph;\n-import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Dictionary;\n+import java.util.Iterator;\n+import java.util.List;\n+\n \n public class RenameMethodDetection extends MethodDetection {\n \n \tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n \t\tsuper(oldVersion, newVersion);\n \t}\n \n-//\t@Override\n-//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-//\t\tfor (Node[] pair : prePrunedMethods) {\n-//\t\t\tNode original = pair[0];\n-//\t\t\tNode version = pair[1];\n-//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-//\t\t\t\t&& (!(original.getSimpleName().equals(version\n-//\t\t\t\t.getSimpleName()))))\n-//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-//\t\t}\n-//\n-//\t\treturn candidatesWithSameParentClass;\n-//\t}\n-//\n-//\t@Override\n-//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n-//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n-//\t}\n \n+\t/**\n+\t * @param candidates List containing clone methods\n+\t * @return A List containing only the candidate methods that are in the same\n+\t * class\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName()))))\n+\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentClass;\n+\t}\n+\n+\tpublic double computeLikeliness(Node original, Node version) {\n+\t\t// createCallGraph(original, version);\n+\t\t// return computeLikelinessConsideringEdges(original, version);\n+\t\treturn analyzeIncomingEdges(original, version);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Prune further for cases that have n-to-1 mappings.\n+\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n+\t */\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n+\t\tfor (int i = 0; i < prunedList.size(); i++) {\n+\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n+\t\t\tNode target = pair[1];\n+\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n+\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n+\t\t\tfor (Node[] nodes : prunedList) {\n+\t\t\t\tNode potentialTarget = (nodes)[1];\n+\t\t\t\tif (target == potentialTarget)\n+\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n+\t\t\t}\n+\t\t\tif (allPairsWithSameTarget.size() > 1) {\n+\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n+\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n+\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n+\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n+\t\t\t\t\t\t.toLowerCase().trim();\n+\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n+\t\t\t\t\tif ((!targetName.contains(sourceName))\n+\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n+\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n+\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedList;\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.Iterator;\nimport java.util.List;\n\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n\n\t/**\n\t * @param candidates List containing clone methods\n\t * @return A List containing only the candidate methods that are in the same\n\t * class\n\t */\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new ArrayList();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\tpublic double computeLikeliness(Node original, Node version) {\n\t\t// createCallGraph(original, version);\n\t\t// return computeLikelinessConsideringEdges(original, version);\n\t\treturn analyzeIncomingEdges(original, version);\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prune further for cases that have n-to-1 mappings.\n\t * (eg. {start, end, pointAt} -> getStartConnector) in JHD5.3 )\n\t */\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n\t\tfor (int i = 0; i < prunedList.size(); i++) {\n\t\t\tNode[] pair = (Node[]) prunedList.get(i);\n\t\t\tNode target = pair[1];\n\t\t\tString targetName = target.getSimpleName().toLowerCase().trim();\n\t\t\tList<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n\t\t\tfor (Node[] nodes : prunedList) {\n\t\t\t\tNode potentialTarget = (nodes)[1];\n\t\t\t\tif (target == potentialTarget)\n\t\t\t\t\tallPairsWithSameTarget.add(nodes);\n\t\t\t}\n\t\t\tif (allPairsWithSameTarget.size() > 1) {\n\t\t\t\tfor (Object o : allPairsWithSameTarget) {\n\t\t\t\t\tNode[] sameTargetPair = (Node[]) o;\n\t\t\t\t\tNode sourceNode = sameTargetPair[0];\n\t\t\t\t\tString sourceName = sourceNode.getSimpleName()\n\t\t\t\t\t\t.toLowerCase().trim();\n\t\t\t\t\t// Changed from || to && and changed the !='s to =='s\n\t\t\t\t\tif ((!targetName.contains(sourceName))\n\t\t\t\t\t\t&& (!sourceName.contains(targetName))) {\n\t\t\t\t\t\tprunedList.remove(sameTargetPair);\n\t\t\t\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\t\t\t\tdictionary.remove(sourceNode.getFullyQualifiedName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedList;\n\t}\n}\n"
          },
          {
            sha: "a4e72639da4c9e32b6cec2b81eff3a66d81090ad",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 77,
            deletions: 77,
            patch:
              '@@ -10,81 +10,81 @@\n \n public class Node {\n \n-    public boolean hasCallGraph() {\n-        return false;\n-    }\n-\n-    public void setCreatedCallGraph() {\n-    }\n-\n-    public static enum Type {\n-        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n-    }\n-\n-\n-    @Getter\n-    @Setter\n-    private String fullyQualifiedName;\n-\n-    @Setter\n-    @Getter\n-    private Node.Type type;\n-\n-    @Setter\n-    @Getter\n-    private int[] shingles;\n-\n-    @Setter\n-    @Getter\n-    private boolean hasCallGraph;\n-\n-    @Setter\n-    @Getter\n-    private String projectName;\n-\n-    @Setter\n-    @Getter\n-    private boolean isAPI = false;\n-\n-    @Setter\n-    @Getter\n-    private String signature;\n-\n-    @Setter\n-    @Getter\n-    private int flags;\n-\n-    @Setter\n-    @Getter\n-    private boolean deprecated = false;\n-\n-    @Setter\n-    @Getter\n-    private boolean isInterface = false;\n-\n-    /**\n-     * @param fullyQualifiedName fullyQualifiedName\n-     * @param type               type\n-     */\n-    public Node(String fullyQualifiedName, Node.Type type) {\n-        this.fullyQualifiedName = fullyQualifiedName;\n-        this.type = type;\n-    }\n-\n-    public String getSimpleName() {\n-        int pos = fullyQualifiedName.lastIndexOf(".");\n-        if (pos != -1) {\n-            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n-                    .length());\n-        }\n-        return fullyQualifiedName;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (getSignature() != null)\n-            return getType() + "= " + getFullyQualifiedName() + getSignature();\n-        else\n-            return getType() + "= " + getFullyQualifiedName();\n-    }\n+\tpublic boolean hasCallGraph() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic void setCreatedCallGraph() {\n+\t}\n+\n+\tpublic static enum Type {\n+\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n+\t}\n+\n+\n+\t@Getter\n+\t@Setter\n+\tprivate String fullyQualifiedName;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate Node.Type type;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate int[] shingles;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean hasCallGraph;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate String projectName;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean isAPI = false;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate String signature;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate int flags;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean deprecated = false;\n+\n+\t@Setter\n+\t@Getter\n+\tprivate boolean isInterface = false;\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t * @param type               type\n+\t */\n+\tpublic Node(String fullyQualifiedName, Node.Type type) {\n+\t\tthis.fullyQualifiedName = fullyQualifiedName;\n+\t\tthis.type = type;\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n+\t\tif (pos != -1) {\n+\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n+\t\t\t\t.length());\n+\t\t}\n+\t\treturn fullyQualifiedName;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tif (getSignature() != null)\n+\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n+\t\telse\n+\t\t\treturn getType() + "= " + getFullyQualifiedName();\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n\tpublic boolean hasCallGraph() {\n\t\treturn false;\n\t}\n\n\tpublic void setCreatedCallGraph() {\n\t}\n\n\tpublic static enum Type {\n\t\tPROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n\t}\n\n\n\t@Getter\n\t@Setter\n\tprivate String fullyQualifiedName;\n\n\t@Setter\n\t@Getter\n\tprivate Node.Type type;\n\n\t@Setter\n\t@Getter\n\tprivate int[] shingles;\n\n\t@Setter\n\t@Getter\n\tprivate boolean hasCallGraph;\n\n\t@Setter\n\t@Getter\n\tprivate String projectName;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isAPI = false;\n\n\t@Setter\n\t@Getter\n\tprivate String signature;\n\n\t@Setter\n\t@Getter\n\tprivate int flags;\n\n\t@Setter\n\t@Getter\n\tprivate boolean deprecated = false;\n\n\t@Setter\n\t@Getter\n\tprivate boolean isInterface = false;\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t * @param type               type\n\t */\n\tpublic Node(String fullyQualifiedName, Node.Type type) {\n\t\tthis.fullyQualifiedName = fullyQualifiedName;\n\t\tthis.type = type;\n\t}\n\n\tpublic String getSimpleName() {\n\t\tint pos = fullyQualifiedName.lastIndexOf(".");\n\t\tif (pos != -1) {\n\t\t\treturn fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n\t\t\t\t.length());\n\t\t}\n\t\treturn fullyQualifiedName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (getSignature() != null)\n\t\t\treturn getType() + "= " + getFullyQualifiedName() + getSignature().substring(getSignature().indexOf("("));\n\t\telse\n\t\t\treturn getType() + "= " + getFullyQualifiedName();\n\t}\n}\n'
          },
          {
            sha: "b985ec3efc1794451df364522d497a5b176bcf6e",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 7,
            deletions: 2,
            patch:
              "@@ -1,5 +1,7 @@\n package refactoring.crawler.util;\n \n+import lombok.Getter;\n+import lombok.Setter;\n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n \n@@ -10,6 +12,11 @@\n \tprivate int w = 3;\n \tprivate int sMethod = 8;\n \n+\t@Getter\n+\t@Setter\n+\tprivate double methodThreshold = 0.0;\n+\n+\n \tprivate ShinglesStrategy shinglesStrategy;\n \n \tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n@@ -28,8 +35,6 @@\n \tprivate List<Node> newVersionMethodList;\n \tprivate List<Node> newVersionFieldList;\n \n-\tprivate double methodThreshold;\n-\n \tpublic ShinglesUtil() {\n \t\tthis.shinglesStrategy = new FactorOf2Strategy();\n \t}",
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\t@Getter\n\t@Setter\n\tprivate double methodThreshold = 0.0;\n\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "ec166d65d12437ff89774c5db554e23f66c83c5c",
        message: "chore(*): store callers of method",
        stats: {
          total: 768,
          additions: 383,
          deletions: 385
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "adcac2cd85ee8ad64986e41843ebeccfe40b634e"
          }
        ],
        committedAt: 1585134032000,
        changedFiles: [
          {
            sha: "5154729799dd8700cb1a1de21582a267ddd1e304",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 34,
            deletions: 78,
            patch:
              '@@ -2,10 +2,16 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.symbolsolver.JavaSymbolSolver;\n+import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n import lombok.val;\n import org.jgrapht.nio.dot.DOTExporter;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n@@ -22,83 +28,24 @@\n \n \tpublic static void main(String[] args) throws IOException {\n \t\tval crawler = new RefactoringCrawler("project name");\n-\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n-\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n-\t\t\t" * @ClassName ForumDAO\\n" +\n-\t\t\t" * @Author Lai Kin Meng\\n" +\n-\t\t\t" * @Date 2019-02-25\\n" +\n-\t\t\t" * @ProjectName MyCoursesServer\\n" +\n-\t\t\t" */\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n-\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n-\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n-\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import javax.persistence.EntityManager;\\n" +\n-\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"@Repository\\n" +\n-\t\t\t"@Transactional\\n" +\n-\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @PersistenceContext\\n" +\n-\t\t\t"    private EntityManager entityManager;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n-\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n-\t\t\t"    }\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n-\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n-\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n-\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n-\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n-\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n-\t\t\t"        entityManager.flush();\\n" +\n-\t\t\t"    }\\n" +\n+\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n+\t\t\t"public class A{" +\n+\t\t\t"   public void foo(){" +\n+\t\t\t"       System.out.println(1);" +\n+\t\t\t"   }" +\n+\t\t\t"   " +\n+\t\t\t"   public void bar(){" +\n+\t\t\t"       this.foo();" +\n+\t\t\t"   }" +\n \t\t\t"}";\n-\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n-\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n-\t\t\t" * @ClassName ForumDAO\\n" +\n-\t\t\t" * @Author Lai Kin Meng\\n" +\n-\t\t\t" * @Date 2019-02-25\\n" +\n-\t\t\t" * @ProjectName MyCoursesServer\\n" +\n-\t\t\t" */\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n-\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n-\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n-\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"import javax.persistence.EntityManager;\\n" +\n-\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"@Repository\\n" +\n-\t\t\t"@Transactional\\n" +\n-\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @PersistenceContext\\n" +\n-\t\t\t"    private EntityManager entityManager;\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n-\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n-\t\t\t"    }\\n" +\n-\t\t\t"\\n" +\n-\t\t\t"    @Override\\n" +\n-\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n-\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n-\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n-\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n-\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n-\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n-\t\t\t"        entityManager.flush();\\n" +\n-\t\t\t"    }\\n" +\n+\t\tval newSource = "package com.MyCourses.dao.impl;" +\n+\t\t\t"public class A{" +\n+\t\t\t"   public void fooA(){" +\n+\t\t\t"       System.out.println(1);" +\n+\t\t\t"   }" +\n+\t\t\t"   public void bar(){" +\n+\t\t\t"       this.fooA();" +\n+\t\t\t"   }" +\n \t\t\t"}";\n \n \t\tval oldList = new ArrayList<String>();\n@@ -116,9 +63,14 @@ public RefactoringCrawler(String projectName) {\n \t}\n \n \tprivate List<CompilationUnit> parse(List<String> files) {\n+\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n+\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n+\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n \t\tList<CompilationUnit> resList = new LinkedList<>();\n \t\tfor (String source : files) {\n-\t\t\tresList.add(StaticJavaParser.parse(source));\n+\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n+\t\t\tresList.add(cu);\n \t\t}\n \t\treturn resList;\n \t}\n@@ -150,14 +102,18 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n \t\t}\n \n+\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n+\n \t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n+\t\tSystem.out.println(res);\n \t}\n \n \tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n \t                                NamedDirectedMultigraph newVersionGraph) {\n \t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n \t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n-\t\tdetector.setThreshold(tMethod);\n+//\t\tdetector.setThreshold(tMethod);\n \n \t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n \t\tif (renamedMethods.size() > 0) {',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport lombok.val;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void foo(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   " +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.foo();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;" +\n\t\t\t"public class A{" +\n\t\t\t"   public void fooA(){" +\n\t\t\t"       System.out.println(1);" +\n\t\t\t"   }" +\n\t\t\t"   public void bar(){" +\n\t\t\t"       this.fooA();" +\n\t\t\t"   }" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tTypeSolver typeSolver = new ReflectionTypeSolver();\n\t\tJavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n\t\tStaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tCompilationUnit cu = StaticJavaParser.parse(source);\n\t\t\tresList.add(cu);\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tSystem.out.println("-----original graph-----");\n\t\tfor (Edge e : originalGraph.edgeSet()) {\n\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println("-----new version graph-----");\n\t\tfor (Edge e : versionGraph.edgeSet()) {\n\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println(originalGraph.getNamedVertexMap());\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t\tval res = SearchHelper.findMethodCallers(originalGraph, (MethodNode) originalGraph.findNamedNode("com.MyCourses.dao.impl.A.foo"), false);\n\t\tSystem.out.println(res);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n//\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "d1ac2fa49b6e77d50b9b70da0ddd06cf1bf6f61c",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "modified",
            additions: 3,
            deletions: 19,
            patch:
              "@@ -8,23 +8,7 @@\n import java.util.Set;\n \n public class ChangeMethodSignatureDetection extends MethodDetection {\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node node1, Node node12) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n-        return null;\n-    }\n-\n-    @Override\n-    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n-\n-    }\n+\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\tpublic ChangeMethodSignatureDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n}\n"
          },
          {
            sha: "82174d15977e77d326ed89420328c288d576962a",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "modified",
            additions: 74,
            deletions: 49,
            patch:
              "@@ -15,57 +15,82 @@\n \n public abstract class MethodDetection extends RefactoringDetection {\n \n-    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n-        List callers = new ArrayList();\n-        if (this instanceof ChangeMethodSignatureDetection)\n-            callers = SearchHelper.findMethodCallers(node, true);\n-        else\n-            callers = SearchHelper.findMethodCallers(node, false);\n-        for (Object o : callers) {\n-//            IMethod element = (IMethod) o;\n-//            String nodeName = element.getElementName();\n-//            String qualifiername = element.getDeclaringType()\n-//                    .getFullyQualifiedName('.');\n-//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n-//            if (caller != null) {\n-//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n-//                graph.addEdge(edge);\n-//            }\n-        }\n-        node.setCreatedCallGraph();\n+\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tsuper(graph, graph2);\n+\t}\n \n-    }\n+\t@Override\n+\tpublic double computeLikeliness(Node node1, Node node12) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn 0;\n+\t}\n \n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n-        val results = new ArrayList<Edge>();\n-        for (final Edge edge : list) {\n-            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n-                results.add(edge);\n-            }\n-        }\n-        return results;\n-    }\n+\t@Override\n+\tpublic List pruneOriginalCandidates(List candidates) {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn null;\n+\t}\n \n-    protected void createCallGraph(Node original, Node version) {\n-        if (!original.hasCallGraph()) {\n-            createCallGraph(original, graph1);\n-            original.setCreatedCallGraph();\n-        }\n-        if (!version.hasCallGraph()) {\n-            createCallGraph(version, graph2);\n-            version.setCreatedCallGraph();\n-        }\n-    }\n+\t@Override\n+\tpublic boolean isRename() {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn false;\n+\t}\n+\n+\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+\t\tList callers;\n+//\t\tif (this instanceof ChangeMethodSignatureDetection)\n+//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n+//\t\t\t\tnew NullProgressMonitor(), true);\n+//\t\telse\n+//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n+//\t\t\t\tnew NullProgressMonitor(), false);\n+//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n+//\t\t\tIMember element = (IMember) iter.next();\n+//\t\t\tString nodeName = element.getElementName();\n+//\t\t\tString qualifiername = element.getDeclaringType()\n+//\t\t\t\t.getFullyQualifiedName('.');\n+//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n+//\t\t\tif (caller != null) {\n+//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n+//\t\t\t\tgraph.addEdge(edge);\n+//\t\t\t}\n+//\t\t}\n+//\t\tnode.setCreatedCallGraph();\n+\n+\t}\n+\n+\tprotected void createCallGraph(Node original, Node version) {\n+\t\tif (!original.hasCallGraph()) {\n+\t\t\tcreateCallGraph(original, graph1);\n+\t\t\toriginal.setCreatedCallGraph();\n+\t\t}\n+\t\tif (!version.hasCallGraph()) {\n+\t\t\tcreateCallGraph(version, graph2);\n+\t\t\tversion.setCreatedCallGraph();\n+\t\t}\n+\t}\n+\n+\tpublic double analyzeIncomingEdges(Node original, Node version) {\n+\t\tdouble incomingEdgesGrade;\n+\t\tcreateCallGraph(original, version);\n+\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t.incomingEdgesOf(original)));\n+\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t.incomingEdgesOf(version)));\n+//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n+//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n+\t\treturn 0;\n+\t}\n \n-    public double analyzeIncomingEdges(Node original, Node version) {\n-        double incomingEdgesGrade;\n-        createCallGraph(original, version);\n-        val incomingEdgesOriginal = filterNamedEdges(graph1\n-                .incomingEdgesOf(original));\n-        val incomingEdgesVersion = filterNamedEdges(graph2\n-                .incomingEdgesOf(version));\n-        incomingEdgesGrade = computeLikelinessIncomingEdges(\n-                incomingEdgesOriginal, incomingEdgesVersion);\n-        return incomingEdgesGrade;\n-    }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport lombok.val;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.project.IMethod;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\n\tpublic MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tsuper(graph, graph2);\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node node1, Node node12) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic List pruneOriginalCandidates(List candidates) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRename() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic List<Edge> filterNamedEdges(List<Edge> list) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n\t\tList callers;\n//\t\tif (this instanceof ChangeMethodSignatureDetection)\n//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n//\t\t\t\tnew NullProgressMonitor(), true);\n//\t\telse\n//\t\t\tcallers = SearchHelper.findMethodCallers(node,\n//\t\t\t\tnew NullProgressMonitor(), false);\n//\t\tfor (Iterator iter = callers.iterator(); iter.hasNext(); ) {\n//\t\t\tIMember element = (IMember) iter.next();\n//\t\t\tString nodeName = element.getElementName();\n//\t\t\tString qualifiername = element.getDeclaringType()\n//\t\t\t\t.getFullyQualifiedName('.');\n//\t\t\tNode caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n//\t\t\tif (caller != null) {\n//\t\t\t\tEdge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n//\t\t\t\tgraph.addEdge(edge);\n//\t\t\t}\n//\t\t}\n//\t\tnode.setCreatedCallGraph();\n\n\t}\n\n\tprotected void createCallGraph(Node original, Node version) {\n\t\tif (!original.hasCallGraph()) {\n\t\t\tcreateCallGraph(original, graph1);\n\t\t\toriginal.setCreatedCallGraph();\n\t\t}\n\t\tif (!version.hasCallGraph()) {\n\t\t\tcreateCallGraph(version, graph2);\n\t\t\tversion.setCreatedCallGraph();\n\t\t}\n\t}\n\n\tpublic double analyzeIncomingEdges(Node original, Node version) {\n\t\tdouble incomingEdgesGrade;\n\t\tcreateCallGraph(original, version);\n\t\tList<Edge> incomingEdgesOriginal = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t.incomingEdgesOf(original)));\n\t\tList<Edge> incomingEdgesVersion = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t.incomingEdgesOf(version)));\n//\t\tincomingEdgesGrade = computeLikelinessIncomingEdges(\n//\t\t\tincomingEdgesOriginal, incomingEdgesVersion);\n\t\treturn 0;\n\t}\n\n}\n"
          },
          {
            sha: "e04923c393be759d113e51b42ec573aa46e4095a",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "modified",
            additions: 14,
            deletions: 5,
            patch:
              "@@ -8,9 +8,8 @@\n import java.util.Set;\n \n public class MoveMethodDetection extends RefactoringDetection {\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        return null;\n+    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+        super(graph, graph2);\n     }\n \n     @Override\n@@ -19,12 +18,22 @@ public double computeLikeliness(Node node1, Node node12) {\n     }\n \n     @Override\n-    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+    public List<Edge> filterNamedEdges(List<Edge> list) {\n         return null;\n     }\n \n     @Override\n-    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n \n+    @Override\n+    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+\n+    @Override\n+    public boolean isRename() {\n+        return false;\n     }\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    public MoveMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n        super(graph, graph2);\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(List<Edge> list) {\n        return null;\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n\n    @Override\n    public boolean isRename() {\n        return false;\n    }\n}\n"
          },
          {
            sha: "5548c74e0a9cea9b5119e9c97c6b48d51a780661",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 137,
            deletions: 186,
            patch:
              '@@ -2,30 +2,28 @@\n \n import lombok.Getter;\n import lombok.Setter;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.SubProgressMonitor;\n import refactoring.crawler.util.Edge;\n import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n import java.util.*;\n+import java.util.stream.Collectors;\n \n public abstract class RefactoringDetection {\n \n-\t@Getter\n-\t@Setter\n \tprivate double threshold;\n \n \tprotected NamedDirectedMultigraph graph1;\n-\tprotected NamedDirectedMultigraph graph2;\n-\n-\n-\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-\tpublic abstract double computeLikeliness(Node node1, Node node12);\n \n-\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\tprotected NamedDirectedMultigraph graph2;\n \n-\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\tprivate double lowerThreshold;\n \n+\t/**\n+\t * Dictionary contains <Original, Version> pairs for the renaming.\n+\t */\n \tprivate static Dictionary<String, String> renamingDictionary;\n \n \tpublic static Dictionary<String, String> getRenamingDictionary() {\n@@ -34,61 +32,57 @@\n \t\treturn renamingDictionary;\n \t}\n \n+\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n+\t\tthis.graph1 = graph;\n+\t\tthis.graph2 = graph2;\n+\t}\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tpublic abstract boolean isRename();\n+\n+\t/**\n+\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n+\t * refactoring The original candidates are prunned (for getting rid of\n+\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n+\t * the end we eliminate FalsePositives. Subclasses must override\n+\t * computeLikeliness and pruneOriginalCandidates.\n+\t */\n \tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n+\n+\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n \t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n \t\treturn pruneFalsePositives(listWithFP);\n \t}\n \n-\t/**\n-\t * A default implementation that prunes all those candidates that have the\n-\t * same qualified name. Subclasses might reuse this when they implement the\n-\t * abstract pruneOriginalCanditates, or they can augment to this initial\n-\t * implementation.\n-\t *\n-\t * @param candidates\n-\t * @return\n-\t */\n-\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n-\t\tfor (Node[] pair : candidates) {\n-\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-\t\t\t\t.getFullyQualifiedName()))) {\n-\n-\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n-\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n-\t\t\t\t\t\t.getFullyQualifiedName());\n-\n-\t\t\t\t\tif ((n2inV1 == null)) {\n-\t\t\t\t\t\tprunedCandidates.add(pair);\n-\t\t\t\t\t}\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Node[] pair : prunedCandidates) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n \t\t\t\t}\n+\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n+\t\t\t\t// detect those cases when two\n+\t\t\t\t// types of refactorings happened to the same node\n \t\t\t}\n \t\t}\n-\t\treturn prunedCandidates;\n-\t}\n-\n-\t/**\n-\t * The client is assumed to be passing it\'s parent to this method to\n-\t * determine if they are Modulo Renames of each other.\n-\t *\n-\t * @param original\n-\t * @param version\n-\t * @return\n-\t */\n-\tprotected boolean isTheSameModuloRename(String original, String version) {\n-\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n-\t\tif (version.equals(dictionary.get(original)))\n-\t\t\treturn true;\n-\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-\t\t\treturn original.equals(version);\n-\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n-\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n-\t\t\treturn isTheSameModuloRename(\n-\t\t\t\textractFullyQualifiedParentName(original),\n-\t\t\t\textractFullyQualifiedParentName(version));\n-\t\telse\n-\t\t\treturn false;\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n \t}\n \n \tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n@@ -99,12 +93,12 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n \t\t\tif (originalInV2 != null) {\n \t\t\t\tcreateCallGraph(originalInV2, graph2);\n-\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n-\t\t\t\t\t.incomingEdgesOf(originalInV2));\n-\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n-\t\t\t\t\t.incomingEdgesOf(version));\n-\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n-\t\t\t\t\t.incomingEdgesOf(original));\n+\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n+\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n+\t\t\t\t\t.incomingEdgesOf(version)));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n+\t\t\t\t\t.incomingEdgesOf(original)));\n \n \n \t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n@@ -113,9 +107,7 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \n \t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n \t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n-\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n-\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\tfor (Node node : verCallers) {\n \t\t\t\t\tif (origInV2Callers.contains(node))\n \t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n \t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n@@ -126,15 +118,10 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n \t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n \t\t\t\t// should be different\n-\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n-\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\tNode node = (Node) iterator.next();\n-\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n-\t\t\t\t\t\t.hasNext(); ) {\n-\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n+\t\t\t\tfor (Node node : origInV1Callers) {\n+\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n \t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n \t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n-\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n \t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n@@ -156,66 +143,25 @@ else if (original.substring(original.lastIndexOf(".")).equals(\n \t\treturn listWithFP;\n \t}\n \n-\n-\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-\t\tboolean retval = false;\n-\n-\t\tif (source.getSignature() == null)\n-\t\t\treturn false;\n-\n-\t\tretval = source.getSignature().equals(target.getSignature());\n-\n-\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n-\t\t\tString sourceParent = extractParentSimpleName(source);\n-\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n-\t\t\t\t.getSignature(), "( , )");\n-\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n-\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n-\t\t\t}\n-\n-\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n-\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n-\t\t\t\t\treturn false;\n-\t\t\t\telse {\n-\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n-\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n-\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tretval = true;\n-\t\t\t\t}\n-\t\t\t}\n+\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<>();\n+\t\tfor (Edge edge : incomingEdges) {\n+\t\t\tcallers.add(edge.getSource());\n \t\t}\n-\t\treturn retval;\n+\t\treturn callers;\n \t}\n \n \t/**\n-\t * This helper method takes a string containing the dot separated name of a\n-\t * node and it returns the subtring from the beginning up to the last dot\n-\t * (e.g. for pack1.class1.method1 it returns class1)\n-\t *\n-\t * @param original\n-\t * @return\n+\t * This prunes cases like m(i) -> m\'(i)\n+\t * m(i) -> m\'(S)\n+\t * <p>\n+\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n+\t * generated because of a method overload.\n+\t * <p>\n+\t * This method is never called in the ChangeMethodSignature detection.\n \t */\n-\tprotected String extractParentSimpleName(Node original) {\n-\t\tString originalName = original.getFullyQualifiedName();\n-\t\tString parentName = originalName.substring(0, originalName\n-\t\t\t.lastIndexOf("."));\n-\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-\t\treturn parentName;\n-\t}\n-\n \tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n+\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n \t\tfor (int i = 0; i < listWithFP.size(); i++) {\n \t\t\tboolean hasSameNameAndSignature = false;\n \t\t\tNode[] pair = listWithFP.get(i);\n@@ -232,7 +178,7 @@ private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n \t\t\t}\n \t\t\tif (hasSameNameAndSignature) {\n \t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n-\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n+\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n \t\t\t\t\tNode source2 = pair2[0];\n \t\t\t\t\tif (source.equals(source2)) {\n \t\t\t\t\t\tNode target2 = pair2[1];\n@@ -255,19 +201,24 @@ private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n \t\t}\n \t}\n \n-\n+\t/**\n+\t * This takes into account the possible renaming in the parent of the node\n+\t *\n+\t * @param g        is the Version2 graph\n+\t * @param original is a node from Version1\n+\t * @return\n+\t */\n \tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n \t\tDictionary<String, String> dictionary = getRenamingDictionary();\n \t\tString fqnParent = extractFullyQualifiedParentName(original);\n \t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n \t\tif (possiblyRenamedFQN != null)\n \t\t\tfqnParent = possiblyRenamedFQN;\n-\t\t// TODO implement find name node\n \t\tNode parentNode = g.findNamedNode(fqnParent);\n \n \t\tif (parentNode != null) {\n \t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n \t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n \t\t\t\tEdge edge = (Edge) iter.next();\n \t\t\t\tNode child = (Node) edge.getTarget();\n@@ -287,9 +238,9 @@ private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original\n \n \tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n \t\tList<Edge> results = new ArrayList<>();\n-\t\tfor (Edge o : list) {\n-\t\t\tif (label.equals(o.getLabel())) {\n-\t\t\t\tresults.add(o);\n+\t\tfor (Edge edge : list) {\n+\t\t\tif (label.equals(edge.getLabel())) {\n+\t\t\t\tresults.add(edge);\n \t\t\t}\n \t\t}\n \t\treturn results;\n@@ -301,70 +252,70 @@ protected String extractFullyQualifiedParentName(Node original) {\n \t}\n \n \tpublic String extractFullyQualifiedParentName(String originalName) {\n-\t\tString fqParentName = "";\n+\t\tString fq_parentName = "";\n \t\tint lastIndex = originalName.lastIndexOf(".");\n \t\tif (lastIndex > 0)\n-\t\t\tfqParentName = originalName.substring(0, lastIndex);\n-\t\treturn fqParentName;\n+\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n+\t\treturn fq_parentName;\n \t}\n \n-\tprivate List<Node> getCallers(List incomingEdges) {\n-\t\tList<Node> callers = new ArrayList<Node>();\n-\t\tfor (Object incomingEdge : incomingEdges) {\n-\t\t\tEdge edge = (Edge) incomingEdge;\n-\t\t\tcallers.add(edge.getSource());\n-\t\t}\n-\t\treturn callers;\n-\t}\n+\t/**\n+\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n+\t * IDE.openEditor(IWorkbenchPage, IFile)\n+\t */\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n \n-\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-\t\tboolean foundNewRefactoring = false;\n-\t\tfor (Object prunedCandidate : prunedCandidates) {\n-\t\t\tNode[] pair = (Node[]) prunedCandidate;\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tdouble likeliness = computeLikeliness(original, version);\n-\t\t\tif (likeliness >= threshold) {\n-\t\t\t\tif (!refactoredNodes.contains(pair)) {\n-\t\t\t\t\trefactoredNodes.add(pair);\n-\t\t\t\t\tfoundNewRefactoring = true;\n-\t\t\t\t}\n+\t\tif (source.getSignature() == null)\n+\t\t\treturn false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n \t\t\t}\n-\t\t}\n \n-\t\tif (foundNewRefactoring) {\n-\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n-\t\t}\n-\t\treturn refactoredNodes;\n-\t}\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n \n-\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-\t\tdouble count = 0;\n-\n-\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n-\n-\t\tfor (Edge edge1 : edges1) {\n-\t\t\tNode node1 = edge1.getSource();\n-\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n-\t\t\t\tEdge edge2 = arrEdge2[i];\n-\t\t\t\tif (edge2 != null) {\n-\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n-\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n-\t\t\t\t\t\tcount++;\n-\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n-\t\t\t\t\t\t// count it\n-\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n-\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n+\t\t\t\t\treturn false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n+\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n+\t\t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn retval;\n+\t}\n \n-\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-\t\treturn (fraction1 + fraction2) / 2.0;\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a\n+\t * node and it returns the substring from the beginning up to the last dot\n+\t * (e.g. for pack1.class1.method1 it returns class1)\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName\n+\t\t\t.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n \t}\n+\n+\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.SubProgressMonitor;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic abstract class RefactoringDetection {\n\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\n\tprotected NamedDirectedMultigraph graph2;\n\n\tprivate double lowerThreshold;\n\n\t/**\n\t * Dictionary contains <Original, Version> pairs for the renaming.\n\t */\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n\t\tthis.graph1 = graph;\n\t\tthis.graph2 = graph2;\n\t}\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tpublic abstract boolean isRename();\n\n\t/**\n\t * TEMPLATE METHOD Describes the algorithm for detecting any particular\n\t * refactoring The original candidates are prunned (for getting rid of\n\t * obvious extraneous ones, then the likeliness of each pair is computed. In\n\t * the end we eliminate FalsePositives. Subclasses must override\n\t * computeLikeliness and pruneOriginalCandidates.\n\t */\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n\t\tList<Node[]> refactoredNodes = new ArrayList<Node[]>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\t// List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Node[] pair : prunedCandidates) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t\t// candidates.remove(pair); acivating this line would fail to\n\t\t\t\t// detect those cases when two\n\t\t\t\t// types of refactorings happened to the same node\n\t\t\t}\n\t\t}\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2)));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(new ArrayList<>(graph2\n\t\t\t\t\t.incomingEdgesOf(version)));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(new ArrayList<>(graph1\n\t\t\t\t\t.incomingEdgesOf(original)));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Node node : verCallers) {\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Node node : origInV1Callers) {\n\t\t\t\t\tfor (Node callingNode : origInV2Callers) {\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\tprivate List<Node> getCallers(List<Edge> incomingEdges) {\n\t\tList<Node> callers = new ArrayList<>();\n\t\tfor (Edge edge : incomingEdges) {\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\t/**\n\t * This prunes cases like m(i) -> m\'(i)\n\t * m(i) -> m\'(S)\n\t * <p>\n\t * This method prunes away the pair m(i)->m\'(S) since it is likely that this is\n\t * generated because of a method overload.\n\t * <p>\n\t * This method is never called in the ChangeMethodSignature detection.\n\t */\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\t/**\n\t * This takes into account the possible renaming in the parent of the node\n\t *\n\t * @param g        is the Version2 graph\n\t * @param original is a node from Version1\n\t * @return\n\t */\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge edge : list) {\n\t\t\tif (label.equals(edge.getLabel())) {\n\t\t\t\tresults.add(edge);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fq_parentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfq_parentName = originalName.substring(0, lastIndex);\n\t\treturn fq_parentName;\n\t}\n\n\t/**\n\t * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n\t * IDE.openEditor(IWorkbenchPage, IFile)\n\t */\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the substring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\n}\n'
          },
          {
            sha: "0e829a47dc0fc538dc5627a18def25cba6a8b1b3",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 23,
            deletions: 24,
            patch:
              "@@ -10,31 +10,30 @@\n public class RenameMethodDetection extends MethodDetection {\n \n \tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\t\tthis.graph1 = oldVersion;\n-\t\tthis.graph2 = newVersion;\n+\t\tsuper(oldVersion, newVersion);\n \t}\n \n-\t@Override\n-\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-\t\tfor (Node[] pair : prePrunedMethods) {\n-\t\t\tNode original = pair[0];\n-\t\t\tNode version = pair[1];\n-\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n-\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n-\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-\t\t\t\t&& (!(original.getSimpleName().equals(version\n-\t\t\t\t.getSimpleName()))))\n-\t\t\t\tcandidatesWithSameParentClass.add(pair);\n-\t\t}\n-\n-\t\treturn candidatesWithSameParentClass;\n-\t}\n-\n-\t@Override\n-\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n-\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n-\t}\n+//\t@Override\n+//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+//\t\tfor (Node[] pair : prePrunedMethods) {\n+//\t\t\tNode original = pair[0];\n+//\t\t\tNode version = pair[1];\n+//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+//\t\t\t\t&& (!(original.getSimpleName().equals(version\n+//\t\t\t\t.getSimpleName()))))\n+//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+//\t\t}\n+//\n+//\t\treturn candidatesWithSameParentClass;\n+//\t}\n+//\n+//\t@Override\n+//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n+//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n+//\t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tsuper(oldVersion, newVersion);\n\t}\n\n//\t@Override\n//\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n//\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n//\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n//\t\tfor (Node[] pair : prePrunedMethods) {\n//\t\t\tNode original = pair[0];\n//\t\t\tNode version = pair[1];\n//\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n//\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n//\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n//\t\t\t\t&& (!(original.getSimpleName().equals(version\n//\t\t\t\t.getSimpleName()))))\n//\t\t\t\tcandidatesWithSameParentClass.add(pair);\n//\t\t}\n//\n//\t\treturn candidatesWithSameParentClass;\n//\t}\n//\n//\t@Override\n//\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n//\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n//\t}\n\n}\n"
          },
          {
            sha: "c72a989a7b251464264dc101c26f212f9881e3f5",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "modified",
            additions: 27,
            deletions: 5,
            patch:
              "@@ -1,13 +1,35 @@\n package refactoring.crawler.detection;\n \n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n+import lombok.Getter;\n import org.eclipse.core.runtime.IProgressMonitor;\n+import refactoring.crawler.util.MethodNode;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n import refactoring.crawler.util.Node;\n \n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.Collectors;\n \n public class SearchHelper {\n-    public static List findMethodCallers(Node node, boolean withSignature) {\n-        return new LinkedList();\n-    }\n+\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n+\t\treturn graph.vertexSet()\n+\t\t\t.stream()\n+\t\t\t.filter(n -> (n instanceof MethodNode))\n+\t\t\t.map(methodNode -> (MethodNode) methodNode)\n+\t\t\t.filter(methodNode ->\n+\t\t\t\tmethodNode.getCalledInside()\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.anyMatch(calledMethod -> {\n+\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n+\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n+\t\t\t\t\t\treturn expect.equals(actual);\n+\t\t\t\t\t})\n+\t\t\t)\n+\t\t\t.map(methodNode -> {\n+\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n+\t\t\t})\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.MethodNode;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SearchHelper {\n\tpublic static List<String> findMethodCallers(NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n\t\treturn graph.vertexSet()\n\t\t\t.stream()\n\t\t\t.filter(n -> (n instanceof MethodNode))\n\t\t\t.map(methodNode -> (MethodNode) methodNode)\n\t\t\t.filter(methodNode ->\n\t\t\t\tmethodNode.getCalledInside()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.anyMatch(calledMethod -> {\n\t\t\t\t\t\tString expect = withSignature ? calledMethod.getFullyQualifiedNameWithSignature() : calledMethod.getFullyQualifiedNameWithoutSignature();\n\t\t\t\t\t\tString actual = withSignature ? node.getFullyQualifiedName() + node.getSignature() : node.getFullyQualifiedName();\n\t\t\t\t\t\treturn expect.equals(actual);\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.map(methodNode -> {\n\t\t\t\treturn withSignature ? methodNode.getFullyQualifiedName() + methodNode.getSignature() : methodNode.getFullyQualifiedName();\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n\n}\n"
          },
          {
            sha: "5e95b415b9c2ed14017572d7f3eb2cb290726203",
            filename: "src/main/java/refactoring/crawler/util/MethodNode.java",
            status: "added",
            additions: 35,
            deletions: 0,
            patch:
              "@@ -0,0 +1,35 @@\n+package refactoring.crawler.util;\n+\n+import jdk.nashorn.internal.codegen.CompilerConstants;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class MethodNode extends Node {\n+\n+\t@AllArgsConstructor\n+\tpublic static class CalledMethod {\n+\t\t@Getter\n+\t\t@Setter\n+\t\tprivate String fullyQualifiedNameWithoutSignature;\n+\n+\t\t@Getter\n+\t\t@Setter\n+\t\tprivate String fullyQualifiedNameWithSignature;\n+\t}\n+\n+\t@Setter\n+\t@Getter\n+\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n+\n+\t/**\n+\t * @param fullyQualifiedName fullyQualifiedName\n+\t */\n+\tpublic MethodNode(String fullyQualifiedName) {\n+\t\tsuper(fullyQualifiedName, Type.METHOD);\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport jdk.nashorn.internal.codegen.CompilerConstants;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MethodNode extends Node {\n\n\t@AllArgsConstructor\n\tpublic static class CalledMethod {\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithoutSignature;\n\n\t\t@Getter\n\t\t@Setter\n\t\tprivate String fullyQualifiedNameWithSignature;\n\t}\n\n\t@Setter\n\t@Getter\n\tprivate List<CalledMethod> calledInside = new LinkedList<>();\n\n\t/**\n\t * @param fullyQualifiedName fullyQualifiedName\n\t */\n\tpublic MethodNode(String fullyQualifiedName) {\n\t\tsuper(fullyQualifiedName, Type.METHOD);\n\t}\n}\n"
          },
          {
            sha: "fc33acfda6432cefce9e013f18b7ff34937e9ce3",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "modified",
            additions: 18,
            deletions: 16,
            patch:
              "@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import lombok.Getter;\n import org.jgrapht.graph.DirectedMultigraph;\n \n import java.util.HashMap;\n@@ -8,24 +9,25 @@\n \n public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n \n-    private Map<String, Node> namedVertexMap = new HashMap<>();\n+\t@Getter\n+\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n \n-    public NamedDirectedMultigraph() {\n-        super(Edge.class);\n-    }\n+\tpublic NamedDirectedMultigraph() {\n+\t\tsuper(Edge.class);\n+\t}\n \n-    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n-        super(vertexSupplier, edgeSupplier, weighted);\n-    }\n+\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n+\t}\n \n-    public boolean addNamedVertex(Node v) {\n-        if (!addVertex(v))\n-            return false;\n-        namedVertexMap.put(v.getFullyQualifiedName(), v);\n-        return true;\n-    }\n+\tpublic boolean addNamedVertex(Node v) {\n+\t\tif (!addVertex(v))\n+\t\t\treturn false;\n+\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n+\t\treturn true;\n+\t}\n \n-    public Node findNamedNode(String name) {\n-        return namedVertexMap.get(name);\n-    }\n+\tpublic Node findNamedNode(String name) {\n+\t\treturn namedVertexMap.get(name);\n+\t}\n }",
            rawContent:
              "package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n\t@Getter\n\tprivate Map<String, Node> namedVertexMap = new HashMap<>();\n\n\tpublic NamedDirectedMultigraph() {\n\t\tsuper(Edge.class);\n\t}\n\n\tpublic NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n\t\tsuper(vertexSupplier, edgeSupplier, weighted);\n\t}\n\n\tpublic boolean addNamedVertex(Node v) {\n\t\tif (!addVertex(v))\n\t\t\treturn false;\n\t\tnamedVertexMap.put(v.getFullyQualifiedName(), v);\n\t\treturn true;\n\t}\n\n\tpublic Node findNamedNode(String name) {\n\t\treturn namedVertexMap.get(name);\n\t}\n}\n"
          },
          {
            sha: "da3fd43afd25a44efeafdbb93ce382240d81e7a1",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -5,6 +5,8 @@\n import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n \n+import java.awt.*;\n+\n \n public class Node {\n ",
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\nimport java.awt.*;\n\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {\n    }\n\n    public static enum Type {\n        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n    }\n\n\n    @Getter\n    @Setter\n    private String fullyQualifiedName;\n\n    @Setter\n    @Getter\n    private Node.Type type;\n\n    @Setter\n    @Getter\n    private int[] shingles;\n\n    @Setter\n    @Getter\n    private boolean hasCallGraph;\n\n    @Setter\n    @Getter\n    private String projectName;\n\n    @Setter\n    @Getter\n    private boolean isAPI = false;\n\n    @Setter\n    @Getter\n    private String signature;\n\n    @Setter\n    @Getter\n    private int flags;\n\n    @Setter\n    @Getter\n    private boolean deprecated = false;\n\n    @Setter\n    @Getter\n    private boolean isInterface = false;\n\n    /**\n     * @param fullyQualifiedName fullyQualifiedName\n     * @param type               type\n     */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n                    .length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType() + "= " + getFullyQualifiedName() + getSignature();\n        else\n            return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "5e122b87f0633073d0de210bc2c673d604778977",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 0,
            deletions: 2,
            patch:
              '@@ -134,8 +134,6 @@ public void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMul\n \t\t\toldVersionPackageList, oldVersionFieldList);\n \n \t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-\n-\t\tSystem.out.println("fuck you");\n \t}\n \n \tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,',
            rawContent:
              'package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tprivate double methodThreshold;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "e0c160b5a0ee4d70a58b822b2d2e803ee9f4cea2",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 16,
            deletions: 1,
            patch:
              '@@ -1,5 +1,6 @@\n package refactoring.crawler.util;\n \n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n@@ -10,10 +11,14 @@\n import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n import org.eclipse.jdt.core.Signature;\n+import refactoring.crawler.detection.SearchHelper;\n import refactoring.crawler.project.*;\n \n import javax.annotation.Nonnull;\n@@ -68,6 +73,7 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n \t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n \t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\n \t\t\t\t\t\t\tthis.allClassCounter += 1;\n \t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n \t\t\t\t\t\t\t\tclassNode.setAPI(true);\n@@ -105,7 +111,16 @@ public void browseProject(@NonNull String projectName, @NonNull List<Compilation\n \t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n \t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n \t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n-\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n+\n+\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n+\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n+\t\t\t\t\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n+\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n+\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n \n \t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n \t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tMethodNode methodNode = new MethodNode(qualifiedName);\n\n\t\t\t\t\t\t\t\t\tList<MethodNode.CalledMethod> calledMethodList = method\n\t\t\t\t\t\t\t\t\t\t.findAll(MethodCallExpr.class)\n\t\t\t\t\t\t\t\t\t\t.stream()\n\t\t\t\t\t\t\t\t\t\t.map(MethodCallExpr::resolve)\n\t\t\t\t\t\t\t\t\t\t.map(resolved -> new MethodNode.CalledMethod(resolved.getQualifiedName(), resolved.getQualifiedSignature()))\n\t\t\t\t\t\t\t\t\t\t.collect(Collectors.toList());\n\n\t\t\t\t\t\t\t\t\tmethodNode.setCalledInside(calledMethodList);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "adcac2cd85ee8ad64986e41843ebeccfe40b634e",
        message: "chore(deps): add symbol solver core pck",
        stats: {
          total: 2,
          additions: 2,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "3fcec084a313374eebbba80657d7a8352cc955c5"
          }
        ],
        committedAt: 1585133997000,
        changedFiles: [
          {
            sha: "f5b97179043b72ae904d32cde7dc67b9f0feff46",
            filename: "build.gradle",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -28,6 +28,8 @@ dependencies {\n \n     compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n \n+    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n+\n     compileOnly 'org.projectlombok:lombok:1.18.12'\n     annotationProcessor 'org.projectlombok:lombok:1.18.12'\n ",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          }
        ]
      },
      {
        sha: "3fcec084a313374eebbba80657d7a8352cc955c5",
        message: "chore(*): source navigator done",
        stats: {
          total: 2064,
          additions: 1408,
          deletions: 656
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [
          {
            sha: "c82267764fe895754822d57203483cc54cd44f7d"
          }
        ],
        committedAt: 1585110635000,
        changedFiles: [
          {
            sha: "ea419d85c301b292fbadf5b1f4da2c8350a1c0f1",
            filename: ".gitignore",
            status: "modified",
            additions: 1,
            deletions: 1,
            patch:
              "@@ -1,6 +1,6 @@\n .gradle\n /build/\n-\n+/.idea/\n # Ignore Gradle GUI config\n gradle-app.setting\n ",
            rawContent:
              ".gradle\n/build/\n/.idea/\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n"
          },
          {
            sha: "9f56d869b444336267c0bd57e2f567208acd7aad",
            filename: "build.gradle",
            status: "modified",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -26,6 +26,8 @@ dependencies {\n \n     implementation 'com.github.javaparser:javaparser-core:3.15.14'\n \n+    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n+\n     compileOnly 'org.projectlombok:lombok:1.18.12'\n     annotationProcessor 'org.projectlombok:lombok:1.18.12'\n ",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "b7cc792f483cfd5c41dde7c729179f7b78a21de3",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "modified",
            additions: 90,
            deletions: 34,
            patch:
              '@@ -2,12 +2,16 @@\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import lombok.val;\n+import org.jgrapht.nio.dot.DOTExporter;\n import refactoring.crawler.detection.RefactoringDetection;\n import refactoring.crawler.detection.RenameMethodDetection;\n import refactoring.crawler.project.IProject;\n import refactoring.crawler.util.*;\n \n import java.io.IOException;\n+import java.rmi.server.ExportException;\n+import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n@@ -17,50 +21,93 @@\n \tprivate String projectName;\n \n \tpublic static void main(String[] args) throws IOException {\n-\t\t// creates an input stream for the file to be parsed\n-\t\tString source = "import detections.Detection;\\n" +\n-\t\t\t"import detections.DetectionFactory;\\n" +\n-\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n-\t\t\t"import utils.*;\\n" +\n+\t\tval crawler = new RefactoringCrawler("project name");\n+\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n+\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n+\t\t\t" * @ClassName ForumDAO\\n" +\n+\t\t\t" * @Author Lai Kin Meng\\n" +\n+\t\t\t" * @Date 2019-02-25\\n" +\n+\t\t\t" * @ProjectName MyCoursesServer\\n" +\n+\t\t\t" */\\n" +\n \t\t\t"\\n" +\n-\t\t\t"import java.util.List;\\n" +\n+\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n+\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n+\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n+\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n+\t\t\t"import javax.persistence.EntityManager;\\n" +\n+\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"public class RefactoringCrawler {\\n" +\n-\t\t\t"    public static void main(String[] args) {\\n" +\n-\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n-\t\t\t"//        parser.setSource();\\n" +\n+\t\t\t"@Repository\\n" +\n+\t\t\t"@Transactional\\n" +\n+\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @PersistenceContext\\n" +\n+\t\t\t"    private EntityManager entityManager;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n+\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n \t\t\t"    }\\n" +\n \t\t\t"\\n" +\n-\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n+\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n+\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n+\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n+\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n+\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n+\t\t\t"        entityManager.flush();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"}";\n+\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n+\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n+\t\t\t" * @ClassName ForumDAO\\n" +\n+\t\t\t" * @Author Lai Kin Meng\\n" +\n+\t\t\t" * @Date 2019-02-25\\n" +\n+\t\t\t" * @ProjectName MyCoursesServer\\n" +\n+\t\t\t" */\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n-\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n+\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n+\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n+\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n+\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n-\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n+\t\t\t"import javax.persistence.EntityManager;\\n" +\n+\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n+\t\t\t"@Repository\\n" +\n+\t\t\t"@Transactional\\n" +\n+\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n+\t\t\t"    @PersistenceContext\\n" +\n+\t\t\t"    private EntityManager entityManager;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n+\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n+\t\t\t"    }\\n" +\n \t\t\t"\\n" +\n-\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n-\t\t\t"            for (Pair pair : pairs) {\\n" +\n-\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n-\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n-\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n-\t\t\t"                    }\\n" +\n-\t\t\t"                }\\n" +\n-\t\t\t"            }\\n" +\n-\t\t\t"        }\\n" +\n-\t\t\t"        return rlog.getResult();\\n" +\n+\t\t\t"    @Override\\n" +\n+\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n+\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n+\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n+\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n+\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n+\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n+\t\t\t"        entityManager.flush();\\n" +\n \t\t\t"    }\\n" +\n-\t\t\t"}\\n";\n-\t\tCompilationUnit cu;\n-\t\t// parse the file\n-\t\tcu = StaticJavaParser.parse(source);\n+\t\t\t"}";\n \n+\t\tval oldList = new ArrayList<String>();\n+\t\tval newList = new ArrayList<String>();\n+\n+\t\toldList.add(oldSource);\n+\t\tnewList.add(newSource);\n+\n+\t\tcrawler.detect(oldList, newList);\n \n \t}\n \n@@ -88,12 +135,21 @@ public void detect(List<String> oldVersion, List<String> newVersion) {\n \n \t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n \t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n-\t\tnavigatorForVersion.browseProject(newVersion);\n+\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n \t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n \n-\n \t\tshinglesUtil.initialize(originalGraph, versionGraph);\n \n+\t\tSystem.out.println("-----original graph-----");\n+\t\tfor (Edge e : originalGraph.edgeSet()) {\n+\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n+\t\t}\n+\n+\t\tSystem.out.println("-----new version graph-----");\n+\t\tfor (Edge e : versionGraph.edgeSet()) {\n+\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n+\t\t}\n+\n \t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n \t}\n ',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport lombok.val;\nimport org.jgrapht.nio.dot.DOTExporter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.rmi.server.ExportException;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tval crawler = new RefactoringCrawler("project name");\n\t\tval oldSource = "package com.MyCourses.dao.impl;/*\\n" +\n\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n\t\t\t" * @ClassName ForumDAO\\n" +\n\t\t\t" * @Author Lai Kin Meng\\n" +\n\t\t\t" * @Date 2019-02-25\\n" +\n\t\t\t" * @ProjectName MyCoursesServer\\n" +\n\t\t\t" */\\n" +\n\t\t\t"\\n" +\n\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import javax.persistence.EntityManager;\\n" +\n\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n\t\t\t"\\n" +\n\t\t\t"@Repository\\n" +\n\t\t\t"@Transactional\\n" +\n\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @PersistenceContext\\n" +\n\t\t\t"    private EntityManager entityManager;\\n" +\n\t\t\t"\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public void update(ForumEntity forumEntity) {\\n" +\n\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n\t\t\t"        entityManager.flush();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}";\n\t\tval newSource = "package com.MyCourses.dao.impl;/*\\n" +\n\t\t\t" * @PackageName com.MyCourses.dao.impl\\n" +\n\t\t\t" * @ClassName ForumDAO\\n" +\n\t\t\t" * @Author Lai Kin Meng\\n" +\n\t\t\t" * @Date 2019-02-25\\n" +\n\t\t\t" * @ProjectName MyCoursesServer\\n" +\n\t\t\t" */\\n" +\n\t\t\t"\\n" +\n\t\t\t"import com.MyCourses.dao.IForumDAO;\\n" +\n\t\t\t"import com.MyCourses.entity.ForumEntity;\\n" +\n\t\t\t"import org.springframework.stereotype.Repository;\\n" +\n\t\t\t"import org.springframework.transaction.annotation.Transactional;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import javax.persistence.EntityManager;\\n" +\n\t\t\t"import javax.persistence.PersistenceContext;\\n" +\n\t\t\t"\\n" +\n\t\t\t"@Repository\\n" +\n\t\t\t"@Transactional\\n" +\n\t\t\t"public class ForumDAO implements IForumDAO {\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @PersistenceContext\\n" +\n\t\t\t"    private EntityManager entityManager;\\n" +\n\t\t\t"\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public ForumEntity retrieveByFid(Long fid) {\\n" +\n\t\t\t"        return entityManager.find(ForumEntity.class, fid);\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    @Override\\n" +\n\t\t\t"    public void updateAgain(ForumEntity forumEntity) {\\n" +\n\t\t\t"        ForumEntity f = retrieveByFid(forumEntity.getFid());\\n" +\n\t\t\t"        f.setTopic(forumEntity.getTopic());\\n" +\n\t\t\t"        f.setQuestionerStudent(forumEntity.getQuestionerStudent());\\n" +\n\t\t\t"        f.setQuestionerTeacher(forumEntity.getQuestionerTeacher());\\n" +\n\t\t\t"        f.setCommentEntityList(forumEntity.getCommentEntityList());\\n" +\n\t\t\t"        entityManager.flush();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}";\n\n\t\tval oldList = new ArrayList<String>();\n\t\tval newList = new ArrayList<String>();\n\n\t\toldList.add(oldSource);\n\t\tnewList.add(newSource);\n\n\t\tcrawler.detect(oldList, newList);\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tresList.add(StaticJavaParser.parse(source));\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(projectName, newVersionCU);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tSystem.out.println("-----original graph-----");\n\t\tfor (Edge e : originalGraph.edgeSet()) {\n\t\t\tSystem.out.println(originalGraph.getEdgeSource(e) + " --> " + originalGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tSystem.out.println("-----new version graph-----");\n\t\tfor (Edge e : versionGraph.edgeSet()) {\n\t\t\tSystem.out.println(versionGraph.getEdgeSource(e) + " --> " + versionGraph.getEdgeTarget(e));\n\t\t}\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "40c414cbaec6302b68b1062229cecdcd8b438ed8",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "modified",
            additions: 357,
            deletions: 357,
            patch:
              '@@ -10,361 +10,361 @@\n \n public abstract class RefactoringDetection {\n \n-    @Getter\n-    @Setter\n-    private double threshold;\n-\n-    protected NamedDirectedMultigraph graph1;\n-    protected NamedDirectedMultigraph graph2;\n-\n-\n-    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n-\n-    public abstract double computeLikeliness(Node node1, Node node12);\n-\n-    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n-\n-    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n-\n-    private static Dictionary<String, String> renamingDictionary;\n-\n-    public static Dictionary<String, String> getRenamingDictionary() {\n-        if (renamingDictionary == null)\n-            renamingDictionary = new Hashtable<>();\n-        return renamingDictionary;\n-    }\n-\n-    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n-        List<Node[]> refactoredNodes = new ArrayList<>();\n-        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n-        return pruneFalsePositives(listWithFP);\n-    }\n-\n-    /**\n-     * A default implementation that prunes all those candidates that have the\n-     * same qualified name. Subclasses might reuse this when they implement the\n-     * abstract pruneOriginalCanditates, or they can augment to this initial\n-     * implementation.\n-     *\n-     * @param candidates\n-     * @return\n-     */\n-    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n-        List<Node[]> prunedCandidates = new ArrayList<>();\n-        for (Node[] pair : candidates) {\n-            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n-                    .getFullyQualifiedName()))) {\n-\n-                if (pair[0].isAPI() && pair[1].isAPI()) {\n-                    Node n2inV1 = graph1.findNamedNode(pair[1]\n-                            .getFullyQualifiedName());\n-\n-                    if ((n2inV1 == null)) {\n-                        prunedCandidates.add(pair);\n-                    }\n-                }\n-            }\n-        }\n-        return prunedCandidates;\n-    }\n-\n-    /**\n-     * The client is assumed to be passing it\'s parent to this method to\n-     * determine if they are Modulo Renames of each other.\n-     *\n-     * @param original\n-     * @param version\n-     * @return\n-     */\n-    protected boolean isTheSameModuloRename(String original, String version) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        if (version.equals(dictionary.get(original)))\n-            return true;\n-        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n-            return original.equals(version);\n-        else if (original.substring(original.lastIndexOf(".")).equals(\n-                version.substring(version.lastIndexOf("."), version.length())))\n-            return isTheSameModuloRename(\n-                    extractFullyQualifiedParentName(original),\n-                    extractFullyQualifiedParentName(version));\n-        else\n-            return false;\n-    }\n-\n-    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n-        for (Node[] pair : listWithFP) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n-            if (originalInV2 != null) {\n-                createCallGraph(originalInV2, graph2);\n-                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n-                        .incomingEdgesOf(originalInV2));\n-                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n-                        .incomingEdgesOf(version));\n-                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n-                        .incomingEdgesOf(original));\n-\n-\n-                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n-                List<Node> verCallers = getCallers(verIncomingEdges);\n-                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n-\n-                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n-                // since a call site cannot be calling both the old and the new entity at the same time\n-                for (Iterator iterator = verCallers.iterator(); iterator\n-                        .hasNext(); ) {\n-                    Node node = (Node) iterator.next();\n-                    if (origInV2Callers.contains(node))\n-                        if (!nodesToRemove.contains(pair)) {\n-                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n-                            nodesToRemove.add(pair);\n-                        }\n-                }\n-\n-                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n-                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n-                // should be different\n-                for (Iterator iterator = origInV1Callers.iterator(); iterator\n-                        .hasNext(); ) {\n-                    Node node = (Node) iterator.next();\n-                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n-                            .hasNext(); ) {\n-                        Node callingNode = (Node) iterator1.next();\n-                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n-                            if (!nodesToRemove.contains(pair)) {\n-                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n-                                nodesToRemove.add(pair);\n-                            }\n-                            break;\n-                        }\n-                    }\n-\n-                }\n-\n-            }\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            listWithFP.remove(pair);\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-\n-        pruneOverloadedMethodFP(listWithFP);\n-\n-        return listWithFP;\n-    }\n-\n-\n-    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n-        boolean retval = false;\n-\n-        if (source.getSignature() == null)\n-            return false;\n-\n-        retval = source.getSignature().equals(target.getSignature());\n-\n-        if (!retval && (this instanceof MoveMethodDetection)) {\n-            String sourceParent = extractParentSimpleName(source);\n-            StringTokenizer sourceTokenizer = new StringTokenizer(source\n-                    .getSignature(), "( , )");\n-            StringTokenizer targetTokenizer = new StringTokenizer(target\n-                    .getSignature(), "( , )");\n-            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n-            String[] targetTokens = new String[targetTokenizer.countTokens()];\n-\n-            for (int i = 0; i < sourceTokens.length; i++) {\n-                sourceTokens[i] = sourceTokenizer.nextToken();\n-            }\n-\n-            for (int i = 0; i < targetTokens.length; i++) {\n-                targetTokens[i] = targetTokenizer.nextToken();\n-            }\n-\n-            if (targetTokens.length == sourceTokens.length + 1) {\n-                if (!targetTokens[0].trim().equals(sourceParent))\n-                    return false;\n-                else {\n-                    for (int i = 0; i < sourceTokens.length; i++) {\n-                        if (!sourceTokens[i].trim().equals(\n-                                targetTokens[i + 1].trim()))\n-                            return false;\n-                    }\n-                    retval = true;\n-                }\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    /**\n-     * This helper method takes a string containing the dot separated name of a\n-     * node and it returns the subtring from the beginning up to the last dot\n-     * (e.g. for pack1.class1.method1 it returns class1)\n-     *\n-     * @param original\n-     * @return\n-     */\n-    protected String extractParentSimpleName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        String parentName = originalName.substring(0, originalName\n-                .lastIndexOf("."));\n-        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n-        return parentName;\n-    }\n-\n-    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n-        List<Node[]> nodesToRemove = new LinkedList<>();\n-        for (int i = 0; i < listWithFP.size(); i++) {\n-            boolean hasSameNameAndSignature = false;\n-            Node[] pair = listWithFP.get(i);\n-            Node source = pair[0];\n-            for (int j = i; j < listWithFP.size(); j++) {\n-                Node[] pair2 = listWithFP.get(j);\n-                Node source2 = pair2[0];\n-                if (source.equals(source2)) {\n-                    Node target2 = pair2[1];\n-                    if (source.getSimpleName().equals(target2.getSimpleName()))\n-                        if (signatureEqualsModuloMoveMethod(source, target2))\n-                            hasSameNameAndSignature = true;\n-                }\n-            }\n-            if (hasSameNameAndSignature) {\n-                for (int j = i; j < listWithFP.size(); j++) {\n-                    Node[] pair2 = (Node[]) listWithFP.get(j);\n-                    Node source2 = pair2[0];\n-                    if (source.equals(source2)) {\n-                        Node target2 = pair2[1];\n-                        if (source.getSimpleName().equals(\n-                                target2.getSimpleName()))\n-                            if (!signatureEqualsModuloMoveMethod(source, target2))\n-                                if (!nodesToRemove.contains(pair2))\n-                                    nodesToRemove.add(pair2);\n-                    }\n-                }\n-            }\n-\n-        }\n-        for (Node[] pair : nodesToRemove) {\n-            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n-            listWithFP.remove(pair);\n-\n-            Dictionary<String, String> dictionary = getRenamingDictionary();\n-            dictionary.remove(pair[0].getFullyQualifiedName());\n-        }\n-    }\n-\n-\n-    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n-        Dictionary<String, String> dictionary = getRenamingDictionary();\n-        String fqnParent = extractFullyQualifiedParentName(original);\n-        String possiblyRenamedFQN = dictionary.get(fqnParent);\n-        if (possiblyRenamedFQN != null)\n-            fqnParent = possiblyRenamedFQN;\n-        // TODO implement find name node\n-        Node parentNode = g.findNamedNode(fqnParent);\n-\n-        if (parentNode != null) {\n-            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n-            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n-            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n-                Edge edge = (Edge) iter.next();\n-                Node child = (Node) edge.getTarget();\n-                if (original.getSimpleName().equals(child.getSimpleName()))\n-                    if (original.getSignature() != null) {\n-                        // This handles the method nodes\n-                        if (original.getSignature()\n-                                .equals(child.getSignature()))\n-                            return child;\n-                    } else\n-                        // Classes and packages\n-                        return child;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n-        List<Edge> results = new ArrayList<>();\n-        for (Edge o : list) {\n-            if (label.equals(o.getLabel())) {\n-                results.add(o);\n-            }\n-        }\n-        return results;\n-    }\n-\n-    protected String extractFullyQualifiedParentName(Node original) {\n-        String originalName = original.getFullyQualifiedName();\n-        return extractFullyQualifiedParentName(originalName);\n-    }\n-\n-    public String extractFullyQualifiedParentName(String originalName) {\n-        String fqParentName = "";\n-        int lastIndex = originalName.lastIndexOf(".");\n-        if (lastIndex > 0)\n-            fqParentName = originalName.substring(0, lastIndex);\n-        return fqParentName;\n-    }\n-\n-    private List<Node> getCallers(List incomingEdges) {\n-        List<Node> callers = new ArrayList<Node>();\n-        for (Object incomingEdge : incomingEdges) {\n-            Edge edge = (Edge) incomingEdge;\n-            callers.add(edge.getSource());\n-        }\n-        return callers;\n-    }\n-\n-    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n-        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n-        boolean foundNewRefactoring = false;\n-        for (Object prunedCandidate : prunedCandidates) {\n-            Node[] pair = (Node[]) prunedCandidate;\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            double likeliness = computeLikeliness(original, version);\n-            if (likeliness >= threshold) {\n-                if (!refactoredNodes.contains(pair)) {\n-                    refactoredNodes.add(pair);\n-                    foundNewRefactoring = true;\n-                }\n-            }\n-        }\n-\n-        if (foundNewRefactoring) {\n-            doDetectRefactorings(candidates, refactoredNodes);\n-        }\n-        return refactoredNodes;\n-    }\n-\n-    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n-        double count = 0;\n-\n-        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n-\n-        for (Edge edge1 : edges1) {\n-            Node node1 = edge1.getSource();\n-            for (int i = 0; i < arrEdge2.length; i++) {\n-                Edge edge2 = arrEdge2[i];\n-                if (edge2 != null) {\n-                    Node node2 = (Node) edge2.getSource();\n-                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n-                            node2.getFullyQualifiedName())) {\n-                        count++;\n-                        // we mark this edge as already counted so that we don\'t\n-                        // count it\n-                        // twice when there are multiple edges between two nodes\n-                        arrEdge2[i] = null;\n-                    }\n-                }\n-            }\n-        }\n-\n-        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n-        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n-\n-        return (fraction1 + fraction2) / 2.0;\n-    }\n+\t@Getter\n+\t@Setter\n+\tprivate double threshold;\n+\n+\tprotected NamedDirectedMultigraph graph1;\n+\tprotected NamedDirectedMultigraph graph2;\n+\n+\n+\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+\tpublic abstract double computeLikeliness(Node node1, Node node12);\n+\n+\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\n+\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+\tprivate static Dictionary<String, String> renamingDictionary;\n+\n+\tpublic static Dictionary<String, String> getRenamingDictionary() {\n+\t\tif (renamingDictionary == null)\n+\t\t\trenamingDictionary = new Hashtable<>();\n+\t\treturn renamingDictionary;\n+\t}\n+\n+\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n+\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+\t\treturn pruneFalsePositives(listWithFP);\n+\t}\n+\n+\t/**\n+\t * A default implementation that prunes all those candidates that have the\n+\t * same qualified name. Subclasses might reuse this when they implement the\n+\t * abstract pruneOriginalCanditates, or they can augment to this initial\n+\t * implementation.\n+\t *\n+\t * @param candidates\n+\t * @return\n+\t */\n+\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n+\t\tfor (Node[] pair : candidates) {\n+\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+\t\t\t\t.getFullyQualifiedName()))) {\n+\n+\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n+\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n+\t\t\t\t\t\t.getFullyQualifiedName());\n+\n+\t\t\t\t\tif ((n2inV1 == null)) {\n+\t\t\t\t\t\tprunedCandidates.add(pair);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn prunedCandidates;\n+\t}\n+\n+\t/**\n+\t * The client is assumed to be passing it\'s parent to this method to\n+\t * determine if they are Modulo Renames of each other.\n+\t *\n+\t * @param original\n+\t * @param version\n+\t * @return\n+\t */\n+\tprotected boolean isTheSameModuloRename(String original, String version) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tif (version.equals(dictionary.get(original)))\n+\t\t\treturn true;\n+\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+\t\t\treturn original.equals(version);\n+\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n+\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n+\t\t\treturn isTheSameModuloRename(\n+\t\t\t\textractFullyQualifiedParentName(original),\n+\t\t\t\textractFullyQualifiedParentName(version));\n+\t\telse\n+\t\t\treturn false;\n+\t}\n+\n+\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+\t\tfor (Node[] pair : listWithFP) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n+\t\t\tif (originalInV2 != null) {\n+\t\t\t\tcreateCallGraph(originalInV2, graph2);\n+\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n+\t\t\t\t\t.incomingEdgesOf(originalInV2));\n+\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n+\t\t\t\t\t.incomingEdgesOf(version));\n+\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n+\t\t\t\t\t.incomingEdgesOf(original));\n+\n+\n+\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n+\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n+\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n+\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n+\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n+\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\t\tif (origInV2Callers.contains(node))\n+\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n+\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n+\t\t\t\t// should be different\n+\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n+\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\tNode node = (Node) iterator.next();\n+\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n+\t\t\t\t\t\t.hasNext(); ) {\n+\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n+\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n+\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n+\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tlistWithFP.remove(pair);\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\n+\t\tpruneOverloadedMethodFP(listWithFP);\n+\n+\t\treturn listWithFP;\n+\t}\n+\n+\n+\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+\t\tboolean retval = false;\n+\n+\t\tif (source.getSignature() == null)\n+\t\t\treturn false;\n+\n+\t\tretval = source.getSignature().equals(target.getSignature());\n+\n+\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n+\t\t\tString sourceParent = extractParentSimpleName(source);\n+\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n+\t\t\t\t.getSignature(), "( , )");\n+\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n+\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n+\t\t\t}\n+\n+\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n+\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n+\t\t\t\t\treturn false;\n+\t\t\t\telse {\n+\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n+\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n+\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tretval = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * This helper method takes a string containing the dot separated name of a\n+\t * node and it returns the subtring from the beginning up to the last dot\n+\t * (e.g. for pack1.class1.method1 it returns class1)\n+\t *\n+\t * @param original\n+\t * @return\n+\t */\n+\tprotected String extractParentSimpleName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\tString parentName = originalName.substring(0, originalName\n+\t\t\t.lastIndexOf("."));\n+\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+\t\treturn parentName;\n+\t}\n+\n+\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n+\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n+\t\t\tboolean hasSameNameAndSignature = false;\n+\t\t\tNode[] pair = listWithFP.get(i);\n+\t\t\tNode source = pair[0];\n+\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\tNode[] pair2 = listWithFP.get(j);\n+\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n+\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\thasSameNameAndSignature = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (hasSameNameAndSignature) {\n+\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n+\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n+\t\t\t\t\tNode source2 = pair2[0];\n+\t\t\t\t\tif (source.equals(source2)) {\n+\t\t\t\t\t\tNode target2 = pair2[1];\n+\t\t\t\t\t\tif (source.getSimpleName().equals(\n+\t\t\t\t\t\t\ttarget2.getSimpleName()))\n+\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n+\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n+\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\t\tfor (Node[] pair : nodesToRemove) {\n+\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+\t\t\tlistWithFP.remove(pair);\n+\n+\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n+\t\t}\n+\t}\n+\n+\n+\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n+\t\tString fqnParent = extractFullyQualifiedParentName(original);\n+\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n+\t\tif (possiblyRenamedFQN != null)\n+\t\t\tfqnParent = possiblyRenamedFQN;\n+\t\t// TODO implement find name node\n+\t\tNode parentNode = g.findNamedNode(fqnParent);\n+\n+\t\tif (parentNode != null) {\n+\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+\t\t\t\tEdge edge = (Edge) iter.next();\n+\t\t\t\tNode child = (Node) edge.getTarget();\n+\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n+\t\t\t\t\tif (original.getSignature() != null) {\n+\t\t\t\t\t\t// This handles the method nodes\n+\t\t\t\t\t\tif (original.getSignature()\n+\t\t\t\t\t\t\t.equals(child.getSignature()))\n+\t\t\t\t\t\t\treturn child;\n+\t\t\t\t\t} else\n+\t\t\t\t\t\t// Classes and packages\n+\t\t\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+\t\tList<Edge> results = new ArrayList<>();\n+\t\tfor (Edge o : list) {\n+\t\t\tif (label.equals(o.getLabel())) {\n+\t\t\t\tresults.add(o);\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\tprotected String extractFullyQualifiedParentName(Node original) {\n+\t\tString originalName = original.getFullyQualifiedName();\n+\t\treturn extractFullyQualifiedParentName(originalName);\n+\t}\n+\n+\tpublic String extractFullyQualifiedParentName(String originalName) {\n+\t\tString fqParentName = "";\n+\t\tint lastIndex = originalName.lastIndexOf(".");\n+\t\tif (lastIndex > 0)\n+\t\t\tfqParentName = originalName.substring(0, lastIndex);\n+\t\treturn fqParentName;\n+\t}\n+\n+\tprivate List<Node> getCallers(List incomingEdges) {\n+\t\tList<Node> callers = new ArrayList<Node>();\n+\t\tfor (Object incomingEdge : incomingEdges) {\n+\t\t\tEdge edge = (Edge) incomingEdge;\n+\t\t\tcallers.add(edge.getSource());\n+\t\t}\n+\t\treturn callers;\n+\t}\n+\n+\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+\t\tboolean foundNewRefactoring = false;\n+\t\tfor (Object prunedCandidate : prunedCandidates) {\n+\t\t\tNode[] pair = (Node[]) prunedCandidate;\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tdouble likeliness = computeLikeliness(original, version);\n+\t\t\tif (likeliness >= threshold) {\n+\t\t\t\tif (!refactoredNodes.contains(pair)) {\n+\t\t\t\t\trefactoredNodes.add(pair);\n+\t\t\t\t\tfoundNewRefactoring = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (foundNewRefactoring) {\n+\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n+\t\t}\n+\t\treturn refactoredNodes;\n+\t}\n+\n+\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+\t\tdouble count = 0;\n+\n+\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n+\n+\t\tfor (Edge edge1 : edges1) {\n+\t\t\tNode node1 = edge1.getSource();\n+\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n+\t\t\t\tEdge edge2 = arrEdge2[i];\n+\t\t\t\tif (edge2 != null) {\n+\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n+\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n+\t\t\t\t\t\t// count it\n+\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n+\t\t\t\t\t\tarrEdge2[i] = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+\t\treturn (fraction1 + fraction2) / 2.0;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n\t@Getter\n\t@Setter\n\tprivate double threshold;\n\n\tprotected NamedDirectedMultigraph graph1;\n\tprotected NamedDirectedMultigraph graph2;\n\n\n\tpublic abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n\tpublic abstract double computeLikeliness(Node node1, Node node12);\n\n\tpublic abstract List<Edge> filterNamedEdges(Set<Edge> list);\n\n\tprotected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n\tprivate static Dictionary<String, String> renamingDictionary;\n\n\tpublic static Dictionary<String, String> getRenamingDictionary() {\n\t\tif (renamingDictionary == null)\n\t\t\trenamingDictionary = new Hashtable<>();\n\t\treturn renamingDictionary;\n\t}\n\n\tpublic List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\t\tList<Node[]> refactoredNodes = new ArrayList<>();\n\t\tList<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n\t\treturn pruneFalsePositives(listWithFP);\n\t}\n\n\t/**\n\t * A default implementation that prunes all those candidates that have the\n\t * same qualified name. Subclasses might reuse this when they implement the\n\t * abstract pruneOriginalCanditates, or they can augment to this initial\n\t * implementation.\n\t *\n\t * @param candidates\n\t * @return\n\t */\n\tpublic List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n\t\tList<Node[]> prunedCandidates = new ArrayList<>();\n\t\tfor (Node[] pair : candidates) {\n\t\t\tif (!(pair[0].getFullyQualifiedName().equals(pair[1]\n\t\t\t\t.getFullyQualifiedName()))) {\n\n\t\t\t\tif (pair[0].isAPI() && pair[1].isAPI()) {\n\t\t\t\t\tNode n2inV1 = graph1.findNamedNode(pair[1]\n\t\t\t\t\t\t.getFullyQualifiedName());\n\n\t\t\t\t\tif ((n2inV1 == null)) {\n\t\t\t\t\t\tprunedCandidates.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prunedCandidates;\n\t}\n\n\t/**\n\t * The client is assumed to be passing it\'s parent to this method to\n\t * determine if they are Modulo Renames of each other.\n\t *\n\t * @param original\n\t * @param version\n\t * @return\n\t */\n\tprotected boolean isTheSameModuloRename(String original, String version) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tif (version.equals(dictionary.get(original)))\n\t\t\treturn true;\n\t\tif (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n\t\t\treturn original.equals(version);\n\t\telse if (original.substring(original.lastIndexOf(".")).equals(\n\t\t\tversion.substring(version.lastIndexOf("."), version.length())))\n\t\t\treturn isTheSameModuloRename(\n\t\t\t\textractFullyQualifiedParentName(original),\n\t\t\t\textractFullyQualifiedParentName(version));\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new ArrayList<Node[]>();\n\t\tfor (Node[] pair : listWithFP) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tNode originalInV2 = findNamedNodeWithSignature(graph2, original);\n\t\t\tif (originalInV2 != null) {\n\t\t\t\tcreateCallGraph(originalInV2, graph2);\n\t\t\t\tList<Edge> origIncomingEdges = filterNamedEdges(graph2\n\t\t\t\t\t.incomingEdgesOf(originalInV2));\n\t\t\t\tList<Edge> verIncomingEdges = filterNamedEdges(graph2\n\t\t\t\t\t.incomingEdgesOf(version));\n\t\t\t\tList<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n\t\t\t\t\t.incomingEdgesOf(original));\n\n\n\t\t\t\tList<Node> origInV2Callers = getCallers(origIncomingEdges);\n\t\t\t\tList<Node> verCallers = getCallers(verIncomingEdges);\n\t\t\t\tList<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n\t\t\t\t// remove those pairs where N1InV2 has at least one call site as N2inV2.\n\t\t\t\t// since a call site cannot be calling both the old and the new entity at the same time\n\t\t\t\tfor (Iterator iterator = verCallers.iterator(); iterator\n\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\tNode node = (Node) iterator.next();\n\t\t\t\t\tif (origInV2Callers.contains(node))\n\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\tSystem.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n\t\t\t\t//is a false positive (since there should be either no more callers for N1inV2 or their call sites\n\t\t\t\t// should be different\n\t\t\t\tfor (Iterator iterator = origInV1Callers.iterator(); iterator\n\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\tNode node = (Node) iterator.next();\n\t\t\t\t\tfor (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n\t\t\t\t\t\t.hasNext(); ) {\n\t\t\t\t\t\tNode callingNode = (Node) iterator1.next();\n\t\t\t\t\t\tif (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair)) {\n\t\t\t\t\t\t\t\tSystem.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n\t\t\t\t\t\t\t\tnodesToRemove.add(pair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tlistWithFP.remove(pair);\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\n\t\tpruneOverloadedMethodFP(listWithFP);\n\n\t\treturn listWithFP;\n\t}\n\n\n\tprivate boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n\t\tboolean retval = false;\n\n\t\tif (source.getSignature() == null)\n\t\t\treturn false;\n\n\t\tretval = source.getSignature().equals(target.getSignature());\n\n\t\tif (!retval && (this instanceof MoveMethodDetection)) {\n\t\t\tString sourceParent = extractParentSimpleName(source);\n\t\t\tStringTokenizer sourceTokenizer = new StringTokenizer(source\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tStringTokenizer targetTokenizer = new StringTokenizer(target\n\t\t\t\t.getSignature(), "( , )");\n\t\t\tString[] sourceTokens = new String[sourceTokenizer.countTokens()];\n\t\t\tString[] targetTokens = new String[targetTokenizer.countTokens()];\n\n\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\tsourceTokens[i] = sourceTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < targetTokens.length; i++) {\n\t\t\t\ttargetTokens[i] = targetTokenizer.nextToken();\n\t\t\t}\n\n\t\t\tif (targetTokens.length == sourceTokens.length + 1) {\n\t\t\t\tif (!targetTokens[0].trim().equals(sourceParent))\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < sourceTokens.length; i++) {\n\t\t\t\t\t\tif (!sourceTokens[i].trim().equals(\n\t\t\t\t\t\t\ttargetTokens[i + 1].trim()))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tretval = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\t/**\n\t * This helper method takes a string containing the dot separated name of a\n\t * node and it returns the subtring from the beginning up to the last dot\n\t * (e.g. for pack1.class1.method1 it returns class1)\n\t *\n\t * @param original\n\t * @return\n\t */\n\tprotected String extractParentSimpleName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\tString parentName = originalName.substring(0, originalName\n\t\t\t.lastIndexOf("."));\n\t\tparentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n\t\treturn parentName;\n\t}\n\n\tprivate void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n\t\tList<Node[]> nodesToRemove = new LinkedList<>();\n\t\tfor (int i = 0; i < listWithFP.size(); i++) {\n\t\t\tboolean hasSameNameAndSignature = false;\n\t\t\tNode[] pair = listWithFP.get(i);\n\t\t\tNode source = pair[0];\n\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\tNode[] pair2 = listWithFP.get(j);\n\t\t\t\tNode source2 = pair2[0];\n\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\tif (source.getSimpleName().equals(target2.getSimpleName()))\n\t\t\t\t\t\tif (signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\thasSameNameAndSignature = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSameNameAndSignature) {\n\t\t\t\tfor (int j = i; j < listWithFP.size(); j++) {\n\t\t\t\t\tNode[] pair2 = (Node[]) listWithFP.get(j);\n\t\t\t\t\tNode source2 = pair2[0];\n\t\t\t\t\tif (source.equals(source2)) {\n\t\t\t\t\t\tNode target2 = pair2[1];\n\t\t\t\t\t\tif (source.getSimpleName().equals(\n\t\t\t\t\t\t\ttarget2.getSimpleName()))\n\t\t\t\t\t\t\tif (!signatureEqualsModuloMoveMethod(source, target2))\n\t\t\t\t\t\t\t\tif (!nodesToRemove.contains(pair2))\n\t\t\t\t\t\t\t\t\tnodesToRemove.add(pair2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (Node[] pair : nodesToRemove) {\n\t\t\tSystem.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n\t\t\tlistWithFP.remove(pair);\n\n\t\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\t\tdictionary.remove(pair[0].getFullyQualifiedName());\n\t\t}\n\t}\n\n\n\tprivate Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n\t\tDictionary<String, String> dictionary = getRenamingDictionary();\n\t\tString fqnParent = extractFullyQualifiedParentName(original);\n\t\tString possiblyRenamedFQN = dictionary.get(fqnParent);\n\t\tif (possiblyRenamedFQN != null)\n\t\t\tfqnParent = possiblyRenamedFQN;\n\t\t// TODO implement find name node\n\t\tNode parentNode = g.findNamedNode(fqnParent);\n\n\t\tif (parentNode != null) {\n\t\t\tList<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n\t\t\tList filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n\t\t\tfor (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n\t\t\t\tEdge edge = (Edge) iter.next();\n\t\t\t\tNode child = (Node) edge.getTarget();\n\t\t\t\tif (original.getSimpleName().equals(child.getSimpleName()))\n\t\t\t\t\tif (original.getSignature() != null) {\n\t\t\t\t\t\t// This handles the method nodes\n\t\t\t\t\t\tif (original.getSignature()\n\t\t\t\t\t\t\t.equals(child.getSignature()))\n\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Classes and packages\n\t\t\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n\t\tList<Edge> results = new ArrayList<>();\n\t\tfor (Edge o : list) {\n\t\t\tif (label.equals(o.getLabel())) {\n\t\t\t\tresults.add(o);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprotected String extractFullyQualifiedParentName(Node original) {\n\t\tString originalName = original.getFullyQualifiedName();\n\t\treturn extractFullyQualifiedParentName(originalName);\n\t}\n\n\tpublic String extractFullyQualifiedParentName(String originalName) {\n\t\tString fqParentName = "";\n\t\tint lastIndex = originalName.lastIndexOf(".");\n\t\tif (lastIndex > 0)\n\t\t\tfqParentName = originalName.substring(0, lastIndex);\n\t\treturn fqParentName;\n\t}\n\n\tprivate List<Node> getCallers(List incomingEdges) {\n\t\tList<Node> callers = new ArrayList<Node>();\n\t\tfor (Object incomingEdge : incomingEdges) {\n\t\t\tEdge edge = (Edge) incomingEdge;\n\t\t\tcallers.add(edge.getSource());\n\t\t}\n\t\treturn callers;\n\t}\n\n\tprivate List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n\t\tList<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n\t\tboolean foundNewRefactoring = false;\n\t\tfor (Object prunedCandidate : prunedCandidates) {\n\t\t\tNode[] pair = (Node[]) prunedCandidate;\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tdouble likeliness = computeLikeliness(original, version);\n\t\t\tif (likeliness >= threshold) {\n\t\t\t\tif (!refactoredNodes.contains(pair)) {\n\t\t\t\t\trefactoredNodes.add(pair);\n\t\t\t\t\tfoundNewRefactoring = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (foundNewRefactoring) {\n\t\t\tdoDetectRefactorings(candidates, refactoredNodes);\n\t\t}\n\t\treturn refactoredNodes;\n\t}\n\n\tpublic double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n\t\tdouble count = 0;\n\n\t\tEdge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n\n\t\tfor (Edge edge1 : edges1) {\n\t\t\tNode node1 = edge1.getSource();\n\t\t\tfor (int i = 0; i < arrEdge2.length; i++) {\n\t\t\t\tEdge edge2 = arrEdge2[i];\n\t\t\t\tif (edge2 != null) {\n\t\t\t\t\tNode node2 = (Node) edge2.getSource();\n\t\t\t\t\tif (isTheSameModuloRename(node1.getFullyQualifiedName(),\n\t\t\t\t\t\tnode2.getFullyQualifiedName())) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// we mark this edge as already counted so that we don\'t\n\t\t\t\t\t\t// count it\n\t\t\t\t\t\t// twice when there are multiple edges between two nodes\n\t\t\t\t\t\tarrEdge2[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n\t\tdouble fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n\t\treturn (fraction1 + fraction2) / 2.0;\n\t}\n}\n'
          },
          {
            sha: "ad23be0bb72541bba39990d23583c5bc90ee1d66",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "modified",
            additions: 27,
            deletions: 26,
            patch:
              "@@ -9,31 +9,32 @@\n \n public class RenameMethodDetection extends MethodDetection {\n \n-    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n-\n-    }\n-\n-    @Override\n-    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n-        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n-        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n-        for (Node[] pair : prePrunedMethods) {\n-            Node original = pair[0];\n-            Node version = pair[1];\n-            String parentClassOriginal = extractFullyQualifiedParentName(original);\n-            String parentClassVersion = extractFullyQualifiedParentName(version);\n-            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n-                    && (!(original.getSimpleName().equals(version\n-                    .getSimpleName()))))\n-                candidatesWithSameParentClass.add(pair);\n-        }\n-\n-        return candidatesWithSameParentClass;\n-    }\n-\n-    @Override\n-    public double computeLikeliness(Node oldVersion, Node newVersion) {\n-        return super.analyzeIncomingEdges(oldVersion, newVersion);\n-    }\n+\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+\t\tthis.graph1 = oldVersion;\n+\t\tthis.graph2 = newVersion;\n+\t}\n+\n+\t@Override\n+\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+\t\tfor (Node[] pair : prePrunedMethods) {\n+\t\t\tNode original = pair[0];\n+\t\t\tNode version = pair[1];\n+\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n+\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n+\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+\t\t\t\t&& (!(original.getSimpleName().equals(version\n+\t\t\t\t.getSimpleName()))))\n+\t\t\t\tcandidatesWithSameParentClass.add(pair);\n+\t\t}\n+\n+\t\treturn candidatesWithSameParentClass;\n+\t}\n+\n+\t@Override\n+\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n+\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n+\t}\n \n }",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n\tpublic RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\t\tthis.graph1 = oldVersion;\n\t\tthis.graph2 = newVersion;\n\t}\n\n\t@Override\n\tpublic List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n\t\tList<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n\t\tList<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n\t\tfor (Node[] pair : prePrunedMethods) {\n\t\t\tNode original = pair[0];\n\t\t\tNode version = pair[1];\n\t\t\tString parentClassOriginal = extractFullyQualifiedParentName(original);\n\t\t\tString parentClassVersion = extractFullyQualifiedParentName(version);\n\t\t\tif (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n\t\t\t\t&& (!(original.getSimpleName().equals(version\n\t\t\t\t.getSimpleName()))))\n\t\t\t\tcandidatesWithSameParentClass.add(pair);\n\t\t}\n\n\t\treturn candidatesWithSameParentClass;\n\t}\n\n\t@Override\n\tpublic double computeLikeliness(Node oldVersion, Node newVersion) {\n\t\treturn super.analyzeIncomingEdges(oldVersion, newVersion);\n\t}\n\n}\n"
          },
          {
            sha: "448f7bcee55deabe401c3a889ce95bd377b9dfd5",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "modified",
            additions: 1,
            deletions: 11,
            patch:
              "@@ -28,18 +28,8 @@ public RCProject(String projectName, List<String> fileSources) {\n \t\t}\n \t}\n \n-\n-\tprivate void browsePackages(){\n-\t\tfor(CompilationUnit unit: this.units){\n-\t\t\tunit.\n-\t\t}\n-\t}\n-\n-\n \t@Override\n \tpublic List<IPackage> getPackages() {\n-\t\tif (null != packages) {\n-\t\t\tbrowsePackages();\n-\t\t}\n+\t\treturn null;\n \t}\n }",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\treturn null;\n\t}\n}\n"
          },
          {
            sha: "fe676e94ebfb94cc6e342fed1ffd6bc08ecda4d1",
            filename: "src/main/java/refactoring/crawler/util/BloomFilter.java",
            status: "added",
            additions: 544,
            deletions: 0,
            patch:
              '@@ -0,0 +1,544 @@\n+package refactoring.crawler.util;\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.net.URL;\n+\n+/**\n+ * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n+ * hash table.</p> <p>\n+ * \n+ * Bloom filters allow you to perform membership tests in just a fraction of the memory \n+ * you\'d need to store a full list of keys. As you might suspect, the savings in space \n+ * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n+ * key from a filter once you\'ve added it in. But in the many cases where those constraints\n+ * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n+ * \n+ * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n+ * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n+ * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n+ * filters were prized primarily for their compactness; in fact, one of their earliest applications\n+ *  was in spell checkers.</p> <p>\n+ * \n+ * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n+ * a given length. We choose the length of the bit vector and the number of hash functions\n+ * depending on how many keys we want to add to the set and how high an error rate we are\n+ * willing to put up with. </p> <p>\n+ * \n+ * All of the hash functions in a Bloom filter are configured so that their range matches the\n+ * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n+ * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n+ * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n+ * function would increase our false-positive rate.</p> <p>\n+ * \n+ * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n+ * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n+ * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n+ * in a Bloom filter.</p> <p>\n+ * \n+ * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n+ * new key. We run the key through our set of hash functions, and then check to see whether\n+ * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n+ * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n+ * \n+ * As you might expect, the false-positive rate depends on the bit vector length and the number\n+ * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n+ * we check will be on, unless the key actually exists in the filter. The relationship between the\n+ * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n+ * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n+ * filter will be very dense, increasing the probability of collisions. You can calculate the\n+ * false-positive rate for any filter using the formula:</p> <p>\n+ * \n+ * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n+ *\n+ * Where c is the false positive rate, k is the number of hash functions, n is the number of\n+ * keys in the filter, and m is the length of the filter in bits.</p> <p>\n+ *\n+ * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n+ * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n+ * need some way of finding out how large a bit vector is to make sure the false-positive rate\n+ * never exceeds our limit. The following equation will give us vector length from the error rate\n+ * and number of keys:</p> <p>\n+ * \n+ *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n+ *\n+ * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n+ * possible to use calculus to find a minimum for k. You can also find lookup tables for \n+ * various combinations of error rate, filter size, and number of hash functions at \n+ * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n+ *  \n+ * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n+ * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n+ * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n+ *\n+ * Alternatively, this class can also use an implementation of a hash function based on Rabin\n+ * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n+ * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n+ * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n+ * function with very satisfactory properties. In addition the polynomial operations are fast in\n+ * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n+ *\n+ * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n+ * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n+ * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n+ * paper in PDF format.</p> <p>\n+ *\n+ * Included in this class are additional methods that can compute the Rabin hash value\n+ * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n+ *\n+ * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n+ * initial value multiplied by a list of distinct values.\n+ * \n+ * @see java.lang.Object#hashCode()\n+ * @see java.util.Map\n+ *\n+ * @author      Bruno Martins\n+ */\n+public class BloomFilter implements Cloneable {\n+\n+\t/** A buffer for the Rabin fingerprinting algorithm. */\n+\tprivate byte[] buffer;\n+\t\n+\t/**\n+\t *  The 32 bits of this integer represent the coefficients of the degree 32\n+\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n+\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n+\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n+\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n+\t *  bit is the constant coefficient.</p> <p>\n+\t *\n+\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n+\t *\n+\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n+\t *\n+\t *  Therefore it correponds to the polynomial:</p> <p>\n+\t *\n+\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n+\t */\n+\tprivate static int POLYNOMIAL = 0x000001C7;\n+\n+\t/** Internal values for the Rabin fingerprinting algorithm. */\n+\tprivate static int[] table32, table40, table48, table54;\n+\t\n+\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+\tprivate static int P_DEGREE = 32;\n+\t\n+\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n+\tprivate static int READ_BUFFER_SIZE = 2048;\n+\t\n+\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n+\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n+\n+\t/** The bit vector for the Bloom Filter. */\n+\tprivate boolean keys[];\n+\n+\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n+\tprivate boolean useRabin = true;\n+\t\n+\t/** The number of hash functions. */\n+\tprivate int numFunctions;\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n+\t * and the default length for the bit vector (1000).\n+\t */\n+\tpublic BloomFilter() {\n+\t\ttable32 = new int[256];\n+\t\ttable40 = new int[256];\n+\t\ttable48 = new int[256];\n+\t\ttable54 = new int[256];\n+\t\tbuffer = new byte[READ_BUFFER_SIZE];\n+\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n+\t\tint[] mods = new int[P_DEGREE];\n+\t\tmods[0] = POLYNOMIAL;\n+\t\tfor (int i = 1; i < P_DEGREE; i++) {\n+\t\t\t// x^i == x(x^(i-1)) (mod P)\n+\t\t\tmods[i] = mods[i - 1] << 1;\n+\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n+\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n+\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n+\t\t\t// to account for this:\n+\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n+\t\t\t\tmods[i] ^= POLYNOMIAL;\n+\t\t\t}\n+\t\t}\n+\t\tfor (int i = 0; i < 256; i++) {\n+\t\t\tint c = i;\n+\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n+\t\t\t\tif ((c & 1) != 0) {\n+\t\t\t\t\ttable32[i] ^= mods[j];\n+\t\t\t\t\ttable40[i] ^= mods[j + 8];\n+\t\t\t\t\ttable48[i] ^= mods[j + 16];\n+\t\t\t\t\ttable54[i] ^= mods[j + 24];\n+\t\t\t\t}\n+\t\t\t\tc >>>= 1;\n+\t\t\t}\n+\t\t}\n+\t\tmods = null;\n+\t\tthis.keys = new boolean[1000];\n+\t\tthis.numFunctions = 10;\n+\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t * Constructs a Bloom Filter from a string representation.\n+\t *\n+\t * @see #toString()\n+\t */\n+\tpublic BloomFilter(String filter) {\n+\t\tthis();\n+\t\tint index1 = filter.indexOf(":");\n+\t\tint index2 = filter.lastIndexOf(":");\n+\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n+\t\tkeys =\n+\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n+\t\t\t\t.intValue()];\n+\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n+\t\t\tif (filter.charAt(i) == \'1\')\n+\t\t\t\tkeys[i] = true;\n+\t\t\telse\n+\t\t\t\tkeys[i] = false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with a given length for the bit vector,\n+\t * guarenteeing a maximum error rate.  \n+\t *\n+\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n+\t */\n+\tpublic BloomFilter(int numKeys, double errorRate) {\n+\t\tthis();\n+\t\tdouble lowest_m = Double.MAX_VALUE;\n+\t\tint best_k = 1;\n+\t\tfor (int k = 1; k <= 100; k++) {\n+\t\t\tdouble m =\n+\t\t\t\t(-1 * k * numKeys)\n+\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n+\t\t\tif (m < lowest_m) {\n+\t\t\t\tlowest_m = m;\n+\t\t\t\tbest_k = k;\n+\t\t\t}\n+\t\t}\n+\t\tthis.keys = new boolean[numKeys];\n+\t\tthis.numFunctions = best_k;\n+\t\tfor (int i = 0; i < numKeys; i++)\n+\t\t\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n+\t * and a given length for the bit vector.\n+\t *\n+\t *@param  numKeys           The length of the bit vector.\n+\t */\n+\tpublic BloomFilter(int numKeys) {\n+\t\tthis(numKeys, 10);\n+\t}\n+\n+\t/**\n+\t * Constructs an empty BloomFilter with a given number of hash functions\n+\t * and a given length for the bit vector.\n+\t *\n+\t *@param  numKeys                The length of the bit vector.\n+\t *@param  numHashFunctions  The number of hash functions.\n+\t */\n+\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n+\t\tthis();\n+\t\tthis.keys = new boolean[numKeys];\n+\t\tthis.numFunctions = numHashFunctions;\n+\t\tfor (int i = 0; i < numKeys; i++)\n+\t\t\tthis.keys[i] = false;\n+\t}\n+\n+\t/**\n+\t *  Internal method for producing the hash value for a given function number.\n+\t *\n+\t * @param  fnum      The number of the hash function.\n+\t * @param  original   The original value for the hash of the object. \n+\t * @see java.lang.Object#hashCode() \n+\t * @return   Returns the hash code value for the given function number.\n+\t */\n+\tprivate int getHash(int fnum, int original) {\n+\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n+\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n+\t\tint hash[] = { original };\n+\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n+\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n+\t\thash[0] = hash[0] % keys.length;\n+\t\tif (hash[0] < 0) hash[0] = -hash[0];\n+\t\treturn hash[0];\n+\t}\n+\n+\t/**\n+\t *  Returns true if this Bloom Filter contains the specified key.\n+\t *\n+\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n+\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n+\t */\n+\tpublic boolean hasKey(Object obj) {\n+\t\tboolean result = true;\n+\t\tint hashCodeObject;\n+\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n+\t\t\thashCodeObject = hashRabin(obj);\n+\t\t} catch ( Exception e ) {\n+\t\t\tuseRabin = false;\n+\t\t\thashCodeObject = obj.hashCode();\n+\t\t}\n+\t\tfor (int i = 0; i < numFunctions && result; i++) {\n+\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t *  Adds the specified key in this Bloom Filter.\n+\t *\n+\t *@param  obj  The key to be added to this Bloom Filter.\n+\t */\n+\tpublic void put(Object obj) {\n+\t\tint hashCodeObject;\n+\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n+\t\t\thashCodeObject = hashRabin(obj);\n+\t\t} catch ( Exception e ) {\n+\t\t\tuseRabin = false;\n+\t\t\thashCodeObject = obj.hashCode();\n+\t\t}\n+\t\tfor (int i = 0; i < numFunctions; i++) {\n+\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *\n+\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n+\t * integer specifying the number of hash Functions, an integer specifying the length of the\n+\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n+\t * separated by the character ":".\n+\t * \n+\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n+\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n+\t * \n+\t * @return A string representation of this Bloom Filter.\n+\t */\n+\tpublic String toString() {\n+\t\tStringBuffer aux =\n+\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n+\t\tfor (int i = 0; i < keys.length; i++) {\n+\t\t\tif (keys[i])\n+\t\t\t\taux.append("1");\n+\t\t\telse\n+\t\t\t\taux.append("0");\n+\t\t}\n+\t\treturn aux.toString();\n+\t}\n+\n+\t/**\n+\t * Returns a copy of this Bloom Filter instance.\n+\t *\n+\t * @see java.lang.Object#clone()\n+\t */\n+\tpublic Object clone() {\n+\t\treturn new BloomFilter(this.toString());\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of bytes.\n+\t *\n+\t *@param  arr  An array of bytes.\n+\t *@return    The Rabin hash value for the array of bytes.\n+\t */\n+\tpublic int hashRabin(byte[] arr) {\n+\t\treturn hashRabin(arr, 0, arr.length, 0);\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of bytes.\n+\t *\n+\t *@param  arr        An array of bytes.\n+\t *@param  offset    Index of the first byte of the array to hash.\n+\t *@param  length   Number of bytes to hash.\n+\t *@param  ws          ??         \n+\t *@return  The Rabin hash value for the array of bytes.\n+\t */\n+\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n+\t\tint w = ws;\n+\t\tint start = length % 4;\n+\t\tfor (int s = offset; s < offset + start; s++) {\n+\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n+\t\t}\n+\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ (arr[s] << 24)\n+\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n+\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n+\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Return the Rabin hash value of an array of chars.\n+\t *\n+\t *@param  arr  An array of chars.\n+\t *@return   The Rabin hash value for the array of chars.\n+\t */\n+\tpublic int hashRabin(char[] arr) {\n+\t\tint w = 0;\n+\t\tint start = 0;\n+\t\tif (arr.length % 2 == 1) {\n+\t\t\tw = arr[0] & 0xFFFF;\n+\t\t\tstart = 1;\n+\t\t}\n+\t\tfor (int s = start; s < arr.length; s += 2) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n+\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n+\t *\n+\t *@param  f                       A <code>File</code>.\n+\t *@return                          The Rabin hash value for the contents of the File.\n+\t *@throws  FileNotFoundException  If the file cannot be found.\n+\t *@throws  IOException            If an error occurs while reading the file.\n+\t */\n+\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n+\t\tFileInputStream fis = new FileInputStream(f);\n+\t\ttry {\n+\t\t\treturn hashRabin(fis);\n+\t\t} finally {\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n+\t *\n+\t *@param  is          An InputStream.\n+\t *@return               The Rabin hash value for the contents read from the InputStream.\n+\t *@throws  IOException  if an error occurs while reading from the InputStream.\n+\t */\n+\tpublic int hashRabin(InputStream is) throws IOException {\n+\t\tint hashValue = 0;\n+\t\tint bytesRead;\n+\t\tsynchronized (buffer) {\n+\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n+\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n+\t\t\t}\n+\t\t}\n+\t\treturn hashValue;\n+\t}\n+\n+\t/**\n+\t *  Returns the Rabin hash value of an array of integers. This method is the\n+\t *  most efficient of all the hash methods, so it should be used when\n+\t *  possible.\n+\t *\n+\t *@param   arr  An array of integers.\n+\t *@return    int The Rabin hash value for the array of integers.\n+\t */\n+\tpublic int hashRabin(int[] arr) {\n+\t\tint w = 0;\n+\t\tfor (int s = 0; s < arr.length; s++) {\n+\t\t\tw =\n+\t\t\t\ttable32[w\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table40[(w >>> 8)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table48[(w >>> 16)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ table54[(w >>> 24)\n+\t\t\t\t\t& 0xFF]\n+\t\t\t\t\t^ arr[s];\n+\t\t}\n+\t\treturn w;\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a given Object.\n+\t *\n+\t *@param  obj            An Object.\n+\t *@return                   The Rabin hash value for the Object.\n+\t *@throws  IOException  If Object serialization fails.\n+\t */\n+\tpublic int hashRabin(Object obj) throws IOException {\n+\t\treturn hashRabin((Serializable) obj);\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a given serializable Object.\n+\t *\n+\t *@param  obj             An Object.\n+\t *@return                   The Rabin hash value for the Object.\n+\t *@throws  IOException  If serialization fails.\n+\t */\n+\tpublic int hashRabin(Serializable obj) throws IOException {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tObjectOutputStream oos = null;\n+\t\ttry {\n+\t\t\toos = new ObjectOutputStream(baos);\n+\t\t\toos.writeObject(obj);\n+\t\t\treturn hashRabin(baos.toByteArray());\n+\t\t} finally {\n+\t\t\toos.close();\n+\t\t\tbaos.close();\n+\t\t\toos = null;\n+\t\t\tbaos = null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of a String.\n+\t *\n+\t *@param  s  A <code>String</code>.\n+\t *@return   The Rabin hash value for the String.\n+\t */\n+\tpublic int hashRabin(String s) {\n+\t\treturn hashRabin(s.toCharArray());\n+\t}\n+\n+\t/**\n+\t *  Computes the Rabin hash value of the contents of a Web document,\n+\t *  specified by an URL.\n+\t *\n+\t *@param  url         The URL of the document to be hashed.\n+\t *@return               The Rabin hash value for the document.\n+\t *@throws  IOException If an error occurs while reading the document.\n+\t */\n+\tpublic int hashRabin(URL url) throws IOException {\n+\t\tInputStream is = url.openStream();\n+\t\ttry {\n+\t\t\treturn hashRabin(is);\n+\t\t} finally {\n+\t\t\tis.close();\n+\t\t}\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup\n * hash table.</p> <p>\n * \n * Bloom filters allow you to perform membership tests in just a fraction of the memory \n * you\'d need to store a full list of keys. As you might suspect, the savings in space \n * comes at a price: you run an adjustable risk of false positives, and you can\'t remove a\n * key from a filter once you\'ve added it in. But in the many cases where those constraints\n * are acceptable, a Bloom filter can make a useful tool.</p> <p>\n * \n * Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time\n * trade-offs in hash coding with allowable errors</a>. In those days of limited memory, Bloom\n * filters were prized primarily for their compactness; in fact, one of their earliest applications\n *  was in spell checkers.</p> <p>\n * \n * A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit vector of\n * a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are\n * willing to put up with. </p> <p>\n * \n * All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return\n * a value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.</p> <p>\n * \n * To enter a key into a Bloom filter, we run it through each one of the k hash functions\n * and treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off\n * in a Bloom filter.</p> <p>\n * \n * Checking to see whether a key already exists in a filter is exactly analogous to adding a\n * new key. We run the key through our set of hash functions, and then check to see whether\n * the bits at those offsets are all turned on. If any of the bits is off, we know for certain the\n * key is not in the filter. If all of the bits are on, we know the key is probably there.</p> <p>\n * \n * As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k bits\n * we check will be on, unless the key actually exists in the filter. The relationship between the\n * number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the\n * filter will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:</p> <p>\n * \n * <code>c = ( 1 - e(-kn/m) )k</code></p> <p>\n *\n * Where c is the false positive rate, k is the number of hash functions, n is the number of\n * keys in the filter, and m is the length of the filter in bits.</p> <p>\n *\n * When using Bloom filters, we very frequently have a desired false-positive rate in mind and\n * we are also likely to have a rough idea of how many keys we want to add to the filter. We\n * need some way of finding out how large a bit vector is to make sure the false-positive rate\n * never exceeds our limit. The following equation will give us vector length from the error rate\n * and number of keys:</p> <p>\n * \n *<code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code></p> <p>\n *\n * You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for \n * various combinations of error rate, filter size, and number of hash functions at \n * <a href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters -- the math</a>.</p> <p>\n *  \n * This implementation uses the <code>hashCode()</code> method supplied for all Java objects, which\n * produces a 32-bit signed int number. For example, in <code>String</code> Objects, the hashcode is usually\n * computed by adding up the character values with an prime multiplier (31, in the case of JDK 1.4).</p> <p> \n *\n * Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes.\n * It does so by considering strings of bytes as large polynomials with coefficients of 0 and 1\n * and then reducing them modulo some irreducible polynomial of degree 32. The result is a hash\n * function with very satisfactory properties. In addition the polynomial operations are fast in\n * hardware, and even in this Java implementation the speed is reasonable.</p> <p>\n *\n * The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.</p> <p>\n *\n * Included in this class are additional methods that can compute the Rabin hash value\n * for any serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by <code>URL</code>.</p> <p>\n *\n * As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n * \n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n *\n * @author      Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n\t/** A buffer for the Rabin fingerprinting algorithm. */\n\tprivate byte[] buffer;\n\t\n\t/**\n\t *  The 32 bits of this integer represent the coefficients of the degree 32\n\t *  irreducible polynomial over GF(2); that is, every coefficient is 0 or 1. However, a\n\t *  degree 32 polynomial has 33 coefficients; the term of degree 32 is\n\t *  assumed to have a coefficient of 1. Therefore, the high-order bit of the\n\t *  <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n\t *  bit is the constant coefficient.</p> <p>\n\t *\n\t *  For example the integer 0x00000803, in binary, is:</p> <p>\n\t *\n\t *  <code>00000000 00000000 00001000 00000011</code></p> <p>\n\t *\n\t *  Therefore it correponds to the polynomial:</p> <p>\n\t *\n\t *  <code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n\t */\n\tprivate static int POLYNOMIAL = 0x000001C7;\n\n\t/** Internal values for the Rabin fingerprinting algorithm. */\n\tprivate static int[] table32, table40, table48, table54;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int P_DEGREE = 32;\n\t\n\t/** The size of the buffer for the Rabin fingerprinting algorithm. */\n\tprivate static int READ_BUFFER_SIZE = 2048;\n\t\n\t/** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n\tprivate static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n\t/** The bit vector for the Bloom Filter. */\n\tprivate boolean keys[];\n\n\t/** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n\tprivate boolean useRabin = true;\n\t\n\t/** The number of hash functions. */\n\tprivate int numFunctions;\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and the default length for the bit vector (1000).\n\t */\n\tpublic BloomFilter() {\n\t\ttable32 = new int[256];\n\t\ttable40 = new int[256];\n\t\ttable48 = new int[256];\n\t\ttable54 = new int[256];\n\t\tbuffer = new byte[READ_BUFFER_SIZE];\n\t\t// We want to have mods[i] == x^(P_DEGREE+i)\n\t\tint[] mods = new int[P_DEGREE];\n\t\tmods[0] = POLYNOMIAL;\n\t\tfor (int i = 1; i < P_DEGREE; i++) {\n\t\t\t// x^i == x(x^(i-1)) (mod P)\n\t\t\tmods[i] = mods[i - 1] << 1;\n\t\t\t// if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n\t\t\t// x^P_DEGREE term that \'fell off\' the top end.\n\t\t\t// Since x^P_DEGREE == P (mod P), we should add P\n\t\t\t// to account for this:\n\t\t\tif ((mods[i - 1] & X_P_DEGREE) != 0) {\n\t\t\t\tmods[i] ^= POLYNOMIAL;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tint c = i;\n\t\t\tfor (int j = 0; j < 8 && c != 0; j++) {\n\t\t\t\tif ((c & 1) != 0) {\n\t\t\t\t\ttable32[i] ^= mods[j];\n\t\t\t\t\ttable40[i] ^= mods[j + 8];\n\t\t\t\t\ttable48[i] ^= mods[j + 16];\n\t\t\t\t\ttable54[i] ^= mods[j + 24];\n\t\t\t\t}\n\t\t\t\tc >>>= 1;\n\t\t\t}\n\t\t}\n\t\tmods = null;\n\t\tthis.keys = new boolean[1000];\n\t\tthis.numFunctions = 10;\n\t\tfor (int i = 0; i < 1000; i++)\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs a Bloom Filter from a string representation.\n\t *\n\t * @see #toString()\n\t */\n\tpublic BloomFilter(String filter) {\n\t\tthis();\n\t\tint index1 = filter.indexOf(":");\n\t\tint index2 = filter.lastIndexOf(":");\n\t\tnumFunctions = new Integer(filter.substring(0, index1)).intValue();\n\t\tkeys =\n\t\t\tnew boolean[new Integer(filter.substring(index1, index2))\n\t\t\t\t.intValue()];\n\t\tfor (int i = index2 + 1; i < filter.length(); i++) {\n\t\t\tif (filter.charAt(i) == \'1\')\n\t\t\t\tkeys[i] = true;\n\t\t\telse\n\t\t\t\tkeys[i] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given length for the bit vector,\n\t * guarenteeing a maximum error rate.  \n\t *\n\t *@param  errorRate           The maximum error rate (false positives) for the Bloom Filter.\n\t */\n\tpublic BloomFilter(int numKeys, double errorRate) {\n\t\tthis();\n\t\tdouble lowest_m = Double.MAX_VALUE;\n\t\tint best_k = 1;\n\t\tfor (int k = 1; k <= 100; k++) {\n\t\t\tdouble m =\n\t\t\t\t(-1 * k * numKeys)\n\t\t\t\t\t/ (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n\t\t\tif (m < lowest_m) {\n\t\t\t\tlowest_m = m;\n\t\t\t\tbest_k = k;\n\t\t\t}\n\t\t}\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = best_k;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with the default number of hash functions (10)\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys           The length of the bit vector.\n\t */\n\tpublic BloomFilter(int numKeys) {\n\t\tthis(numKeys, 10);\n\t}\n\n\t/**\n\t * Constructs an empty BloomFilter with a given number of hash functions\n\t * and a given length for the bit vector.\n\t *\n\t *@param  numKeys                The length of the bit vector.\n\t *@param  numHashFunctions  The number of hash functions.\n\t */\n\tpublic BloomFilter(int numKeys, int numHashFunctions) {\n\t\tthis();\n\t\tthis.keys = new boolean[numKeys];\n\t\tthis.numFunctions = numHashFunctions;\n\t\tfor (int i = 0; i < numKeys; i++)\n\t\t\tthis.keys[i] = false;\n\t}\n\n\t/**\n\t *  Internal method for producing the hash value for a given function number.\n\t *\n\t * @param  fnum      The number of the hash function.\n\t * @param  original   The original value for the hash of the object. \n\t * @see java.lang.Object#hashCode() \n\t * @return   Returns the hash code value for the given function number.\n\t */\n\tprivate int getHash(int fnum, int original) {\n\t\t//int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n\t\t//int hash = ((fnum * fnum + 1) * original) % keys.length;\n\t\tint hash[] = { original };\n\t\tif(!useRabin) for (int i=0; i<fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n\t\telse for (int i=0; i<fnum; i++) hash[0] = hashRabin(hash);\n\t\thash[0] = hash[0] % keys.length;\n\t\tif (hash[0] < 0) hash[0] = -hash[0];\n\t\treturn hash[0];\n\t}\n\n\t/**\n\t *  Returns true if this Bloom Filter contains the specified key.\n\t *\n\t *@param  obj   The key whose presence in this Bloom Filter is to be tested.\n\t *@return   true if this Bloom Filter contains a mapping for the specified key.\n\t */\n\tpublic boolean hasKey(Object obj) {\n\t\tboolean result = true;\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try {\n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions && result; i++) {\n\t\t\tresult &= keys[getHash(i, hashCodeObject)];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t *  Adds the specified key in this Bloom Filter.\n\t *\n\t *@param  obj  The key to be added to this Bloom Filter.\n\t */\n\tpublic void put(Object obj) {\n\t\tint hashCodeObject;\n\t\tif(!useRabin) hashCodeObject = obj.hashCode(); else try { \n\t\t\thashCodeObject = hashRabin(obj);\n\t\t} catch ( Exception e ) {\n\t\t\tuseRabin = false;\n\t\t\thashCodeObject = obj.hashCode();\n\t\t}\n\t\tfor (int i = 0; i < numFunctions; i++) {\n\t\t\tkeys[getHash(i, hashCodeObject)] = true;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * Returns a string representation of this Bloom Filter. The string representation consists of an\n\t * integer specifying the number of hash Functions, an integer specifying the length of the\n\t * bit vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are\n\t * separated by the character ":".\n\t * \n\t * This implementation creates an empty string buffer, and iterates over the bit vector, \n\t * appending the value of each bit in turn. A string is obtained from the stringbuffer, and returned.\n\t * \n\t * @return A string representation of this Bloom Filter.\n\t */\n\tpublic String toString() {\n\t\tStringBuffer aux =\n\t\t\tnew StringBuffer(numFunctions + ":" + keys.length + ":");\n\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i])\n\t\t\t\taux.append("1");\n\t\t\telse\n\t\t\t\taux.append("0");\n\t\t}\n\t\treturn aux.toString();\n\t}\n\n\t/**\n\t * Returns a copy of this Bloom Filter instance.\n\t *\n\t * @see java.lang.Object#clone()\n\t */\n\tpublic Object clone() {\n\t\treturn new BloomFilter(this.toString());\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr  An array of bytes.\n\t *@return    The Rabin hash value for the array of bytes.\n\t */\n\tpublic int hashRabin(byte[] arr) {\n\t\treturn hashRabin(arr, 0, arr.length, 0);\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of bytes.\n\t *\n\t *@param  arr        An array of bytes.\n\t *@param  offset    Index of the first byte of the array to hash.\n\t *@param  length   Number of bytes to hash.\n\t *@param  ws          ??         \n\t *@return  The Rabin hash value for the array of bytes.\n\t */\n\tprivate int hashRabin(byte[] arr, int offset, int length, int ws) {\n\t\tint w = ws;\n\t\tint start = length % 4;\n\t\tfor (int s = offset; s < offset + start; s++) {\n\t\t\tw = (w << 8) ^ (arr[s] & 0xFF);\n\t\t}\n\t\tfor (int s = start + offset; s < length + offset; s += 4) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ (arr[s] << 24)\n\t\t\t\t\t^ ((arr[s + 1] & 0xFF) << 16)\n\t\t\t\t\t^ ((arr[s + 2] & 0xFF) << 8)\n\t\t\t\t\t^ (arr[s + 3] & 0xFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Return the Rabin hash value of an array of chars.\n\t *\n\t *@param  arr  An array of chars.\n\t *@return   The Rabin hash value for the array of chars.\n\t */\n\tpublic int hashRabin(char[] arr) {\n\t\tint w = 0;\n\t\tint start = 0;\n\t\tif (arr.length % 2 == 1) {\n\t\t\tw = arr[0] & 0xFFFF;\n\t\t\tstart = 1;\n\t\t}\n\t\tfor (int s = start; s < arr.length; s += 2) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ ((arr[s] & 0xFFFF) << 16)\n\t\t\t\t\t^ (arr[s + 1] & 0xFFFF);\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a <code>File</code>.\n\t *\n\t *@param  f                       A <code>File</code>.\n\t *@return                          The Rabin hash value for the contents of the File.\n\t *@throws  FileNotFoundException  If the file cannot be found.\n\t *@throws  IOException            If an error occurs while reading the file.\n\t */\n\tpublic int hashRabin(File f) throws FileNotFoundException, IOException {\n\t\tFileInputStream fis = new FileInputStream(f);\n\t\ttry {\n\t\t\treturn hashRabin(fis);\n\t\t} finally {\n\t\t\tfis.close();\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the data from an <code>InputStream</code>.\n\t *\n\t *@param  is          An InputStream.\n\t *@return               The Rabin hash value for the contents read from the InputStream.\n\t *@throws  IOException  if an error occurs while reading from the InputStream.\n\t */\n\tpublic int hashRabin(InputStream is) throws IOException {\n\t\tint hashValue = 0;\n\t\tint bytesRead;\n\t\tsynchronized (buffer) {\n\t\t\twhile ((bytesRead = is.read(buffer)) > 0) {\n\t\t\t\thashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n\t\t\t}\n\t\t}\n\t\treturn hashValue;\n\t}\n\n\t/**\n\t *  Returns the Rabin hash value of an array of integers. This method is the\n\t *  most efficient of all the hash methods, so it should be used when\n\t *  possible.\n\t *\n\t *@param   arr  An array of integers.\n\t *@return    int The Rabin hash value for the array of integers.\n\t */\n\tpublic int hashRabin(int[] arr) {\n\t\tint w = 0;\n\t\tfor (int s = 0; s < arr.length; s++) {\n\t\t\tw =\n\t\t\t\ttable32[w\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table40[(w >>> 8)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table48[(w >>> 16)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ table54[(w >>> 24)\n\t\t\t\t\t& 0xFF]\n\t\t\t\t\t^ arr[s];\n\t\t}\n\t\treturn w;\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given Object.\n\t *\n\t *@param  obj            An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If Object serialization fails.\n\t */\n\tpublic int hashRabin(Object obj) throws IOException {\n\t\treturn hashRabin((Serializable) obj);\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a given serializable Object.\n\t *\n\t *@param  obj             An Object.\n\t *@return                   The Rabin hash value for the Object.\n\t *@throws  IOException  If serialization fails.\n\t */\n\tpublic int hashRabin(Serializable obj) throws IOException {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = null;\n\t\ttry {\n\t\t\toos = new ObjectOutputStream(baos);\n\t\t\toos.writeObject(obj);\n\t\t\treturn hashRabin(baos.toByteArray());\n\t\t} finally {\n\t\t\toos.close();\n\t\t\tbaos.close();\n\t\t\toos = null;\n\t\t\tbaos = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of a String.\n\t *\n\t *@param  s  A <code>String</code>.\n\t *@return   The Rabin hash value for the String.\n\t */\n\tpublic int hashRabin(String s) {\n\t\treturn hashRabin(s.toCharArray());\n\t}\n\n\t/**\n\t *  Computes the Rabin hash value of the contents of a Web document,\n\t *  specified by an URL.\n\t *\n\t *@param  url         The URL of the document to be hashed.\n\t *@return               The Rabin hash value for the document.\n\t *@throws  IOException If an error occurs while reading the document.\n\t */\n\tpublic int hashRabin(URL url) throws IOException {\n\t\tInputStream is = url.openStream();\n\t\ttry {\n\t\t\treturn hashRabin(is);\n\t\t} finally {\n\t\t\tis.close();\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "8ab90c54876e0577e1454c425fd77360d1d02109",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "modified",
            additions: 197,
            deletions: 123,
            patch:
              '@@ -2,129 +2,203 @@\n \n import org.jgrapht.graph.DirectedMultigraph;\n import org.jgrapht.traverse.BreadthFirstIterator;\n-import java.util.List;\n-import java.util.ArrayList;\n+\n+import java.util.*;\n \n public class ShinglesUtil {\n-    private ShinglesStrategy shinglesStrategy;\n-\n-    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n-\n-    private DirectedMultigraph<Node, Edge> newVersionGraph;\n-\n-    private List<Node[]> similarMethods;\n-\n-    private List<Node> oldVersionPackageList;\n-    private List<Node> oldVersionClassList;\n-    private List<Node> oldVersionMethodList;\n-    private List<Node> oldVersionFieldList;\n-\n-    private List<Node> newVersionPackageList;\n-    private List<Node> newVersionClassList;\n-    private List<Node> newVersionMethodList;\n-    private List<Node> newVersionFieldList;\n-\n-    private double methodThreshold;\n-\n-    public ShinglesUtil() {\n-        this.shinglesStrategy = new FactorOf2Strategy();\n-    }\n-\n-    public int[] computeMethodShingles(String str) {\n-        return null;\n-    }\n-\n-    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n-        this.oldVersionGraph = oldVersionGraph;\n-        this.newVersionGraph = newVersionGraph;\n-\n-        this.oldVersionPackageList = new ArrayList<>();\n-        this.oldVersionClassList = new ArrayList<>();\n-        this.oldVersionMethodList = new ArrayList<>();\n-        this.oldVersionFieldList = new ArrayList<>();\n-\n-        this.newVersionPackageList = new ArrayList<>();\n-        this.newVersionClassList = new ArrayList<>();\n-        this.newVersionMethodList = new ArrayList<>();\n-        this.newVersionFieldList = new ArrayList<>();\n-\n-        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n-                oldVersionPackageList, oldVersionFieldList);\n-\n-        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n-    }\n-\n-    /**\n-     * For the passed graph, fills the respective arrays for packages, classes,\n-     * methods and fields by using a breadth first iterator.\n-     *\n-     * @param graph\n-     * @param methods\n-     * @param classes\n-     * @param packages\n-     * @param fields\n-     */\n-    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n-                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n-        // Create a BreadthFirstIterator for the graph\n-        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n-        while (bfi.hasNext()) {\n-            Node n = bfi.next();\n-            if (n.getType().equals(Node.Type.CLASS)) {\n-                classes.add(n);\n-            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n-                packages.add(n);\n-            } else if (n.getType().equals(Node.Type.METHOD)) {\n-                methods.add(n);\n-            } else if (n.getType().equals(Node.Type.FIELD)) {\n-                fields.add(n);\n-            }\n-        }\n-    }\n-\n-    public List<Node[]> findSimilarMethods() {\n-        if (this.similarMethods.isEmpty()) {\n-            List<Node[]> similarMethods = new ArrayList<>();\n-            for (Node m : this.oldVersionMethodList) {\n-                if (!m.isAPI())\n-                    continue;\n-\n-                for (Node m2 : this.newVersionMethodList) {\n-                    if (!m2.isAPI())\n-                        continue;\n-\n-                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n-                        Node[] arr = {m, m2};\n-                        // if (!isThisArrayInTheList(simMet, arr))\n-                        similarMethods.add(arr);\n-                    }\n-                }\n-            }\n-            this.similarMethods = similarMethods;\n-        }\n-        return this.similarMethods;\n-    }\n-\n-    public double howMuchAlike(int[] arr1, int[] arr2) {\n-        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n-        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n-        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n-        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n-        return finalGrade;\n-    }\n-\n-    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n-        int[] tempArr = (int[]) arr2.clone();\n-        double grade = 0.0;\n-        for (int value : arr1) {\n-            for (int j = 0; j < tempArr.length; j++) {\n-                if (value == tempArr[j]) {\n-                    grade += 1.0 / arr1.length;\n-                    tempArr[j] = Integer.MIN_VALUE;\n-                    break;\n-                }\n-            }\n-        }\n-        return grade;\n-    }\n+\n+\tprivate int w = 3;\n+\tprivate int sMethod = 8;\n+\n+\tprivate ShinglesStrategy shinglesStrategy;\n+\n+\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\n+\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n+\n+\tprivate List<Node[]> similarMethods;\n+\n+\tprivate List<Node> oldVersionPackageList;\n+\tprivate List<Node> oldVersionClassList;\n+\tprivate List<Node> oldVersionMethodList;\n+\tprivate List<Node> oldVersionFieldList;\n+\n+\tprivate List<Node> newVersionPackageList;\n+\tprivate List<Node> newVersionClassList;\n+\tprivate List<Node> newVersionMethodList;\n+\tprivate List<Node> newVersionFieldList;\n+\n+\tprivate double methodThreshold;\n+\n+\tpublic ShinglesUtil() {\n+\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n+\t}\n+\n+\tpublic List<String> tokenizer(String s) {\n+\t\tList<String> list = new ArrayList<>();\n+\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n+\t\twhile (st.hasMoreElements()) {\n+\t\t\tlist.add(st.nextToken());\n+\t\t}\n+\t\treturn list;\n+\t}\n+\n+\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n+\n+\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n+\t\tListIterator<String> iter = tokenList.listIterator();\n+\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n+\t\t// W=2, iterIndex = size - W identifies the last window\n+\t\t{\n+\t\t\tList<String> tempList = new ArrayList<>();\n+\t\t\tfor (int i = 1; i <= w; i++) // W=3\n+\t\t\t{\n+\t\t\t\ttempList.add(iter.next());\n+\t\t\t}\n+\t\t\tbagOfTokensList.add(tempList);\n+\t\t\tfor (int i = 1; i <= w - 1; i++)\n+\t\t\t\t// i<= W-1\n+\t\t\t\titer.previous();\n+\t\t}\n+\t\treturn bagOfTokensList;\n+\t}\n+\n+\tprivate int findNumberOfLines(String str) {\n+\t\tint retval = 0;\n+\t\tchar[] c = str.toCharArray();\n+\t\tfor (char value : c) {\n+\t\t\tif (value == \'\\n\')\n+\t\t\t\tretval++;\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\tpublic int[] computeMethodShingles(String str) {\n+\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n+\t}\n+\n+\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n+\t\t/*\n+\t\t * We are now introducing the idea of finding the number of lines in the\n+\t\t * method, and incorporate that into the calculation of shingles, so\n+\t\t * that, if there are more lines, then there are going to be more\n+\t\t * shingles associated with the method. However, a 1-1 correspondance\n+\t\t * will be misleading, thus another method is required.\n+\t\t */\n+\t\tBloomFilter bloomFilter = new BloomFilter();\n+\t\tList<String> tokenList = tokenizer(str);\n+\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n+\n+\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n+\t\tint numberOfWindowedTokens = 0;\n+\n+\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n+\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n+\t\t\tfor (int i = 0; i < window; i++) {\n+\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n+\t\t\t\tif (i != window - 1)\n+\t\t\t\t\ttokensInOneWindow.append(" ");\n+\t\t\t}\n+\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n+\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n+\t\t\tnumberOfWindowedTokens++;\n+\t\t}\n+\n+\t\tArrays.sort(shinglesValues);\n+\n+\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n+\t\t\tnumberOfWindowedTokens);\n+\n+\t\tint[] retVal = new int[correctNumberOfShingles];\n+\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n+\t\treturn retVal;\n+\t}\n+\n+\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n+\t\tthis.oldVersionGraph = oldVersionGraph;\n+\t\tthis.newVersionGraph = newVersionGraph;\n+\n+\t\tthis.similarMethods = new LinkedList<>();\n+\n+\t\tthis.oldVersionPackageList = new ArrayList<>();\n+\t\tthis.oldVersionClassList = new ArrayList<>();\n+\t\tthis.oldVersionMethodList = new ArrayList<>();\n+\t\tthis.oldVersionFieldList = new ArrayList<>();\n+\n+\t\tthis.newVersionPackageList = new ArrayList<>();\n+\t\tthis.newVersionClassList = new ArrayList<>();\n+\t\tthis.newVersionMethodList = new ArrayList<>();\n+\t\tthis.newVersionFieldList = new ArrayList<>();\n+\n+\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n+\t\t\toldVersionPackageList, oldVersionFieldList);\n+\n+\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n+\n+\t\tSystem.out.println("fuck you");\n+\t}\n+\n+\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n+\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n+\t\t// Create a BreadthFirstIterator for the graph\n+\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+\t\twhile (bfi.hasNext()) {\n+\t\t\tNode n = bfi.next();\n+\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n+\t\t\t\tclasses.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n+\t\t\t\tpackages.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n+\t\t\t\tmethods.add(n);\n+\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n+\t\t\t\tfields.add(n);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<Node[]> findSimilarMethods() {\n+\t\tif (this.similarMethods.isEmpty()) {\n+\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n+\t\t\tfor (Node m : this.oldVersionMethodList) {\n+\t\t\t\tif (!m.isAPI())\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n+\t\t\t\t\tif (!m2.isAPI())\n+\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+\t\t\t\t\t\tNode[] arr = {m, m2};\n+\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n+\t\t\t\t\t\tsimilarMethods.add(arr);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.similarMethods = similarMethods;\n+\t\t}\n+\t\treturn this.similarMethods;\n+\t}\n+\n+\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n+\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+\t\treturn finalGrade;\n+\t}\n+\n+\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+\t\tint[] tempArr = arr2.clone();\n+\t\tdouble grade = 0.0;\n+\t\tfor (int value : arr1) {\n+\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n+\t\t\t\tif (value == tempArr[j]) {\n+\t\t\t\t\tgrade += 1.0 / arr1.length;\n+\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn grade;\n+\t}\n }',
            rawContent:
              'package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\n\nimport java.util.*;\n\npublic class ShinglesUtil {\n\n\tprivate int w = 3;\n\tprivate int sMethod = 8;\n\n\tprivate ShinglesStrategy shinglesStrategy;\n\n\tprivate DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n\tprivate DirectedMultigraph<Node, Edge> newVersionGraph;\n\n\tprivate List<Node[]> similarMethods;\n\n\tprivate List<Node> oldVersionPackageList;\n\tprivate List<Node> oldVersionClassList;\n\tprivate List<Node> oldVersionMethodList;\n\tprivate List<Node> oldVersionFieldList;\n\n\tprivate List<Node> newVersionPackageList;\n\tprivate List<Node> newVersionClassList;\n\tprivate List<Node> newVersionMethodList;\n\tprivate List<Node> newVersionFieldList;\n\n\tprivate double methodThreshold;\n\n\tpublic ShinglesUtil() {\n\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n\t}\n\n\tpublic List<String> tokenizer(String s) {\n\t\tList<String> list = new ArrayList<>();\n\t\tStringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tlist.add(st.nextToken());\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n\t\tList<List<String>> bagOfTokensList = new ArrayList<>();\n\t\tListIterator<String> iter = tokenList.listIterator();\n\t\twhile (iter.nextIndex() <= (tokenList.size() - w))\n\t\t// W=2, iterIndex = size - W identifies the last window\n\t\t{\n\t\t\tList<String> tempList = new ArrayList<>();\n\t\t\tfor (int i = 1; i <= w; i++) // W=3\n\t\t\t{\n\t\t\t\ttempList.add(iter.next());\n\t\t\t}\n\t\t\tbagOfTokensList.add(tempList);\n\t\t\tfor (int i = 1; i <= w - 1; i++)\n\t\t\t\t// i<= W-1\n\t\t\t\titer.previous();\n\t\t}\n\t\treturn bagOfTokensList;\n\t}\n\n\tprivate int findNumberOfLines(String str) {\n\t\tint retval = 0;\n\t\tchar[] c = str.toCharArray();\n\t\tfor (char value : c) {\n\t\t\tif (value == \'\\n\')\n\t\t\t\tretval++;\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic int[] computeMethodShingles(String str) {\n\t\treturn computeMethodShingles(str, w, this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n\t}\n\n\tpublic int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n\t\t/*\n\t\t * We are now introducing the idea of finding the number of lines in the\n\t\t * method, and incorporate that into the calculation of shingles, so\n\t\t * that, if there are more lines, then there are going to be more\n\t\t * shingles associated with the method. However, a 1-1 correspondance\n\t\t * will be misleading, thus another method is required.\n\t\t */\n\t\tBloomFilter bloomFilter = new BloomFilter();\n\t\tList<String> tokenList = tokenizer(str);\n\t\tList<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n\t\tint[] shinglesValues = new int[bagOfWindowedTokens.size()];\n\t\tint numberOfWindowedTokens = 0;\n\n\t\tfor (List<String> tempList : bagOfWindowedTokens) {\n\t\t\tStringBuilder tokensInOneWindow = new StringBuilder();\n\t\t\tfor (int i = 0; i < window; i++) {\n\t\t\t\ttokensInOneWindow.append(tempList.get(i));\n\t\t\t\tif (i != window - 1)\n\t\t\t\t\ttokensInOneWindow.append(" ");\n\t\t\t}\n\t\t\tint shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n\t\t\tshinglesValues[numberOfWindowedTokens] = shingle;\n\t\t\tnumberOfWindowedTokens++;\n\t\t}\n\n\t\tArrays.sort(shinglesValues);\n\n\t\tint correctNumberOfShingles = Math.min(upperBoundLimit,\n\t\t\tnumberOfWindowedTokens);\n\n\t\tint[] retVal = new int[correctNumberOfShingles];\n\t\tSystem.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n\t\treturn retVal;\n\t}\n\n\tpublic void initialize(NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n\t\tthis.oldVersionGraph = oldVersionGraph;\n\t\tthis.newVersionGraph = newVersionGraph;\n\n\t\tthis.similarMethods = new LinkedList<>();\n\n\t\tthis.oldVersionPackageList = new ArrayList<>();\n\t\tthis.oldVersionClassList = new ArrayList<>();\n\t\tthis.oldVersionMethodList = new ArrayList<>();\n\t\tthis.oldVersionFieldList = new ArrayList<>();\n\n\t\tthis.newVersionPackageList = new ArrayList<>();\n\t\tthis.newVersionClassList = new ArrayList<>();\n\t\tthis.newVersionMethodList = new ArrayList<>();\n\t\tthis.newVersionFieldList = new ArrayList<>();\n\n\t\tinitializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n\t\t\toldVersionPackageList, oldVersionFieldList);\n\n\t\tinitializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n\n\t\tSystem.out.println("fuck you");\n\t}\n\n\tprivate void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n\t                                     List<Node> classes, List<Node> packages, List<Node> fields) {\n\t\t// Create a BreadthFirstIterator for the graph\n\t\tBreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n\t\twhile (bfi.hasNext()) {\n\t\t\tNode n = bfi.next();\n\t\t\tif (n.getType().equals(Node.Type.CLASS)) {\n\t\t\t\tclasses.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.PACKAGE)) {\n\t\t\t\tpackages.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.METHOD)) {\n\t\t\t\tmethods.add(n);\n\t\t\t} else if (n.getType().equals(Node.Type.FIELD)) {\n\t\t\t\tfields.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<Node[]> findSimilarMethods() {\n\t\tif (this.similarMethods.isEmpty()) {\n\t\t\tList<Node[]> similarMethods = new ArrayList<>();\n\t\t\tfor (Node m : this.oldVersionMethodList) {\n\t\t\t\tif (!m.isAPI())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (Node m2 : this.newVersionMethodList) {\n\t\t\t\t\tif (!m2.isAPI())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n\t\t\t\t\t\tNode[] arr = {m, m2};\n\t\t\t\t\t\t// if (!isThisArrayInTheList(simMet, arr))\n\t\t\t\t\t\tsimilarMethods.add(arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.similarMethods = similarMethods;\n\t\t}\n\t\treturn this.similarMethods;\n\t}\n\n\tpublic double howMuchAlike(int[] arr1, int[] arr2) {\n\t\tdouble finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n\t\tsimilarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n\t\tsimilarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n\t\tfinalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n\t\treturn finalGrade;\n\t}\n\n\tprivate double howMuchIs1Like2(int[] arr1, int[] arr2) {\n\t\tint[] tempArr = arr2.clone();\n\t\tdouble grade = 0.0;\n\t\tfor (int value : arr1) {\n\t\t\tfor (int j = 0; j < tempArr.length; j++) {\n\t\t\t\tif (value == tempArr[j]) {\n\t\t\t\t\tgrade += 1.0 / arr1.length;\n\t\t\t\t\ttempArr[j] = Integer.MIN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn grade;\n\t}\n}\n'
          },
          {
            sha: "d024c32869d45a2dd958ab6752d813ea8db10d88",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "modified",
            additions: 189,
            deletions: 104,
            patch:
              '@@ -1,10 +1,15 @@\n package refactoring.crawler.util;\n \n import java.util.List;\n+import java.util.Optional;\n import java.util.stream.Collectors;\n \n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.FieldDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n import lombok.Getter;\n import lombok.NonNull;\n import lombok.val;\n@@ -45,121 +50,201 @@ public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n \tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n \t\tthis.projectName = projectName;\n \t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n-\t\tval packages = compilationUnits.stream()\n-\t\t\t.map(CompilationUnit::getPackageDeclaration)\n-\t\t\t.filter(p -> !p.isPresent())\n-\t\t\t.collect(Collectors.toList());\n-//        this.graph.addVertex(projectNode);\n \t\tthis.graph.addNamedVertex(projectNode);\n-\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n-\t}\n+\t\tcompilationUnits.forEach(cu -> {\n+\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n+\t\t\tif (packageDeclaration.isPresent()) {\n+\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n+\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n+\t\t\t\tpackageNode.setProjectName(projectName);\n+\t\t\t\tthis.graph.addNamedVertex(packageNode);\n+\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+\t\t\t\tcu.getTypes().forEach(type -> {\n+\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n+\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n+\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n+\t\t\t\t\t\tif (className.isPresent()) {\n+\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n+\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n+\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n+\t\t\t\t\t\t\tthis.allClassCounter += 1;\n+\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n+\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n+\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n+\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n \n-\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n-\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n-\t\tchildrenPackages.forEach(childrenPackage -> {\n-\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n-\t\t\tpackageNode.setProjectName(this.projectName);\n-//            graph.addVertex(packageNode);\n-\t\t\tgraph.addNamedVertex(packageNode);\n-//            graph.addEdge(projectNode, packageNode);\n-\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n-\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n-\t\t\tthis.packageCounter += 1;\n-\t\t});\n-\t}\n+\t\t\t\t\t\t\t// fields\n+\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n+\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n+\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n+\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n+\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n+\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n+\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t\t\t\t\t\t});\n \n-\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n-\t\tval classes = pckg.getClasses();\n-\t\tclasses.forEach(clz -> {\n-\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n-\t\t\tclassNode.setProjectName(this.projectName);\n-\t\t\tclassNode.setFlags(clz.getFlags());\n-//            graph.addVertex(classNode);\n-//            graph.addEdge(packageNode, classNode);\n-\t\t\tgraph.addNamedVertex(classNode);\n-\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n-\t\t\tthis.browseClass(clz, classNode);\n-\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n-\t\t\tclassNode.setInterface(clz.getIsInterface());\n-\t\t\tthis.allClassCounter += 1;\n-\t\t\tif (clz.isProtected() || clz.isPublic()) {\n-\t\t\t\tclassNode.setAPI(true);\n-\t\t\t\tthis.apiClassCounter += 1;\n-\t\t\t}\n-\t\t});\n-\t}\n+\t\t\t\t\t\t\t// methods\n+\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n \n-\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n-\t\tval methods = clz.getMethods();\n-\t\tbrowseMethods(methods, classNode);\n-\t\tval fields = clz.getFields();\n-\t\tbrowseFields(fields, classNode);\n-\t}\n+\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n+\t\t\t\t\t\t\t\tString statementBody = "";\n+\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n+\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n+\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n+\t\t\t\t\t\t\t\t\t} else\n+\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n+\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n+\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n \n-\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n-\t\tmethods.forEach(method -> {\n-\t\t\tString statementBody = "";\n-\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n-\t\t\t\tstatementBody = method.getSource().trim();\n-\t\t\t} else\n-\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n-\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n-\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n-\t\t\t\t+ method.getElementName();\n-\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n-\n-\t\t\tallMethodsCounter += 1;\n-\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n-\t\t\t\tmethodNode.setAPI(true);\n-\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n+\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n+\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n+\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n+\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n+\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n+//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n+\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n+\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n+\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n \t\t\t}\n-\t\t\tif (method.getIsDeprecated())\n-\t\t\t\tmethodNode.setDeprecated(true);\n-\t\t\tmethodNode.setProjectName(projectName);\n-\t\t\tmethodNode.setShingles(shingles);\n-\t\t\tmethodNode.setFlags(method.getFlags());\n-\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n-//            graph.addVertex(methodNode);\n-//            graph.addEdge(classNode, methodNode);\n-\t\t\tgraph.addNamedVertex(methodNode);\n-\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n-\t\t});\n-\t}\n \n+\t\t});\n \n-\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n-\t\tStringBuilder buffer = new StringBuilder();\n+//\t\tval packages = compilationUnits.stream()\n+//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+//\t\t\t.filter(Optional::isPresent)\n+//\t\t\t.collect(Collectors.toList());\n+////        this.graph.addVertex(projectNode);\n+//\t\tthis.graph.addNamedVertex(projectNode);\n+//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n+\t}\n \n-\t\tbuffer.append(\'(\');\n+//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n+//\t\tval childrenPackages = iPackage.getChildrenPackages();\n+//\t\tchildrenPackages.forEach(childrenPackage -> {\n+//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n+//\t\t\tpackageNode.setProjectName(this.projectName);\n+////            graph.addVertex(packageNode);\n+//\t\t\tgraph.addNamedVertex(packageNode);\n+////            graph.addEdge(projectNode, packageNode);\n+//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+//\t\t\tthis.packageCounter += 1;\n+//\t\t});\n+//\t}\n \n-\t\tString[] types = method.getParameterTypes();\n-\t\tfor (int i = 0; i < types.length; i++) {\n-\t\t\tif (i > 0)\n-\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n-\t\t\tString typeSig = Signature.toString(types[i]);\n-\t\t\tbuffer.append(typeSig);\n-\t\t}\n-\t\tbuffer.append(\')\');\n+//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+//\t\tval classes = pckg.getClasses();\n+//\t\tclasses.forEach(clz -> {\n+//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+//\t\t\tclassNode.setProjectName(this.projectName);\n+//\t\t\tclassNode.setFlags(clz.getFlags());\n+////            graph.addVertex(classNode);\n+////            graph.addEdge(packageNode, classNode);\n+//\t\t\tgraph.addNamedVertex(classNode);\n+//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+//\t\t\tthis.browseClass(clz, classNode);\n+//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+//\t\t\tclassNode.setInterface(clz.getIsInterface());\n+//\t\t\tthis.allClassCounter += 1;\n+//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+//\t\t\t\tclassNode.setAPI(true);\n+//\t\t\t\tthis.apiClassCounter += 1;\n+//\t\t\t}\n+//\t\t});\n+//\t}\n \n-\t\treturn buffer.toString();\n-\t}\n-\n-\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n-\t\tfields.forEach(field -> {\n-\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n-\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n-\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n-\t\t\tfieldNode.setProjectName(this.projectName);\n-\t\t\tfieldNode.setShingles(shingles);\n-\t\t\tfieldNode.setFlags(field.getFlags());\n-\t\t\tfieldNode.setSignature(field.getTypeSignature());\n-\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n-//            graph.addVertex(fieldNode);\n-//            graph.addEdge(classNode, fieldNode);\n-\t\t\tgraph.addNamedVertex(fieldNode);\n-\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n-\t\t});\n-\t}\n+//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+//\t\tval methods = clz.getMethods();\n+//\t\tbrowseMethods(methods, classNode);\n+//\t\tval fields = clz.getFields();\n+//\t\tbrowseFields(fields, classNode);\n+//\t}\n+//\n+//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+//\t\tmethods.forEach(method -> {\n+//\t\t\tString statementBody = "";\n+//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+//\t\t\t\tstatementBody = method.getSource().trim();\n+//\t\t\t} else\n+//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+//\t\t\t\t+ method.getElementName();\n+//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+//\n+//\t\t\tallMethodsCounter += 1;\n+//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+//\t\t\t\tmethodNode.setAPI(true);\n+//\t\t\t\tthis.apiMethodCounter += 1;\n+//\t\t\t}\n+//\t\t\tif (method.getIsDeprecated())\n+//\t\t\t\tmethodNode.setDeprecated(true);\n+//\t\t\tmethodNode.setProjectName(projectName);\n+//\t\t\tmethodNode.setShingles(shingles);\n+//\t\t\tmethodNode.setFlags(method.getFlags());\n+//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+////            graph.addVertex(methodNode);\n+////            graph.addEdge(classNode, methodNode);\n+//\t\t\tgraph.addNamedVertex(methodNode);\n+//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+//\t\t});\n+//\t}\n+//\n+//\n+//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+//\t\tStringBuilder buffer = new StringBuilder();\n+//\n+//\t\tbuffer.append(\'(\');\n+//\n+//\t\tString[] types = method.getParameterTypes();\n+//\t\tfor (int i = 0; i < types.length; i++) {\n+//\t\t\tif (i > 0)\n+//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+//\t\t\tString typeSig = Signature.toString(types[i]);\n+//\t\t\tbuffer.append(typeSig);\n+//\t\t}\n+//\t\tbuffer.append(\')\');\n+//\n+//\t\treturn buffer.toString();\n+//\t}\n+//\n+//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+//\t\tfields.forEach(field -> {\n+//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+//\t\t\tfieldNode.setProjectName(this.projectName);\n+//\t\t\tfieldNode.setShingles(shingles);\n+//\t\t\tfieldNode.setFlags(field.getFlags());\n+//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+////            graph.addVertex(fieldNode);\n+////            graph.addEdge(classNode, fieldNode);\n+//\t\t\tgraph.addNamedVertex(fieldNode);\n+//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+//\t\t});\n+//\t}\n+//\n \n \t/**\n \t * This prunes away the javadoc comments',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tcompilationUnits.forEach(cu -> {\n\t\t\tval packageDeclaration = cu.getPackageDeclaration();\n\t\t\tif (packageDeclaration.isPresent()) {\n\t\t\t\tval packageName = packageDeclaration.get().getNameAsString();\n\t\t\t\tval packageNode = new Node(packageName, Node.Type.PACKAGE);\n\t\t\t\tpackageNode.setProjectName(projectName);\n\t\t\t\tthis.graph.addNamedVertex(packageNode);\n\t\t\t\tthis.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\t\tcu.getTypes().forEach(type -> {\n\t\t\t\t\tif (type.isClassOrInterfaceDeclaration()) {\n\t\t\t\t\t\tval classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n\t\t\t\t\t\tval className = classOrInterfaceDeclaration.getFullyQualifiedName();\n\t\t\t\t\t\tif (className.isPresent()) {\n\t\t\t\t\t\t\tval classNode = new Node(className.get(), Node.Type.CLASS);\n\t\t\t\t\t\t\tclassNode.setProjectName(projectName);\n\t\t\t\t\t\t\tclassNode.setDeprecated(classOrInterfaceDeclaration.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\tclassNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\t\t\t\t\t\t\tthis.allClassCounter += 1;\n\t\t\t\t\t\t\tif (classOrInterfaceDeclaration.isProtected() || classOrInterfaceDeclaration.isPublic()) {\n\t\t\t\t\t\t\t\tclassNode.setAPI(true);\n\t\t\t\t\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgraph.addNamedVertex(classNode);\n\t\t\t\t\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n\t\t\t\t\t\t\t// fields\n\t\t\t\t\t\t\tList<FieldDeclaration> fieldDeclarations = classOrInterfaceDeclaration.getFields();\n\t\t\t\t\t\t\tfieldDeclarations.forEach(field -> {\n\t\t\t\t\t\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getVariables().toString());\n\t\t\t\t\t\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getVariables().toString();\n\t\t\t\t\t\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\t\t\t\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\t\t\t\t\t\tfieldNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\t\t\t\t\t\tfieldNode.setSignature(field.getCommonType().asString());\n\t\t\t\t\t\t\t\tfieldNode.setDeprecated(field.getAnnotationByClass(Deprecated.class).isPresent());\n\t\t\t\t\t\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\t\t\t\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// methods\n\t\t\t\t\t\t\tList<MethodDeclaration> methodDeclarations = classOrInterfaceDeclaration.getMethods();\n\n\t\t\t\t\t\t\tmethodDeclarations.forEach(method -> {\n\t\t\t\t\t\t\t\tString statementBody = "";\n\t\t\t\t\t\t\t\tval methodBody = method.getBody();\n\t\t\t\t\t\t\t\tif (methodBody.isPresent()) {\n\t\t\t\t\t\t\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\t\t\t\t\t\t\tstatementBody = methodBody.get().toString().trim();\n\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\tstatementBody = statementBody(methodBody.get().toString()).trim();\n\t\t\t\t\t\t\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\t\t\t\t\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t\t\t\t\t\t\t+ method.getNameAsString();\n\t\t\t\t\t\t\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n\n\t\t\t\t\t\t\t\t\tallMethodsCounter += 1;\n\t\t\t\t\t\t\t\t\tif (method.isPublic() || method.isProtected()) {\n\t\t\t\t\t\t\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\t\t\t\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (method.getAnnotationByClass(Deprecated.class).isPresent())\n\t\t\t\t\t\t\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\t\t\t\t\t\t\tmethodNode.setProjectName(projectName);\n\t\t\t\t\t\t\t\t\tmethodNode.setShingles(shingles);\n//\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\t\t\t\t\t\t\tmethodNode.setSignature(method.getSignature().toString());\n\t\t\t\t\t\t\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\t\t\t\t\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n//\t\tval packages = compilationUnits.stream()\n//\t\t\t.map(CompilationUnit::getPackageDeclaration)\n//\t\t\t.filter(Optional::isPresent)\n//\t\t\t.collect(Collectors.toList());\n////        this.graph.addVertex(projectNode);\n//\t\tthis.graph.addNamedVertex(projectNode);\n//\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n\t}\n\n//\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n//\t\tval childrenPackages = iPackage.getChildrenPackages();\n//\t\tchildrenPackages.forEach(childrenPackage -> {\n//\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n//\t\t\tpackageNode.setProjectName(this.projectName);\n////            graph.addVertex(packageNode);\n//\t\t\tgraph.addNamedVertex(packageNode);\n////            graph.addEdge(projectNode, packageNode);\n//\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n//\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n//\t\t\tthis.packageCounter += 1;\n//\t\t});\n//\t}\n\n//\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n//\t\tval classes = pckg.getClasses();\n//\t\tclasses.forEach(clz -> {\n//\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n//\t\t\tclassNode.setProjectName(this.projectName);\n//\t\t\tclassNode.setFlags(clz.getFlags());\n////            graph.addVertex(classNode);\n////            graph.addEdge(packageNode, classNode);\n//\t\t\tgraph.addNamedVertex(classNode);\n//\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n//\t\t\tthis.browseClass(clz, classNode);\n//\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n//\t\t\tclassNode.setInterface(clz.getIsInterface());\n//\t\t\tthis.allClassCounter += 1;\n//\t\t\tif (clz.isProtected() || clz.isPublic()) {\n//\t\t\t\tclassNode.setAPI(true);\n//\t\t\t\tthis.apiClassCounter += 1;\n//\t\t\t}\n//\t\t});\n//\t}\n\n//\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n//\t\tval methods = clz.getMethods();\n//\t\tbrowseMethods(methods, classNode);\n//\t\tval fields = clz.getFields();\n//\t\tbrowseFields(fields, classNode);\n//\t}\n//\n//\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n//\t\tmethods.forEach(method -> {\n//\t\t\tString statementBody = "";\n//\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n//\t\t\t\tstatementBody = method.getSource().trim();\n//\t\t\t} else\n//\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n//\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n//\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n//\t\t\t\t+ method.getElementName();\n//\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n//\n//\t\t\tallMethodsCounter += 1;\n//\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n//\t\t\t\tmethodNode.setAPI(true);\n//\t\t\t\tthis.apiMethodCounter += 1;\n//\t\t\t}\n//\t\t\tif (method.getIsDeprecated())\n//\t\t\t\tmethodNode.setDeprecated(true);\n//\t\t\tmethodNode.setProjectName(projectName);\n//\t\t\tmethodNode.setShingles(shingles);\n//\t\t\tmethodNode.setFlags(method.getFlags());\n//\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n////            graph.addVertex(methodNode);\n////            graph.addEdge(classNode, methodNode);\n//\t\t\tgraph.addNamedVertex(methodNode);\n//\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n//\t\t});\n//\t}\n//\n//\n//\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n//\t\tStringBuilder buffer = new StringBuilder();\n//\n//\t\tbuffer.append(\'(\');\n//\n//\t\tString[] types = method.getParameterTypes();\n//\t\tfor (int i = 0; i < types.length; i++) {\n//\t\t\tif (i > 0)\n//\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n//\t\t\tString typeSig = Signature.toString(types[i]);\n//\t\t\tbuffer.append(typeSig);\n//\t\t}\n//\t\tbuffer.append(\')\');\n//\n//\t\treturn buffer.toString();\n//\t}\n//\n//\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n//\t\tfields.forEach(field -> {\n//\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n//\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n//\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n//\t\t\tfieldNode.setProjectName(this.projectName);\n//\t\t\tfieldNode.setShingles(shingles);\n//\t\t\tfieldNode.setFlags(field.getFlags());\n//\t\t\tfieldNode.setSignature(field.getTypeSignature());\n//\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n////            graph.addVertex(fieldNode);\n////            graph.addEdge(classNode, fieldNode);\n//\t\t\tgraph.addNamedVertex(fieldNode);\n//\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n//\t\t});\n//\t}\n//\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          }
        ]
      },
      {
        sha: "c82267764fe895754822d57203483cc54cd44f7d",
        message: "Initial commit",
        stats: {
          total: 2580,
          additions: 2580,
          deletions: 0
        },
        author: {
          id: "Patrick Lai"
        },
        committer: {
          id: "Patrick Lai"
        },
        parents: [],
        committedAt: 1585100843000,
        changedFiles: [
          {
            sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
            filename: ".gitattributes",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# Auto detect text files and perform LF normalization\n+* text=auto",
            rawContent:
              "# Auto detect text files and perform LF normalization\n* text=auto\n"
          },
          {
            sha: "a1fc39c070f4f8ba52f278c15cd4d2121d07c8a8",
            filename: ".gitignore",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+.gradle\n+/build/\n+\n+# Ignore Gradle GUI config\n+gradle-app.setting\n+\n+# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n+!gradle-wrapper.jar\n+\n+# Cache of project\n+.gradletasknamecache\n+\n+# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n+# gradle/wrapper/gradle-wrapper.properties",
            rawContent:
              ".gradle\n/build/\n\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n"
          },
          {
            sha: "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d",
            filename: ".idea/compiler.xml",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              '@@ -0,0 +1,14 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="CompilerConfiguration">\n+    <annotationProcessing>\n+      <profile name="Gradle Imported" enabled="true">\n+        <outputRelativeToContentRoot value="true" />\n+        <processorPath useClasspath="false">\n+          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n+        </processorPath>\n+        <module name="refactoring-crawler.main" />\n+      </profile>\n+    </annotationProcessing>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="CompilerConfiguration">\n    <annotationProcessing>\n      <profile name="Gradle Imported" enabled="true">\n        <outputRelativeToContentRoot value="true" />\n        <processorPath useClasspath="false">\n          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n        </processorPath>\n        <module name="refactoring-crawler.main" />\n      </profile>\n    </annotationProcessing>\n  </component>\n</project>'
          },
          {
            sha: "a64b2758bd03a20260566a40b58c116679055c17",
            filename: ".idea/gradle.xml",
            status: "added",
            additions: 20,
            deletions: 0,
            patch:
              '@@ -0,0 +1,20 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="GradleMigrationSettings" migrationVersion="1" />\n+  <component name="GradleSettings">\n+    <option name="linkedExternalProjectsSettings">\n+      <GradleProjectSettings>\n+        <option name="distributionType" value="DEFAULT_WRAPPED" />\n+        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n+        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n+        <option name="gradleJvm" value="1.8" />\n+        <option name="modules">\n+          <set>\n+            <option value="$PROJECT_DIR$" />\n+          </set>\n+        </option>\n+        <option name="useQualifiedModuleNames" value="true" />\n+      </GradleProjectSettings>\n+    </option>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="GradleMigrationSettings" migrationVersion="1" />\n  <component name="GradleSettings">\n    <option name="linkedExternalProjectsSettings">\n      <GradleProjectSettings>\n        <option name="distributionType" value="DEFAULT_WRAPPED" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n        <option name="gradleJvm" value="1.8" />\n        <option name="modules">\n          <set>\n            <option value="$PROJECT_DIR$" />\n          </set>\n        </option>\n        <option name="useQualifiedModuleNames" value="true" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>'
          },
          {
            sha: "4fed64e0de33c78035aa4aa1eb052668eb85c6d4",
            filename: ".idea/jarRepositories.xml",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              '@@ -0,0 +1,30 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="RemoteRepositoriesConfiguration">\n+    <remote-repository>\n+      <option name="id" value="central" />\n+      <option name="name" value="Maven Central repository" />\n+      <option name="url" value="https://repo1.maven.org/maven2" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="jboss.community" />\n+      <option name="name" value="JBoss Community repository" />\n+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="BintrayJCenter" />\n+      <option name="name" value="BintrayJCenter" />\n+      <option name="url" value="https://jcenter.bintray.com/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="MavenRepo" />\n+      <option name="name" value="MavenRepo" />\n+      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n+    </remote-repository>\n+    <remote-repository>\n+      <option name="id" value="maven" />\n+      <option name="name" value="maven" />\n+      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n+    </remote-repository>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="RemoteRepositoriesConfiguration">\n    <remote-repository>\n      <option name="id" value="central" />\n      <option name="name" value="Maven Central repository" />\n      <option name="url" value="https://repo1.maven.org/maven2" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="jboss.community" />\n      <option name="name" value="JBoss Community repository" />\n      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="BintrayJCenter" />\n      <option name="name" value="BintrayJCenter" />\n      <option name="url" value="https://jcenter.bintray.com/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="MavenRepo" />\n      <option name="name" value="MavenRepo" />\n      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="maven" />\n      <option name="name" value="maven" />\n      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n    </remote-repository>\n  </component>\n</project>'
          },
          {
            sha: "b1662faf91f158c3fc95e7f294260c2ea0cdbc12",
            filename: ".idea/misc.xml",
            status: "added",
            additions: 5,
            deletions: 0,
            patch:
              '@@ -0,0 +1,5 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="ExternalStorageConfigurationManager" enabled="true" />\n+  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ExternalStorageConfigurationManager" enabled="true" />\n  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n</project>'
          },
          {
            sha: "e96534fb27b68192f27f985d3879e173ec77adb8",
            filename: ".idea/uiDesigner.xml",
            status: "added",
            additions: 124,
            deletions: 0,
            patch:
              '@@ -0,0 +1,124 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="Palette2">\n+    <group name="Swing">\n+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n+      </item>\n+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n+      </item>\n+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n+        <initial-values>\n+          <property name="text" value="Button" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="RadioButton" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="CheckBox" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n+        <initial-values>\n+          <property name="text" value="Label" />\n+        </initial-values>\n+      </item>\n+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n+          <preferred-size width="150" height="-1" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n+          <preferred-size width="150" height="50" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n+          <preferred-size width="200" height="200" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n+          <preferred-size width="200" height="200" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n+      </item>\n+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n+      </item>\n+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n+      </item>\n+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n+          <preferred-size width="-1" height="20" />\n+        </default-constraints>\n+      </item>\n+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n+      </item>\n+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n+      </item>\n+    </group>\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="Palette2">\n    <group name="Swing">\n      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n      </item>\n      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n        <initial-values>\n          <property name="text" value="Button" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="RadioButton" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="CheckBox" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="Label" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n          <preferred-size width="-1" height="20" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n      </item>\n    </group>\n  </component>\n</project>'
          },
          {
            sha: "0f5826ff690d76f8961058a4fd1cf25f380882c3",
            filename: ".idea/workspace.xml",
            status: "added",
            additions: 143,
            deletions: 0,
            patch:
              '@@ -0,0 +1,143 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project version="4">\n+  <component name="ChangeListManager">\n+    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n+    <option name="SHOW_DIALOG" value="false" />\n+    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n+    <option name="LAST_RESOLUTION" value="IGNORE" />\n+  </component>\n+  <component name="ExternalProjectsData">\n+    <projectState path="$PROJECT_DIR$">\n+      <ProjectState />\n+    </projectState>\n+  </component>\n+  <component name="ExternalProjectsManager">\n+    <system id="GRADLE">\n+      <state>\n+        <projects_view />\n+      </state>\n+    </system>\n+  </component>\n+  <component name="FileTemplateManagerImpl">\n+    <option name="RECENT_TEMPLATES">\n+      <list>\n+        <option value="Interface" />\n+        <option value="Class" />\n+      </list>\n+    </option>\n+  </component>\n+  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n+  <component name="ProjectViewState">\n+    <option name="hideEmptyMiddlePackages" value="true" />\n+    <option name="showExcludedFiles" value="true" />\n+    <option name="showLibraryContents" value="true" />\n+  </component>\n+  <component name="PropertiesComponent">\n+    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n+    <property name="WebServerToolWindowFactoryState" value="false" />\n+    <property name="aspect.path.notification.shown" value="true" />\n+    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n+    <property name="show.unlinked.gradle.project.popup" value="true" />\n+  </component>\n+  <component name="RunManager" selected="Application.RefactoringCrawler">\n+    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n+      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n+      <module name="refactoring-crawler.main" />\n+      <extension name="coverage">\n+        <pattern>\n+          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n+          <option name="ENABLED" value="true" />\n+        </pattern>\n+      </extension>\n+      <method v="2">\n+        <option name="Make" enabled="true" />\n+      </method>\n+    </configuration>\n+    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n+      <ExternalSystemSettings>\n+        <option name="executionName" />\n+        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n+        <option name="externalSystemIdString" value="GRADLE" />\n+        <option name="scriptParameters" />\n+        <option name="taskDescriptions">\n+          <list />\n+        </option>\n+        <option name="taskNames">\n+          <list>\n+            <option value="dependencies" />\n+          </list>\n+        </option>\n+        <option name="vmOptions" />\n+      </ExternalSystemSettings>\n+      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n+      <method v="2" />\n+    </configuration>\n+    <recent_temporary>\n+      <list>\n+        <item itemvalue="Application.RefactoringCrawler" />\n+        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n+      </list>\n+    </recent_temporary>\n+  </component>\n+  <component name="SvnConfiguration">\n+    <configuration />\n+  </component>\n+  <component name="TaskManager">\n+    <task active="true" id="Default" summary="Default task">\n+      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n+      <created>1584971244282</created>\n+      <option name="number" value="Default" />\n+      <option name="presentableId" value="Default" />\n+      <updated>1584971244282</updated>\n+      <workItem from="1584971249949" duration="21487000" />\n+      <workItem from="1585056855574" duration="4355000" />\n+    </task>\n+    <servers />\n+  </component>\n+  <component name="TypeScriptGeneratedFilesManager">\n+    <option name="version" value="1" />\n+  </component>\n+  <component name="WindowStateProjectService">\n+    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n+    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n+    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n+    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n+    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n+    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n+    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n+      <screen x="0" y="0" width="1440" height="900" />\n+    </state>\n+    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n+  </component>\n+</project>\n\\ No newline at end of file',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ChangeListManager">\n    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n    <option name="SHOW_DIALOG" value="false" />\n    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n    <option name="LAST_RESOLUTION" value="IGNORE" />\n  </component>\n  <component name="ExternalProjectsData">\n    <projectState path="$PROJECT_DIR$">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name="ExternalProjectsManager">\n    <system id="GRADLE">\n      <state>\n        <projects_view />\n      </state>\n    </system>\n  </component>\n  <component name="FileTemplateManagerImpl">\n    <option name="RECENT_TEMPLATES">\n      <list>\n        <option value="Interface" />\n        <option value="Class" />\n      </list>\n    </option>\n  </component>\n  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n  <component name="ProjectViewState">\n    <option name="hideEmptyMiddlePackages" value="true" />\n    <option name="showExcludedFiles" value="true" />\n    <option name="showLibraryContents" value="true" />\n  </component>\n  <component name="PropertiesComponent">\n    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n    <property name="WebServerToolWindowFactoryState" value="false" />\n    <property name="aspect.path.notification.shown" value="true" />\n    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n    <property name="show.unlinked.gradle.project.popup" value="true" />\n  </component>\n  <component name="RunManager" selected="Application.RefactoringCrawler">\n    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n      <module name="refactoring-crawler.main" />\n      <extension name="coverage">\n        <pattern>\n          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n          <option name="ENABLED" value="true" />\n        </pattern>\n      </extension>\n      <method v="2">\n        <option name="Make" enabled="true" />\n      </method>\n    </configuration>\n    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n      <ExternalSystemSettings>\n        <option name="executionName" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="externalSystemIdString" value="GRADLE" />\n        <option name="scriptParameters" />\n        <option name="taskDescriptions">\n          <list />\n        </option>\n        <option name="taskNames">\n          <list>\n            <option value="dependencies" />\n          </list>\n        </option>\n        <option name="vmOptions" />\n      </ExternalSystemSettings>\n      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n      <method v="2" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue="Application.RefactoringCrawler" />\n        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name="SvnConfiguration">\n    <configuration />\n  </component>\n  <component name="TaskManager">\n    <task active="true" id="Default" summary="Default task">\n      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n      <created>1584971244282</created>\n      <option name="number" value="Default" />\n      <option name="presentableId" value="Default" />\n      <updated>1584971244282</updated>\n      <workItem from="1584971249949" duration="21487000" />\n      <workItem from="1585056855574" duration="4355000" />\n    </task>\n    <servers />\n  </component>\n  <component name="TypeScriptGeneratedFilesManager">\n    <option name="version" value="1" />\n  </component>\n  <component name="WindowStateProjectService">\n    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n  </component>\n</project>'
          },
          {
            sha: "669e8aabbeb973fc803553332427c4c3309bf0b6",
            filename: ".project",
            status: "added",
            additions: 17,
            deletions: 0,
            patch:
              '@@ -0,0 +1,17 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<projectDescription>\n+\t<name>refactoring-crawler</name>\n+\t<comment>Project refactoring-crawler created by Buildship.</comment>\n+\t<projects>\n+\t</projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n+\t\t\t<arguments>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n+\t</buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n+\t</natures>\n+</projectDescription>',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<projectDescription>\n\t<name>refactoring-crawler</name>\n\t<comment>Project refactoring-crawler created by Buildship.</comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n\t</natures>\n</projectDescription>\n'
          },
          {
            sha: "e8895216fd3c0c3af4c4522334775f41b7deb42e",
            filename: ".settings/org.eclipse.buildship.core.prefs",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+connection.project.dir=\n+eclipse.preferences.version=1",
            rawContent:
              "connection.project.dir=\neclipse.preferences.version=1\n"
          },
          {
            sha: "bd1f8bca1aac632eadf627f03cf51f2c130c8fe2",
            filename: "build.gradle",
            status: "added",
            additions: 52,
            deletions: 0,
            patch:
              "@@ -0,0 +1,52 @@\n+/*\n+ * This file was generated by the Gradle 'init' task.\n+ *\n+ * This generated file contains a sample Java Library project to get you started.\n+ * For more details take a look at the Java Libraries chapter in the Gradle\n+ * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n+ */\n+\n+plugins {\n+    // Apply the java-library plugin to add support for Java Library\n+    id 'java-library'\n+}\n+\n+repositories {\n+    // Use jcenter for resolving dependencies.\n+    // You can declare any Maven/Ivy/file repository here.\n+    jcenter()\n+    mavenCentral()\n+}\n+\n+dependencies {\n+    // This dependency is exported to consumers, that is to say found on their compile classpath.\n+    api 'org.apache.commons:commons-math3:3.6.1'\n+\n+    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n+\n+    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n+\n+    compileOnly 'org.projectlombok:lombok:1.18.12'\n+    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n+\n+    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n+    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n+    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n+\n+    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n+\n+    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n+    implementation 'com.google.guava:guava:27.1-jre'\n+\n+    // Use JUnit Jupiter API for testing.\n+    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n+\n+    // Use JUnit Jupiter Engine for testing.\n+    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n+    implementation 'org.jetbrains:annotations:15.0'\n+}\n+\n+test {\n+    // Use junit platform for unit tests\n+    useJUnitPlatform()\n+}",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\n\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n    compile group: 'org.eclipse.jdt', name: 'org.eclipse.jdt.core', version: '3.20.0'\n\n    compile group: 'org.antlr', name: 'antlr4-runtime', version: '4.8-1'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\n\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n"
          },
          {
            sha: "5c2d1cf016b3885f6930543d57b744ea8c220a1a",
            filename: "gradle/wrapper/gradle-wrapper.jar",
            status: "added",
            additions: 0,
            deletions: 0,
            rawContent:
              'PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m±>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MFóMÌËLK-.Ñ\rK-*ÎÌÏ³R0Ô3àåòÌ-ÈIÍMÍ+I,\u0001\nê\u0086d\u0096ä¤Z)¸\u0017%¦ä¤*\u0084\u0017%\u0016\u0014¤\u0016ñrñr\u0001\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/gradle/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000org/gradle/wrapper/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ªÙfØ\u0003\u0005\u0000\u0000ê\t\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.class\u008dV[W\u0013W\u0014þ\u008e\u0099d`\u001c\u0005c@\u0083\u008a\u00837\u0012.\u0089µÖV°´J½ \u0001-\u0001lDÛ\u000eÉ!\u008cNfÒÉÄKï\u0017{ý\u0007¾ö¥O]«}\t´®ÚÕ×þ\u008bþ\u008b>i÷\u0099É@\u0012\u0082«,Ö\u00993ûìÛ÷í}öäïg¿?\u0005p\n?(\u0088â\u0082\u0082\u0001LÊxKÆE\u0005½¸¤à2®(\u0098ÂU±L+\b!£`\u0006³b¹Ö\u0081ëBòv\u0007ædde\u008c(èÂ¼\u008c\u0005\u0005g±(ãÆNÄð\u008e\u008c\\\u0007n\nwKb¹%\u0096Û\u001dxWÁ{x_\u0086Þ\u0081e±Í+8\u0084\u0082\fÎ\u00109gX\u0086;Á\u0010J$\u0017\u0019¤I»@Ò®\u008cañÙji\u0099;óú²I\u0092hÆÎëæ¢î\u0018â½.\u0094ÜU£Â\u0090ÌØN1]tô\u0082ÉÓ÷\u001d½\\æNú\u0082m»\u0015\u0097^ftÃÊººãrg\u009c!\\\u0011[\u0086c\u0089¥Ì\u001dý\u009e\u009e6u«\u0098Îº\u008ea\u0015Ç}\u0089a§/\u0019&\u001f÷òÑ\u009d"EØÛF\u0099AñC^±K\u0094Ëîfc\u0086NÿôªîPöyÛrù\u0003wÒÔ+\u0095\u008c\u00ad\u00178\tã¾\u0085ÅÝôÂ\\¦áH\u0018\u0097(kOÄ°§!¶\'\u0012¡Åù\fwWí\u0002C_\u0083\u0082ÃWL\u009ewÓþ\u0019iö6\u0013÷°\u001c\u0090\u0017ku{nh\u0082ôw\u0011Wù»3zÙS\u0093±BÁ.>Èó²kØVEF\u0091ª³bX\u0085\u008c^µò«Üñðõ\'Z¨k%CZ1\u0084³Ur\u0096µ«N\u009e\u000b9QÐ®J)a«â\b\u008eª8\u0087×\u0019ömÃ\u0013\u0083Úx¢ÂÀ\u001d\u0019wU\u0098(É°TØ(«ø@,GàÈ¨¨pQUq\u000f÷)eê\u0099\u0094_¢\u0094YÇ\u0092ºì½\u008b\\T<ÀCÊ[ðL\u0088[¨Rñ!>bèÞ\u0014_[¾C´«ø\u0018\u009fPÅ\u0002ô\u0093¦]á\u0082G\u0015\u009fâh\u0090o\u009d\u0016êyÓX\u0016¹}¦âs|¡âK|Ehý¤F\u0083¤FSC·\u0088\u0012Êÿ\u0091\u008a¯ñ\rÕ{3ì\\Õr\u008d\u0012ß(\u0010ÃÅI»j\u00164Ëv5\u0093*ïrÍ]å\u009a\u000fL\u000b|jWÏÏi\u0086\u0015\u0088\u000b\u0006ÕÀX®\n\u000fÚàñÊ`JÅ·øN¤ö=Ãàÿ¼]\fû·ëCºA\u009bG\rÉv-µ6JØµ\u0017æ¦\u0088ÚD²ñzL\u008d7\u0017{ª®\u0099Ù¢\u0099!Í\u009e\u0096r\u0005í\u0012+r7û°âòRóE\f<´Zx·\u0098»×u\u0087[43\u0092ÁÌ\b"mc%\u0006GCkÌ¯:\\\'\nvå«\u008ep\u0014¼Ç\u009aÂúR\u0091|\u0085»\u0093mÆE_â\u0005á:MÚ×çÅñÄÖaµ\u0005`\u001dZP\u009e7ÛØ,m±I¾hÐD\fë\u009e}\u0097ºúl£/ÿ^4ùª\u008b\u0092[ETÔ¼¸1\fG[\u0006J\u001bD\u001ejj\\q.¦d"¹¥\u0099dB8«\u008béÜÌõÆ\u0004ïn\u0095\u0091MIwé\u008a\u0090Ç\u009ev<Þ$ +¶CJ-@Û\u0090Ö\u0006èFä¶Î\u0017é\u0093<@ßfñ\u0017\u0002\u0013#\u0090Öcô\u0096¦\'£gxh\rìWÚìÀqZ#\u009ep?NÐªú\n\u0018D\u0082\u009eÔ\u00ad\u0018"-2f\u0003¤\'\u0093\u008c\u000f\u008d¬aÇì\u0013\u0084rÒ\u001f\u0090r¡Ñ\u001aÂ5D²ë\u0090kèXCç\u0098´\u000e%.Õ°3.EÕ\u001av\u008d\u0085ãáènÒîÊ\u0085¢ÝÙ\u001aö\u008cEâ\u0011F\u0082h.4Lï{oÄ¥¿\u0010{,Ì~C\u000f\u0083HNò\u0092;\u0081NZû(ø\u0001Âq\u0010ÃôÑ?\u008d~\\Âa,@ÃmÂZ \u0013\u0091ü\u0015?Ázòb7\u008c\u0011\u000f\u0010Ç(R\u0004$B¿\u001bÒ´\u000b\u0091Å\u0005\u009cÄK\u0014å4\u00ad§ð2\u0081\u0016>Oã\u0015Ò:S§Â?{\u0095Î^#I?Øs\n&Ë\u0018\u0090Ñ-£×û\u000fÉè\u0092é÷\u000b0æeÍ0N\u0091è\u009bSgýgÊ*BÏé\'èÍ\rG÷\u00ada\u007f\rñ\u0099\u0091§\u0013¡3R\u008ftèG\u001c\u001eé\u0091N\t\u0092jè\u008b\u001e¨áàcDâá_\u001eIì§çÿ<Á¡\\´?àj\u001d\u0087× ýé\u0095VÐÓK©\t\u00924\u0002=J°OÒþ\fÁ\u0016th¤£¡\u001b\u0013\u0004XhMo\u00103íÑÁ<P»\u0011z\u0086\u0098\u008c7\u0018;ð/éÑ5ö:ãü\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQþ}¢\u0000\u0000\u0000Ò\u0000\u0000\u0000#\u0000\u0000\u0000org/gradle/wrapper/Download$1.class}\u008cM\nÂ0\u0010\u0085ßh5µ*v/\u0082\u000b×\u0006½\u0082?àB\\x\u0082Ø\u0086Ø\u0012\u0092\u0092T{7\u0017\u001eÀC\u0089)âÖ\u0019æ\r\u000f¾÷^ïÇ\u0013À\u001aC\u0006Æ0 $g{s\u0099Ü\u0017Z\u0012Æ[Û\u0018mE¾,Å]\u0010&;\u0093ië\u000b£\u008e²¾Ú\u009c!!Ì¬S\\9\u0091kÉ\u001b\'ªJ:þË-V\u0084ÑÁ\u0018é6Zx/=!m«¸\u0016FñÓ¥\u0094YM\u0098þiHç tð\u009dnX\u0004\u0017¡\u0017~\u0084~Ð8\\\u0012\u0018j\u00814þ\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Çåî©\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.class\u0095S]O\u0013A\u0014=³-l]¶XWmEäC@Ü¢v\u008b_ÑÔ\u0098\u0090\u001a\u0012\u0093jHP\u0012ÃÓÐNÚ5ËN3\u009dZú\u008fLÐD_\u0084hâ\u000fðG\u0019ï\u0094\u0082\r4E÷agæÞsÎ=wnæ×ïï?\u0001ÜÇc\u0007\u0013\u0098uàbÖÆ\\\nó\u000enb!\u0085Å\u0014\u0096Ìö\u0096\u0083eÜv\u0090\u0080ocÅÆ\u001d\u0086ñga\u001cêç\f\t?¿Å\u0090,Ë\u009a`¸X\tcñº½»#Ô\u001b¾\u0013QÄ«È*\u008f¶¸\nÍ¹\u001fLêFØ¢Ü\u0086\u0092{Ýµ¶n\u0088X\u0087U®¥bp_Æ±På\u0088·Z\u00820Å\u008aTõ ®x-\u0012AGñfS¨à\u0085ìÄ\u0091äµ¥³\u0002%\u0086©ºÐ\u001bDïHU\u001bÈ\u00852fXôó\u0095÷ü\u0003\u000fb¡\u0083á \u0092\u008d»\f\u000bþÈÂ«%ÓµµWd\u0098;\u0007ÈàlÊ¶ª\u008aõÐô\u009e>N\u0015\u008c\u000f\u0017iL\u0092Æ9\u009e\u0018&\u001bZ7\u000bMÓïÛ\u0096P6î¹(  Kü\u009b8æ2À$\u008b6V]\u009aî\u0003Sä¡\u008dG\f\u0085ÿ»L\u0086ì\u0089±S\u0089\u0099\u0091M3dzÄ\u0088Çõ`³ÛÒb\u0097aÂÌEIBê.Ã²_\u0019\u0080h\u0015ÆõRþl\u0088áÉ\u0010à?R3§cdBËr\u0083«5¥8\u0099Húùí2CnH\u0089í²\u0099ðô\u008861O¯Æ\u0085ù\u0012°Ì A/\u0080N\u0001\u00ad4\u0003\u008c\u00ad\u001cÀúJ\u001b\u000b\u0019ú\u008f÷\u0082\u001fq\tf>=\u0000<\\¥5\u0089,r}ò+\u008a\u009a\\î\u0007\u0012ï¼ä!Æ¼qÏ>Dê\u001b.\u001cÀùr"ç\u0011\rØ\'ÙOtþL\u0012û\u0003Ò¹#i\u0002¦1Õ\u0097~J«Õ÷Å\u0086ûÊ\u001e\u0001ú¾Ìî:¦{´\u001b=ü\f®ôJ[Ôz\u001e\u0097áà\u009a\u0081eR\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005¶<\u009bÀ\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000org/gradle/wrapper/Download.class\u009dY\t|\\ÇYÿ\u007fÒî¾§ÕÓáõ¹¾²NìXÖi;\u008e\u001dË\u0089\u0013K¾dË\u0092¬\u0095äÊvâ<IOÒÚ«]åí[ÛJJCJ\r¥%\u0084£4ÍÑ¤@Û@)à´õÊ\u008dÚ&\u0004ê@\u0081rS å(PÎPî\u0016hZ÷?³\u0087v¥\u00adHë_4oæ\u009boæ»ÿ3³ùÜ·^ú\f\u0080\u009dòÖ Öã×\u0082èÁg«Ø»¡\u009a×Tóëªù\r5û9\u0013¿\u0019Äoá·\r|>\u0088 ~\'\u0088ßÅï\u0005ñ\f~_5\u007f xþP5\u007f\u0014Ä\u000eü±\u0081/\u0018ø\u0093 \u0096ãO\u0083\báÏ\u0082x\u001e_TÓ_RÍ\u009f\u009bø\u008b Þ\u008f¿TÍ_\u0019ø²úþu\u0010Ïáo\u0082ø[|E5\u007fWEi\u007foâ\u001f\u0082øGü\u0093\u0081\u007f6ñz\u0010\u009bñ/~¨\u007fõ\u0080\u0089¯\u0006ñ¯ø·jü;þ#\u0088gñ\u009f&þKQþ[íô5Eù\u009a\u0081¯+}þG5ÿ«\u009aÿSÍ7Tó\u0086j¾©\u009ao)\u009dn\u009aB³úEL©0¥Ò\u0010_\u0010ûñYSüüJ\u0080,b¨\u009eI7IU\u0010]\u00124¥:\u0088kb\u0099RcH\u00ad"Õ\u0099RoÊ2\u0003O\u0018\u0012\nÊrYaÊJµë*CV\u001b²Æ\u0094°)k\rYgÊú \u0086d\u0083)\u001bM¹Eí\u001b¡&²É\u0094[M¹Í\u0094Í¦l1åvS¶\u009aÒ 6ØfH£!M\u0002«+\u0091pÜÎ¸\u009dJ9)A¨ÏM^\u009e9\u0090ö&\u009d\u0084\u0017\u001bµ½¤+¨\u001bì9ÞÓ{ªçÜÐ¡þhWo\u000fÙºÏÛ\u0017í¶¸\u009d\u0098h\u008bzn,1±OPÓ\u0099L¤<;á\rÙñ´cJ³ ¶¯¿÷Hÿ¡hô\\çQn"\u0090®JåkAuÇàáÃ\u0087úÏE»N\u001fª\u0004\u001aH\nÄ\u0093\u0013\u0013\u000eå\u00adëNº\u0013m\u0013®=\u0016wÚ.¹öô´ã¶uëI\u008a18î±§\u001cú\u0097½!ÇMÅ\u0092\tAý´\u009b\u009cp\u009dTª;\u0096ò\u009c\u0084Ú§¥Ü>\u0007\u0093\u0097\u0012ñ¤=Ö·\u0080\u009d;\u0007î\u008e%bÞ~AGÃ\u0012\u001a,6}1eÛ\u0090À×\u0099\u001c£\u0092uÝ±\u0084Ó\u0093\u009e\u001aqÜ\u0001{$î(ç%Gíø\u0090íÆÔ8Gôy\u00931ú\u007fÃR*SÅä\u0092\u009a}7æ¾Y3Ö\u008f&\u0013ã±\u0089´ë,L\ríöÊ\u0006ÅT\u0013õìÑ\u000b\'ìé\u009c5æXN¬à\u0096\u0086ì¾\tÇk\u001bìïÊI\u0089%Û\u000eÇâ\u008e\u0096`ØccJ5¦K)+³dÌIy±DNVméZ&À¡Ë£Î´\u009aäâú¼Ì®\u0084ç¸\t;NåÒn|Á®Ý\\V\u009bN9î\u0081\t\'\u0097©\füHz|\\eLÅ\u0099\u000eê\u0093HOõ;J÷\u001aÚNoyÝNbÂ\u009bd,ó9Ö\u0099L+!Ìçcä"\u007fÞÍ\u000eWù¸\u008aÚ®)\u0011ËÚH8£JU*P\u0099L{\u0082U\u0005szÓÞtÚ£Ó\u001d{\u008aÓ\u00151._Y\u0098íJÌO\u001aÒbH«!m\u0086l7d\u0087!;©oÊ\u001ew\u0006Ý\u0098`ã\u0002_o[èO:$fÈ\u001d\u0094M\u009fwØ©ØèÂxn+\u001b®ÅF¨À\u0005G\u000bc\u0086\\9µ+1\u009e$¦\u008cØ)g÷®C\u0089Q]\u0001·7\u0094É¬r\u0000R?áxÙEî\tÇ\u009bLÒ\u0097k\u008bø\\g<NimÙ9ò[\u008efÎó\u001aÙ¡[\nO½#ç¹HE]Ñîìu\u000fÙn<¦¸V\u0016q\u0015\u0012)Ï¸§\u00881 #ËÎê¢\u0015\u001a2»õ\u0004£²K°\u008cE=\u009a\u008eÛ\u009e3XðÄ\u00adå\u0003Rj¶ö\\B#\u009a9ÍM/%]Z\u0013*ÙNg«`ECÙ\u001d\u0082\u008a6ä$Æ\u0014ZWg\u00079X\\6?U \u0005\u0092©,\u0080V%SÅÄ\u0003î(\u0093<\u0018M¦ÝQG\u0095\u0018s;\u009fØ\u00adj\u001f\u000b\u0097ñ¨j\u001e³à"eÁÃy\u000biÕ\\Ä%\u000bß\u008fÇè¾IÏ\u009bn\u009dV`¡47äNKvã#\u0082Ö%àióâs\u0087rd\u008f!wY²WÚ-Ù\'w[r\u008fì·ð.¼ÃÂOãg,¹Wî#@åë¤C\u0017±3V\\M,ÃbÌ(\u009eRû\u001fPM\u0087%\u009drÐÂ\u0087ða\u000b/a\u008e.P\u008a·h\u009f[rH\u000e[rD\u008eò\\ZÂ\u0000Kºä\u0098%Ç¥Û\u0090\u0013\u0096ôH¯%}JÛ\'å$c\u0012Spá¦§=gÌ\u0090~K¢2 X^¨ðÞBþ\tÂù-#\u0097ìT¤ha«R\u0096ËTý\u000fZ2$§\fy\u008b%ÃrÚ\u00923rV\u0000Kî\u0097\u0001K\u001ePa°\u008a\u0013Ï\u0092s\u0098³äAÕØJÏ\u0011Õ\u001bUÍ\u0018\u001bîëXÈ`VàWÑKY2.\u0013\u0082+§\u000eô÷tõ\u001c\u0089\f¦\u0098h\u0091£\u0003\u0003}\u0011\u008d\u001a\u0091RØ\u0088$/:nÄNPÛ\u00943Ê£"2\u008f\f\u0011/\u0019É#s\u0084\u008b"G´\u0003#c<\u0088ÜØHZñ´Fúâ\u000e1C-KÅXQ\u0091tA`´\u0095Y¨Ä%ÝØÃ9\u0090Z½°\u0006:Ò±¸®Ð@V=å\u009dI\u000b?\u008f\u008fX\u0012SV\u009e\u0097\u000b\u0096Ä\u0085ùP¯Ö¶Rl¼µCÃ\u0094%\ta©\u0006çÁ\u0087@¿ Î-\u0099\u0096\u0087r¹T¼vsaEm\u0016|\u0006\u0092Y\u0085rr\u008a!È\u0010×\u0092\u0094°\u008aý\u0083\u0003\u0087[\u0098×i¹XÂ\u0097_º¼\f.\t"\u008az¹õòT¼u$\u0096\u0018k=h{¶73í\u0010\u0094é}}\u001a-\u009bæ\u0006^Vµ\u000e\u001e\u009bî\f\u0011t~³~\u001eZ±)§hÏûó¹¦¼]&0©È¥\u00987¹Dàc©H"éERééé$u\u0018\u008b\u00906Cü\u0088\u001c\u001b:¡óõ\u0012\u0091,[2\u00ad¹\u0092QµÅ\u0003¨\u0094Ø\u0097Ã=\u0015¸Ë\u0096Ì¨*Ô@Öz1\u0007kVn\u0094\u0083«ºìpj\u009eb$S\u00adY\u0014\r²WB¶5°\u00adÛ\u0092jÛ\u0092\u008a4lIíÓÿm+êZò°<B,)Sá]\u0007\u000bw\u0099\rK!Ø\u000eVæö|Ýåð\u0086\u0088]î\u008c§ùå\u008fÕbLH\u0014±\u0017\u0017swI\u0082\fLºÉKÙK×ºâ\u008a\u008fÎ$<ûrQ¨W\u0096=ºJóo\u0086wCJ«f)\u0010\u008fi\u009d7£Ï°%ÍÖW\u0081y{\u0016¼\u001d\u0082)Ç;è\u008cÛé8\u0013\u007f]ÑqXÂ§÷¨Qbm\u0097Ä¬ëêó\u0087Ýü\u0085/0ua,æ¦ôµó4\u000bÉKj\u007f\u00148çïxË\u001a\u0016_4Ã\råo\\j®\u0096æ&\u008a\u0003±vÁ\u009e%\u0017¸\u0010\u00adêw\u001eJóv:ï¨\u00adeî9åïÔµ´´$¾«\u008bL-¾îeïD\u009d¥·PÚÞÅ[¦«¯¨þ\u00863\u001djX_\u0092\u0012¹ÛkÚUÞÌ\u008fK/\u000fYªz¶ÅR]ó\u0087LñÅ³O¡IA\u0093åeÈ\u0094¯!\u0087«Ê]ò\u0094Ï¿ãs\u0085ÑTÃ\u0004En/^Ü9i»QåÛÄ¨Sra: ¹U®S\u009b¦ïâ\u00adCíò\'\u0010ß)^:E\u0011\u0089\teëò\u0005÷³cÇ\u0094ÎþKnÌc\u0002\u001aômW\u0097¢TòiJúh<\u0099R×&Æ$::é(¬1Ø?\u009aLyÙ^\u001fA0×³U¨LöN¦\u001d\u0085Ãª¨\u000e»öÄ\u0094¾ÈM¿©\\YLéúÞ\u0096)\u001b\u0002ô©\u001dO-\bUîz¬ª©åMÝÓsG\u00adº·z\u0085ÃNÙ©QE¹tÛÂ[ò¾lÆ\u0097ÀNx1[î2MÿªHå¶Ûòÿ(\u0095\u0017 b\u0092\u007f\bÜWfÍ\u0099Ek\u008awYô´Xó\u009dæèÇXâbò\u0002C¿·\u008c\u001fÏ\u0094qm¹Ç\u0088rXÇ\u008c§~rYUÎBõ\u000em\\:G\nÈ\u009f}¦7t.\u0015+\u0095}óÏ\u0092ÀxÒ\u009d²½\u0005&\u0094ñT\u0019\u0013r\\Ø\u0084õè\u0081À\u0081\u00810b8Ïþ\u0005\u0000\u0015\u0088c-¦\u0090(\u008c\u0093\u001cO\u0017\u008d\u001fBH½\u001eØ\u000f©\u0007\u0084þ¦s_>#ø\r\u0092÷2fØ>ÌÑ üðñ[ÕØ$Í-³\u0090\u0017õ6\u008fhÆ\n¶\u009b`âV¼\u0095½Æ,#¾\u000foÓ?ëUiA¢{JT\u0085î)a\u0095ZÄ£9\u0011ïä\u008cú!pcã,*\u001a\u009b®¡²±å\u001a|\u008daß5ø\u001b\u009b¯!À\tc^îF\u001a\rl¦´-ÜïvÔb+V \u0081\u008eØ\u0086\rÔBé²+»cA\u0097\u008d\u0005]6j3+tÏÓº¨\u009eÒÊG*\u001fQ9\u00adzµ\u0096À\u008a\u0090y\u001dU7P;\u0087à°Ì¢ú:,¥K¥Ö¥V¯o¡\u000fZ±\u001cÛµl+».\'ûí\u009aW\u0096\u0093ø\u0003x\u0007Ed½Z©\u0017Ö5gP\u0093Aí©Æ¦æYÔÍÛ\u0098Ý÷\u000eî»\u008bý;õ¾\u0091ì\u0092\u0082Mu¸\u0082\u001fÔ²êðCÚ\u008b?Ì¾\u008f\u0094(ûïÊ\u000b«Ü\u0084\u0080þÙ¯\u0086\u000f£v\u007fÓuÔg°¬=0\u0087Ðð\u001c\u0096\u000fSð\u008aY¬ì\t\u00072XÕîkl\nûf±\u009a._Ón\u0084}¡pØÈ`mØ\u0097Áºvÿ²\u0006|Êl7ÕhÃî`Õ\u009eêª=5a\u007fØÌ`ãðîª\u008aç1u\u001d·d\u0010y\n+?\u0086M¡[3¸m\u000e\u009b\u0087C[fqûË«jVV]±÷Ô¬ªÖßêUÕ+°uªê=Ï¡©ñ\u0013¨\fmË ñ\u0094&:{ªI\tÜ@H}\u009aV\u0006¯¬ªù$\u009a\u0002h\t\u009b\u0095+«2h~áæ»õ\u009a\u0096\fZÃþ\u001b0Ãþ\fÚZn \u0091\u0094í/à¶öºòó\u0086\u009a\u000f×½ü¢NºÏãuºìu|U\u007f³!}/Ó\nØËù}ä¸\u0087îßÏ\u0004¹\u0097ÔûÐ\u008c\u0003Ø\u0089\u000eÎt²=\u0088.\u001cF\u001f\u008eÐáG1ÄÑ\u0018\u008e±ú\u008e3\u009dº\u0099Þ=\fK/\u009e ÇÓ8\u0089\u000f¢\u001f\u001f%çÇ1\u0080Wq\u008a²Oã\u000b8\u0083/á,¾\u008c\u0007ð\u0015\u009c£\u0016§ñuÒÞÀY\u0011< ~\u009c\u0093*ØbaD§À\u008fR\u009bZ¼\u0082wãG\u0018Ô\u009dx\u0016\u008f3q\rJ¾Â¹\'\u0098.\u000f²Ö\u007f\u008c\u007fU\u0094ú6ü8{AÊ|\u0004?\u0081\u009fD5u¼\u008c÷°WCk^ÃOÑV\u009fJ\u008c|J±\u0097K)ö²)U!Õx\u0012ïC¥¨´Î®ð\u008b\u0089§h\u0093_\'÷«¨ºÉ\u008dk\f¬7°ÃÀ3\u0006\u009e5ð~\u0003Ï\u0019xÞ@¿\u0081\u0013\u0010\u001fåÜd\u008d.Å%\u009aë\u001bè¸IM\u0003\u008b\u0019\tQ7iMÉ\f\u0014]\f|à&\u000b®~ÑLþ\u001f\u0019ØÜ¤=e÷-*\u001cSý¸\u0091«Òãô¢*¯MsØ1Ü\u0098ÁNas\u0007ÿvñïNþíæß\u009eYÜuµP·\u0001½àB\u0011\u000elÂÏÒ¥ó">HÎ\u000fáÃ9\u0011¿\u0098\u0083×ý\u008dM³ØÛÓò\u001a|/\u0086Ú\u009b(+\u0083}OÃÒI|7\u0093¸9tÏ\u001cö\u000fÏâÞÐ}\u0019\u001ch$\u0014wð\u009bA\'«s\u001e\u008f²Ø\u0098¤\u001eÓtÕCtd\n«\u0089s\u0011¢Þ=Ä½y\u009cÞ_À\u0091ý\u0005\u001cÙ\u008f\u0017\u0018`:\twáç46¾]cvÅ\u001b¨f\u008cV\u0014\u008cØL&¾ï³P)q\n\rpæqºã`\u0006\u0087N4\u0087\u000egp$t´òÓèÊàXOsè¸\u001awû8\u001e®\f\u009d\u0088\u0092Øîk\u0011Î÷dÐÛî\u000fûÂ~Nö\fW6\u0085ú28I\u0086ÞWÐ\u007f\u0095+\u0007ÔÊÁÒ\u0095a\u009f\u0094ãn÷Íah8tJ\u0001Ø[^¦\u008a&\u008bà$\u0083ÚOK\u001få7ë£Fz\u0006´Ùd\u008a¯a\u0092·Ò¬½ÄË\u0093,«~\u0016Ô$KéQ\u0016Óc,$å¯³ôÀ\u001arü\u0002Ë·\u0092Ü·1j\u001f¥\u001bö\u0092úKøeFp\u0092>ÎÒ\u001ecÔ¯âEöú\t\u0012\u001fcOaöã\u0005_?®ýÊ+\bå\u007f\u001c\u009f \u008eÊÃM¨¸Iñ\u0095:7Y\n×TJGoò\\ñ\u0015H$h*\u0097d0\u009b;¤\u009eæH\u0005sGh\u0098\u0087Ô\u0089Ði¶=Í7p\u000b\u0091n]._xÄ\u001c¨oÏàLK6_®2»Î^-dÌ*}R¾\u0097\u0001|\u0092º¿\u008feô\u0014aî\u0099¢LÙQÐ~\u0087Îe^a¨ñu}¢[\u0004\u0092O\u00162¥\u001aòM4k}û9ù\u0012ærz~\u0091BTbÞ\u001fº\u009f\u001av\u0087\u001eÐÚ\u009eSÚ\u0086\u001edÛî\u000bÙêã\u000f\u008d¨O 4Zoê\u00003ÿ}Ña\u001f?þè0Ó$:\u001c\b³g\u0084\u0003Ña³):\\\u001fhfc´D¯cl¾\n³Uð<õü\u0000Ô¯\u0095!\u0096t\u0098ºGX}[Y}Ê¶£Y\u0085r¶\u0005\bÈ\u009fÒ\u0091±\u0018\u0088OkÛB\u0004\u0080ÏhÛÂ\u0084ú\u0097õ\r!Â*z\u0085=?÷Ù\u008d_a/@ÎWµä_Å\u0084¾FU`\\ÿ_M\u0013êÿEN"ømPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L¢¡\u0000\u0000\u0000Ê\u0000\u0000\u00001\u0000\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classu\u008dÁ\n\u0082@\u0014Eï+Ój\u0015DËöEÐ@Û\u0096E\u0090\bERûI\u001f¦\u0088#3cþ[\u008b> \u008f\u008a4Úv\u0017\u0087»9\u009c×ûñ\u0004°ÂÀ\u0083ç¡O\u0098Äª.r%ãÐJ[\u0099ÍM\u0016\tÇ\u0084ñ,Èä]\u008a\u0082\u00ad8\u009fökß\u009f_\bÃPU:â]\u009a3aºý©G\u00ad\u0012ÍÆ\u0004©±\\°^¶&a¡t"\u0012-ã\u009cE\u00adeY²\u0016ÿ\u0014Âè\u009bË\u009b¼8\\3\u008e¬K tÐ\u008e\u001cB\u0017NûÐkØ\u0081û\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b¶\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.class\u0095WÛs\u001bW\u0019ÿ\u001dYÒÚ«u|iªVÍMNZ*;±\u0095\u0006J\u008alB\u001c×NåK\u009cÆ\u008e[\u0097\u0090t-\u009dØ\u001b¯vÅj\u0015ÇÜS\u009aB[(·¶ÐP`x¡\u000f\f3íL«$x\u0086ô©Ì0Ã\u001b\f\u007f\u0001\u008f}á\u0085\u0019\u00180¿³+9¾%L=öÙs¾óÝ¿ß÷íúOÿýý\u001f\u0000\u001cÁ¯t<\u008agZ ãYµÌjxNG\u0014_ÔpNG\u001cÏ¨Ã\u0097Ôî¼\u0086\u000bÍx^mME\u009cSKA-EµH\r\u0017\u009b1¯¶\u000b::`éÔvIÃb3l\u001dIÅ\u009eDIG\u001e\u008eºqu\u0094ñåfxJ_¥\u0019~\u0002O¡ªc\u0014\u0097u,áJ\fê§íÄñ\u0004\u0096ñ\u0015\r_Õð5\u0081öñÉ¡±\u000b#ùñá\u000bSgGFòÏ\nt\u008e_2/\u009bYÛtæ³S¾g9óý\u0002\u00adC®SñMÇ\u009f1íª\u0014hñ\u00ad\u0092t«þDE@ä\u0005v\u0094]ÛÎ;¾ô.\u009b¶"Æ\u0007,Çò\u008f\tÄ2ù|÷\u008c@tÈ-R°mÜrä©jiNzÓæ\u009c-\u0095=·`Ú3¦g©s\u009d\u0018õ\u0017,jÉ\u008e»Þ|vÞ3\u008b¶Ì.yf¹,½ìð\u0095\u0082]\u00adX\u0097å\u0088eËÁBAV*\u0013¦cÎK\u008f\u008eÆÍ\u0080 0\u0098\tã°Ü¬âë\u000fOUß²³\u0005×)T=O:~vÈ´me±¿{]Ô\u0093s\u0097dÁWÊä\u0095²å-3ÄQºd»\u0085E\u0081Ý!£C½\u0085\u0005Óq¤]\t\f0\u008aE\u0095(¹Þ;&f£\u0017*2³B5ûþ\u008f?\u0002ÍÊ^¨¤£±}Òòè\u0099«\\j÷L§è\u0096ÂøC¶\u0087Öl\u009dÙtGuZÝÛ5Ó["\u0018\n\u000fäMn,Ér¹Q\u0096\u0087ïíõÀôtÿ1\u0095\u0084)ß,,N\u0098å@LÃ×5|CÃ75|K@gùdÙ·\u0088\'ÂhÊ\u009awL¿êQ÷ÄÀtnk\u0011\u008e}¢2\u0086\u000ets¥\u0013óÒ\u009f&J\',ÛVXjÊt³\u008a\u001d%syN\u000eÙnE>]µ¤o3\u0095É;6\u0082\u008b\u0010\u0010ÄlK¡q\u0014¸o\u001b\u001eF3åV½B½Öûî\u008eÌ>%l \u000fW\r\u001cÄ!\u0003½8$`¬\u000fÍÀ\u000bø¶À\u0003\u009b»ïDÕ²\u008bÒ3ð"®\u0019x\tß\u0011èýD]AÌõÙ\u0085E\u0003ßU\núð²\u0081Wðª\u0081ï©åûx\u0095À¹cóLÕQ\u00ad½V$\u0081ÃCnÕ.¦\u001d×O\u0017<iú2]6UÒÓÅ\u0006\u0018Ó\u0017]/\u00ad \u009a¾HÛi\u0003¯\u0085\u0086~``\u0012§\u0005\u001e¼\u001b,\u0005"Þ\u0092\u0081\u001fâG\u0006~\u008c\u009f\u0018x\u001ag4¼nà\r¼)\u0090\u0098\u000egLÚ½\u0098V\u0081ÿ\u0094ó M\u000f\n\u000b²\u0098^2-\u009fÉ\tL¯µ\\:lþ´ï\u0006\u009eä(ö3¼eà:®jø¹\u0081·qZÃ/\fü\u0012WYÐ;A¯\u008b¶}3\u0002\u0005öÜ\u0013r\u008dû»µS#»Û\u000e\u008c\r^L/xîR¨\u0092X\u009d\t\u0011|:Èu\u0098¬öL÷æi¢\u0091å\u0094YâåÎL÷v\u0083;®Ðá\u0014\u0089\u0099ÌÖë\u00ad\u0012u°©ñã»!IàÀ¶=¸A\u0011½\u008d\u0097\u0016\u0089\u0088°Ñ\u009e\u000bf§UñyLX\u0095uc«\u008d\u000e\u000fÎU\\»êËÓ¦¿ pÿv\u008eQ\u009fNÎµ\u001cv5¢»ÇÔÒ|o9LêÞ»r×§tû\u0086¬K\u0093ù\u0089Ul)Ëì\u0095Ì¨²¾;\u0093¿Wv¢\u009c\u008föæ¤¯½74OÚÒ¬È\r\u0086¦\u0096+¾,1±\u008eé¸\nÚ\u001cF[F\ný\bf\u000eº >#\u0080&¤\u0090A7\u0004zx\u008a \u0081N5@¸ïT3\u0084Ï(ïú\u0090åz\u0098§Yò4©\u0017}Ï\r\u0088\u009e]\u001f Ò³û\u00034½\u0017\b?\u0016\u0088E¹vqÝ\u008f\u0016\u001cÀ\u000e<Ì\u008f\u0016 \u001d\u008aáÓøLø¥\u0010\u0098\u0011ÁN\u0019\u008apÿ8>K.\u009a\u0089ü\u00191´\u0002â\u0089\u0015Dg\u000fÖ\u0010[A|ö\u00064n\u009bkhéLp©Á¸\u0081ÖS½¼ÍESÑ\u001av\\ÇcêÙö\u0016\u0012êÙ~\u001d]+è\u0098\u00adËvvR\u0088Ü÷5dwÞ\u0016¹\u0098ÈÅ\u0019Êý=ï#rÍ<ª\u0089\\Kªå\u008f\u0018T´¤öúÛ8º\u0082äloç\u00037ð`.\u0096\u008aÕ\u0090ÊÅSñ\u001a\u001e\n\u0018Wÿ\u009a\u008aßÄ®T\u008c\u000bU4]»\u0089Ýï¬~¨Tô®7½\u00876\u0095\u0089\u001aövîãþà\u00067\u000eÝBZ §§Hè\n\u0014Ò«@\'\u001d¼c ¥¿\u009bKlÏ\u0093¸\u009d3Ö1\u001a·\u0099ÿ¿ãcÑÆ\u001c¶\u0089\u000eõDQDDwp>¨\u009eäPõz\u0013\u008fp}\u0094ÕÊ\u0004@8B \u001cgmÎ³*&\u000b_$W\u0099Ô\nëö\u0002+ô\u001akô\u0006\u008erÖ}\u000e¿F\u000e¿A?~\u008b\u0001Ô(µ\u0082AZ\u001dÆÇ8\u0089\u007fðÃñ\u009fü:ü\u0017Æ°\u008aq\u0011Á¤Ð8\u00ad\r\fÓ\u009b\u0093"\u0089¼Ø\u0085Q±\u0017câ\u0000ï?\u0085\tz5)\u000e\u0093çq\u000ej\u0085\u0099sDP\u0019·hí\thô F\u009b9Ò\u0088\u008b\u0006\u008e¸ë§u\u0011ì>\u008fcÄÑ~êþ\u0002iMÈ\u0088vz5ÀHMü\u008d¾\u009d ª\u008aø\u000b\u0086ð$?b\u0087)n¬I\u008ePò$)SÐþ\u0083ã\u001a¢üÝ³\u008a\u009dhÑ \u0007Ç§B¢\u0086¤\u0086<\u001f£À¿q¢ÏÒ0¶Ê.Ò¶å\u0003\u0083\u001eÃx½\u008f\u0018dÐ(§øÇWW½§\u008e\u0004w@óMìß\u0089\u0003¥ß\u00ad5S< \u009f\r\u0092a\u0084<õÀuõ.«Ë\u009fç3\u0012ôäGhí¹\u0085G\u0004ÞAtü=\u0092£dl¥Ù¦@]\u0012± \u0085ùß\u0002éçys\u008eýùü:õm\u008c\u007f\u009aO\u0095\t\r\u0091\t\u008d²¼8\u001bx4ó?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090ì\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.class\u008dSÛNÛ@\u0010=\u000b$v\u008c\u0081Ô\u0094K\n\u0014J)$´Ä\u0005ÚÒ\u000bE¢`@"\\\u0094@¤<E&Y\u0005\u0083±#Ç¡¢_Õ\u008b\u0004¨H}ìC¿©ª:ë\u0084K \u000fäaföäìÌ9ëÝ?ÿ~þ\u00020\u0083\u0005\u0005Q\u008cIx&c\\Á\u0004â\u0012\u0012\nB\u0098\u0094ñ\\¬_DÐ\u0082)\tI\u0005\nÆdè"¿\u00941-ò\u008c\u0084Y\u0086þeceq7µ\u0093_M/.§\u008cünÆHç×¶6\f\u0006-u`\u001e\u009bºm:%=ã{\u0096SúÀ0t\u009b\u0097ßNom\u001bé\u009d\\~ÝÈ1t,¹NÅ7\u001d?kÚUNýïð\u008dÍl\u008d\u001a\u009e·\u001cË_`h\u008d\'²\fmKn\u00916t¥,\u0087oV\u008fö¸·cîÙ\\èp\u000b¦\u009d5=K¬ë`\u009b¿oU\u0018\u0012)×+é%Ï,Ú\\ÿì\u0099å2÷ôÕ`¹[áÞ\u009a{ÄS®{X-\u0093ôÎR\u0003Î\u0010\u008d\'j\u0016-W_±lN\u009c\u008e\u008co\u0016\u000e7Ìr0FÂ+\u0006y¾`×\u0085*\u0019·ê\u0015¸à2Ä\u009a\u008dI\u008a~*zÑÇ0qOi$¤ÆJV\tOîÓ\u001f\u0012^«x\u00839\u0006õ¦@Ñø-Ño\u009f©\u008aw\u0098Sñ\u0000\u001aCßí\u008fö©jÙEî1D®Ú«x\u000f2+ëÉÚ`\u0015óøH}¯·ní\u001dð\u0082ß\u0000Õº5B\'\u0015\u009f\u001f1´\u0097¸¿í¹dÐ?a\u0018\u008fß½8\u0089fw©§\u0019\u0091nB\u0098Úqç\u0098\nqhN\u0091aê^-ëN\u00853ß½\u0094û0Þd6\u009eÐÃ\u0088Ò\u001bjEL\u001c\u001bU1tS&>Õ-\u0001Þsc-\u0011ÂÄg¥ØO\u0088N\u0099Q\u000eM\u009e\u0081}\u000b(1\u008aá\u0000ìÁ#\u008aj\u008d\u0080\u0001\fR\u008e`\b\u008fë\u009b¿\u0004Í\u0080i\u00adõ\u001cm¹õßP/\u0010ÊQ«ðWM:\u0087Ü\b\u0089â;"¢¬+\u0006)\tQ\u001c¤g<Dº\u0087)\u008e`\u001c£W\u0083%L\u0012&|\r\u0007Ã[þ¢[Â\u0088\u0006\u0099¬_\u009a\u0098%Õâ7p\u0001%w\u0086vM%9§èÐ:)\u009c¢ë\u0007"Â\u001a»a\u00ad\u0097âh`÷é\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67§\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000org/gradle/wrapper/GradleWrapperMain.class\u009dX\u0007x\u0014Ç\u0015þ\u0007\u009d´§Õ"¡\u0013íh>c@\'Q\u0084)\u0006\u008bf!\tIp @\u0002"p\u0080å´H\u0007w·bo\u008f\u00928=N%Å¤Ú\u0089Ó\u0013;\u001dRN²\u0015 ½8½÷êôÞC\u0012ÇÉ?»§Ó\u0095\u0005éË÷¡¹\u009d7oþWç½\u0019\u001eyüá+\u0000V\u0089\u0005\n\u009e¡b3\u009e©BÅ³äðl9Ü\u00adà9**$¹\u0002ÏUð<\u0005Ï÷ã\u0005~¼P\u0012Î«x\u0011^ìÇKüx©\u0082{TÔJÆZ\\\u0090\u008b/Sñr¼BÁ+UÌtÉ¯RñjÜ+aï\u0093ÃkäðZ\u0015÷ãu\n^ïÇ\u001büx£\n\u00817)x³\u008a\u0085x\u008b\u008a\u0005x«\u0082·©X,\u0001îÇ\u0003\n\u001eôãí*Âx\u0087\u008awâ]òëÝrx\u008f\u001cÞëÇE?.©¨Äûäüý*>\u0080\u000fªÈ`XÅ\b\u001eRñ0F\u0015|HÁe\u0015ëqEÅ]¸êÇ\u0087å\u0086\u008føñQ\u0005\u001f\u0093\u009f\u001f\u0097\u008b\u009fPñI|ª\n\u009fÆg\u0014<"9?+!Iþ\u001c>/\u0087/¨ø"¾¤âËø\u008a\u0082¯ªØ\u008e¯\tÌêØÛÒ\u0016i?²¯§}ï\u0091Îî\u009díGºw÷vuï\u0012\bDNè§õ¦¸\u009e\u001chê±\u00adXr`\u0083ÀÔV3\u0099²õ¤½_\u008f§\r\u0081PÉö¶öÞ\u0096®H{[\u000e§.Ë²g_W{o\u008e:¯\u0080Z²©bc,\u0019³7\u000b\u0094\u0085\u001bö\u000bøZÍ~J«\u0089Ä\u0092Æ®tâ\u0098aõêÇâ\u0086TÒ\u008cêñýº\u0015\u0093ó,Ñg\u000fÆR\u0002K"¦5Ð4`éýq£é\u008c¥\u000f\r\u0019VS\u00873=àÎvê±$\u008dò%ø+03|¨ÔdGºn\r\u0010¯ÎcY@Í"o×-\u0081j\u0097#f6m\u008bÅ\r®V\u000fY&\u0017í\u0098\u0091\u0092\u0014\u0001Å2M»-FÞ\u008a!ÝJ\u0019üX\u0098¯g4\u001ekj5\u0013\t=Ù/\u008dÝíð\u0010¨2j&O\u0013HnX[¼¡ç\\Ê6\u0012»s¢ò\u0000ZÇ¶\u0011C1\u0087ì\u0018ãç!Ò\u0091Ó\u009f·\u008fìÓRE°t\u0091k_Ú\u008eÅ\u009bÆéÒN\u0017k\u001f\u0095í4\u0013´³"n\u000e\fHeçzE!â,r_M\u0096Ò~Ö\u0088¦m\u0093ü\u008b¼ø\u000f\u0014rI··\u009f\u008d\u001a®9\n¾ÎàèýýÅn\u0010¸)\\\u0018\u0090Â\u0099\u008c\u00adêJr\u0095^PÄÞP\u001cÎÚ¬Bù2¦\u0085KØüqf¥Ô-\u0097\u0011IÃnÚ··\u008bk\u0082ræ\u0017\u0010{Î%mýlÎ\u001eò\u0084ò\u0012m\u0097Ù\u001a×S©6ãø63\u009dìo·,Çþ©=¶\u001e=¹S\u001frr^Á7\u0004V\u0085\'\u008ej\u0089ª[&µéF!T{Ì´\u00155Üô\u009eYr¾VH\u0081L\u0003\u000f\u00886óL2nêý\u001aö¢GÃ\u0013\u0091Ö`#¥á(è×ÐD§BÃ7ñ-ú¿øP2\u0087&sð\u0019\n²NsÙ\u0096§\t¸|\u0090Y áÛø\u008e\u0082ïjø\u001e¾O\u009eS\u0002å§Ò1Ã\u0016Xý\u007f\u001c;\r?À\u000f5ü\b?Vð\u0013\r\u008fâ§Ì¢ñCÔ©§\u0006\u0019D\r?ÃÏ\u0015üBÃ/ñ+\r1<EÃ\u0010Ni8\u0081§*øµ\u0086ßà·\u0002s<Ìê\u0092å8\u001eçáv\u0017ÎPå\u0095Ò¡¿+ôà\u0018ÿnÝ\u001elI¥\u008c\u0004³Æ\u0092|¿\u0097Ã\u001f\u0004ê=\u0098·²V¥lN¤¿\u0098p®A\u007fÄ\u009f\u0004´ü<¢IîÎ\u0015ãåNÂþYÁ_4ü\u0015\u007fÓðw\u0019Ü\u007fà\u009a\u0086\u007fâ\u001aËÃ\u009dÌ\u000bk\u0091@UÁ\u0096\u007fáßrßc\nþ£áqüW¡ !Ä\u0014E\u0094iÂ\'Ê\u0015Q¡\tEø\u0099O78AôÔxNìM\'íXÂÈ-\u0012_TjB\u0095Zø\u008eSyMT\tM`s«\u009eL\u009av¨ß \u0091\t\u00860\u0014\u0095çn\u0088þ\n\u001d7\u00adPÖ\'!ÖùÐqËL\u0084¢lIÇô\u0094\u0011ª_\u009cª_Q\u0090\u0087ÝÇN\u0018Q[\u0013SEµ\u0014W£\u0088i\u009a¨\u0015\u0001EÔib:Ò¬47>à\u009a\u0098\u0081k\u008a\u0098©\u0089Yb63R\u0004\u00151G\u0013s%q\u009eÌ\u000fB\u0004¯{(¥Ìù,\u0089ã2ò\\£å;NÖÍxÜ<³/y2ÉÃØ=Ö\u001f\u0016\u0085\u001b&Ó\u0094*Ì,è:ÏÖy\u0003\u0088î\\©\u009b\u0088\u0087)2¨§Z¬\u0081tÂHÚ\u0013©\u0096Ã\u0095ýòxl m19\u0017\u0097Ô¸Rcd/(w:òd\u00adñl\u0099yÛ\u009câÀB=`ØùíböX»(m¢J¶Ç\u000bl\u009dDUÎCa\u0005ÙÐP4\u0017\u0098î%FÞ;Òv\u008b¬\u0018\u0081p1\u0004}°pâîK\u001bx \u000e\u0014wB·\u0010¬)i¡\u0093jç\u0085\u0006\u0017õ\u0098Ò`xßÓj\u008be\u0093vø\u0086À^\u0005u¬+y®\u0016\u0094OG\u0080b8VÐôC^iã)Â\u00adÙ\u009ek^%×\u0091s\u008bçU¦Ø\u0005\u008d\u001e\u0090Åmª\u0093\u0019\u0014\u0097W³:¦æÄw¦ÒÄrRZ·x\u001cÝ\u0098WææLº±ô.¼%+dÙ¥Ë;\u0096f\u0019Cq]Þ\u0017¬\u0014ù×\u0087\'\u0015]/ÌúÉm¥WjÆ©N\u00aduM§Ñ6Ë4ëE\u009bé¾\u0000\u0016\u008e)\u009fbH\u00ad\u0098}®©\u0098gÃXé¾.\u0087ë\u001eù^qïE|ê\u0094 \u008e¯\u0012oöõÖXù\u0088\u0014É]%s\u0017M·xG6\u0014\u0016ó\b\u000b\u0098m:E½\u0088S^;gç;«wÐ2ÏÈ{£ã\u001d\u0019¾\u009eè á\\Û\u008dSi=N\u0007ÍÈçwûÙ\u0086\u0086\u0083dàÑOè\fÜí\u001eÞ?ä±Ç+r3<öJMÜ\u008e\u0095dæÉÆì\u001c6ªR6`8u¿Ð¤1\u000bó\u0099\t\u001d(¥RiÛÌ¾¾\u009cL\u0095¤â¾SR_é\u0017ö\u009d±\u001eä©1Ý±Ñ\u008b>aíÎu©%\u0093ãä\u008b\u0082\u008ag\u009fÜ^\u0017µ\u008e\u0082×WÄ4O¦\u0087x½\t\u001flØ\u008f\u009b!ÿ\u0097\u0004ð!\u0088\bvB`\u0017gSPÅywÞ\\ã|wÞ¼\u0086ó=yóiðó\u009b7u\u008e½¤4ñWð·¼q\u0018S.9,û8V8Ä\u0010ösÔ\\\u0006\u001cÀ\u0013ø[\u0089>\u001c$\u00177\u008b{¨T\u0015iWGP\u0016Y:\u0002ßN\u000eå»FQÑ7\f¥Ù\u0017ôeà?\u0010ô\u0095_Fe_Y ª§Ï\u0017Ðz2\u0098\u009aAõ8¹F\u0092§Iò\u0081QÔrg ¹<X.÷Ö\u0005}\u008d\u0019Lo®\u0018Á\u008cf%¨\u0090Z1\u008a\u0099d\u0099\u0095Áì\f\u0082A®Ìiö\u0007ýËG0WNæ5W.\u001bÁüf5¨6\u008ebA_°r\u0014\u0082cà¦@h\u00187\u008fba_Ð?\u008c[\u0086±h\u0014\u008b\t´$\u0083úq³·#À±\u009e^\u000eÓÐ\u0006Tc)fa\u0019æc9Ö`\u0005:±\u0092Þ¼\u0095\u008eXÍçÍZ\u0018¸\rg±\u001eOC3îÆF\u009cg\u008c.`\u000b® ÕqÝ\u0090ë\u001e\u001cÂ\u009dNìFù<:LwV"\u0083#ü\u009aB\t\u0097\u0088t\u0018e\u0094ó t\u001c#×\u001e$\u0011E?]~\u0094\\\u0006\u008e3\u001c\u0006\u009d>\u0080A(\u0094u\u0007¯\u008e\u0087\u0019ÇóÔâ\u0004N\u0012í\u0002õ\u008b#Áp$\u001d9\u0002&¿ùöÈF9J¬)Ò2:r\u0014á¾Æ@Ã0\u001aG°\u0094>Ì\u0092\u0096æ\u0091Æ\u001dRMÅ\u0080m¨C\u0007\u0096Ð|iÔL\u0017\n\u0016\u0095\u0080óuÔ1J\u0095/¾¬ÀµÙ´ªbü\u0096¹ÿ.\u0016%×\u008e¼äªrü\u0002BØ9\u0088\u0096,ß,Gá\f\u0096óoE )°2\u0083[\u0087±ª\u0018®;\u000fnV\u000e\u008e¯Ñ,Ü£t\u009dÔ»7 f°:\u00835\u0019¬Íà¶\u001d\u000f`jd\u0014ëû\u0096\u000eãö«\u0014Ñ\u001cØ\u0090ÁÆû0[\u0012\u0003\u009b|\u0097±¹¯¬±g\u0004[\u0086qÇU:¨å!l\u0015¸\u0018ÉªÕ6\u008cö\u008b\u000er\r\u0093g\u001d6Ñ[\u001d\f\u007f\u0099£Û\u0012\u0006\u0007üªaÊ\u0004¨a\u001dOÑ<\u009e 0Ã¹\u0089ÚuPÏN\u0006YêÞÈÀÕpßi\u009cá¬\u008e;Ïâ\u001cµï¤Ugñ$~Ícª¹«Oæ_-|{\u0015¬{\f\u0095\nî\nu)\u0014ªÊGgÖà>\'\u000f\u0080\u0005\u008d\u0081ª\f¶Ý\u008bénä9éÈ Sª=\u0082.éÆ²¼P÷S¬\u00819Ìµqw.prÐ\u0015Z\u00061\u0087bø¢Í\u008aY\u009f\u0015S=\u008aíD¯¡¨aì(\u008eÎÉ<¸ê,\u009c`*K®§ÿ\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000úâ\u0018æª\u0000\u0000\u0000Û\u0000\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/IDownload.classE\u008dÁ\nÂ0\f\u0086ÿÌéæ\u0014\u0011¼\n^õbÁë®*\f\u0004AÑ{ÝÊØ(í¨Óùl\u001e|\u0000\u001fJìTf $_òçÏóu\u007f\u0000X ï¡ë! ø\u0089®\u0094Ô<!L¦\u009b\u009c_9S¢d\u0087]\u0014~)Ól\u009dI\u0011Î\u008e\u0084`u\u008bEQfZ\u009d=ô,ïõÅÄ¢Þ\u0013\u0006Ñòg5¯\u000f\tcmR\u0096\u001a\u009eHÁ*Ã\u008bB\u0018Öh\bÃ\u008f½ä*eÛS.â\u00920ú\u008f\u009aO\u001d\u0002ÁA\u001dä\u0012Zp-·-ÕµcÓ³½\u0003ÿ\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@áõc\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/Install$1.class\u009dWù\u007f\u001ce\u001d~Þì1ÓÍ\u0084¦\u0081\u0006\u0097¶\u0010¥ÐÍ\u0096d{ÐÖ¦\u0007-I+\u0091MZ\u0092&¡¡(\u0093Ýéf\u009aÉÌ:;Û\u0003\u000f<ðV\u0014/\b§\'EE)ØlSª\u0080¢¨\u0088\nÊ¯þ\u001d~>\u0002êóÎìn6\u009bmlýaßó{<ïû}¾ßwöµ\u007f¿ð"\u0080Mxk\u0019\u001bC6Ge\u0093\u0093Í¤lLÙ\u001c\u008ba3¦\u0014X1¨\u0098V`Ç\u0010Ã\u0094\u009c8r\u0094Wñ\u0011Ù»r¥ \u001bO6EÙ\u001c\u008f!\u0083\u00131\u009cÄ)\u0015÷Ê\u0095\u008fÊ\u0095\u008f©ø¸TùD\f÷á\u0093råSÍø4>#\u0005î\u0097ÓÏ6ã0>×\u008cq|^6_PñE¹ü¥\u0018¾\u008c¯Äp§t\u0096ÁWeó\u0080\u0082¯©øº\u008a\u0007U|CÅ7cèÄ·äÆ·¥µïÄx\u0080\u0087\u0014<¬`FÁ#\u0002\u00adÇuk\u00adådtkÜÌï7-Cà\u008aô1ý¸\u009e2\u009d\u0094\u009cï\u0010h\u00962Y³àõ\u0099®À\u0095\u0095\u0099kN\u0014=Ó±G\\«ªd\u001b^jd¨\u009fJ+¤XÆ±\u008f\u009a¹¢«K9\u0081Î´ãæR9WÏZFê\u0084«çó\u0086\u009b\u001a\u000búÞZQêÇëÝ\fOê\u009b¶l\u001d.N\u000b´\u0005Î,ÝÎ¥\u0086)`ç¨\u0010õ&ÍÂÚ\r\u0002«\u001byé·\u000b\u009enYRn§i\u009bÞn\u0081û\u0013K\t.¼\u0084F³ÊY/ùP\u008bQw\u008e\n\u0084{\u009d,o}yÚ´\u008dÁâô\u0084á\u001eÒ\'d\u001cÚÒ2,£ºkÊyy1,O) õÛ6Í[z¡`pzí\u0012\'Y»\u0091\u0087\u000eÓ\u0012£Ô\u009aè¬\u000fnÌ\u009bÎWC\u001fÊÊ\b\u000b\u008eVVåú\u000fì;\u00991òå°Ä¦uwÊp\u0003ñ\u0016Û0²\u0085>ç\u0084m9z\u0096\u008aã¤GA?jôÕÓCó\u009c|Ú8nX¤\u0010ñ¶\u0006Ö¹o¥Ò\u0094\u0095\b]Çñ\u0004Ú\u0017\u001eúT¾rð\u008e:\u0095\u009d\u000b\u000f²\u009b&Z\u0086==35 ç}\u0015\u0005\u008f*xLÁã\u0004]=AAÁ\u0013\u0002WU®Á\u008fÅ\u0081\u0089cFFBX6lælÝ+ºt·w±@\r\u0000ò:St]ÃöR½¼Xé®\u0001\u009eØ°St3FpWZ9\u001cÝR\u008cáÞgg,§@\u0012\f\u0018Þ¤\u0093Uð¤\u0086ïâ{\u001avã\u0016\r[°UÃ6Ù¼\u001fÛ5ô`\u0087\u0086\u009dØ¥a\u000f¾O[µ®4ü\u0000ý\u0002W×\u0093ëÖ¢ie\rWÃ\u000fñ#\rOá4ÃÛíLixZÎ÷àÇ\u001a~\u0082\u009fjxF6?\u0093k?Ç³\nÎhx\u000eÏ\u000bDºóºëiø\u0085Ü>\u008bYz\u00ad\u0004\u009aÆ;¤Å\u0092\u0082s\u001aæp^Ã\u000b¸ à\u0097\u001a~\u0085\u00175¼\u0084\u00975ü\u001a¿Ñð\n~«áwÒÂ«¸\u009bÜè3,Ã\u0093êä\u0019¯ÔqOÑÐïñ\u0007\u0005\u007fÔð\u001aþ¤áuüYÃ_ðW\n7  \u0099Óë\u0014\u00adl\u0087íx\u001dEû^3ßAætx\u000e;Ñ- \u000e\u0019zÁ±{hõ\ry¢7ñ7\r\u007f\u0097þo\u0093w´z©,¡íú\u0090\u000b¬Y2æ\u0095H\u0094+\u0001«àB\u008e2\u0087ç\u0017ú=\u0083uÀq+\'óýÔ\u009cì\u009a\u008b\u0083#\u00952®¡{~^\tloX¸\u001a\u0096\u009cEé\u001eJÈ\u009aÓ\u00923¼\u0083º<K@N\u0085óA}Ú¨O\u008dùâ*mÛLñ®D\u0083*¶h©Ì=*ª\u009e\u0013,\t\\\u009fhTEëËa³Yè«\u0090Ã\u0087Ë\u009a\u00125\u000b\u0001ÎåÄ¹w¢àXEÏ8¨{\u0093¼\u0018=\u00931\n¬û\u001bXùÓ\u0097]Ñ\u001b\u001ccþ®V506_ì\u0014YèF\\\u0093Õ7±ðAè¬\u007f\u000b£YÉ{c\u001eíF\u0089¶q\u0018+h\u001b¾\u0095i\'\u0097ó¯uA\u0018Êõi©0Ä/j\u008cwl9\u008cÎÊF\u0081\u001d\u009d\u0087¼IBÞyù\u0090û+7¶ã"ù7\u007f£j¶:¼®îJ\u0017\u0086FâRÉ^2ö\u0090ÃO\u008d:bIÊT`oþß°ë\u0094\u0017?MªYMÝöDí~%¥)£Lê\u0085Aã$³3lû]\u0005ÀÍ\u0012@×å\u0000 úu\u0097\u0098ßAFÔ¾¶5oü<ÿ*X¶H,w\\\u0002\u0096Z\u0012\\JÒV\u001cl\u0095\u000evüßßU¾)\u001eh\u0080¶ô\\M¾l»ìK\u0094E.¨\u0099\u0083Æ\t¹\u0084\u000e~ùn\u0086ÀÍ\u0088¶¶Ê\u0007\u0016`¿\u00adÜó\u0099õ{¾´~ÏÇÖïù\u001aó/A\u0088¿=ØKí[9\u001aG\u0013\u0014ö7&×ÏB$o\u009aES²k\u0016¡d<<\u008bp2\u001e\u0099E$\u0019\u008fÎ"\u009a<\u0007å9J6¡\u0097m\u0094úÀ\u0006ô±mç\u001a-`\u001f>\u0000ø#é\u0089¯\u0098|©¸G?Mo#"ý\u0088·.@=\u009c<\u008b¦\u0012\u0096]@ìð94\u00073\u00ad\u0084\u0096¶+Ø\u0094°ü\u001c?ª¸\u001a*aÅ\fÖ¬/¡m\u0006í\\\u0010r1Ø¸r\u000eW\u009d\t4Û\u001e\u0081\u0012>\u008dph\u0017çá9¬\u001c\\=\u0083©%ý´Wýô\u0084ãá\u0012®\u001e\u0093Öçð\u009e²h[\u009c\u0002]%\\C¡\u0012V\u0005\u009b«¥ùxø<Ö\u0084\u0010\u000f\u0007Ö®\u001d«À\u009aÃu=þ.\u009fï\u009eH<r\u001eï\u0015\u0098Á.9z\u009fÀËP{¢uN®§\u0093x\u0094g\tÐ\u0094\u001dÅ£sX;vú?/\u0095-GJ¸¡ÄøÐ\u001f\u007fÜ\\WÞh\nÜ&Nã\u009e\u009eH\u009dé$M\u0006\b¥ñ¶õÁ4T\u009eÞ´Àa\u008dZ\u0097DD\u0087ÝU\u0081x¤\u0082#ÄÍ\u001byë\u0081¯xd\u000e)\u009aÝ0\u0016\u008f\u009c\u0081\u0010½bH\u008cðïYØg\u0087\u008dUþ\u009fÏ\u0004Yº\u009d,M\u0093\u009bGÈË,99IV>HN>DV\u009e%S^%WÞ GþAÍwÐ\'Ö`\u009fX\u0087ý"\u0089ÛD/n\u0017C8HËi1\u0086\u0001ñ\u0000\u0006Å³8 \u009eÇ\u0090x\u0005Ãâu\u001c\u0012obÔgá\u0011,£Ý[ðAfA\u0098\u0096Öãv\u008e¢Ô»\u008bþ\u0007È?²¯ÌÑ\u0084x\u0006\u0083Ü\u00158"Nâ\u0000\u000e\u0092¥Y\u0091Ç\u001dD\u001b"\u0092\u007fb\bÃ\bÓÇ\n\u001c¢\\\u0004#ÔÒ(\u001fì\u008dÒÃ\u0018Wn\u0080ú\u000eÒ\nÔ\u0096=â]xBÁ\u009dïb¥\u0082Ã\nÆÿ\u0085Þc\n:ß&°»(\u001a\u0096ÎZ÷2%î\u000eR\u0002)?EÀü*aã\u0099\u0086\u0099¥\u0005\u0002eÔU3l?äË\u007f\u0018÷ø½\u008e\t\u007f/Ã\u001bÞÏQ\u008cR\u009bü\\Ä\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T¨,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000org/gradle/wrapper/Install.class\u009dY\t|TÕÕ?\'³¼ÉðØ\u0002!\fë\u0088\u0004²\u0087\u001d\t\u0088\u0084$H4\tHX\u008c\u0014áeæ%\u0019\u0099%Î¼!\tµj-Vkµ\u00ad[-Z×ªh¥UP\u0012 \u008akÕZÜª\u00adÚM«¶Öª\u009f¶ý\u0016ý\u008a¦ÿóÞÌd\u0092\f\u0002ò#÷½w\u0097sÏò?Ë½óÜ\u0017\u0007\u000f\u0011Ñ\u001cþÈMÛy¸4#¤\u0019)Í(iFg£É\u0091f\u008c|\u008euS!ç*<ÎFüêcnrs\u009e\u008c\u008d\u0097Æãæ\t<Q\u009aIn\u009eÌSÜt\u0003O\u0095Æ«ðIn\u001aËÓdþÉ\nOwq¾\u009b\u001eà\u0019\nÏtÓ\u0004.pÓ\u001e.\u0094\u009e"i\u008a\u0015.qÓTÎus)\u0097¹©\u0092Ëås\u00964³¥\u00993\u008c\u000eò\\\u0085ç¹x¾Â\u000bdÆB7ÍäS¤\u007f\u0091\u008b+ä¹XØ]"c§º)\u008f\u0097ºø4y.ËæJ^îæ*®vã\u00adFá\u0015nZ\u0088½0vº4+¥©\u0015\ng\b\u00853]\\\'=õ\n7(¼ÊÅ«]|\u0096t¬qÓ2n\u0094f\u00ad\u009b^ãu\n¯Wx\u0083¼\u009eí¦ZnrÓJ>Gá\u008dnª\u0017ê+ùk.Þ$\u001fçJ3GáÍnjä-\nknnf\u009f4~7\u00ad\u0093\u001eÝMM\u009cëâ\u0016y¶J3ÇÍm\u001cpñy.Þ*l\u0007³9Äa\u0011.ââvy\u009e/<E\u0015\u008e¹©U\u0014ÚÊÆ0ú\u0098ãÒlS¸ÃMA®\u0095¦S&v)¼]á¯»é|\u0099ÛÎ\u0017È\u0082o\u0088¼\u0017ºé\u0013¾H>/\u0092·\u008bÅ4\u0017)üM&µ6\u001cÖ£UA-\u0016ÓcL\u009eê\u009a\u0015\u0095ëêÖn®®m\\»¦vùºµµ«\u001a6¯®\\»\u0092)§î<m\u009bV\u001eÔÂ\u00adå\u008dF4\u0010n]Ì4¼*\u0012\u008e\u0019ZØX¯\u0005ãº\u008b/ar\u0006#\u00ad\u00adz\u0094ib]$ÚZÞ\u001aÕüA½¼#ªµ·ëÑò:s\u0010+]þHG8\u0018ÑüLS2M¬\u00adN\u008cË.í\u009aÑV\t\u0016CÍA¡<-Ó\u0082Õés°h\u0082Þé\u000bÆc\u0081mú\u008a@P¯ôùôX¬^\u000bk&oå\u0099(Ô\u001cu\u0001È9\u0097\u0004Â\u0001c)Ó¹\u0005_"×\u0097Krl¶\u000b×3Ù«"~\u009did] ¬7ÄCÍzt\u00ad\u0086A±@Ä§\u0005×kÑ\u0080|\':íF[\u0000\u0096\u009b\u0094qg±M0\bîÝ¾¨®\u0019zu f0-Ê(Á\u0006ë\t\u0083¶\u0004ZãQÍ\bDÂ\u008b\u000b-£\u0007"å¢\u00131\u0085/}\u009c©ð¸IA"?¶\u008f\u0006\u009aãò½.\u001ad\u001aa\u0091\u000fëFùº5µ\u0098\u0092\u009b>¥±M\u009b3\u007fAc<Ä4:(¢W§\r*ü-t×\rîf\u009awL-O\u001f²\n;+²su \u009abª_fÕÜü\u009c@»|C\u0097À\u0089Þ.Ëb\nï\u0080Y0è\u008b\u0007¡Þ4\u0086§\u0015\f¤R\u0098É{lmz\'\u0013\u0007ðW\u000bK¶\u0098ä³Bp\u0089ÉÖô\u0098î\u008bG\u0003FWy=°\b V\u0007Zõ\u0098!+[Äè¹©=jÃíq\u0003tu-\u0084Q\u0086\u001a\u009cÍñ\u0096\u0016\u0081zÖÆåð¶æ.X_34¦lljqÀ4~\bWËÍUbèFCóm\u00ad×ÚM\u009c)|©ÂßVè> \u00adU7*Ãþõz4ÐÒ\u0095®Ä5\u0091\bÀ5k\u0090àCå\u001e\u0082©¼t£Wë1_4ÐnÙÒî\u000fD!ç(k\u0005Æ\u0083åu\u0001S\u0001ã\u0006úBW{Ò\u001f¼\u0083æ.\u0019¸ÛÒÅ\n_\u0086åÛ,ö\u0013\u009eYÕ¦û¶ÆÄnó\u000b\u00862|L\u0081à´JÈ²\u0010ô«ù\u008c¸\u00164Q\u0090\u001d\u008bÄ£>ÝÄú0½³]÷\u0019ºß\u001cq\u0005-¸A:of¨ôK«ðå Õ\u0018h\rkF<ª\u000fÕñà\u0015Cd\u0086¥cºQÓ\t8\u0019¢¦Õz4\u0014\u0088Å\u0004Âp¢ÁÔ N\u0096Àk|ªßB\u0085î_£k~+\u001aÆ\f\u007f$n¤ hn½"\u0012\ri\u0086aN°\u0007\u0011½@§½\u0019\u00918Me«£\u0011\u0089«Ëã\u0081 E\u0089Û\u0099Æ\f\u009d #ú\u0000\u0084¯J¹Ýâ\u0094\u0095Í\u0015µal\u0019\u008d·CµéSÜV\bX\u0019\t\u0081Îpë£*\u0012\niaø\u0097\u008a\u0015\u0091hÂ«\u0014þ\u000eô\u001b\u0088m\b\u0084\u0091\u0094 ¸\u00ad ð\u001cÈ\u0018\u00895h²8Û¯\u0007u\t\u009eÑ\fÊÂD%\u00167\u0093\u0005XÆ\u0097Ë×\u0006Ù¢:à;fcF¯\u0007¨\u0015z\u008bÉ\u0011\u000fo\u000f@ü©\u0019]&Ý\u001c\u000e=lD»R\u00161µ\u008d¥å\u0088I52"A\næHÅ\u0000ñ\u008f$\u0091Uiý\u0012ç\u0084T@\u0092}^\u001a±\u009ap<¤§\u0002µÍdËî×%[(Û\u0093\u0081/oèî&\u0087\n_¡ðw\u0015¾\u0012!Þ\u0017iïJ\u000bFLe\u0005\u0019\u0083Tfö,èAs6\u0013\\¶ hÑ\u00ad\u0099Ú\u009d>kÖ,¦º\u008c¹+\u0099èN8ôduÎ\u0092f¶4sú·\u009a-[eN\u0093É\u00ad2&¾Tu\u0093$4G\b-9qBéÕO\u0092ÖÜcÓ:F é§5Oh\u0095\u009e\b\u00adsú\u0017Ï\u0097Åg\u001dÇâ\u0013\r¢Y\u009dsûwY »,>as§»M\u0092ÔÂ\u0013\u0096V\u00167\u009a±Û\u0082¾\u009a\u0098W&ÓTz\u009a\u009eQé\u001dzW¥^zX¥ßÓ\u001fTz\u009c\u009ePé\u0012ú\u0096J\u0017Ó7Uz\u0090\u001eRér¾\n\u001b\u009fP©)\u008b¾§Ò·é2\u0095v\u0010²î÷Uþ\u0001_\u00adò5|\u00adÂ×ÉÇõ*ÿ\u0090oPùG|\u0003ÒñÑ\u0085\u009a>[\u0088íTùF¾\t"¤K\b·n\\YY\u008ajEå\u001fóÍðíôÑ4G\u0005\u0005ÈÊ·ð\u00ad*ßÆ·«|\u0007ÿ\u0004Ñ%sÙ ð\u009d*ßÅw«¼\u008bïQù^þ©4÷©¼\u009b¯Uùgô\u0006rAÿÊ5ñ°\u0011\bé©\u0098Í´åtS\u000eoz=à\u009d\u0099\u001f\u009béõGô\u00987\u001c1¼(?\r-\u0010öjá.L\u008b"¡F$\u009a\u0095yk\u0012ÙÕkD¼-\bä^½\u0013\u00898Øå\u009d\u009d\u009a×U\u0086R¢\u007fÿUÍç¡[å\u009fóý¢§\u0007TÞÃ÷0m:*\u0013\u0089½cØ"â\r}5\u000eTÞË\u000fªt+Ý¦òC¼Oånh\u0085ÛÌj*à3\u0003°7ÒâÍÄC\u008b\u0006ÓøOÊ\u000fç\u0087\u009b\u0000Í\u008csBZ\u0097·MÛ¦{\u009bu=ì5´P»¤moGÀh+Ë\u000f\u009b\u0005y4ä5Ú4\u0003\u008dî\u009d\u0099±Ü\u009eém\u008fF°ÐèòBÓ]²\u0097\u0005°Ò\u0004ÀÊ\u0012ã\u0010Û+E«7\u0010\u0083r¢"#\fã\u0097%^-\nÖ\u0012A\f\u00001·K,÷¶D#!¯æ5¢ñ\u0098èË*\u0092ÊD0ozAéEÝTáÍ\u008få\u0087\u0093ÑÐ+U\u009f\fYÝ)\u008dû\u0012õ[\u0085i(\u0090ñV\u009aEØ\u0090\u0001\u0095{Ä\u008dö«|\u0080\u000f*Ü«òÃbøGø\u0010²u\u007f´¬\u008cFµ.\t\u0099*?Jo¨ü\u0018?®ò\u0013òö$lF¯\u000b\u0092ÝÍ\u0081pÂñ\u0004>O!;\u001f\u00adÌ\u0019\u0000»dííðµ\u0085"(El\u000bçÏWù\u0017ð\u0010PyZågøY\u0095\u007f)H\u001c\u0097¹üÂ1=CFµÆT~\u008e\u007f%\u0084\u000eKóü\u0000¡Rå\u0099Ê/ðµÈï¢B\u0081ÿ\u008bÉi\u0003Ë,\u0095_\u0092iS¾¼ÒRøe\u0095\u007fÍ¯¨üª\u0004»¼¡\u0091!¡\u0082¢ªH<è7\u009d\u0018µ(\u009c#Y\u008czÛû«QoK$Zá\u0095¨ñ\u001b\u0085\u007f«òkü\u0000\u0012ñê ®Å\u0004N^9ì\u008aëÁ¶p¬@\u008b\tµ\u000e-l\u0088ÓÅ1G`\u0096p\u008cuµðw%\u0012+\u000b£\u008aSùu~Cáß©ü{þ\u0083Ê\u007fä?a¬Ã*øT~\u0093ßRùÏü6\nÎ\u008c%\u008eJïó;*¿+\bø\u000bÿ5i\u009a!u\u0098ÊïI¤û\u009bàcÒ`ë\u00ad\u001aP \u008dO\u000f¸éCb¸÷Å\u008e\u007fWé\u009fô/\u0095?à«Tþ\u0090oGð<z¬G\u0089\u009bì\u0011\u009fFy7çÄ\u008fÁI\u001c\u0098æK\u008bË\u0013¿ä0\u009a\u008e\u009dôºoÄÀÚ\u0003¥áÆÁÅ×è!þ2@ÿi5)ÓØLõâ\u0000~×¶E#\u001dÖ\u0019\u0010õ»\u0014Í\u0005µµò\u009cy\u009c7\u0014`\u0011GÛ\u0081ú\u0018UP8ø\u008abü Ii\u0087þ±\u0005\u0019\u008fùÞcY\u0082ió\u0089\\É|¥û\u008d\u009cAl\u009b§\u0099\u0094xýFqc^êªcÇW.¿\u0006jí¸\u0085Ë\\\u0017:µÄùª2ãIÉD\u000b\u00923à\u0089c\u0097Q^\u0005æ\u0004\b\u0003.]¬l\u000f\u0001\u0087A@S\u0082°\u000f\u0012ÎÎpÞ/<Æå\u008b\u001dØó\u000b¾6./¬\u0005wñv¿fHI\u0085\u000e\u000brN\u007fÂ7ì\u0005\u0085rý2z`\f5¯ \u0087\u0019\u0091\u0095ý71¹\u0005µ\u0019±ãÄ\u0011¨Õh31-{\u0089Îä\u0000;± jèüÔåMÉÑ¥Ê4ÝeD\u0092|(\u0081XM¨ÝÀYÓÙbæ\u000bó\u001c4\u0084ØÆ¡\u009aÍÈ~n&Fä\u008e3\u0016Ø.\u008e\n[\f\u0091=e)§~>â|l\u0010\u0095ävrB·\u000eæ\u0096ãV6Ç"Á¸¡\u008b+\fL¸]¨2à\u009d6ä®ô\u001b\u0085Õà¦ÿ\\<&C7ÔÑ._A¹\u008aÒ;\u0003¦A-\u0003ãË\u008c²Ùr\u008f#X4/R\n\u0087Ä¸a\u0081Xu²ø\u0003\u000b\u009a\u001f¶;ùØWdØb\u0014dªÒÂ\u00910ÊÂ %Ô¸\u0082\f\u0017\nf¨\u0003\u009c£¦&Ó\u0015Ù\u007f\u0095¢th\u0001\u0003ù\u001faÙD\u007fZ\u0004ÍK\u000b\u0001\u0003o\u0011Çg>¹Ë~cú\u0087\u0012WBÒë\u0012¿¨3ï}\u0096\u009c\u0010f\u0086Ü\u001eI\u0010ªO^¨¥\u0099\u00121Þt½á\tWO~\u000f\f¼Vïb¹ÓI\u0016,æñï¸\\"y/å9êñ^î%"\u00adV Y\u009d(\u0094\u0099f\u001c\u0017ýÅIq¬Ä(qZnÉÖ5¦~_I\u001bXl\u0006\u0089ºH\u0007¢$ê\u009fþ=ÒçdÜCAa£w®j9\u008a\u0003Ö\u009a÷s1\u000b0\u0019ï¨<\u0005é¦\u0019x;4²M\u008bÕG¢zMP\u000fÁ\u0006\u0000þ°°Þi$>\u0007\u001b#åÍ\nÔeÝ§9C[\u00ad{]O?\u008c\u0086\\\u0003\u0095§Ë:à®ëhxuø\u0082\u0011Ñ\u0092£\u0003Q[§\u0093h;\u0015\u0012\u0091\u0083<t\u0001}\u0083\u0098.ÄW\u0016]D9rBÇ{\u008e\u001c×Í\'\u000eÚæ\u0013§n<Ç`îåô\u001d´WàëbP°ã9½¨\u0087²\u008bzÉÝ\u00943l4=ÛCê>\u001a^T¼\u008f\u0094¢\u0092}ä,*ÝG#ö\u0098;|\u0017í\u0004r¢\u009d\u0086\u0095^\u001aK\'\u0083\u0087é4\u0085òñ6\u0083®ÄH\u0091E\u0093®¢ï\u0011\u0099oÂ\u0013\u009boÂU\u0096ù&|ÙÐû}ú\u0001z\u0084\u009býä&\u0005Ï¥ÅÝ4²\u001eÍ¨\u0086¢\u0087h\u0004^FWØ=önÊ©pÈcL\u0085\u0013ýÃ=Î^\u001aÛTäqz\u001c%Å¥=\u0094ÛMã\u001e£¼\u0007\u0006ñY\b\u0019\u008b@¹\u0004¼\u0096ÒD*\u0003ç³L>WZ»¥ø\\JWÓ5àÈA\u008bèZº\u000eTÜ4\u008f®\u0087~mX[D?¤\u009d\u0090l"ä¼\u0091nÂ¬i4\u0089~\u008c7\'Ý\u008cÕv¬¼\u0005kpüµäá\u000bÐçÆÈ¥9ã÷\u0093§¾\u0097&4\u0015÷ÐÄ\u0006Û\u0002ûèQô°«Â\u0091kÏº\u0095&\u0095z\u001cÝ4i\u0081=×~Kß\'%\u001e\u0087-\u0017BNÞÕ÷nI7M©\u0080\u0094S\u009bzÈ[¡Ø\u0016¸r]\u001eç¡;hÖhêó8s]s/ÜO\'Ud{²»i\u009aý6\u001aæQFÍê¦\u00937x\u0014é\u009a¾a\u0087\u008bwõ½àQº)_Ôb3Õ²\u0082F£Ý\u0004¶Ï¥\u0091´\u0019ÐØ\u0002\u0013j4\u0095\u009ai&ù (?\u009dB\u00adPG\u0080N§óh\rmÅ\u008c ¾Bt>E¨\u000b}\u0017QÔTa\u000b\u0004\u0094Õ·CIÙt\u0006Í§;è\'ä\u0012¡Sj½\u0094î\u0084\u0092à\u001aXu\u0017Ý\rå\u008c¤m´\u008bî\u0001?9\u0014£{±Â\u000e\u001aAú)Ý\u0007µ.Å®»ñæÄs)ý\u008c~\u000e3Ý\u000f:¥äèÃ4§BÛ\u0015ÊSè\u0001\u0085ö°B{\u0089¦|A£ñ¢ÐT>B3\u0014ªü\u008c\u0086\u000f°É\u0083ôP\u0002c¿\u00021AgC\u0011Láh(=@3\u0018f\u001dßK3\u009br\nì\u008fPa\u0093\u00ad¤q?Á!\u008a\u001fÅh\tÂÉ\u00ad\u0089áÒÁÃ¶\u0003T\u0096E\tÌÙÓ0×\u0081¶\u0013bv\u0001ç_\u0007â. *xh¿o4¤\u0094Ó`b\u0089Í·}Pb\u0016V®¤nê\u0081rö£W5\u0015\'=\u0007Ð#jÈ¦¬#4]¡\u0083S\u0006\u0088ØK\u000f\'D|\t:\u0014&jJ\u009f¦ª¢\u0092\u001e*¯°\u0097\u008aßÌº\u0091æ\u0002R³7äÌQLI\u008a\u001b\u009bìè\u0098ÛØä(mlrzì"Y\u0085c/Í\u0013DÎ·ï§\u0005{R°)2±|\t6ÜAÃ`Ô±\u0088(\u001eÄ\u0094\u0019ðß¹x\u009e\u0002ßY\u0006¿©\u0086\u009f\\iz\u0093\u0013}*=\u0002©\u001cX±\u0088\u000eáM¤¯II_C\u008f\u009aÑKÞÄ\u0093²Ì·ÇL\u008f»ß\u008coüo\u0010L\u0097óqz"!ç«x\u008a\u0003WöÒB8È)\u00121\u0016í¤¹xT4\u0094\u001eZ`·-päÂÅî oi®cN\u0085Óãì¦Å;I-ñ8\u000fÐ\u0092,Ú°Ã\u0001÷x³¤ßzSL\u0082;\u0001à\u001ba½\u009b¨\u0000\\ÍÂö\u008bð~\u001a@\u009e´`\u0001\\èNÓó±}J\u009aÊ\u0084-]\u0098/\u0016ÌJYÐê9\u0080\u001e\u0091j"ÙúÐ¤\u0080|P¡\'\u0019J\u0098ü)\u0004~Ê\f_¿ÀßÓô\u008c\u0015¦³\u0086c£lô\u001f\u0006ìNE\fÚÓKyMÅ9K{è´znè¥eMÎG¨²É\u0096³\u001c\u0006Í©\u00829aÕêÆ\u001eª±âæ\nÄM\u0018ôô\u009d´¢\u0097V6õRm\u0093|\u009fÑCgöP\u009dD\u0098z(°¡B\u0011\r\u00adjªp=My\u001e%gµ\u0085w\u008f«±\u009bÎÚ\u0080x$\u0081dMÃ.\u009ad\u0091]\u008bWDæý´¾\u009b6HÇÙ\r\u0080\\!b³ÒKM xNÎÆnú\u009a \f\u008fnÚÔMçÊ`Îf¼ì\u0081\u0084¹\u0080ÑåÔh>¯¥u\t \u009dKyhï\u0082)î\u0086âîAÊº\u00173î\u0003ÈvS\u0005âÁrD\u0084\rPä\u0016Ú\u0083È´\u0017Qå!¬ï\u0005¥nh«\u0007pì\u0005µý\bÜ\u0007`\u008e\u00830ÛÃ ö\bps\bîÿ\u0098iÄv\u0000r\u0003\u001cóYú%t»\u0005Éë934´Ñd:\fø¹°Û\u001az\u009e^\u0080±+èLzÑôª+0÷eú5ú®\u0087Y_¦WL8\u001fN\u0001à00)\u0000\u0018\u0083\u009d\u007fcÂ9\u0017üü6\u0005ç\u001ar¹ú°¯+iyü¯Th\u0099B¯)´R¡z¢#4\u0005}}\u0092\u0097Ó\'\u0011-W¨ñ\f\u0085Ö\r/\u0004Ù×é\u008dD\u0006oÃ\u0097xÍ\u0084\u009c-ûIÛKÍÝä«+Îñw\u0093\u009eu\'9ì»m»S\u001e\u009cc²û$X\u007f\u008aÆ\u0001bã\u00010QÆ8\u008bBB\f\u0095FÐïL¯\u0014\u0096]\u0084\u0090:^8È\u0092\u009f\u0002\u0012»î\u0087"\u001cx.,6=ª\f\u008f\u0096zÛÒÉ%ÈM\'\u0015\u0099è,\u0099<\u0007ðì!»äµ\u001bÉaÛ½Ã&Þ\u0086©³ûY\u009afæ\nÑüalü<\u0082Ê\u000b°Å\u008bp²\u0097\u0090\u0087\u009e§9Ð\u009e°8\u000fÛåcÖ\u001féO\u0010b\u0004Âªä\u0019\u001bÖÌ 7é-S\u0080\u0085);,¤?\u009bv\u0010\u0001\u0086\u0093ís\u001a¡ÐÛ<ù3\u0010É\u0092\u009f6\u0012ùùel.nuM/µJfn³`\u001d\u0090¬p\u009ed\u0085\u0000^¶2 \u0013´\u001c(´\u0093òD¸\u0012ù\bC¼n\u008aÀ/^é¥v8ÕùM\u0003Æz(ÚC1\u0094*\u001e»t\u0019\u001eg\u000fÅÅÁ¶í¢á\u0096«mó(\u008fîê»N6í\u0090N\u0097ùæq=º\u0007BnB\u009a\u008d\u0082»(\u0019æÓ\r K\u0005w\u0019ª·ËR\nl\u0000Ø\b\u0096qC5£ \n\u000f\u00941\u009dÞ\u0086òÞ¡S!é2z\u000f\u0094Þ\u0007\u00ad\u000f\u0090º?\u0004¥\u000f\u0090\u0095>DFú\bô>F,ÿ\u0004Ô>\u0086â>Aõó\u000fSÙk \u0097ét6ý\u0085þ\n\u008dmBað\u001eý\r\u0016\u001f\u0085¼ö>ý\u001d;Cg)e_\u0003\u008aV\u0006»\u0006t\u0005ôWãË\u009aç\u0086S~Dÿ\u0005iÄ\u0014\u001a)\u009fÓ(\u0085>V¨õ\b\u0095+\u0014ì£Ù¤¤á\\FÐ\u00ad\u0080\u0019dö\u007f|FÙY}°º#5\u0005\u001f\u00adæP\u001f,ç\u0018´\u0012[$3E#Øø\'ý+\u0091)nF\u009fÀ5\u007f´\u001deWCq)Ê\u00ad¦\u0005ö\u009bhDI©Yluîêû\bÀìB¨ÚÖ\u009fñ¬\\þßhÿ\u000fñþST{ÿFÅ\u008bäK\u009f§@\t¢)Mäcî=¦&òé\u007f 1ÉåSÍ¢Æ\u0006ÈæÑÿ\u009a\u0085Îý¦\u008f!\u0087#þï=B¹ÜÏô(\u0017vú4Át\rV\u0089¦\u0095¢bäpW\u007fYë4·\u0098h²àµ¦Ðg\t\u0016\u0014úÿ\u00841\u00140+åD*w\u0082ø\u00110n9p9\u009e2Ë!ñ83iÕ\u009a`\u0091Æâ/¨/Ãbçq-Æ|N,®H\u0004,§Y\u0080e^m\u0005$gJ*§%\u0015èd±-\u0013\u001dûî\u0013¤cgGBÍ«¡\u001d\t\u008b.¨\u0019\u0087\bÛ\u009e\u008c\u0094¬²Í\u0095¢ä\u0002%«pqAÏVáâb§\u0019éÓ4Î\n»2\u009a3+ó6_nÎ\u009bÒÌ\t¬p6»3)\u00833Ó>\u008a2(\u008b\u0087É|VQ©J\u008eÈB\u0010¶þÝÀ\u0093éGÄÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ð¿:öo\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000org/gradle/wrapper/Logger.class\u0085\u0093koÒ`\u0014Çÿ\u000f\u0097Unc\u008cá@Ø&s*\u0017]7¼\u008b11$KHð\u0092°`²wÏÊ\u0093®³´¬\u0014\u008d_ÅO¡Fgâ\u000b?\u0080\u001fÊx\u009eR\u0019\u008e5KÓÓçrÎÿw.éï??\u007f\u0001h \u0019G\f·b¸\u0082Û1TP\u008d£\u0086º4w¤¹+Í¶\u0002UÁ\u008e\u0082]\u0086èÉØ\u0010.\u0003;`XxfX\u0086û\u009c!R9¨öèÓ²û\u0082!Ý1,ñj<8\u0014Î>?4éd¹ckÜìqÇ\u0090{ÿ0â\u001e\u0019#\u0086bÇvtUwxß\u0014ê\u0007\u0087\u000f\u0087ÂQ;¶®\u000b§É\u00106m\u009d!Wé\u001có÷\\5¹¥«]×1,½)\u0081Ê@\u008cF\\÷\bs\u000e\f©®Ëµw/ùÐ\'.Hq«Ï°3«×:âNW\u009c\u008c\u0085¥\u0089fuæâ\u0085ç-Ce"Úè\u0084!\u001f\u0014ÇÐ\bÔl·\u0003U£#\u0097;²\u009bm"x©\u0015*\u00ad@o¦ÑÛb\u0088wí±£\u0089=C\u0016\u0095\u0098ôj[Æ$\u0091B#\u0089\u0004\u0092\nî%q\u001f\u000f\u0014<Lâ\u0011rI\u0014ðX\u009a\'Ò<%N`×\u0019\u0096Îø¯\u000f\u008f\u0085F\t®\\\u0094\u0012å\\\u0091c\u0098ñï~\u001c¹b@\u0017ö\u0098¢r\u0093J\f[}C#qi0\u0082\u000f¨\u0090ì\u0005Ç4Í¡Ü\u0099\u0016\u0083zÙ|æ\u0014w/ïþ\\L~ÚêsW(Óß\u0010\u00035\u009aÞeÙNúS¢´Na\u0091l\u009av{\bÑ\u0003Äk?ÀjÅï\b}¡]\bKd\u0017\u0011&{\u0015\u0011¬\u0092J\u001e\u0019oçy\u0093Z\u0016ðVR\u0095Æ\u0089\u0015ä|Í}_3]û\u0086Ð\'Ä¿"\\?ED\n\u0087g\u0084\u008bPP¢õú\u008cpz*\u009c¦\u0093U\u0012Ì{QLæ[À5\u009fÐó\t\u0099\t!1!DßÖ>\u009fc\u0094\u0089±I![3\u008cÌ\u0094\u0091¡\u001cJg\u008c´ÇXó\u0019&Õ\u001d¡ovÂHIFií\u0014\u000bó\u0094\nQª¤V÷(µIØ\u0094\u0092õ)rµ\u008e\r/\u0087,®Ó*ü\u008f\u009cñÈåàê\u008a§Pæ¹*qw(¤\u0011PÝ&nü_Ý\u00967Û\u009b\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011¶\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.class\u0095R[K\u001bA\u0014þÎf³«éVãª½ÙK¢>Äõ²EúÖR\b\u008aP\b¶ÐâCß&É\u0090L\\wÃd£ø¯\u0014\fB\u001fú\u0003ú£JÏLB1V\b}\u00983çö\u009dï\u009bÃüúýã\'\u0080}lÌ£\u0088\u0017%xX3ÞKc^ùxã£BðÛj\u0090\u007fW}ÂB£\'ÎE¬²øH%òý¤t¨4ÁË»j°ù\u0096°ÞÈt\'îhÑNd|¡E¿/uüEäÝú` Ï\u009a\u0089Ô\u008có>¨Tå\u001f\tõÚìöiÒéhë\u0084à\u001edmIXl¨T\u001e\u000fÏ\u009aR\u007f\u0013\f$\u0084\u008d¬%\u0092\u0013¡\u0095\u0089\'I×\b%,ÙÚ!Ë×ª9ÌU\u0096\u0012\u0082Oi*õA"\u0098\u009a[ÞÍ\u0094¶ùÏ\u0010~[Ø\u0091ùÝ\u0094]O¹¶u\u007fw%îã\u00ad\u009a\u0088\u0083¯ÙP·ä8\b§Hö\f.@\t\u008f\u0002\u0004¨\u0006\u0098Ç\\\u0000\u001fs>Ö\tûÿ¯\u0091ÕX)\u0089H;ñçfO¶rB¡fVY\u00995\rUþ\u0019\u001eÿ\u0099\u0002B£\u0081½Ð\b\u0002Êe#ÑVx\u0093xÌv\u0081£.\u001c¸|¯DÛ#Pt\u000b\'Ú\u0019¡\u0010í\u008eà^sÞÁ¢\u009daz\u0014Oê1ê\u0014ËHPæL4Æb\u0089\u000f¬g8Èz\u0086Õ±\u009eÑaXWñdÂ\u001aómº\u008aÑ\r\nW\u007fi<\u009bÔvt0n\u0098\u008c&<}\u0010ìÞ\u0007_>\u0000vðÌÚç¬\u001b¬\u0090¸ò\u009aßD\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJØâ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/wrapper/PathAssembler.class\u0095Vic\u001bW\u0015=cK\u001aY\u001eÇ\u008eb\'µc\u0017Å1\u00ad,Ù\u0016\t4@Ü\u0006¼5QkÙÁ[qÒÖ\u001d[\u0013y\u0012y¤\u008eF\u0089\re)\u0090\u0096})P(\u0094²CÙ]h¤P\u0003ýÎob;wf,Ù®LÛ\u000fzï¾§ûî9wy÷Í?ÿóÆ?\u0000\u009cÅß#\u001cr-\u0088c=\u0002\u0013×#\u0094nÈ\u0090\u0097aC\u0085%Û\u0005Y\u0014U<\u001dA\u00049Ù±E*\u0085áÈ\\\u008e@ÅMÙ¾%Ã¦\u008a\u00ad\b\u008eá\u0013\u0011|Rþ\u008bã\u00990>\u0015Á§ñ\u0099\bt|V¤gU|NæÏGp\u0012_\u0090á¶\u008açT<\u001fÆ\u0017#\u0088áKa|Y\u0094¿"ÃWÅÐ×Dúº\u008ao\u0084ñM\u0011¿\u0015Æ\u000ba|;\u0082ïà»\u0082ÿb\u0018ß\u000bãûrøE\u0015/)8:]XÓó\u0093fÉ±ÍÕ²c\u0016,\u0005ZÚ²\f{"¯\u0097JFIÁ\u0089\u008bsc\u0093ÓS+\u008bóSs+\u0097f3S+ó\u000bsé\u0099\u008b\n¢Ó×õ\u009bz*¯[¹Ô<\rX¹Q\u0005m\u0013\u0005«äè\u0096³¤çË\u0086\u0082#\u0097çf\u001f\u0099\u009aX¨\u009d:\u0092³õlÞX,\u0019ö¥Â\u0086hxfÌBêa3oÐDèAÓ2\u009d\u000b\n\u009aã\u0083K\n\u0002\u0013\u0085,ÕÚ§MË\u0098)o¬\u001aö\u0082¾\u009a7\u0004_È/é¶)k\u007f3à¬\u009bdÝ?]°s)\u000f*uËÖ\u008bEÃN]Ö\u009dõ1zµAM\u009b@Gãû¡\u0005\u00ad=g8ûã±\u0012odë1o¦·×Ì\\ÙÖEwtðmQ\u0007Þ\u0012p\u0089ÙÚ^+\n\u001a\u009ai\b¨ ¼ª\u0097\u008c\u0019]\u0002\u0019ÎÒ¬\'¶Ú\u0085\u0002Ý°½\u0095*\u007fpåKWÌ¢\u0082Ùø[³÷.ül\u0090yµlç/é¥uJ\u008c¡\'Ý×\u0000¥áá¶\r£TÒsÆ¤\u00993J\u008e\u0082>O©d¬\u0095mÓÙJeöþMýàê\u0096#ÕÙtu\\\u0081B\u001f»öX\u009dÚ\\3\u008a~|B%\u0017\u0082\bó\u008e¾v#£\u0017ýBi·\u008d\u008dÂMcjÓ1¬\u0092\u001bö\u0080åFKat\u00944cèW\u0082\u0017Ã~ß\u0013ËpR\u008bséCB á]´óµ¢ÞÕ¦ñ"Ë@Å\u000f\u0014Dhw\u009cIs\u0013Ò\u007fx\u0080ê\u0017" 9æÁùBÙ^3d\u0093Å¿¯¬Fä\u0084\u0086Q<¨áÃ8¯â\u0087\u001a&ð²\u0086Çñ\u0084\u0086\u008fcVC\u001aÓ¼Û{-kø\u0011^Ñ°\u008a5Þò\u0083,ÆËf>kØ\u001a~,:?ÁO\u0019\u0094\u0094\u0086\u009fÉj\u0014?×ð\u000b\u0091~\u0089W\u0014\u009c}÷E/6~¥â×\u001af0Ë\u008b\u009e\u0099|@Å«\u001a~\u0083ßjø\u001d~¯á\u000fø£\u0082N\u0097Õ\u0006m¥ÆÍ\\Úr\u008c\u009cPú\u0093(\u008cb[è¼¦àX\u0083Ì+è©ïÎ\u0095-ÇÜ0öüÙ;Q(ç³1«àÄÖY¨1Ó*\u0096\u009d\u0098W*#bûÏt\u0097Â_ðº\u0086;¨h¨\u008a»w\u0004.övî*è8Ø35ÜÅ_Y\u001f~3ä]-³ÿ\u008ddM[Å\u001b\u001av$A£ø\u001bËU*ã|\u008cÕ\u00173K±²uÃ*Ü"ß\u008eº3³«×\u008d5gßÖ¼_â÷¿ÃûËÃñÁ\u0083\u0005zì@ã\u001bwk®3Þ°Ð\u000f*\u008bÿ$/PVVÁð;ºö~\u0089I\u0013s\n»>\u009c>Ð\u0093\u001b\u0018Zòî\u0010Û\u0098ÇÑ_x\u001cÆ\u001avëý\u009d¿\u0011ÂÞ7@Û\u001b\u001a\u0005\'ÿO+òÚDÚ}òÖÈåÌá\u009e\u001fÚËÂÒ\u0010¼v\u0016\u0088\u000fJC\u000b\u0095\u008bYÝ¡¹`üê¸0\ne}´P<íítÅÓ\r3\u0093hÔ×ë;\u000bëvá\u00964@×ÑV>ò$\u009f56g¯\u0089É\u0006Üé\u007fK©¼ºÛE\u008fÇÓ\u008dq¥çûU`<]Öó¥\u0003ö¼²\u001d\u001d¼²¿r·J\u008e±á\u0005ñ²]`ª\u009c\u00adC\u0088,á\u0014¿\u0092Îò\u008b¬\u0019Ýx\u0000ç à\u0083\\5a\u0090ë\u000fíY\'ùc\u0013¤\u001cæ\u001e{"Ç\u0087¸z?g\u0085s0Q\u0085ò\u009a«z\u0081c\u00843Ð\u0087\u0000îÅG(i\u009e\u0012>\u008a1Îb`Ü7ð05E7"\u0006\u0012É;hª[9BZàwU\u00804[ÐïZ:îiû\u0096D\u0012ZBb\u0002\u0093¾Íÿ\u0012Iå|;\u0091¬ ¹\u008a@&1TEp&1\u009c¬"t>°\u0003uYþ\nWÑ²\u0083Èr\u0015\u00ad\\i\u0015´E\u008fpè\u000ep¨ ½\u008a\u008eóÁ]Ý£ût£ût]i¨~(´\u0083cË\u0089î`w¨\u008aÎí\u009a;=\bq\u008cÓ\u0095A´#\u0081\u0013\u008cê\u0004\u0086°\u0089a×µK\u001eé\u009ak·1Åð°Vð\f.2\u0017M<u\u0093Zç\u0018\u0096\u0013°øú\u009cch&\u0018ÊG\u0018\u0082 í´áQJ!jòeò\u0083Qä*Ày A\u0086Í\u0015tUq|¦î\u0089G~Ø#¿} \u0081g\u0098¸³.·\u0084g£ÆmÀå¡¸Ò\u0094\u009bD\r÷ ãrk\u0092\u0007ÈG\u007f\u0095çääHôÄ]Ü\u0093!`÷Ì\u0010Ñzvpr9@F½Uôu\fTpïvf\u0007±åè)fªÿM×ò)¦ü=´W\u008fÝ\u0018Çq´Òç\u000e&»\u009fÈ§\u0089-ü>@ÿCèÅe|\u008cø\u00ad\u008cÏ\u001cæyö4å\u0005,ºÞ\u008cÔØ\u008f`Éeÿ\u0018å\u0010\u0094U\u00958Mò¤û¬¯ó¤\u0094^g2zº\u0082\u0081\u0087z_F0¹\u009dlî\u00adà½Ûîm\u0011NQ×³G\u0099µi¢d\u0018ýY\u0097KÌ;[CëÄ²\u008b¦Rã\n®\u0012ÉÇý\u0017Úøµ%ß\u0013>î³<)6{\u0018§û2C\u0092\u009a\u0081\u000b}\u0004\u001fÚ\u001eê\u000b<UÁýuôãô\u0018ô1Hÿ4zØA\u009f¢ô¡\u009e\u00ad\u009e\u001a\u0083\u001e<\u0089\u0015b\u0004Ñ\u0085§ÜJÒx¹\u0084K³Ë¥\u0005Ê¿\u0011U¡\u000b\u001d~»øt^ \u0019\tÜd2:XAâ%\u0084\u0013¯£i;\u0019Mº«\u000e¹\u001bÑ¡»\u0018®bd[²ç\u0097U4Årrkë}»\u0097âÌ\u009b\u0007\u0088?NÐ\'HâI¦j\u0085E¤ï¹Ý\u00935â\u0093ÈÖ\u0012E.Gºø¿á\u0016é5¦\\Ê\u0094ï&¯\u0014ÛÐÿ\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007fÍëÂ\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.class\u008dVÝS\u001bU\u0014ÿ]\u0092°!,-Ð\u0002\rÒ\u0016\u008b-á3\u00ad\u008aTR°\u0096\u0006\u0089ò%A(õ£.a\u009b,\u0084Ý¸Ù\u0094âWý~ì\u0093ãL}ðÍÁ\u0019Ç\u0099ú\u0092\u000e2cÇWÿ¤Ú±þî&\r$¤µ\u000f9÷Üs~çÜs\u007fçÞ\u009býûß?þ\u0004ð"¾\u000b \u0013Q\u0005\u0013\u0001Ô \u001aÀ\u0018ÞP0\u0019\u0080O\u001ac\u0001(xSNÞ\u0092Ú\u0094\u0082i\u00053\nf\u0003h@Ô\u008f99¾-Å¼\u0014ñ\u0000T,Hø;õXÄR=.â\u008a\u0014Ër\u0091¸\u0082«~¼\u001bÀ{x_\u008a\u000f¤¸&Ñ\u001fÖc\u0014\u009a\u0082\u0015\u0081æør|!:}mn~v\u008e":\u0011»BãÔ\u009avC\u000b§53\u0019\u008e;¶a&#\u0002\rã\u0096\u0099u4ÓYÔÒ9] ö\u0082a\u001aÎ\u0098\u0080\'Ô³(à\u001d·Vi=<e\u0098úLncE·\u0017´\u0095´.\u0093Y\t-½¨Ù\u0086\u009c\u0017\u008d^\'ed\u0005ú§,;\u0019NÚÚjZ\u000foÚZ&£ÛáøVÖÑ7æl\u008b\u0013ÇÐ³\u0093\u009aI·Í\u0012\u008e$u§Ò+p2T(×°Â\u0013FZ\u008fô\u0014¦9ÇH\u0087§µ\fãü\u0086ÉmèÚ\u0086@°\f\u001b339§à"L°°\u0096\u0092?6\u001b½\u0099Ð3\u008ea\u0099ôyÖõ-&ÒìdnC7\u009dr\u008efWÖô\u0084CÔ¡L©.\u0099\u009e\u0086òÒ\u0004ê\u008b\u0088-V&Ùª,5\u0090Ù·³Ö}î½\u001dG¤£\u008cÓ\u00adÌc^\u0087Ê\u0013^8ØÈ\u0083\u00961ÙÜ¸£%Ö\u0019áæQ\u0090P°ª\u0080Êu\u0081º¸\u009145\'g3\u007fôé\\?óz\u0081¸\u0095³\u0013z\u0081¤\u008e\'t|P\u0086ªx\u0001§\u0005\u009aöÖ\u0099Ô²)®¥"\u0089\u0094ÀÑj\u0014\t´=¡Í2\u009d¡b\rë*Ò2ñ\u0091*ý\u0016hß«z>g:Æ\u0086¾ÏÙV¹¥K9#½ªÛ\u0002]QÛ¶ìÎÍ\u0094nv¦-m\u0095¾Î½\u0086v^g-£*6`Ja©Èà#Y\u0090\u00ad"\u000bGANÅ\rlª¸\u0089\u0094\u008a-|,Ðûì÷\u0083g+[ò\f*øDÅ§øLÅç¸¥â\u000b|©â+|\u00adâ\u001b|+ÐXyvy\u0002Ê\u001a) î\'ð1MnÄBÊ¶6\u008bw{/(æè¶æX,£Ö(\u001e~>\fWÙ¹Ê##\u001f\u000bI\u008eÀ±=×þ\u009b(\u0011¾DÚÊÊWFîÙ$v tð$õ\u001c0\u0015;\u0011©À\u0017/èÓð~Ç*\u0098x¤B\u0007\u0081DôV©`ª\n-nýµ|/âº#·¿ÿ\u008eÐ\u0014)ãÚÅø\u008d\u0012y\u00adeðÇ¤2FIiÙ\u0019ý&Ñ^Ó\u001dÊ«,=A\u008d\u00955ò²ñÙ¶\u009dì\u0092áð¾´Tã\u0091mªMëfR\u0002Øµ\u0018/}6·\u0092-Æ·\u0084bU\tñ$eñgþ\u0087èRe\u001evXà|\u0015ø3%Àó\bò_\rà¹¡~\u008ac\u0017g5hçOÈW\u0082ò\f-a\u008e\u0082£¯÷\u001eÄï.¤\u009b²Ö5\u0006\u0011¢T\u000b\u0000ô \u0097c\u001dúÐO\u0014\u0083Å_ð\u0012\tü¶\u008b\u009aå{ðLõæáý\u0011¾¾»»ðÑP;½\u000be\u0099\u0099ý3ý\u0003yÔñ\u0017Ø\u0086:â\u0095JÐ{\u007f\u001b\u009d3»P\u0097wÑ@ô¡æÃy42ES\u001eÍ\u0003÷pä~\u007f\u001eGwÐ"03°\u0083V\u0081;¸L¥M`Ä\u001bôæq¬¹=\u008fçî ¿4éÈãø\u0088/è£ö\u0013Zú\u0082>×u\u0082Þ\u001d\u009cô`iûÑNß]xÈG7\u0006Yø Îºc\u0010Ã\u0018A=·#7?\u008f£\u0094ÇáÇ\t\u001cÆI4¹lv1ê4ýÝ$ Ä¨n¼Ìq\u0098³\u0011R\u0013!9K\u0018\u0080MÏ-²z\u009b\u0099\u007fÀ9üBÔ¯\u0018r\u0089\u009cäWÊ)´\u00105È\u001a"è î,µÛìÊ9z|\u008c~\u0085_=/±\u000e\u0092ÊÈ!\u008e~üLë0\u009b\u0010Ä÷8\u008fWIþH±-\u0005_\u0084Ú\u0005÷{Éÿ\u0010M\nF\u001f1µWÁ\u0018U\u0005>\u0085Ë\n\u0005¯=\u0080ÿ\u0092\u0082ú\u008e\u0087¨Spñ\u001fL<`¦×Ý\u0096_b\u0086qW»ü\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ª=©\u000f°\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/WrapperConfiguration.class\u008d\u0093mO\u0013A\u0010Çg¡ôÚãJK\u009f\u0004|\u0002\u0015i\u000fá¤\n\n"\tHUL\u0015C\u0005\u0012ß\u0090-\u009cåH¹\u0092»«&~*M$&¾ð\u0003ø¡\u008c3w\u000b\u0094e\u009b\u0098&3³3ó\u009fýíîõÏß_¿\u0001 \u0002Ë:¤ÀÒàa\u0002æ\u0092`@E\u0083G\txLá<\u0099\u00052OÈ<%³¨Á\u0092\u0006Ï\u0018\u0018\u0007\u008e\u001fxN£\u00138m\u0097ÁPí\u0088\u007fæ\u0096k\u0007ÖöÖ\u0006Ö3Ýõ5îÛ\f²QO\u008b»M«\u008e5·)÷½çÁ!\u0083Bwª~È+ó\u000bõÎ1\u0003í«s\u0012M¢(ê\u008d/;®\u0013¬0è/\u0095w\u0018Ä^´\u000f°\u009e®9®ý®sÜ°½\u000f¼Ñ\n÷nïóÖ\u000e÷\u001cZ\u008bd,8t|\u0006åZÛkZM\u008f\u001f´lë\u008bÇONlÏÚ\u008dü\u008b¶ûÉiv<N,\u0088\u009bnÚÁú¥\u0093gJeùìi_n\u001a.]î!Ö\u009c4*:ZþlÜåkÊùªæBéj¯jttWò\u008c(;"õv]ø\u0088ß³¤£êãÙsè~÷"ªDÃEE,êí\u008e·o¿tèîGU\u0017<K§1 \b×\u0018\u008c+\u001e\u0085æ¬ú¾}\u008cÏçáÕ¿ÚZ]¯U÷¶ëÕ\u00ad½×\u009bo«\u0006d`\u0098Á\u0098Bºáú\u0001oµ\u0018¤Î2ô\u0095ù\u0006daØ\u0080<\u0099\u0002\u0099!H\u001b\u0090£)SÿùU ÇÅ#l6\u008eìý\u0000&ð¯\u0092ÂÿW\u001cúh"F}\u0084\u0016ú¬ð9áóÂ\u0017B\u009f\u0002FçG;\u0082«]Ì3ô7Í\u009fÀÌlÿ)ÄÌlü\u0014´0N\u0084qò{(\u001fE[\u0084\u0001´y\u0088a¤ã\u0090\ff\u008b0\u0086?@ p\u0010\\\u0087\u001bè\u0019F·Ä&\u0016zª\r\u0098?@ÿv>,.\u0004\u0017â\u0081sñm\u0018\u0017â\u0015ìî£nsú\u0014ô\u000b\u0014=ÌN æN8¡\u0018u\u0089\t\u0014Ñ½ÐÆ\u0013Øq\u0015$&\u0083L*AîÂ=\u0015HL\u0006)£Æì\u0001B\u000fC\u001bO*A4\u0019dF\tr_\r¢É s¨©ô\u0000É\n\u0090)%È \f2¯\u0004)©A\u0006e\u0090EÔ,õ\u0000É\t\u0090²\u0012$!\u0083<W\u0082\u0098j\u0090\u0084\f²\u008a\u009aµ\u001e y\u00012\u00ad\u0004IÊ U%È\u00035HR\u0006Ù@Í\u009b\u001e \u0005\u00012\u0013jfÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Gü¨\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000org/gradle/wrapper/WrapperExecutor.class\u0095W÷\u007f\u0013ç\u0019ÿ\u009e-ùäãX2\u0006l\f\u0011Æ\u0080\u0090l\f\u0004\b+¤Ø\u0098âÖCµl\u0088!\u00ad9Kgû@Ö)§\u0013à\u0014\u009aÑÒt¤+m\u009a\u0090îtÐ\u0099\u0098\u0016l\u001a7¡\u0013Útï½ûgäÓöyÞ;¤\u00938(ýAïz\u009e÷ûìç=½òï\u0017_\u0006°\u0005ÿ\u0092ñ\u0088\u008cGCxLA\u0015Þ*ãm\n\u00828§@ÂÛùäq\u0019ï\bá\u009d2Þ¥à\fÞ\u00ad \u0016O(\u0098\u0087s2Þ£`!ÎÕ\u0012ç{yx\u001f\u000fïç\u008b\u001fàáI¦~0\u0084\u000fñü\u0014\u009f|\u0098WO\u0087ð\fÏçyx6\u0084\u008fðüQ&\u007f\u008cW\u001f\u000fá\u0013<\u007f\u0092\u0087O\u0085ð\u001cÏ\u009fæá32>\u001bÂçX\u0081\u000bÌþy\u0005wã\u000b¬â\u0017yõ%^}9\u0084¯°úÏ3Ã\u000b2¦y~\u009eÉOÈ¸¨`;¾Êä¯)Hã\u0012\u0083^V0\u0083Y\u0005Wðõ\u0010^\u0094Ð°¿;98ÐÝ14ØÝß724Ð3\u0092\u0018èOt\r\f\u000eK\b÷\u001c×Njí\u0019-;Þ\u009e´-#;¾[ÂüN3\u009b·µ¬}HË\u0014t\t\u008de\u0000\u001dû\u0092]\u001e\u0084rbbßàA\u000fqy\u00191ypßÈ\u0096mÛG\u0092C½\u0012\u0096\u001déN\u008c$\u0007û\u0007º*\u0011=\u0094\n8%g\u00999Ý²\r=/a©£zÁ62í\u0089â9©¿ ÄuÀÈ\u0090þ\u000b\u001cNÃlç=qÔ¤Ìì\u00981.aC\u008fi\u008d·\u008f[Z:£·\u009f²´\u001cÝk?ìÌ\u009d\u0082§`i¶aféRÝ\u0098i\u0091\u009cãzÊÞoX4\u009aÖ\u0094\u0084\u00adÑrðÛ!v\u009dÖS\u0005ºF`\u0081N3M\u009a-ì1²z_arT·\u0006µQÖ5Üc¦´Ì!Í2xï\u001e²Ý®\\ò)éá\u0002&*\f\u009d\u009f´µÔ\u0089^-çÞ«Ùcd\r{¯\u0084õ\u0015Zú»nÃ!\t\u0012]«÷$E×é\u0094\u009es=\u0010°\'\fr|Ë\u009d\u0099¸4gé9ÍÒ÷\u001byJ¬Ñ\u0002\u0083\fY\u0086\u0084EÑ\r\u008e\u0080¬n·\u000f\rts@òfÁJ\u0095BU¢(E\u0005ò2æÈDK×Ò\u0002Ò\u001c²2t!cjé\u0084\'-BF\u0096\u0012Y×&\u008bv\u0090ÑÝÙ\\Áv\u008ewËø\u0086\u008c\u0097d¼Lî\u001f×m¯z¤\u001b\u009d\u0094\u0005^B<úÿd\u0089¬\u000b\u000f\u0090)G£Go..?¤n.¶LÆ\u0097Öa\u009a6é§åz5¶K³lÝ\u0012q\nhÖ8Y[ç#\u0083\u00940\u001cH\tM·\u0013(aÉ¨\u000fþ-ÊÂW\u0015\n\u0090ÃvÐ\u009c$\u009bç\u0091ûÜ`Pm¬\u008bÞ¬Ü\u0006?}U·b§ú4FÙásïN\u0091Òú\u0098VÈÜè\\;ï\bé\u0088/TÈÒ\u001f,P¡§©(\u008eH\b\u009edH\u0019W)¯(±MËî5òyb-Ù«$E\u0016;µ¸¤¢"6²\b\tÍÿ»vÈ\no±J\u0088Vð;Û6w»±ÔîT\fâ\u009b$Ú¯º\u0099ö-\u001e\u0086T|\u001bß¡Æ]²y \u0090µ\u008dI½Xj\u0012Z]\u009d"%ðÈ\u0018)\u0013Y¿6¿>\u00926i\u009b5í\u0088~\u009aªg#\u0095M\t«\u007f\u0094;\u0095\u008aïâ{,í\u001a5\u009f;¬\u001e\u0015¯ÃëU\u001cÀkU\u001cD·\n\u008du=\u0082£*®ãû$$í)Õ\u000e-¯«ø\u0001^Q\u0091ÇI\u0015?dIe\u001c\tÍ\u009ePñ#æø1\u0013ë½Ää\u0084F/Q²0©â\'\u000eÆi\u0015?e6õ!#\u0097¤(è\u008e\u0084\u009f1õçe\u0004\u0007ø\u0017Lø%\u0013ê|º%y°Ó,dÒÂKÜ¢"§|\u001cj\u0099\u0093Â¡\u001bÙS¿Rq\u008cmý5\u0003ÿ\u0006¿Uñ;^ý\u001eG©Q¥Ë\u009ah\u0086\u0015&\u001f\u009f\u0085}#YÜ\u008eI¯§7w<}\u008fEüAÅ\u001fñ\'\u0015\u007fæL\u0018ÇQ\u0019\u007fQñWüMÆßUü\u0003ÿ\u0094°¯Ï\u008c\u0088D\u008f\u009c2ì\u0089È\t}Ê\u0089x>§§\u008c1COG\u008c¬¯)7r\u0083\u0092a\u0085W¡äTÖÖN{üRçÓ\u0093Ë|88a\u0099§\u009c÷«ÄÛïAXTY¬\u0012Öø¾oeÝ\u0082zfu\u0094Ç\u001a\u0091´y±¥º®¡çtR³ý{\u0085·»:\u0089íßvêý:\u001dÉZ\u0098¯|`\u0016GË_8æª«x\u00868ó¨\u008a£¾¢êò~Ì\u0095\u0010\u009c£7ó:§Ë+x\u008bµ@¤ü-I\nÝ:bä\u001cqJÞ»q(\u000e¸Kq6±Û·ßb¤\u0085\u0017j\t&\u0099\u009aÐù\u0005\u0098Ïï\b};dm§\u0003\u0016?\u0019JßpõEö¤\u0093\u009b)º@a\fÚ¦¨\u0083Å\u0095\u001fführ%\u0092\u0095Qß\u000f\u0003æ\b¦2&ÛÔxëg\u0093lL\u0011¿->lDÚÜé×ÁM6øuF¿g\u0096ôÊÛÂº\u0016ß\u008f\u008a\nC±\u009aþ!Ì£\u007fBµhÀ^ÜG»×Ð®\n\u009bh¿Ï³_Fû\u000eÏ~\u0005í;=ûU´ßïÙ7Ó¾Ë³_\u008b0·kZ\u0087¹c\u008b\u0099z8ÍóIv\u000fz\u0089³\u008fv\u009d¨¡\u0015Ð0\u0007ix\u000eUÃ±põ,\u0002s\b\u000eÏ¢f\u0016ò´\u0080ë§Ña\\\u0087\u0004\u008dªs\to\u0010Ðµ\u0018(\u0002\u008eC\u0016´ÖØ\fBÏbù\u001cj\u0087ÃJà%Ì\u001b®\u008e%¯@\u009dÅü«,,V.£ZÈX@3\u0010#\u008c8\u009aÐæ\u0091Õê\u009a\u0091\u0014¼R\u0013Mô`:B¥ûéB\u0080N¦c³X@À\u000b\txÑe,\u008eµ^F8\u0016¿\u008cº8is\u001eOÆ[¯`Iì\u0012QfQ?\u0083¥b\u0019^ÆÓ\f\u0096Ï¢a\u0006\u008dÎÙ\nç¬I\u009c\u00adtÎV9gw\u0091\u0087"3Xí\u001c6;\u0087k\u0004c\u008bs¶Ö9[\'ÎÖ_@c\u009fpÃ\u0006Ç\rqvCÛ,bW/\u0092þ\u0011<\u0085g\u0010u\u001dÐ\u0081E4n"kÖÐÿÅÍXBÿ\u0099\u001bè\u000fe\u0004Û(¦Û\u0089r\u000fÅ}\u0007îÇNLb\u0017\u001eÅnº¿\u0097\u0010öà<îÅ\u000b\u0014ÿ\u0084pa\u0080öKq\b\u0087\u0085K§éÆ0 VìHI¬8Cª\u0084K\u0097¢ê?\u0004RMÁ\u0093Q%Ó¿V\u009a£tÊ¯<\u008d\u001cZ\u008b0«hn!çÅ{È£\u00ad×9o(g.¡n\u0006mt²\u0091rg\u0006íÓñRHÃ"2\u009d\u0084¸\u001fü\tÑLò\u0013\u008eDÆrõ\nâ.<\u00807\u0092^¬M\bÒ«h\u0096Éî7Ñ.@§#Ä}¬¨É\u0003â\f"\u0004áð¦\u0019l¾\u000e%\u0016Þ4\u008b-\u0087çp÷°Xn\u009dÅ¶ÊÌê%\u0015úPG\n\u00942kµ«\u0082\u009bYu\u001e\u0099\n\u007fè¸2\u009f&"[²r\u000eÛ\u0087É\u0003÷ôÆ[g°\u0083~;/@éã¹M\u0004´\u0096dÕ\u0017å®¢ÔäT\u00ad¥P, Ia\u0092UOs#ÍMä\\Ö#"t[éf8¯80\u008c´\u0004£HyCTÏ!âøÈHs\u0088ô\u009a¢ºcô£/\u0007·\u000e·ÐÌÖ\u0085\u009cTÜUYÇÇ<\u001e\b¹\u001e\u00900\u0001Ã½ßîÞ\u000fòýÊËã\u009eËÁâåã8áú*C\u0006\u00059ö\u00ad\u008eôÝ»\u0002mñ\u0006Ê\u008c=\u0017\u008bHN@N\u0090\u008f3XL¹Ì\u0088[\u009d[Å\\\r\u0013mRH\t#\u000bSdL\u00189<Hw\u0015RÛ"\u0087\u0005\u008a\u000e\u0088\u0012\u009d>¾\\\u0003ö¸Ù\u001a\u008aÅ¥\u0000\u0015l¥\r9O\u0016\u0086\u008a\u0012C(\u0088.ÊH\']¤\u0003\u0084Tí µú!Ù\u009e Þ\u008cÄ«S´ª\u0012\u0098§]Ìçh\u0017\u0014µD\u0019L\u0085³yW !p\r5\r\u0081éÖk\b¶N¯<\u008fÚX\u009c\u0012zZ*%q3a\u00810\u0014LQwx\u0088|q\u0086,8\u008båx\u0098\u0092é\u0011¢?æñcKQ\u0097\u0096¢.-®.¼\u009a"\u0004öc#ÞLg\u0001\u0091d\nª_EXÆ\u0099`-q\u009d-z3AiÌ·\u009aD#»7è6²á\u0000×þ\u008d¶^á\u0097Ç=\u001en*êÒäê"á-\u0082ÿáÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Ôe\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000gradle-wrapper-classpath.properties+(ÊÏJM.)¶M/JLÉIÕMÎÉä**Í+ÉÌMµå\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000gradle-wrapper-parameter-names.properties\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000org/gradle/cli/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ÕÜ?®<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.class\u0095T]o\u0012A\u0014=\u0003\u000b\u008bëÚ"¶µ~C?\u0094\u008fR*O¦\u0010\u0012Òh4!\u00ad\u0011ÒÄÇaY×m`\u0097\fC£\u007fÂß¢/4ÑÄ\u001fà\u008f2Þ\u001d\u0090P\u0096´ôaçÞ9{ï¹sæÞÝ?\u007f\u007fþ\u0006PFÙ@\u0002;:v\rD°c@ÇóÀ{\u0011xY\u001d9\u001dy\u001d\u0005\u0086xÕõ\\Yc\u0088fs§\fÚ\u0091ß±\u0019V\u001b®g\u001f\u000f{m[´x»KHªá[¼{Ê\u0085\u001bì\' &?»\u0003\u0086bÃ\u0017NÉ\u0011¼ÓµKV×-ÕÛ\u0003)¸%\u008fü^\u008f{\u009d\u0080ìÈ÷Îm!mQaØ¸Ìõµÿ\u009f¯|\u0013¢j«U©\u0011\u009bn\u008d\u0011\u0086Ãlã\u008c\u009fóR\u0097{Né\u001d\u0085\u0004¬\u0095\u0019ì¤}f[²\u0092\u000bC¤\u0085\u000b\u0087´¬-¢ k\u0092ôÚ\u0096Á=,È\u008d÷¹\u0018Ø\u0082ak^ÀÌÁß«\u0018\u008a^tÊê\fÖ\u0094Âõ\u001c¥-J\u001a\u0019\u008c×_,»/]ß\u001bèØc¸Õt\u001d\u008fË¡ +;X\u009a\u008d¨r\u008aîCµu\u0018VQ\u000bCW\u0088\tuÁhúCaÙoÜ \u008f\u0099«ú¶\u001fÔ1aà6Cúºë2QÄ¾\u0089\u0012\u000eLÜÃK\u0086Â\r&\u0084!9¯\u0089a{\tQá23Quá\f{¶\'§M¡\u0086Ð\b~r\u001dÕ\u0090Ýìõ3\u0010|i153\f¯\u0016\u000emn\u009eDevf¨èÎß\u0086J\u0085£\u0096\u009a~-C\u007f\u0085\u0004H\bý;"d©9´\u009a´«\u0093edcù\u000b°\u001fäDq\u0087Ö¸\u0002SX¡Õ\u001c\u0007`\u0015I²w/!)²\u008c:·Fy\u0001Ý7²\u001aÙÍ_\u0088|¼@ô8_\u001cAË\u0017\u000b#ÄöF\u0088\u007f\u009fVX!\u000bÊK`\u009dö\u001bªR~\u009c;©\u0014xëô\u0086)ï>=\u0011\u008aNâ\u0001\u001eRnp\u008e´âØ\u009c\u009cc\u001cÿh\u001aÿ\u0098â\u009f\u0090¯\u0011ò\u0014Ï\u0094ô4=c/\u0083-e·ÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000×\u0083µ³X\u0004\u0000\u0000ì\n\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.class\u00adV[W\u001bU\u0014þN2ÉÀ0å\u0012\tH¡\u0015°Ô\u0084¤ÄKKµIQJ©\u008d\u0086\u008b¦\u0082Ø\u001a;L\u00860\u0010fâÌ\u0004áOøîZ¾ûZ_¢t\u00adºúìÿñA\u0097·}N.\u0010\u0012iÊ2Y9çì}öÞç;ûvòëßO\u007f\u0001ð6¾Q0\u008c÷e| `\bó|¸£`\u0001w\u0015,â\u001e\'?ä«û\nÒøHÁÇÈô`\tË=\u0098Å\n\u001fV»ð\u0089\u0002\u001f>íB¶\u0007\u0083xÀ\u0089Ïø°&c\u009dë\u007f.cCÆ\u0017\fÁ\u0094i\u0099Þ\u001c\u0083?\u0012]c\u0090\u0016ì¼ÁÐ\u00971-c¹¼·i8\u000f´Í"qB\u0019[×\u008ak\u009acrºÆ\u0094¼mÓe¸\u0099±\u009dB¢àhù¢\u0091Ð\u008bfb~Óõ\u001cM÷V\u001d»d8\u009ei¸\u000böÞ\u009efå¹Ù\u0005ÛÚ\'¦á$\u0019\u0006\nF]èp¥ä\u0099¶Å0\u0018\u0089fv´}-QÔ¬B"ë9¦U Ñ\u0091\u0016Ñ»\u0086§\u0099E#Ï0ÖfÏÕ\u001d³f±[·\u00ad-³Pv\bòTä4Ø\u0013ÐV5Ç%\\Ü\u0011Á\u0092X3L¾X\u009e¤íÚQgIW\u0091\u0091´¬W]Àp§\u0005\u008d0\u0099?¡\u0095¬:£ì\u0099ÅÄ\u0092VJFOÑ\u0014¹\u0092MA`i\nÒ®q¸¦\u0015ËÆâAÉ1\\W@\nµó¦\\\u0005ì¶AÜ\u008a\u0080A)5"É\u0093ã4\u0082¡æä8,Õ\u0013äF³hª\u0015J+g\u008e\f^Èz\u009a¾K\u001aÂ\u008e\u008c\u0087\u0004añ@7ª e<¢ fÍ\u0082¥y"¨ß¾´\u001b;D\u0012=\'þû\u001d\u0003\u0012\u009a+\u009b;\u0086î%£\u00ad,\u0086ü\u007f\u0015W»\u0092J\u009d\u000b/G¬dí²£\u001b÷L\u001e¶Xg\u0005<Ãm©x\u0015#\fý§íªx\rã*&0.ãK\u0015o \'ã+\u0015\u008fA\u001a\u0093|g\u0013º\u008c<ß¡\u0000o©(`[\u0086©b\u0007»*\u008aØSaÁ¦¼¾\u00ad¢\u0084¯\u0019 Â\u0081«ÂC\u0099\u000fû\u0094%M\u0097U\u0011Å4¥Ü¹z\u0011Ýù%ÜLEu|t\u009a\u0018\u009ag·1qBuÞ)\u0094÷\fËk$1Ãø\u008bú\n5ÖÈÃÖxE;i1g\u0018¯÷Yu[së°¨ª¯D:2ÜKZMÍu6ò?Al©\u0010\u0086T\'¶[ô\u001a\'\\íL\u0092z\t½\u001f¢o\u0092\u001fB\u0091\u0093E\u009f1]^\u0084½Í\u001c\u0086.³\u0011õ¡&\u0085z6ð\u001eK®Z6\u000e<ñ¶ÒS+Y\u0082h~ß\u001au.\u009bVÞ8XÙb\b·»u\u009a÷ù2©¿\u001biÕî°\u0095t»e\u009eÔd\u008f£N§Û¾³áH;¾4A\u007f\u001a\u0086Á?2\u0018/y\u001a/\u0012\u0095 \u0099j\u0013\u0081é\u009fÀ~¤\u0085\u000f£4\u0006\u00053\u008c1ðº\u0015\u0002¸\u0084Ë\u0080$ñ¾ æ\u0089Ú<Ég\u0092y\u001dWjFK$í§ùj,ð\f¾\rÿt\u0005þì\u0086D\u0093\u0094\u00ad °\u0014¯ ¸\u0014\'R® kýøÔ\u0010$\u001aG\tè\u0018}/a\u008aNä\bÆ«Öª\bÄj\u008a~\u008cäú¨ýDH\u009bñæARüôßèô Í¹\u0018?·\u0082î\n\u0094#ô0,_;\u0082Êð\u001d\u0016iq\u0081á9|·¤\u0011)Ô[Aßl \u001cø\u001e\u0003q"û\u008f0àÇú\u000f\u0018%Ê\u001f\u000eT\u0010\u001a\u0091Â\u0001éq\u0005¯Ô¶þù9þ\u0084N\u0090\u0004êËäR\u00907¦È\u00133ä\u0085wÈ\u000fó\u0084o\u0083\u0090="\\ü\u0006×\tÓ\fbô\u008dÓj\u008aèkDóÛæ\u001a·ÊQ0Þ\u0014¾Îá-ú\u0013é#KuïsÎuâÜ\u0010Q\u0091þÄ\u0080\u008cÙ¿\u0090\u0090ác¿cø\u000fÚº)\u0000Q\u0082á=áÐ[ýótx\u0092V\u0017\u0005\u0000¿p¢2\u001d\u008b?Ç`\u0005á\'g\u0004[©\u0081:¶é«YMá¶\u0098çþ\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adÎyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000org/gradle/cli/CommandLineArgumentException.class\u0095\u0091ÍJ\u00031\u0014\u0085Oú3£µ¶Zm+êÂî´U\u0007ÜV\n"\nÂàÂ\u0096îÓi\u0098Ff\u0012ÉÌ¨¯åªàÂ\u0007ð¡Ä$-U´\bfq\u0093{rïwOÈûÇë\u001b\u008034K(`Ë\u0084m\u0017u\u0017\r\u0002ç\u009c\u000b\u009eö\bê\u0087þ=}¤^DEèõSÅEØ=\u001a\u0012\u0014.å\u0098\u0011T}.Øm\u0016\u008f\u0098\u001aÐQ¤\u0095\u009a/\u0003\u001a\r©â&\u009f\u008b\u0085tÂ\u0013\u0082\u0013_ªÐ\u000b\u0015\u001dGÌ\u000b"î]Ê8¦bl \u0017*Ìb&Ò«ç\u0080=¤\\\u008a.\u0081\u001b³$¡¡¥þrAÐ^âí\u009b2\u0098(ùdæ[ÃÅ\u0080f\u0089&Õ\u0097V\u0010\u0094ú2S\u0001»æÆoë/c§\u0006PF\u0011\u008e\t\u0015\u0082Î?^E°û5ÿ.\u0013)\u008fÙâ\u0012-äõ/\u0098\u0095\u00031\u0013ttuÖÓyNïN»3\u0005y±÷+:\u0096¬ÚÔ\u0095;XÕ§Æ¬Jëk\u0096â \u008cuÍ0¬Ê\u009cu£gäõî¶;ÇSä~ÂötÓ¾\u0085\u001dÌÊ\u00160w\u000e3§*6¬ÅMÛ]û\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000³ßâú\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000org/gradle/cli/CommandLineConverter.class\u008dQMKÃ@\u0010}ÓÖÆÔ¯ª\'Ï"4\nF<6¥ EQ\b($xß¦ë²%ÝÈvSúÛ<ø\u0003üQâ6\u0085\u0012L\n]XvæÍ¾÷\u0086\u0099\u009fß¯o\u0000÷8wÐupJp\u0092L-¸6\u0084~/\u009c²\u0005óS¦\u0084ÿb¸fã\u0094\u0007%ìu<å\u0089\t¼*Dè<.\u0013þid¦æ\u000eÎ\bn$\u0085b&×\u009cpW\'<(a\u0091ÑR\u0089`\u0018ÄqàÙKxî\u0085\u0099\u0016¾Ðl\u0092r?I¥ÿÆô\u009cOFÙlÆÔ$\u0094jçÎ®w\u0090Úøºv\u001a\u001fR\u0014m_U\u0088%J¡¡\u0003ï\u009dÐ\u001bÄýªñ°vJQ\u0096ë\u0084?ÉÔê_\u0094äFë%p}»b\u0011.·;o¾\u0012ºÿ-\b7Û\u0089\u000fZä3®ÌfSm\u0002¡\u0081Õi¶\bM´l¶g³\u0096ÅÛplÔÀ~Qqk*\u001d[9Àa\u0011¯\u0091#\u001c\u0017ïÉ\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\nÕ\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineOption.class\u009dV[w\u0013U\u0018Ý\u0093¦\u009d4\u0099^\u0088´i¡\\ä"iB\u001bµ´ \u00adÜZ.Å^ÐÖ\u0016\u008a\bÓdL\u0007¦\u00990\u0099p\u0011ïwü\u0007¼ø¦¼ð .\u0081UYËå\u0093\u000f¾ù\u0017ü\u0019.\u0097¸Ïd:\u0099Ü¤Ë\u0087\u009có\u009ds¾³¿ÛþNæ÷\u007f~þ\u0005ÀËø&\u008cm8\'ã|\u0018\u0001\u009ckE\u001f\u0096Zq\u0001o\u000bé¢\u0018Þ\u0089à\u0010.Eð\n.\u008bA\u0095±\u001cA\u001a\u0019\u0019\u009a\u008cwÃh/ÝÊ\niEHz\bWÂ\u009c¯\u008a\u0085\u0011Âª8É\u0089Á\u0014C^Ü¾&\u0006KFA\u0086-A6ó¶næ\n\u0012:¦®¨×ÕTÑÖ\u008dÔ\u009cf\u008fJh\u009dÓ³9Õ.Z\u009a\u0084Ý\u0095§c¥¥¡æ²©9ÛÒsÙÑÃ¼¡¨V¶¸ªåìù[y^ÚäÓ\u001a7ÔB\u0081*\u009b«÷Æ\u0012âf$£\u0015Ò\u0096î8#!Z\u000b/!¬çÒÅeÕæJ\u0082´Dÿ²\u0096YÌ/êö\u008a\u0084¡jÿL+\u009bÊZjÆÐRiCO\u008d\u009b««j.3¥ç´YÇ\u0088ão8£å--\u00adÚZFBË\u0098\u009eÓíÃ\u0012bq\u009fùI[³ÔeC\u001bí_\u0090\u0010\u001c73\u009aH\u0015af\u008a«Ë\u009a5/Î\u0084ÃfZ5\u0016TK\u0017kw³ÅtÃ\tÚ+:3¼ëÙNUæÇ³-¡»Ò\u0000Óë\u001a©çk\u0083ê´ÍÙjúê´\u009aw®Ê(Ê¸.!¹a\u0004\u0091\u0081pV³g×)³)Þ_C\u009a½Õ{\r\u009c\u0089¬¨\u0085c.[$\fÇk¨Ò¿\u0091l\u001dª¹\'è´¡«{â\u001bRS|~2ävÆ?á§êæõx+ÉÚbi\u0085¢ÁÈzkN\u008f\u0017u#£Y¢ j>¯å2ÓZ¡ fYËT¼¡òR\u00ad\u0011Q\u008e\u0096\u0012\u0002ûxu\u001d¤\u009d\u000eWx8R\u008bº±\fE\u0019ë1Ã0oø\u0013Ð\u0014ïgëmñ\u008e¦\u0019¥\u009e74\u009f\u008a¢Ó\u0081r_q9éë\\\u0085WO\u0095\u001bw¸\u0096/\u001bjÝh¼\u008az"\u001d#ñÿ\u0081åÐzÎ,Zií¤.Zª»FkP *Ø\u008f\u001b$}ÙÂiµ°B+\n¶c\u0087\u008c\u009b\nna·\u0082]bèÇ\u000e\u0005ïá¶\u0082÷1£à\u0003|(¡³º\f2>Rð1>aÑÊ Sz\u0081´\u00895 \u0082\u0082½xAÁ$>U\u0090D\u009cé¼P~Ã.*8\u0085Ó\nö\u0095\u000eÊï%\u000f>Ã\u0084\u0082Ïñ\u0085¸û¥\u0082¯ðµ\u0082;ÂôÎg¥¨ÂñÙå+Z\u009aþEkß\u008cõM\'\ngÓ6-\u00870\u000bë\u0001:ú\u000b¦NV\u0004çÏ\u009f=!!¤{\u008aÝ\u0015LX\u0007`©e2zF»I«Á\u009c3Uö\\É%ÑN\u0015µ§e5CC]ñZ]Aá\u0081ºmÑ¸YC¶YÚb×\u0019Z.+ÈËØ&%ôÅÇÿëb\u000bÝ`¯ð)ð³sÜ4\fº"((¼á{±j^×ð<ÿ¸·ñë \u0005QÁ*°>\\\u0005¸\u001f\u0010ÄòÖ{ø#\u0013\u001c\u0099åæ\u001c\u0015\u009cóÎ\u0013ü%\u009dýNîíÇ\u0000×\u0083\\ý\u0081&\u00049\u009fI<\u0086\u0094x\u0082ÀùÇhz\u0088`âG4?DKyGN®!$azÿ\u001aZ%ÜÅV\na\t¿"2\u0093ø\tÁ\u00815(\u0001,Þ{úç\u0003¢\u0005\u0091â¸\u000b!\u008eÛ¹\u008a¡\u0003=èÆVú½\u0003£ôé$¥Ij¼H\u008d\u009dôa\u0014\u0011¼Dÿ\u009b\u0084/ü\u0016\u001a\u0002\u001ci;\u000eÐßaÊ\nçÒÎ\b¥\u0083\u0094»\u0010xÊ\u0090\u009adôÉ8$ó\u008b\b\u007f\u0011¬\u0014ð«T\u001aÅ\u0098\u001bf\u008a+q½Yøú\u0083£\u0090r²*6÷:^\u0094ð\u009b]Û%\u0090×¸w\u0018G\\\u009078\u00078Ë\u0089¤H\u008d\u0080ir`ÂÎv?/\'\u001c¨î\u0092\u009a\u0017\u0086ì\u0096ª\u001c\u0086ØÙã\u0015ç¨cæ\u0018Gaf\u0084;B\'\u0094\u0088FÖí\u0004|v\u0006évÊçrÈµ#áx=\u008c¶z\u0018CÄ8P\u0017c\u001c\u0013.Æ\u001d\u0016ÎÑ}\u0082vr c\u008a¹ëü\rJRÌ\u008f°i1!¤hô¹ÇØì\u0088]Ñn\u008aÉG\u0088\u0095S³\u0085\u0086À¯Ö\u0010«ÓÁ¢ô0§»\u0019ì \u0083.§jÈ5\u001f"GO\u0090\u001b¥ú\u0086 ý\u008d\u001e\u0099\u001fª\u0001ñ\u008e¹nÝæJ0¶·ï.b4Öó-ÂÉÎ\u009d\u008fÐ»\u0098\u001c\u0010n=ð\u008cw³"`<A\u0082F\b\u001b%H\u000f)$\f\'J ^\u008dz]ÃB\u009a$«\u0002\u008etÆ¡äA\u0087Ò\u0081h3Ï_Ç\u0094ëÈ\u0011?\u001d:kR<Mã3\rè :U\u0010r\u009a\u001a%°\u0013nÁ:\u0099Ç\u0016öÞw\u0090\u0083÷\u0010lºï\u0005Sâê\u009b¾¢uº\u0088\u0007\u001dÞ\u0006Ú\u008f\nÈY\u000frÂ\u0085ì\u0010\u0090Ñ¶ï\u001b .ø\u0010;*\u0011Û\u001cÄ¤Çªa\u0017QN\u0004\u001f"Z\u0013ñ\u0012ï\\ð¡É\u001e©öÕ\u0087èª\u0081¸D\u0088Ëu!Îzqù{9z¿ª\u00973uzYbçÖ»ÜU}y¥Îe\u0091òz¯\u0088\\ý\u008a\u0018\r_\u00919çq\u0098wA4\u009761\u0001ÂGu\u000b\u009fM!&Ö°\u0095b\u0099½íÎc\u0098\'s¯\u0091B\u0096\u008fJ1Ï·\u0098û§P~YÄNÂ{YÞ¢´àH\u008bÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000üí\u008a¯¥\u0000\u0000\u0000å\u0000\u0000\u0000(\u0000\u0000\u0000org/gradle/cli/CommandLineParser$1.class\u0085\u008cA\nÂ0\u0010Eÿhµµ\nvåº\u0088k\u0083^¡(\b\u008a\u0082\'\u0088íP[Ò\u0004\u0092êá\\x\u0000\u000f%¦¸tá\fó\u0087\u000fïÿ×ûñ\u0004°Æ8D\u0018bD\u0088ÏæfsÞV\u008a\t³Ì4\u008dÔÅ¾Ò|\u0092Ö±]Öò.\tÓ\u008dÎ\u0095q\u0095.\u000fÜ^M\u0011"&Ì\u008d-Eie¡Xäª\u0012?áÅ\u008a0ÙiÍ6SÒ9v\u0084¤ë\u0013JêR\u001c/5ç-!ýW\u0093¤ ôð\u009d¾_x\u0017`à\u007f\u0080¡×È_ì\u0019ê\u0080$ú\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099ÐÆ\u00adN\u0003\u0000\u0000å\t\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classÅVëN\u0013Q\u0010þN[8e[ TA¼#V\u0084¶Ð\u000b" \u0088\u0016\u0094\u008b\u0014\nAIðß²¬u¡ì\u0092í"¾\u0082Ïá\u000b`¢A%1þ3ñQ|\u0006c\u009c³[ X`\u000b!ñÏ9sfæ|sÙ\u0099ÙóóÏ×o\u0000Ò\u0098\u0097Ð\u0080D\u001d-I\t\u008dHHH!\u001d@/îqôqÜ\u0017\u0092\u0001\t\u001c\u0083\u001c\u000f8\u0086%\u00040"AÂ#\u008eÇ\u001c\u0019\u0086ZëµV\u008c$\u0019Ú³\u0086\u0099OäMy¥ &\u0094\u0082\u0096\u00183Ö×e}%«éê\u009cl\u0016Us\u0088´\u00875]³F\u0018&:ÝÕÿÕ°Ù+ezC]\u008b\f¾1cEeh\u0014\u008cÙÍõeÕ|./\u0017\u0088\u0013Î\u001a\u008a\\X\u0094MM\u009cKL\u009fp\u0097ábæ\u0095¥\u009aã\u009aY´\u00166\u0097K\u0090\fÁ)]WÍ±\u0082\\,ª¤Õïêcä(\u001c\u008a3 \u001ch\u001e\u0091\u009aÊH\u0018ê\r}Á\u0092M+·ai\u0086Î1ÆÐäÐ\u008e)\u0012Z\u0084õ²3»*¿\u0091\u0013\u0005YÏ\'\u0016,SÓóC\u0095\u009c.wÏ+°É\u0007¯læEâ*ðèË\u0019¶>9U\u0016Z®Ä;éÛ;:"@²¢¬ÍÈ\u001bö§àxÂ°v.Uà\u001ekÊ®\u0014ÏÛ¤XRbI3Dª¹Ç -\u0018\u009b¦¢\u008ek¢|Z*tzD®\u0082\bãB\u0010!4q<\rb\u001c\u0013\u001c\u0093ALá\u0019C\u009b[j\u0018\u0006]\u001dy¡¯éÆ\u0096~D=´\u001e\'\nâ*®\tÇf¨\u0090]\rL\u001f\u0003ßr\u009c »Ê\u0002s\n\u0088Z«ü(Ü\u009a\u0015K\u008e¡ïL=VML\u008eÅÌ\u0096lª\u0087c:N\u0090>}ÓPí»WÑ\u0089Eà(Q\u009dÉ\u008a¢\u0016\u008b\u0091\u0081$Uio\u0015\u008dÑå´é¦¥\u0015\u0012ÔU¢Ã\u000e1¨\u009dóªÅÐQ>1rË«ªbíÝ-gqÌÑÜ:\u0014Ú»£fÍ9´cùÐ©¶y§«\u009a{Õ¢ý:Ãà9¹ÂOR/\u008dÀÿ\u0095ºøiPÑF¿üFz\u001c°PH\f4¢¼ð\u0088ù\u0006úmÒi\u0092Î^Ú\u0083ÑØ\'x¢±ø\u000e¼\u001fèìA3\u00ad\rBÆ&PÃ&\u0011`Sh!^\u000bÉH\u001f\u0097p\u0005°)\u009aLÄc¸NÖ\u001cÔ÷ðÃG{&ú\u0011\u009eÏðÅ¿ Æ\u0083ï¨\u009díþ\u0081ð.øR\u008c$þ(ÛAÝö.¤%¡·\u008bÀR,N¬`÷\u009e°~ÛvX¸\u0012\u0016\u0080l\u0006Ml\u0016Í,\u0087\b\u009b·Ý\u0089:\u0086öÝÉà\u0016ÚÉ\rAÝ&ÊCA\'\u0011Á\u001dÂé ®\u001fì7"\u001cµ!\u0081ÙYr8GR\u0081Ãí\f°\u0083\fÔ\n(6^f\u008aï\u009bâè"pfSQ;\u0007\u0082\u008a!nç¸ÛÆèÁeÚGÉl\u0003=ÆZ\u0089s\u0083ö\u009b>\tw\u0005DÈO7Rè\u0087x\u0085¥0Dò\u0000í\u000f!Þo)\u008cú<\u0098¦=ë\u0093þ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¥\u0019D£¢\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.class\u00ad\u0095mO\u0013A\u0010Çÿ{-½r-´¨ >W\u0004\u0081+p\u0080\u008a"ÆDð!$\u0015M\u0090Fxa²´g9½î\u0099í¡ø\u0011ü.¾\u0090D%ÑÄ\u000fà\u00872Î^ÏrÒ\u0092\u0003c\u009aìÎÌÎþffwnûó×·\u001f\u0000fqÛ\u0080\u008eQ\u0003i\u008cu\u00934®£h \u0089I\u0003S°tLë\u0098aÈT¼z\u009d\u008bjÉ\u00116ÃPÉ\u00935«&yÕµ\u00ad\u008aëXO¹lØÕ¥}\u009f\u0005\u0086Ô\u001dG8þ]\u0086\u0091±x÷ñ2CrÉ«\u0012<§\f+ÛõM[>ã\u009b.YN\u0094¼\nwË\\:J\u000f\u008dI\u007fËi0dï½ômùä\u008dïxB©ËBØrÉå\u008d\u0086Mªu0r$f\u0090\u0084\u001c\u008eî§¬óuþ~Ó^õ¹ô\u009bF\u0086þ±Ò+þ\u0096[.\u00175kÕ\u0097\u008e¨-\u008co0$¸¬©äÚ\u0016\u0019z<\u0011Aè\u0098eèkÊÍ¨´èS\r\u001b\u001dÈ\u001dbÅ\u0017ÑÆVçï\u0085ùg<±â\u0089?ÕdþÊ`±Smññ¢\u0091t\\cX>Â\u001dÇcg\u0082>Ðv¦Õ@]7|\u0094-\fÆª·-+öCGõÅ@\u009bÏ\u0094ª0\u008b\f²j¸\u009eE7\f\u001d7\u0018æcékâµðÞ\u0089\u000eW7xØ\u0092\u008a1§ãf\u0016·0Ï0y¬\u0006d\u00988ÎÙ3Ì\u001e¿5èó\u008d?U\u0086Ñ¶\u001b=ì¾\nq~\f\u001f:5ú\u007fh\u0098h\u001fþkºmqéóåÕê\u0083\u001d_ò2w·íC^\u00802\nô\\¦é\r¥G@õ\u0014I]ÐT\u009f\u0091¥\u0087´G¤i4gL¶\u0007Í,~Ab\u0097T\r½4ö"A;\u009f£\u008b\u00adÃ`\u001bÈ\u0091m é\u008e<N\u0002\u0081¤°\u008c~§Ð\u001fBçhV^Zâc\u008b\u0095"\u001bØ\u008b\bCk14²\u009c\u000e\u0018\u00838\u00172\u001eÓ\u000e\u008a\u008eÜw$×\u008bæg$T\u0086]\u009f\u000e\u0000+\u0001°Ðtm\u0001s!PIçIÒH¾\u0080K!z1¬ÙPÔâW¤Ì}ª¡VØ\u0016ÒÌ\u0089¤j´ÈF\u0093\u009cW\u0085_\u000ey÷ÉGÅO\u0099Å=°Ý\u0003\u0019®E2Lµ8)\f\u0005Ç¦¤+\u0018\u000e2\u001a\tv^¥\u009b\u0002Lº\'\u009dÆ>ò:CóÙ¤ú÷3q\u0091æ\u0082\u0002äÓô\u0007hb\u0002ÆoPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¤ÇÇà\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classÅVëRÛF\u0014þÖ\u0016¬#\u008bÄ¸\u0098\u0084¶¤\u000e5\u0001|ÁÜ\u0092`\u009b$\u0005\u009a[qpZ\'´&½ÉBq\u0015l9#ËM^¡\u008fÐ·HgÚ!)Ó¤ÿ:Ó·èß¾C;=+9`b\u0083L&3ý£Ý=ûé\u009co?\u009d=:\u007fþûë\u000b\u0000sx c\b\u008b\'è\u0091\u0091\u0011Á"GN\u0086\u0084%\u0019Y\\\u000eâ\n®r|$\u0016Ë\u001c+\u0002ö±\f\u0019×8®\u0007p\u0083ã¦\u008c[øDÆ\u0000Ö8ò2ÂXç(pÜaè·¿3\u001a±\u0019\u0086±|Ýª¤+\u0096ºUÕÓZÕH¯Ök5ÕÜÊ\u001b¦~Gµ\u001aº\u0095#ô\u0092a\u001aö\u0015\u0086\u001b\u0093Þð×\u0011\u008ey«\r\u0097\u009bÚ`\u0090Vë[:Ã)aXoÖÊºuW-WÉ\u0012Î×5µº¡Z\u0086X·\u008c\u0092 Ë\u0010YÑ\u001fÔ-ýºa5ìb³ÜòÉ Ü2MÝZ\u00adª\u008d\u0086N°EO\u0092±®\u008eè¤Am\u001fÚE\u009cÎ³0\fÔÍ¢\u00adZvá\u0091mÔM\u008eÏ\u0018\u0006Ý¹\u001b\u008b6mòµ9\u0099\u007f¨~¯¦«ªYI\u0017mË0+¹NË\u00947õ\u000eßÄÁ¯Z\u0015!]\u0087?úvu\u0007O"¹\u0013w\u0083\u0096\u0085\u0003Ët¯\u0081÷\u001c\u000f¶IUhÅ8*\u009b\\\u008c\u0010\u008cXkÛ·ÕGÎÇå(2l¿\u0095¼ò>Â¬\u0093{¾\'3â1+\u001es\f±^Þc\u0090\u008bõ¦¥QÎ\u0088\u0084\u001cîÀL\u000bí\u0015\u009cÁ\u0088\u0082a\u009cæ¸Ë\u0090:\u0096¦âå{\n6ð9Ç\u0017\nJØd\u0088zé©à>¾dÈxFºgn\u009bõÇf\u0097Ì<sØ\u0096\u0082s\u0018\u0013¬¾aH\u001c\u001e`Ùª4kºi_{¢é\u00ad<8×r\u0019måHªJ¸¨\u009b\u0080Ñ\u0089ñÆÄ4Ch?Y\u000bå\u0087ºfs|«@EYDÔ\u0018.y\u001eií\u0090\u0003\rwß\u0010~©X\\|³âÐ\u000b!7äòcÕÒ\u000f\u0012:lcîø·\u009d.\u0099wº\u001e\u00998.\u0088a\u00ad§\u008aÔë¥\u0092UMÓ\u001b\u008dØâ\f]®ù\u001eîó\u0094\u001b«i\u001bÕ4\u0015\u0003Q\u0018\u000e\u0018¨ªUt\u009bá|;M7S^½ÛnÚg\u0090\u0011\fÆ{a°ÉAz\u0006\u000f¨ûC7UÞBéi/Ø½j\u001az\u009d\t\u0095sJÍ\u009aJ²dºð¼\u007f´R{¥;Òå]\u0011ïï7(Ã\u001eÿ\tï\u001fÂÿ%nò8^\u0011¥î*BM\u0019\u000b\u0085Dy§\u0099\u001f>QíÁð.\u00adnÒÚO£\u0012Oü\u0002_<\u0091Ü\u0081ÿ\'Zûð\u001e=O\u008a=6\u008f>¶\u0080 »\u0080÷É6L{\u0084Ç(ù\u00863£jK6\u0086\u000fq¾åõ/\u0004ÐG£¾\u000b©\u0094H²\u001dô\u00adÇ\u007f\u0086ï\u0019ú\u0093ÏÁ}ø\u001d\u0081¬4"ý\u0081Y×|âG\u0084w!\u0097\u0012´\fÆ\t¯<ÝÅ@)|Rú\r§JþTñ\u0019B;\u0018|¹\u008bpI¼\u0091\u001a\u0091^!ßyê\u001cJÐ=\u000bNt3D5\u008bQ\u0096Ã\u0018[B\u0092]F\u008e]¥æqÅ¡¿à\u0012Û£¯c\u0002\u0093D[Ì¦hæC\u0010\u009b\u0088#I>GI\u009e\u0014¦©uM;\u0007õý\u0083\u001c\u0087Ä\u0011\u0018\n\u0081D\u009cm\u001d·@X\u0089FîèÇöõë\u0017\u008eÙ\u009c\u00138îBö\u0002sj\u0094O;\u00819æ\u001d\u0005Ål\u0001\u0017\u009c/tÑñq\t\u001fÐ¸Bj\u000eQ·|\u0096,1\u001aÇ%ÑMg\u0091 ¦yF¸\n\u0005 ºéU\u0088^9\u008bÛ\u0084\u008bÐø©äÃW4~-Éÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000´*«ZM\u0002\u0000\u0000ï\u0004\u0000\u0000F\u0000\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.class¥S]O\u0013A\u0014=wû±P·RË\u0087\u008a"\u0088UhA\u0016x1¦\u0084¨ML\u009aÔ\u008f¤\u0084÷¡\u001dêàv\u0097Ìn\u0089\u007fÅÿÀ\u008b/\u0098ø`|ö\u001f\u0019ñãÎî\u0006\u0083EkâCçÎÜ9÷Ü{Ng?\u007fÿð\u0011À&6\u000b°Q)`Ì,9Ü5Ë=\u001bK&½l£fcÅÆ*!¿¥|\u0015m\u00132ËÕ]B¶\u0011t%a¢¥|ù|Ðß\u0093zGìy\u009c)·\u0082\u008eðv\u0085Væ\u009c&³Ñ+\u0015\u0012æ\u001b"\u0094M?\u0094~¨"u$Û\u0091V~¯\u0011ô\u000f\u0085\u0016Q \tNÓ÷¥nx"\f%\u0017<i\u0005ºçö´èzÒíxÊel_ø]Óõ¥Ð¡Ô\u0095\u0011\u0094u\u0082Ý\u0089O<ÆÒrë@\u001c\t×\u0013~ÏM\u0090õáLµÉ5Áa¤\u0002\u007fÃè\u0019\u0002\u009c]o²²®Úß\'\u0010×\u0014Û\u0091è¼~&\u000eSÑçº½Ø;\u0090\u009d¨>\u009c©6mÜ\u008fÁ#¥nÔ\u008dóÖ\u009buBå_Ð\u0084ñ¶êù"\u001a\u0018ñ[\u007f\u009af\u0010)ÏýåØÖ°àm¦*´\u0083\u0081îÈ§ÊH\u009b\u0019j·f\u008a\u001c\u0014pÉÁ\u001a\\\u0007ëp\t¥ß©\u001cLbÊ\u0006ûúè\u007fÿÙsì\u0089 ÂÔE\u008a\b\u008b£Ý"L¦ïd\'höü@KÓ\u009f0}Á\u009b1/dü\fMX\u0018EÏnØü\u0085q\u0015\u007fsYXÆ\'>9|r9\u0012Ç\\í=¬w¼±Pä5o\u0092ô\u0005\u0097yï$\u0000L Ì\u0091\u008c\u0085i±ft\u0096cyeõ\u0004\u0099í¹·ÈÍ\u001d\u009b}ö\u0098³\u0099\u0098©l\u0010ô\u0015y:E\u0081¾Á¡\u001f1k-©LYÍn\u001a3q§2®òÎâ\u0019\u001c\\Ãuæ\u0099M&:åâÒcî\u007f#íÿ\u0080ï2\u001c\u008bµ\u0095OÈ\u00adòï\u0004ùã¿\u0088(&íJ`\u0007æR\u0092\u0087\u001c\u00adÔ\u0001ºØ\u0081\u0099\u0004p6k\u000e·0Ï÷\u0019,ÄøÛX\u008cã\u001d\\\u0089ç·Øî*w\u0099ÅM\u0003/\u008dý\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0006è2\t\u0004\u0007\u0000\u0000Á\u0011\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classÝXûw\u0014Õ\u001dÿÜd\u0093Ùl\u0006\b\u0081\u0004\u0013\u0014FMH²y\u0012ð\u0081bÚ\u0098\u0082\u00046\u000b6\u0018\u001añÁ°;n\u000663qf6\t¾ÛZmëûQj\u0000\u0081\u0016\u0094ji\u0005k\u0012R U\u008fµ\u00ad\u0087\u007f£çôôOèá¨ßïÌìn\u0092]ØÄ\u001fýåÎ÷~ï÷u¿Ï»ûÕ×\u007fý\u001b\u0080NL\u0087Ð\u0004µ\u008c\u0096ý!\u0084\u0011\u0093\u0010\u000f!\u0000\u008d1\u008fñ\u0092àe\u0088\u0017\u009d\u0097\u0003L\u007fPB2\u0088a\tF\b·Â\fAÆ\bC\u008f\u0007a\u0095Ã\u0086ÃD©\u0010\u001a0ÊÛ1\t\u0087BX\u0085\'\u0083x*\u0084\u0016<\u001dÂ3x\u0096O\u009e\u000ba7~Ê\u0084?\u000bâç\u008cy¾\u001c\u000fà\u0017¼¼ áE>þ%\u001fÿª\u001c¿Æó\u0012^bÖ\u0097%¼"áU\u0001Ù\u001cqtÓèw,ÝHHx\u009d0;gahÛk\u0018\u009aÕ\u0093Tm[³\u0005Ú#¦\u0095hOXj<©µÇ\u0092z{\u008f9<¬\u001añ\u0088nh»TËÖ¬ºÙüw\u000b\u0094z\u001a\u0004n¹\u000e«ÇCÔå±,2\u000f\u008b«">\u008b\u0091XJlGu4\to\u0010·gB?#\u0004Ú\nÛ:\u008b\u009eM\u001dU\u0093)¾eEä\u0080:ª¶§\u001c=Ù\u001eÑm\u0087ÎÊúõ\u0084¡:)\u008b\u0004×Í;Þìí\u0093ª\u0091h÷ïÝÅâ\u009c!Ý®ë¸þÍ=\u000b\u0098z³nèN\u0097À\u0097\u008d\u0085É\u0017\u0019\u0085Â\u009e/ìèÅ9³i@ ÐcÆÉ[Ë\u0098$\u009a\u001aÞ¯Y»ÕýIÂTFÌ\u0098\u009a\u001cP-\u009d÷>2ÀÞ\u0012¨Þa\u0098c\u0086gÕ\u009chn*l@~VòmÈ4º\u00adDjX3\u001c\u0081{\u001bsÃÕ´ØT\tª\u0019y\u0095¹â\u0004\u0096\u0010aì`\u009f:âßn)ÇBµ\u009c¨6î\u0090)\u0002\u001d\u008d\u008bÖ¹4¡9ÛT;{\u0093âÆ¦\u0007ÝË\u0011çHRc/\u0095¸)L\u0095`:C\u009aµÓ/=yÄ\rgz\u009b\u0093`9Ñö³BÂ\u009b\u0012Þ\u0092ð¶Àÿ¾\u000fYY\u0098z½\u009b¹Eã\u001d¼¬ç¥\u0093\u0097\r¼läå6.ÿ\u0005\u0088¡¸ô\u009b)+¦mÕ9þÕ94m\u009c52ºð\u0003\u0019\u009bq\u000fC¿\u0011X\u0091í,Ý\u0096¥\u001eâöÂG\u0087eÜ\u0089M2\u009aÑ.£\u0003ëe\u001a<\u001bdlÄ\u001d2ú\u0010\u0015h¾¶Mé\u0084Ù2\u001eÓü\fØà\u001f·&é\\ñ:´ÒPo7(qS³\u0015Ãt\u0014G=¨)ª¡¤\u0013½\u008dÚb6Ñwî? ÅÈ²ßâ\u001d6oBÆ\u0011\u001c\u0015ØÜm(Úð\u0088s(Ã¦\u008c©¶2b\u0099£z\\\u008b+\u008f\u0099\u0096\u0012»\u0086ê6\tÇd¼\u008bã2v""ã\u0004¢2N"*áw\u0002·\u0017ty\u009fnÛ\u0094U^æÐ\u0095ý¶Q\u0095\u0017Ï6ÿ\u009e¤FÍïb¨\u008cS8-á=\u0019ïã\u008c\u008c?à¨\u008c\u000fð¡\u008c?r$ºúRIG§zÌ\u0088¶\u00951ÍÒ\u0016,ü,þ$ãÏ|û\u008fpn\u008e×½Â\u0091q\u009e\u001dþ1þ"á\u0013\u0001¥P\u0019É\u0098Ä\u0094À\u001dß±\u007f\nt.°®ç0-Ï\u0083k]T\u0083\u0010hYLu\u000b¬[X[£\u0096\u009d\u00ad²^G³TÇ´hJ\u0017®j\u0081\u0086ÂmÐï!Ô\u009ci-¥X\u000f«Ô«7å\u0099:{#ó\u000b\u008a\u0006Q\u009eaR\u0095ob±ð¤f$\u009c!WW/Í\u0087¹¯\u0012B«ñø<î´\u001a\u009a\u001b\u00954Nº\u0093Is,3QhüJº½\u0085ë÷ºiåÝS`ï\u0002\u009c\u0091;\u008e\u0017êÀr5\u0016Ól»nýÆ\u000eêÆ=\u000bÖ\u0095\u0019éy<9ÿR9\u0019B\u000f=rZ:O\u001eÉãøÂS+g°_k¼Ò£ÇÖ\u009f`\u009d\u0014\u008a\u0001ÿíYÙØ\u0094ûú¬ÍÄ*Ý\\fÅ,¨gr¸z\u000es:·I\u00804¤Úüö \u0095\u0086ûYÙØ\u0094\u009b\u0016ìôx<ûÀ\u0090Ií}\u0096\u0099\u001aÙ£s\u009a-\u009f#½_c\u0086%s\u0010ÄbiÃæh¦Òê¯\u0017¶´¿\u0006 Ð¯\u009d0ý\u009a*E%\u008f8\u0082*yÊ¹_\u001atî\u0097f\u009dû¥9\b\u0081»\b.ÂÝ\u0015\u0015<<]Î"\u009e¥tòCÚ\u001dF1a\u0080\u0096pó$\u008aÂb\u001aÅá\u008b\b\fN£d\u0012¥á\u0096IHáÖI\u0004Ã5\u0081I\u0094\u0085k\b\u001b:ïJì¦u\r$@\u001cAH¼\u0083*q\u0014µâ\u0018Ö\u008awQ/\u008e£Y\u009cÀ½D³\u0011%,\u001f=Ø\u0002¸\u0010Û]äBly±\u000b±í\u0001\u0017bëKÈº\u00ad¸Ï·ñ$iaúhx\nåG°ú"äÁÊ%\u0081ËX:X\u001cþ\u0004Rÿ\u0005,\u009bFÅß\u009b§°<}\\\u0099{Lpió\fV\u0014a\u000f\tZy\u008e$\u0016»·¨e\u000f\u0088S\u0090Äi²þ}¬\u0013gÐ%>@¯øÐ½Aµ§=s\u0083(¶¡\u0097lÛNp\u0000Ek×\u0010¼\u0003\u0011ßÚ}\u0084\u0013ô\u00ad\'}Á)TM \u00865Ï Z`\u0002K.bÕ »ù\u0086ss\u008dXÊ\u008e\u0010\u001f\u0011Õ9(âcW±ì\tò\u0015owi\u0085BHzÈøÚ:éËDA_ÛÙLlJ\u0019O\u008a²\u0082\u0082¾ ÁÏ\u0006\u008f_¨ä[öû\u0015öí\u0004\u001af\u0099ê9²&¯#Ëx\u007f\u0001µ\u009eÖÕ\u0011\u008fíFz]Má&\u0017Ø\u00178\u009dvÁ\u009atPÖæ\u000fÊ\f]\u0018}-3¸\u0099ÕV\u0011p\u008bÀ§¸5ÚÜ:\u0085º3ßü×\u0013S?C\u0091ÉÒÝ\u0090¦k\u0088²ADÚxæ\u009bÿ\u0010\u0018Ê:µ\u0093n\u000eq\t+ÄeÊÇO)ª\u009fáQñ9ÆÄ\u0017ôTÿ\u0007&Ä\u00978&þ\u0085KâßøB|\u0085\u007f\u008a+®¿Âä\u0093·)\u000bwQ\u009c\u008bq\u0089<w¿\u009f©W|\u001fváUü\u0018ý~\u0016¬¦Ìº\u008a\u001d\u0012v_E\u0099\u0084\u0007þ\u008fÚ«\u0090]à¦\n&Þã\u0087Ë¢°H\u001c\u0090psKkM ¦d\u001aâü¼\u0090½å\u009a°Í£Ë$\u009d\u008c\u009fPù\n\u0017\u001aô\u000bHÆ\u0083¾Y2öú\u0005$ã!·\u0080\u0018z\u0018\u008f¸åþ¨«a\u001fÚ\\\u0097\u0094R\u0091\u008d£\u0015!ÜFßÛ\u0003ü\u0007Ê8~D\u0014\u0003¬¨"\u0088U´\u007f\u0002ü\u001fÍ8^\u000b\u0084¾\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$Ä¾¢¥\u0002\u0000\u0000ô\u0006\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.class\u009d\u0095mOÓP\u0014Çÿw\u001bÝÖ\u0015\u0019*\u0088\u008fLDÙ\u0003²\r\u0091!¨\tÎ\u0087\u0018\'\u009a`0ÁW\u0017ÖÌ\u009aî\u0016o;¢ñ\u008doôÓøB\u0012\u0085Ä\u0017~\u0000?\u0094ñÜ¶Ì\u0001K\u0006Ë\u0092î\u009cÛs~ç±í\u009f¿¿~\u0003\u0098Å\u0092\u008e\u0004r:\u0092È\'I*(uZG\n7ÕÙ\u008c\u0092\u008aq\u0094ã\u0098eÐ\u009c-ÏrD\u001c·\u0018\u0086_øòK.]S®zÜ3\u0019\u008c§B\u0098²js×5]\u0086¹\u009a#\u001bÅ\u0086äuÛ,nÚV±ê4\u009b\\Ôk\u00960\u0003¿É#\u0090%\u008ar×\u0012\u0096w\u009f¡\u0092í\u0007\u0090[c\u0088U\u009d:å3¤\fWZÍ\rS¾â\u001b6\u009d\u009c®9\u009bÜ^ãÒRzx\u0018óÞZ\u0094îÈsËu-Ñ\b\u0090Ë²\u0011VµÐ;\u008b®\u009eTJºÉ?n\u0098¤I/¸GQ²µw|\u009b\u0017m.\u001aÅUO\u0092ÛRn\u009d!ÊeCåwä&Ã #\u000e Ö» º@ûë~Ê\u0011+\u008eØ\u000f\u0095:0ß\u0007Ýrï\u001dæ`\u0080´#:L\u001e\u0089:Õ\u009eÍ\u00adÅ1Çð¦¯\u0089÷ö)û[\u0011ùPR\u00972Ãäq\\\u0018ôU§%7ÍÇ\u0096Ú\u0092Ñ#63ª\u0019\u0006\u0086\u0090V\u0097Û\u0006t\u009c20\u008f1\u0003\u0015,\u0018¸\u0088K\u0006î`<\u008eE\u0086ùþ\u0096\u0088aú$ýe\u0098=y\u0003\u0019&z·\u0083aê\u0018Ã\t\u001a\u009d°Üý\u0005ÒýioÙ¦\nSÊ\u009ex[t¿\u0015\u00ad¦)<\u0086L/gdèí\u0095¤÷\u001a=Ij\u001a$i\u0088¨\tÑÉ0iOH\u008bÐ\u007f*Ïö\u0010É\u0017~"ºCj\u0084ÌAæQòÜÂ\u0000{\u000f\u009dI\u009c¡³ÑÀ\u001cgI\u0082/),£ß9\u008c\u0085ÐÅ\u0010ªå\u000b»\u0088}kó4º\u000f¶ÝÁÑÚ\u001c\rçqÁçÐ\u0096\u0084\u009cg\u0014\u009f2À`þ\u0007¢»\u0018(LïBû~\b÷ÉÇe\u0002Ã6n0Ä)I\')Bòe\u008c\u0087à{a\u0082I\u0005¦\u001cã\u0087¡\u009f;rL¶¡Év\u008e\u0019\\\rQ\u0015_\u000fQ\u0094ãëÿíÓ\u0095;û\u0082\u0004ûêã\u008cÀ0À¥AS¸\u0016B\u001e\u0092e4hØ\u001eØÎ¡d\u009a\u001d\u0015v6lÒo¼\u0092®ã\u0086_Ñ\u0094ï\u0099¥\u009a\u0081\tÄh8%\u00181õ\u0005+a\u0004êûUÂ\u0015Ò\'\u0014 \u009dø\u0007PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>ª\u0002\u0000\u0000Ä\u0006\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.class\u00adUÛnÓ@\u0010=\u009b¤qâ¸$\u00946\\Ê%¤)MÝKÚ@)½p)\u0015E\u0015¡ \u0005E*o\u001bÇ\u0004ÓÄ®Ö\u000e\u0085Oá\u000bxá\u0001$\n\u0088J|\u0000\u001f\u0085\u0098MÝ\u0092*A.\u0015/Þ\u009d\u0099³ç\u008cgfí\u009f¿¾ÿ\u0000PÄ½8\u0012È©Ð0*w×Tz\u008c©Èc\\\u0085\u008e\t\u0005\u0093*\u0014L+(¨\u0088cVAQÁu\u0086\u0084á4\u009bÜ®\u0095,ÛdÈ\u0096\u001cQ/Ô\u0005¯5Ì\u0082Ñ°\nO¹pÍÚê\u001fÌ\u0012CÔ{i¹¹\u0099\u001eè\u000e\\û \u0090èeË¶¼;\f\u000fóÁð`ùñ\nCdÕ©Q²IéØh5«¦xÆ«\rò\f\u0094\u001c\u00837*\\XÒö\u009d\u0011\u0099.CúÉ¶g9öÊ\u000e\u0017¾ZÙã\u001eÅµuÛ6Åj\u0083»®I¸\u0085À,s½\u0099è]SMþ¶j\u0092%¼}\fÃP¾ô\u008a¿æ\u0085\u0006·ë\u0085²\',»¾4þ\u009c!ÌE]&Ü\u0015¤\u00968ö\u0086c\u001f\u0010$\u008e${¿\u0017]pÆGÓì§\u008d±õ\u0098oû\u0015RËNK\u0018æ\u009a%\u008dt×éi©¨!\u0089\u0094\u0086Ó\u0098ÓÐ\u008fS\u001anbXÁ¼\u0086[XP°¨a\tË\fs\u0081\u0099¬¼ðL±f\t×+·ª~\u0098a°\u0097[ªÝf\u0098:\u001eç~½¨\u0081Z§)9höæOØS\u0086É\u007f©\u00ad\u0082»\fcÁs\u009e\u009bmÏqÌr\u000fº\u009c\t\u001a|ê\u001a¯Õ\u001e¼ñ\u0004¯ðFËüËdUº©ºÔ©áÜ0L×ÍÍÍÐ-\u001e=Æ½\u0094\u0013»õ_îïqk³Þ¥vr®l0.\u0092¡Ï¥F\u001fÒ\u0010\u0006å|\u0003©\u0094\u009cxò\u0084\u0011¡!\u001a\u0000Ã\u0019²J\u0084\bÓ\u009aÒ\'vÁtö\u0015!}r\u0017áOþYÐY\u008a³,T6\u0082$Ëa\u0088|i\u008aÑ\u0019ZÏ\u0003í\u009dÔ\b\u0011ç\u0005\fûÌ\u008bdKTT\u009fø\u0082È\u0087C¾(ÅÁò\u001d<ÑC\u009e(.â\u0012Å\u0019.#ãóì ¯\u008d*ê\u009f\u0011&ª>ZÙ7Dß!½\u0007eSZ2B\u0099ÇÞ#¹\u0087ø¦oª\u001fÛo+5UÉÀ¦\u0010cÓ\u001dºÅCÝ¢¯{\u0095ö\nB£\u008f\u0014*^\bÙvÒ#8G«Ni$èy6\u0012¢\u0098\u008e+\u0011ùÿÑ1E\u00888\u00ad3$r£]\u008bØoPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%àÌ»\u0002\u0000\u0000ª\u0006\u0000\u00007\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.class\u0095TmOÓP\u0014~îÖÑQ:\u001c¯\n¾\u0080\fÝ\n\u00832@\u0010\u008a\b.Ñ,YÀd\u0086Ä\u008fe4³¤kIÛ\u0011\u007f\u0086?\u0084/~\u0001#\u0089á³ÿÆ¨_\u008dç¶\rN6).]ÏË}Îsî=çô~ýõù\u000b\u0080E\u0094%d0#¡\u009f¿ú0+bN\u0082\u0000UÂ\u0002J"\u0016E,IHs;\u008d\'"V8|UÄS\u0011k"Ö\u0019z6LÛô7\u0019\u0092\u0005e\u008fA(;\u0007\u0006Ã\u00adªi\u001b;\u00adæ¾á¾Ñ÷-ò\fV\u009dºníé®ÉíÈ)øïL\u008f!»{ä\u009b\u008e]v\u009aGº«û\u008eË WlÛpË\u0096îy\u0006!\u0096ª\u008eÛP\u001b®~`\u0019jÝ2UÂ6uû\u0080§y\u00ad»\u009eáN_åÐ\u0018Äz`Q¢W\u0085k\bÂH-\u001e¡T\u0088Ó\tô\u0012ÃT|À%|\u0091ÎÚ4yÔ`õP?ÖUK·\u001bjÍwM»¡\u0085k\u0004É\u0017Ú\u0016w÷\u000f\u008dº¯uz\u0094\u008a\b-\u0000ÇÖ¤¤ñ\u009e$Þ/0Lß\u0004ÍÐ[3\u001b¶î·xÑªÿÚMË7-õO¥7â\u000b±IÔRÍi¹uã¥É;?Ú\u0091~\u009eSËÈb@Æ\u0006\u009e\u0089 \u0099Z½a×ÃB¶ÏÏh÷\u0005Î\u009f\u0013ñ\\Æ\u0016¶ið®ö\u0082a+6eY÷\u008c\u008aí\u0019¶gúæ±Ñ\u0099{"\u0006!c\f/\u0018&ãªÆqã\f¥ÿ\u001eý¿\u000e\u0016v\u008ea¸[ëh\u008aãÇ\u0082Z×0ü0\t}\u008b\u0003\u0005¥m\fj\u0086¯]{\u0096\u0090\u0085a¤=¿eÑ\u009eBº$Í>\u0095½Pí¶Þ}à4¥s2¯|=Ñ§ÕéQ*t±eèº£K\u008a.@\u0001\t>rd\r\u0092¥\u0092d$S3gH|$%\u0081!z÷p\'û\u0086aÒå\u0010\u0080\u0011Ü!Éx\u008b¢à\u000fD\u0096"¹2{\u008aä9\u0084·ì\f©Oè¹\u0080¸Sìp\u00ad\u000bçHs»wnL8\u0085tr\u0099\u00ad\u001fI"þ\u008e!ö\u0003yö3Èº\u001c2GY¹v\u0017÷\u0082\u009d¬à>i<2\u0087\u0007\u0098 Ø<\u001dl\u00924!»M»{\u0018ín\u0095V\u0088\u0017\u0099\u0099Ù\u000bô\u0015é\u007f\nùä\u009a#fÂdYþä"\u00925\u0092\u0089¨>¬{}FCÀåNS\u0098Æ#ZOâq\u0080Ï£\u0010H\u0005·INQÍ2(RÔ8éôË¦ÉSÄ<Ùi\u0092Ë\u0018ÿ\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000äfC\u0098§\u0001\u0000\u0000£\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.class\u0095\u0092ßJ\u001bA\u0014Æ¿³Y³º¦\u001aÿ4Õ¶Ö¨\u0001£\u0014×JoJ¤P\u0003¥\u0085 \u0085H.¼\u009b$Ã:²\u0099\u0095Ù\u0089ø\n}\u001c¯\u0004/ú\u0000}¨Ò3\u009b\u0080\u0088\u00854»\u0017ß\u0099³ßù\u001dÎ\u009cýýçá\u0017\u0080#ÔB\u0014°\u0011ÂÇF\u0080Í\u0000UBñXie?\u0013\nõ½\u000eÁo¦}IXl)-O\u0087\u0083®4ç¢\u009bpf¹\u0095öDÒ\u0011F¹ó8éÛK\u0095\u0011\u0096Î®\u00adJõ\u000fa2iÚVXþTú®µ4ÍDd\u0099dËÇVjâ(6¢\u009fÈ¨\u0097¨¨\u0099\u000e\u0006B÷]\u009fQ]í\u0019¤AXH5\u0087Æ\u009eÊ[ûÅÄ\u0001¶\bóOú\u001cÖ÷&£\u009fBÃT3k8\u0090Ú\u0012Nê\u00ad+q#¢Dè8j[£tÜ\u0098\u009a¸\u0010KûMd\u008fT¾Ì\u008b¼\u0011W^\'ÒÊ\u0000Û\u0084Ýúdð\u0087\u0086[\u0083w{H¨ý\u008f\u009b»´Ó¡éÉ¯Êm¤òÌsàÆ+a\u0006Å\u0000;\u0084£é÷@(?^ÑY÷JöxÂ÷Ó\\\u0011a{ò(\u0084ê$\u0093_åÿ×\u0087{\u008aðÜL \u0004|\u008aX\u0089ufÿ\u001eÞ\u001d\u0007\u001efs\u0013\'é\'æ8.\u008d\f\bñ\u0002ðygXÊu\u0019+¹®âe®\u0015\u0097/;çÚ\u0018þ\u0089Õ\u001bÃéßðÊÈ0\u0082çÑ:^çeorÿ[n\u000fÎ\u0014ø}\u0087y?Ä"k\u0099õ\u0095³\u0097gÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¢Æ÷E«\u0002\u0000\u0000¶\u0005\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.class\u0095TÿN\u0013A\u0010þözåÊq\u0094Z\u0004DQ\u0011\u008b´GËQÄ\u009f \u001akL\u008c\b&(\u0006ÿ[®\u0097rx½kî\u000e£\u008fâ\u0013ø/$\u0002\u0089&>\u0080ï¤qv[\u0010l\u0093B\u0093ÎîÌÎ|óÍÌîýúóý\'\u00809<éE?L\u009dÄ´\u008e4\u008aB-¥0£ã\u001a,\r³:4\u0014\u0085(\u000b1\u0097Âmá;¯á®\u0086{\f\t\u001eÖ\u0018²ËÛü#·<î×¬µ8týÚ\u0002COÐ\u0088ÝÀ§Í¢ë»ñ\u0012ÃT¾Ý¯ÝRXgP+AÕa\u0018Xv}ge§¾é\u0084oø¦ç\u0088L\u0081Í½u\u001eºBo\u0019ÕxË\u008d\u0018\u008cU\u0099°\tCê\u000bßwÂ\u008aÇ£È¡Sk9\bkV-äUÏ±lÏµ*A½ÎýªHñ\u009a\u0087\u0091\u0013æNÆS\u0001é\u009a\u0013?s£\u0086Ç?¯ð:å¹\u0098/t*´\u007f-æö\u0087W¼!éh¸Ï\u0090\u008a\u0083æ±\u0086\u0007\f/ÏTww~eÙ\u001båÓ¬\u0010e!æ\u0018rg\u0089cèã¶íDQ®<?Ká\u0095ü9»Ñ±p}-Ø\tmç¹+\u00860Ü\u00860#B\f\\@Æ@\u0016\u0083B<40\u0080\f1/\u0095\f,`\u0091aä\u007fÜ§;®WuB\u0003\u008f°dà:Æ\u0018\u00189_Á\u0098\u0086Ç\f¥sñfÈüÃ_ÝÜvìø\u0094éÈk¢{\u000fé®çEûõ(æa\u001c½sã-\u0086¡\u000e\u0093-¼§+Ï\u001b\rÇ¯\u0012ÝN\u000em¦VÍÔÒñnD0NÏ/MOW¡vR/i\u0097\u0015-¦5)m\u0083 \u008bJÚ\u0006i\tZ\u0007ÌC$Ìé}¨fq\u001flO\u0086\u000eÉ0\u0015`ôz\u0098\u0082^\u0096@\u009a©\u0018&ûx3\f#¸\fÈ\u009dHÃäN$RhOÓh¥\u0089¤\u000e,\u009aß f\u0093\u0007èù\u0082±\u001fÐ6\u000e\u0091\u0012j/Ù\u0019-\u0007Ð¿bôè ïÔÁ.Å\'$§\u001e\u0081Å4ÉÃhâ¶x\\¥¿\u0006eò\u00adF\u001f&&îE\u008b\u0080E«pL\u009a\u00070v\u008f«k"\u0019\'\u0090\u0092M¤\u008c¨üF+x\u0095òª\u0002Ù\u009c.\u001eBÙ;\u001d\u008eß2Ülº\u001c7DÃD«!\u001anÊ\u0086\u0088]\u000e\u0093HdR¸\u0085©6fTénGè#f\u0013\u0012ZA^Ê\u0002Få|\u0014\u001aõ\u001d\\\u0082N3¡_&õ\u0017PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq²\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.class\u009dTÏO\u0013A\u0014þfvÛ\u0085e\u000b\u0015¡*Z@¬ÐRd) \u0084\u0094\u0010H\u0013\u0092&ULjHô6\u0094MY\\vÉî\u0096ø¯ÀÉ\u009b\u0097^¼@¢\u0089Ñ«\u007f\u00931¾Ù®(\u0016\u00adñÐy?æ\u009b÷¾÷uf¿|{ÿ\u0011À"VtôcF\u0087.\u0017\ry\r³:TÌÉå\u0091\u0086y¹MÖÔ° ¡Ä\u0090\\·];Ü`Pò\u0085]\u0006µâí[\fC5Ûµ\u009e¶\u008eö,ÿ¹Øs(3\\ó\u001aÂÙ\u0015¾-ã8©\u0086\u0007vÀ\u0090Ù9\u000emÏ\u00ad\u0087¾í6+ÞÑ±ðEèù\fFÕu-¿â\u0088 °\b·Vóü¦ÙôÅ¾c\u0099\rÇ6\t{$Ü}Ùì\u0099ð\u0003ËÏ]_©Ì 5¢\u0088\u009aÎäk\u0087âD\u0098\u008ep\u009bf\u0007YîÎ\u0014ªtÆ\u008bª\u0095$û.Àåö"\u0089\u0010\u001cx~H8öòG@ÙT=\u0014\u008dWOÄq<í\u0095Æ;{\u0087V#,wg\nU\r\u008b\u0011¸ç°¥²\u0094\u009c¿^`Èý\u000b\u009a¡¿n7]\u0011¶¤\u000eë\u007fbÓ\nmÇü)Þz÷ì\u001bTJ¯{-¿amÛr´LW»yyÈ\u0080\u0081\u0094\u0081%,kxÌ°Ù\u0093cE\u0004VÕ\r,7°CûÄê¾\u0011\u0013=\u0010²ã¤\u0081Qd\u0018Ò¿ófXýÏ\u000bt¥XG,\u0086\u0091ëÔb\u0098êýOÐ%q,·\u0019\u001eDÏ\u0086nÚd¯3X w§\u0083a\u0080^©\n.\u0085¥h\u0090"\u0093,#\u009b\u0098½\u0000\u007fG\u000eÇ\u0010\u00adI\u0099ä\nÒä\u001b\u001d\u0000n`\u0084,\u0093òÄ\u0087?C¡<°U<\u0087¢¾\u0081¦¾\u0085ªlÌý\u001a\u00ad¨ÙSè£ê\u0019\u0012¼\u009d=\u0093î)\u0012jû\u0003Ô\u0017ì\u0002\u0089"¡\u0093m*¢D\u008dÇé³\u0001\u009eÀ O"Ë5Ló>ä¹\u008e\u0012\u001fÀ\u0012OE\u0084\u0096;McBÒ»\u0085Û\u0011É-Ü!\u008f\u0013¹%\u008cá.ÕÌ"\u0087{ä©ä\u0081N\'\u008dMö\u0015\u0006ë¬zz\u008bÆ\u0019\u008fÇY%¼B65[ü\u0004m\u008e~çèkÿE\u0093T\u0087BZÆ\u0093q\u00915²<\u0016\u0094]/h¦\u0003¸ä\u009fÀ}LÑ¾\u0082\u0007\u0011>\u0087\u0087\u0091\u009dÆM²c\u0094ïG\u0001ÃäMHxº\u008f¦) \u0088±ïPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000¸\u0004\u0000\u00002\u0000\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.class\u0095SßoÒP\u0014þN)\u0014\u000bs\u0080ÛÔ9\u0015\u00117\u0018\u001bÕ½\u0019\u008c&\u0012MLÈf\u0082ÙÃÞ.Ð°.åÖÜvFÿ\'_|ÑÄ\u0007ÿ\u0000ÿ(ã¹-\u009bÝ A\u009a´çG¿ó\u009dï\u009cÛþþóó\u0017\u0080\u0003´mdQ³\u0091C-\u008fÇ6êxbaÇB\u0083\u0090{áI/zIÈ4\u009aÇ\u0004³\u001b\u008c\\ÂjÏ\u0093îáùdàª\u000fbàs¦Ò\u000b\u0086Â?\u0016ÊÓñ4iF§^H(¼\u0017*tU?\u0012\u0011\'\u008bï¤tU×\u0017aèòËv/Pcg¬ÄÈw\u009d¡ï9Ý`2\u0011r¤;$uõTy\u0087P\u009a\u0088/\u0003\u0097#\u0015\u001d}\u008c¼@\u0012Ö\u001b½3ñI8¾\u0090c§\u001f)O\u008e;Í\u0013BÞ\u000b/ \u0019¡ÆZå\f\u008e°\u0012È\u0014\u009b\u0085&¡\u009cøWt\u009fÌi2§íâqf¸YC!\u0090\u0087\u0081¼\u0010ûzÞ<Kï)\u0090)È\u001b9²°KØi,æyÖÑGm|~J¨ÿ\u000f\u009a`÷\u0083s5tßzúÔ7f0m=M\u0011\u0016ò\u0004«ñ*lî·[\u0016ZEì¡la\u009f°·Ìl<Ú¿í\u001c\rÎÜaD8X~í\u0084Úâá®4K\u008e\u0082g\u0098\u0088hxª¿Þê"\u0006³Ê¿V\u000eú²`è\u0015\u0080p\u0083#\u0087-±Íîþ\u0080ñ\u008d\u001d\u00036?s:I%\u0014Ø/&\u0000¶«\u0080ÉJP\u008e\u0089*l\u0013\u0092\u000eW\u0019\u009aºUÉ|\u0087ùõ\u001aÍZL³\u0091@\u0012\u009aØ»\u00855\u0010\u0013®ãNL|\u0017\u009b\u009c\'Ü»T×\u008ac¾¯+ÛJ)£\u0084²¤)ïO\u000b\u009f³5¦cÍ\u0014\u0097Rz²\u0097z²x\u0080\u0087qY5Æ?ÂM¶\u009bÈð\u009bm¬\u00986Wlã6Û-\r/åÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pÍX\rÝ\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.class½UËR\u0013Q\u0010=w\u0092IÂ0@\b\u0010ñ\u0085\u0088(I\b\u0084\u0097\u000f\u0004±\u0090ÒÒ*\n\u00adBY°»$Sqt2CM&Ê/ø/.¤\u008aG\u0095\u000b?À\u0095\u001b_\u000b7nÜè/XvO¦B\u0084P!.ÜtßÛ·Ïé¾§o&ï\u007f¿}\u0007`\n·5Ä\u0090ÕÐ\u0086±6Z\u008d³É±\u0099à\u0083I\u008dR¦£¸\u001aÅ5\u0001µìIÏ\u0088â\u0086@û#é\u0096\rw\u0095\u0003\u0002ú\u0003Û6Ü%K\u0096ËFY`|Ùq\u008b¹¢+\u000b\u0096\u0091Ë[fnÉ)\u0095¤]X6m£\u008a\u001b®\u0083Ï\t\u0084¤[\u0014H,?\u0093/dÎ\u0092v1·ê¹¦]¤£öü\u0001V`è0³ÏS¨ã\'HdÞ´MoAÀH\u001delNÐZóé5\u0081ð\u0092S æº8e¥RÚ0ÜÇrÃ2øFN^ZkÒ5y\u001f\u0004ÃÞS\u0093Dê\u007fb?·\u009d\u0097öÃMÏtì¿ä<A\u000bÇ\u0081éú\u009dEÃ»/Ë\u008bn±R2l\u008fÔM¥×)ìØ\u0094áz+Æ\u0096·ÈrO¤Ò\u00adÎIsì\u0003Ú;\rÔm\u00991&k|DNÙ\u009b\u0096ÁOlVàÕ\u007f\u0098^óìI\u007fÂÊÖ\u0004\u009bI6Sl¦\u0005\u0086O\u0002¦k\u00ad:\u00157oÜ3yöÉ#9ã|G\u001d=èesSG\u0017â:º\u0091Ð¡¡SÇ\u0010\u0006¢\u0098Ó1\u008f[QÐ\u009b\u009eýç§!0Õ\u0014Û\u0000ÔÝ \u0096mEdúÕ6\u0017J`$uÒa\f6{\u0004\u0002\u001d²P¸»å¹rMZ\u0015Ú÷5z«\r¨\u008e\u0094Ä }\u0005ÛèK\u0019B\u0082\u0007B«\u0004\u008fÈ÷4%ò\u0011(<>P\u0015Ú\u0095h\u0017&ß\u0097\u0011ûP2£»\be²»\bgÆv¡nÓ\u0081\u0082$Ù$T@|\u0084*>A\u0013\u009fÑ%¾ W|Å):ËT\tÐ\u008f3\u0080¿â\u0082Â_qIÅ_q3!\u008a\u009eÅ¹ t\u0096<g)á×µ:\u0011\u008e\u0088o>¯^=\rx\u0005Îc @æ\u0002¤\u009aÙCäÍ!ð÷:°Z\u0003_ eªàYòÊqà\u001f>8YM¨ÝHÅEÿF\u0082\u009fw@³@9\\"\u009eÙ!µv\u0010ÚC\u0094\u009czÀ¨1\u008bø\u0089vñ«®¥x\u0095\u0095&Ò\u0083á\u0080k\u009d\u0014$}\u0011Ë\u008cfÇö!¶\u000fuõÁÇÏTsj]Åp9Ð9\u0086+\u0081Î1\u008cø:ó*\u00854ñ*4\u001ff\u001bE\u0007ù!\u008a´\u0013\u0093\u001eæ¿Ë\u0019\u009c¦./1Y\u009c\u009fÍ\f®\u0087µ?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009bÔ\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineParser.class\u009dYi`\\Å\u0091þJ\u009a\u00997zz¶eÙ²=`lá\u0003ë\u00961¶°åS>\u0000\u0019K6\u0096±\u0091\u000fÌXz\u0092F\u001eÏ\u0088\u0099\u0011¶8B¸Â\u0011\u008e\u0010\u008e`\u0013\u0002\u0081`\u0087\u0004\u0082¹d\u000b\u0081ÙM¸Â\u0012Èî\u0012ØÍ²aÙ\u0083=\u0080\r!l\u0000ÇÇ~ýÞ\u009bÑÌè\u0019\u0089üPwOwUuUuÕ×ÕO¯\u001d{ö\u0010\u0080YòT\u001e:ñ±jþW5¿×±\u0016\u009fhø\u0083\u000e/>Ññ)þ¨sú3\rÿ§áOùø\r>×¡ã\u000b\u001dyøRÃa\u001d#ñç|\u001cÁÑ|ìÇ1Õ\u001c×\u0084\u0014W\u008bø%GÇ\u0018ÉÕÄ£c¼xýâS¿5Õø\u0015E\u009e\u008e]¢û%_Í\u0018ª\u0019¡fFúe\u0014u\u0091\u0002¿\u008cÖ¤PÇt|Â\u009de\u008c&cu\u0094à\u0013¿\u0014±\u0097qª\u0019¯8&¨& \u0004\u009c¤ä\u009e¬\u009a\u0089JO\u008bï\u0094|</\u0093Øà¨&\u0093uÔH±&§ê\u0098+S4\u0099ªÉ4\u001dóeº\u008eZ9MQÎÐ¤DÇbzAJuÔ©\u0095\u001a)Ó¤\\Çr%ðm\u0099ä\u0097\nzE*ÕJ\u0095_ªÕ.3Usº.³ä\f5\u009a\u00adÉ\u009c|¬\u0096\u001a¿\u009c©É\\5\u009c§¶¬õË|¥÷\u0002¿,T¿\u0017i²XG3\u0005Ë\u0012\u001cåHêx\u0004Ê¬f\u0019¯ÉR¿,Sv-×±UV¨ÑY~9[yç\u001c]êe¥.çÊ*¿4P\u0013\u009e\u00874ê²ZÖøå<µ¸V\u0093&\u0081Q\u001f\u0089\u0098±eá`<nÆ\u0005ãVw%BÑHS"\u0016\u008a´/\u008bîè\nÆ\u0082\u0089hL\u0093u\u0082ÉË\u0082q³>\u00127#ñP"t\u0089\u0099M$(°¹ÓùÎ\u0017L8?²=\u0012Ý\u0019±\u0017×\u0004cq3Ö\u0094\b&LMÖsÇsO°¶A0Úeú\u0002AQC(\u001eçÖöj]¬ÝZ¢-um\t3fÏÆ5i\u0016\u008cµfÎ\nÅâ\u0089¦îmÔkG0ÒJ\u0001KÍ¶hÌÌ\u009a×dcÊ\u0001u;\u008313cßM\u0082ü\u008c\u0089ÍÜ0Ý[\u00821«×¬«_Ý¸µ±®aÅÖ5uëÖ\u00adXÛ(\b¬ê\f^\u0012¬îN\u0084ÂÕ1³ÝÜU½&\u0098 V\u0091ù\u0082QQ[Ù¥=I\u0019£Ò¨\u001b\u0082]¤Ék\nµG\u0082\u0089î\u0018-\\\u0091¹ºÀþ\u0019\u000eFÚ«m\u0001óWEcíÕí±`kØ¬n\t\u0087ª\u001dÛV\u0085"¦\u00adìüE\u00949:\u0018\u000eGw6\u0084v\u0099\u00ad\u008e»\u0004Êú1Ö|ÆyqeÌ4\u0015\u001d1ë×òP<¸-lÒ\u0089¾\u0005¡H(±H\u0090[RÊsô,\u008b¶\u009aJ\u007fîÔØ½c\u009b\u0019[§\b\u0005\u0085«¢-Áðú`,¤~;\u0093\u009eDG\u0088\u0092§|\u0085º¶³©¬·K\u008d\u0004g\u0096l\u001aloi¶\u0004\u008b\u00ad5M\u000e%ä·\fü¤9.b\u0088I+vµ\u0098ÉÐÙ"\u0098[\u0092FUÏóR\u008a\u000fo;ÃRØñ¬`ö\u0090FN\u001b\u0014ç\u0094â3#\u00ad\u008cm\u001eL=\u0083 \u009a\u008c4åP\u0017õ%$Ðl¢ÓÉ\u001buöÎ\r*\tcÝLa\u0014te+ïr"n\u0006ê\u0016£\u0093uUC\u009b\u0097iØ¸Ì\u0080èéJ\u0006\u0085\u009bÇ]B\\\u0005ð\b\nkÙÎ\u0014°X5¹P°jØìÃ:ÄÉ\u0003)B\u0088p\u0002(^\u0017\u0019H\u0098i%\u0083\u0004¹\u0085¯n\tZÍük\u001bn\f»\u0089\u0019Ý\u0092\u009dÉ_\u009d>N¶§¢\u0082\n\u0017\u000e\u0012\u0011Ï\u0004\u009c&3A\u008632g\u0016\f\u0007R4ìÑd«\u008a\fZ\u00948?\u001elçy\u0006ÒO¤®«\u008b\u0001m\'\u0011áÂ\u0088f@çØh¬Õ\u008c%sÆ\u009eUÊuÅÌ6ë\b\u00923\u0005iÊ\u00ad\nÅ\u0095¾¹ÛÍ\u001e¢Ä%Áp77õ\u009a\u0091DLý^a÷E\u0099\u00909Í\u009aV\\Ñî\u0084\u008aEW\r\u0099p¼ vX8\u009d)â¬ä4iFf(Må¼aú\u0084}î\u008eà.ÁÔl?ºFò´,\u0083N@6ßÍ\f7üwå\u009e3ô½áÂ§ÉE\u009a\u00045ÙF¼î\u008c\u0086\u0018p\u000bJÒ\u0004-\u008b\u0086Ãf\u008b\u0015\u0000n1í\u0002R^¢¾:ít\u0004[½\u00ad\u0093B\u0014ÞY\u008bñÔ\u0099dïÁ3\u0089\u009b©RÃ·\u00ad»\u00adM\u001dÎ\u0084A\u001b-µVÔvmê\u0082Ï¼\u0081\u0007\u0004.(S\u009eYìn\u0091Z\u001c¦Q_;¥S\u0099©\u0007[ZÌx|Ú\u009c\u00993\u0005ÓK\u0086F\u0081R^Ñ9»f\u000epÎU\u009cg\f\u0087sPY\u0091\u00141O\u0089ð/ \u009b}\u009bëMÑîX\u000bk#\u0085Èã\u0006IªRr\fÜ\u008a[\fÜ\u0080\u001b\rÜ¬FßÁíD¨\u0081-Î\tÆ;¸\u008d&-\u0086´\u008aià{¸OP<\u0014ì\u000e\u0092Á´1¤MÚ¹\u0083t¨\u0086·\\Í\u0090×\u008dku§¸;5ÙnHXv\u0018\u0012\u0091¨!]r1\u0011%ûð\f\u0089\tÃ0§²Ò\u0090\u0084t\u000b*\u0087Ü1½ðT\u001b]BØ\u00ad¬ÜtáÂ-å\u0086ì\u0094¸!»¤Ç\u0090Kå2C.\u0097+\b\u001d%\u008bã¥\u000eÅÂª2C¾!W*¢o\u001ar\u0095\\Mx´ÖÕ²ZÅm¸\u0085U\u008c3W¹¥ª\u008cq\u009f\u0006\\ÉêlE,\u0016\u008d\u0019r\u008dRzüà´\b\u0085[UÆ\bíºV®3ä[r½!7(GÜ(W\u0018r\u0093|Û\u0090\u009båjCnÁí\u0086Ü*·\u0019ò\u001d%*ûÜ\u0006Å²!·ËwYX¹À¤\u008a\u008d\u00172Îu]Ì4y®\u0082Ó\u0087Y\u0016\r<\'\u0094kïPÍ\u009d\u0086Ü%w\'\u008dt°3²Ýlu\u0002\u008fY9LáÙ\u008f\u0018C¾\'÷d\u0098R\u0017\u008b\u0005{\u001423$*\u008a\r¼\u0083\u007f0d·\\/\u0080!{ä^C¾/÷hr\u009f\u00817å\u0007\u0086Ü\u009fÅ\u009e\u0002kC\u001ePáæ\u0099\u001e\u009f\u001eÉ\u0088:\u001b\u0001\rù¡\\lÈ\u0083ò\u0010÷\u0099n\u001dÑ\u008f\u0018EñâbÅ`ÈÃ*ÅÆ¹c\u009d&{\u0015ý>V\u0004i%\u0010±¬=\u0018f\tÙ½\u0083wbª¼eic\u009b^<cz|Fq(^\u001c\fÇÌ`kOq+ïÚ\u0088ÙZ¥´ø±ró#\u0086üD¥Bí²`$\u0012M\u0014\u0007[[\u008b£i¼AòF\u00923-6M<\u0011\u008c%\u008aw\u0086\u0012\u001dÅ3*gT\u0019ø\u0016®×ä§\u0086<*\u008fiò3\u0095\u000eQÁ¦aJ,\u008eFÂ=Å-ÑH"\u0018\u008aPÑ®\u008e`\u0084æÄB-Å-\u001d<±\u0016\u0086X\u009cñ©ö²º\u00ad3ª¾2`íÃ×äqCö+E&\u0096l^|ùæ®ËêÂ\u0094{Å¦Ô¨rë\u0096²RC\u009e\u0090\'éÔ!c\u0089%÷\u0092!\u0089\u0086|>Ï\u001bRÄ\u0089^ÒÃ\u0089w÷w¶`Ö×\u007f\u009d\f\u0007\u0084OðF\u009f3<,\u001dôd\u001fn>g?Ü\u0005\u0015_çy2\u001c°Ï|ô\u0097\u009f\u0098Þ%õ\n\u0007\u0080Áz¢Xç>"£Nd1ìV\u0093f\u0090Y\u001072³pLbÊ\u0000h1s}Á¸½6=£Jq\u008a®ÒÁÅ´Ï*£É9¡¤ôDuXà\u0004U ªëÇ»?\u009b¹²}\u0018eÊÐ\u000f³¡\u001f\u009b§[»\u0015\u000eÖ\u0082eN(åóq\u0019æ%ÏB=\u0097:\u0082ñFsWÂú®ÁzË\u0013±~\u008c-)u+Z\u000bv\u0004{¶©\u0097p,\u0091|\u0094\u0015\u0095¸\u0094\u0083\u001bÕ{þâî`8\u009eE\u0090<\t\u0012Ô\u000frÐ_n¾ÆÛ·¥C\u009dc^¼{[Ü\u0089Õ¢\u0092z×\u0012v\u0084\nç4\u00136º\u0098ð\u0097<[]¿k\u008ct6SN¶¾oÌ\u001cÆ;:ë\u0013\u0082\u0016\u008a´\u009a»Ô\u0083ÚC\u0093êÕqÖ»\u009b¦[àc¥¡`©ÛÑ|Ý½ó\u009dÛ(~®zvú\u0082V\u0086\u00127\\e\u009f \b£\u0018\u007f"\u009azü\u0096¸ª>²ÝL°\u009e\u0019P_·k¡°©pÊ\u00176#í\u0089\u000e+Lé\u0080üh¤1\u001aI\u001e`\u0081E\u00994c\u0085Ò/·]AËin±ç\u0016Ø¹¼\u0099\u0019<í±hw×\u0086\u0090Ú§0=ëÕ\u0097\u0002\u0015g3\u0086Nj\'"³@#yëYk>nV\u0017\u000e\u007f\u0005²0=t\u001a\u0090zi\u008fÎH_û»\u0085ò×r3Þ\u0012\u000b%?~u©\'þ\\\u0017\u0093\u0087é\u0004ßv³ÇBä\u0091\u0003\u008b\rAå\f¯\u008a7ºÝo}m°hüÜ~½ý\rÂÇ¡\u001d\u001döW\u0084\u0081\u0087sú\t\u000f\u0001Èé_\u001a&º%î@,yÛÂÝñ\u008eäÅ\u0091å<Þ\u0080Ã\fMçÙ<ïké\u009a\u0019³®àÇ\u0013Ö\u00ad²0nGRZÕ\u009eñA<\u0005[1ëQ; h\u0019K½&Â§\u0019i13|d³7ØLó]$7$å\u008dJ\u0093¦þÙAÈh5ã¡\u0098Ù\u009az=©\u0004ïæ\u0082ÖÂè´\u009e¿_\u0091Ó.\u009fóq*:±\u0016\u0080\u0017\'©ª\u0097£\u001cõF\u0086à&kümþñ¹l\u008doU}Á\u0004õ²ãï\u0011¤á\u001b\u009aíwùk\u0011r9ârÙ\u0001xÊúám>\u0000ß3ÈyÂâ¼\u0083\u00adÎ\u001e\u0098\u0003\u000fæâN\u008e\f\u009b\u001ewánöWñ¹}\u000f)\u0094¬\u0085ì\u0015m^YùAh½ðïO\tñYL+,\u0001ãl"G\u0080\u001aíÆ\u001e®ßË±\u0087ý÷ùÇ7<\u0015£ÐÜ7hb>Åxú\u0091×Ü\u000f½¹ìiäô!_p\u0000Æ\u0001\u008chèÇÈæ²\n9\u0080Q\u008då}(à\u000bÂ\u0013ðôa´`·¼®F\u0085\u0082¿Â\u0098ZoeÀÛ\u008b±»å±\u0080·°¨\u0017ãv£ \u001fã\u009b\u0015ë\u0084Æ}r\u001f§\u0003½8i7N"eÀKâ\u0093{1±Ö\u0017ðõâ\u0014\u0012\\N\u0082I\u0016AUÀ[°°\u0017\u0093k|6e\u0011)\u008a\u0015\u00ad\u0016Ð\u0002üå¹Èâ=\u0095Lg\u0093i\u008aÅtªEëñ:¤\u0014\u001bðúRt\u0093\u009fÄÔ=("õ4RïA~?¦ó(N{\u0081,$ªõ)³\u0003¾>ÌÈ¡»Æ)Y>gGK;¼åÈ®Õ,JÍ¡¼ª²\u001f%\u0014TZXÖ\u008brE\\Þ\u008b\nÕO¬õ\u0007ü½¨Ü\u008dÂ\u0080?i.UÁMjºªÑ[\u0093W\u0094§\\Vý æÒ*þRv\u0015×ê\u0099"uG¤\u009e\u0012YÕxm\u009eì;þâ>,¦.\u0092®®³¾\u000fÓ\u0087ÒK\u0011éÖ\u0091ÍlÜwlfe/N¯ØoE\u0088\u008a§\'QÁö<L`\u0012LE\u0013ê°\u000e+q>Ûõ\bb\u0003¶ã\u0002ô \u0019Wb#Ó`\u0013cm3\u001eÆ\u0016<\u008d\u000bñ×Ø\u008a_ã"¼KÊ÷°\r\u009f£\u0005ÇÑ*#`Êx´É)h\u0097btH):åLl\u0097&\u0084e\u0013vH\'¢Ò\u0085.¹\u0002\u0017ËM\u0088É^ÄåQþ~\u0006;å9ôÈË¸TÞÄ7äC\\)\u007fÀ5ò\u0019®\u0093?ãz9\u0086\u001bsr\u0098\u0096*ö\u001fÅhêåÃ\u000fp?Û»0\u0019\u000fà\u0087\u001c=\u008cQÖ\u009cFÍ\f{\u0095ºØt\u001aw\u009b\u0082\u0007ñ\u0010t\u0089c1~D\u008e<jµÍZõsß<gT\u008aW)é!r|èðúiÙ§ØË9\u001fêäYìãÈ«²)\u0099}\u001cíÆ\u008f\u0099q\u0013ä#<\u0082\u009f07§Êûø)5ÍÅcÉt·¨~ÆÑã\u009cY\u0080\u0082c(×\u0090§áj\rû\u008f`\u008e\u00861Å³g\u008c?\u0082\u0012\u008e\u008e¢\u009e\u00ad\u0086]G¨Ña,:Ìhü\u0012§æ\u001c\u0086\u008fÃ´,·\u0081ê\t\u008e\u009fÄS\u000e\u001cÍá\u008cB\n\u00adÌó\frËög¡Ð\u00adTþ¶4\u0014Ò\u001c3\u0084+®"d\u0090\u0088;(âN\u0017\u0011W16\u009e±E\u0088\u0097¶k\u009cÛ¬ðæ\u0000f5\u00947V\u001eªñäÖx\u008b¼E\u009e\u0007\u0099ÊEÞYµ¾\u008adN\u009e\u0091\u0083>ÌÎÁ\u0086k½\u008cûßUôa\u008e ±Ò\u0006!\u008c¯t0¨F!SE/ÎÜwü\u0083²\u0081X\u009eÂS\u0002ýá\'æMâ©Íd_Ã¸8\u008fç¼\u0081ç¾\u0091g¦ô\u009dMÍ\'¡Ð9Íóø×K\fô(=SXº\u0019\u0007-,õ3\u0013úð,-N\u009e¡=ÓÏ\u0019u\u0086Sá9ÎPôièÔð\u009c\u0086çÙ\nÝñ\u0005¦\u001dQ³û\u000fc"\u0099\u000eá\u0005Û%¹Ïp;Â°üª\u001fs\u009bË\u000f`\u001eq·\u0096x<¿\u0099ð¹à\u0000\u00166V¦\u0080¹\u000f\u008bè\u008b~,¦ï\u0096Ôz*-wÔ\u0012ü\u001c\u0087¼®F\u008eG|¶\u0098:%f)ÅX\u0010J¨X\u0096\u0014²\u009cBV\u0010\u00124[J^ Ï\u0091²^\u008d\u001cl×\u0015úT{\u001eÀ\u0094\u0080ß\r\u009cúp\u0016\u0085íÃä\u0081å¢ÁËÇ÷\u0006ü\u0085g\u001fÄ9Ü\u0085*Ô+±/#ß\u0092½\u0007ZáJNx\u0002y\u0001½\u000fçæ*ú\u0099\u008c\buÃ¬R6+í|*\u001a,í&©\u0091£\u009dVäUÀV}\u0010\r5^Æ\u0087bi\u001cÌÒ\u0095bY\u00ad¼Ð\u00875\u0016»µùÉ\u0015\u0085çy\u009eÇÚæ\\µÐ$hêÅ:\u001a4¯"iÏù4¥\u0088h¹¾p\u0083m\u00947\u0083¼ÙãH´\u0019\u008fßÌ8¼à\u0089T\f^ÊÈRè\u0094Çx\t0ÓK\u0019%³°\u001fk\u0098\u009fAæg\u0084éµ\u0093\u0019r7sä~ÆÝ!ÆÙo\u0019_ÿ\u008cçð\u0001\u009eÇÇ\u009c9Ì`9\u0086\u009f\u008b\u008e_\u0010K_\u0094\u0002¼$³ñ²,Á+²\f¯J;~);ñ\u009aÜ\u0086×å%¼!¯âMy\u009dxw§\u0095Ø#){9í%ÊqÇG\u0088ÒÏ2\u0007wR»\u009fã\u0017\u008cÞ\u000f0\r/r5\u008f{\u009d\u0082\u0097,º5¤ÙË\u001cðq\u001fÃBH\u008d»\\\u0088\u0097\u0089\u0083\u009a\nÖd^pôK¼ÆPÎ\u0093\u0017ñ7x\u009dY\u0010\u0090§ñ+òçb\u0096Ü\u008b7X:y¨ñóx\u0093Yçµ²Få\u009b\u00adÉ¯S\u009aü-1ÍÞáï8gËèOÉø{zSe×\r\u0018y\u001cµNv½¥a®\u0095`¿aZ\u0081x¼\u0002úà\u0005\r5Öøm\u008bè\b\u0016\u0012C\u000fãd"æQL´ðtLîq:É\u009bÅ\n\u001ceÍc%,3w\u0084\u0085Çä]}\u0018s\u0014Úêê\u0013²S\u009e}ÆÞÇ~e?\u009a\u00192\u001b\u001b<\u008bÊ_\u0081¯påª²>lJ¯\u009b0Ý©\u009bj½§ìA^\u0005Ãió\u0086\nu\u0017oQ£ÜEû\u008e¿Ãø¹p\u0000Ãª\u00148Ð~?Þâ\u009eoSÑw\b/¿å-ýOÄ³w\u0089g¿Ã\u0012Þ¶Kñ/´ÿý\u0014\u009eU°\u001aüGÒy\u0095^¤}×B±\u0095\u008c«\u0087,ÌZJ¾÷,;\u0096\u0090ó\u0096ô;É¢\u007f\u009f½òø\u0004x\u008eb´\u0086f9\u0002Ír\u0002\u009d¶öKêaß2ÿJ|ß\u008b\u007fsð=Ä³S\u009e8TÞPqhQn\u008d§ÈsÊ\u0083ØYQä\u0099Uëµ@Ýë\u0094O\u0081~lm.¼ÈI=oÓA\u0004\u000f`\u001b\u008b2\u0005/-ÉõÖìõ\'a*oµõ¢}\u008fCÓ\u0091Ms\u00ad\u0087wÅ\u008dý¨iVÕò\u0001\u0084\u001a*,ØK¿:&U¦@Äcéå©HbÏ{V5\u0094ky¿\u0086E=ð!Æâ#Þ&\u001f³Pÿ==÷\tk OÑ\u0086?âr®]\u008d?1Ë>g\u008e\u007fAäù\u0092y{8u\ncÑaÝ*^®\u008e°òHÝ*\u0087R·Ê!çV¹\u0095g©ò-y\u0087hÇà·.\u008e#¨f\u0080N>\u008c©_À{\u0014EV43$§\u0016øñïø\u000fçf®f¯\u000eN¹8÷Ñ¬·Á\u009c´;ÙËlçÎdþOü\u0097\u000bsNöÃÂ\u009dù¿]w\u0096aìÌÈû\u009fÔ\u0013i\u0089µ\u0002\u0004\n;{±\u009d\u0017\u0081g\u001f<¹Oajaø v<\u0005sð[©\u0080Gò¸%.ÇX"\u009cüÐ"ù\bQ\u000bkG\u0011Oa©XÇg\\\u0017\u009fp\u0017³\u008f±\u009fÏ>Î>Á¾\u009bâ.a¿\u0093\u009c»Ø÷xtòvâ2Î\u008fg\u007f9û+Ø\u007f\u0083ë#Ù_Éþ\u009bì¯òäð´;q\ré¯e\u007f\u001déV\u0013)^ñåý?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008bå>É\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/ParsedCommandLine.class\u0095Wiw\u001bg\u0015~FÛÈòÄ\u008bê%v\u0093TMc[\u0096å\u0018\u0092\u0000ñR·\u008e\u009b\u00908¶SâÆÆ)-L¬\u0089¬TÖ(£\u0091\u0013·\u0094.PhÙ¡liÙ7\u0003\t\u0090\u0014\u0092`rX¾Áá;ßøÆ\u009f \u009c\u009c\u0098ç}g$KÖ¸1GçÌÜ÷Î}\u009f÷Þç.3úÇ½?þ\u0019À\u0001ü.\u0082v\u0098*ò\u0011ø`Ö!\u0089\u008b*¬\b\u0082Î¢ .¶\u008ab\u0004u\u008ef¹\u001e\u0013¸T\u008f\u0093¸,.+*\u009eWñB\u0004M0#hÄ\'ëñ".©øT=^ÂËa¼¢âÕ\b·}:\u0082\u0016|FÅk\u0011tÂ\fã³âþ¹0^\u0017÷7\u0084ÅçÅÎ/Ôã\u008b¸$\u0096_\u0012\u0000_Vñ\u00950¾\u001aA\u0017¾V\u008f¯ãMaó\rqù¦¸¼©â[\n\u001aÍ¼\u009d1s\u0085#+3¶\u0095É¥©\u0099¼ /ë\u0003E;\u0093\u001d\u0098ÒóÃ\nêf2é\u009cn\u0017-CÁÉê§#Î2«çÒ\u0003\u000eÀð¤i¥\u0007Ò\u0096\u009eÊ\u001a\u0003\u000bÙÌÀ\u0093ºU0RãæÒ\u0092\u009eKMfrÆ)yâð(\u0091\u001bò\u0096Q0r¶£*T\u001f>cØ4y¤Zãq \u0004²\u008c%sÙH\u0095\u0081\u001a\u008cË¶¥\u008fYéâ\u0012ñ©hªÀ\u0099Ì\u0014\u0004ô¾Mª-°C#\u0099\\Æ\u001eUÐ\u001e¯08a\u001b\u0096~.k\f÷Î*\b\u008c\u009b)CxÏð¦\u008bKç\fë)ñLAtÒ\\Ð³³º\u0095\u0011kWYçpÎ#\u0084AÍ\u0099\n´¼äÌ\tFA|»\u0094ÒWÓÝ³wó\u001e/ë\u0080½\u0098)xØÖàÓV5KÔ¶x±  \u00ad:Ô\u0095|)ÜÃ\u001eö#÷wOP¿cÆÖ\u0017\u009ec\u009dI(\u0015ßVñ\u001d\u0005Ã^yØ\u0016¢ÈUØ6K¥Þ\u0012ïõ¤ÿbÑ´\u008d±\\jÂÌ\bú½Óîµ3Tp\u0091UG(\u0088\u008c\u0014í|ÑVÐQ³áH1\u0093M\u0019\u0096 7S8\u0096±\n´RÎ\u008a|{\u0085çY\u009b#Û¶õô·nQ/\u0094ª¬5^kÑKo\u009a\u0016u·\u0012O;=F\u0082¸m,·RÚÙ\u0011¯h¤q3\u009b5\u0016$ßbwcÖLO\u001aËF¶Ü\u0099mÞÆ\n\u0012\u009e\u000f¶\b¼ßûLïÐÏn"ª\u0014Ýöûª9mØG7M\u0094h©z*gJw\u008dr\u008b\u0000vè©\u0094D\u009cÕ³Ec\u000búY®Áeçy\u001díK\u0084?ëa{ÿòÿ?ÂÕ\u009cqZ:¯«f\u0002y Ó×È\u008cY´\u0016\u008cc\u0019Ñöm5ðû\u0085Ó\u001a\u000eã\n\tÝ é¸^Xd\u008bkèÇþ\u009a\u0007\u001cù\u001aÞ\u008f\u0003\u001a\u000eá\u0080\u0082\u00076\u009e\u008eY\u0096¾"\bÖð\u0001|PÃ[x[Ãwñ=\rßÇ\u000f\u0014Äîç1sµ=>4ü\u0010?Rñc¶ÂfÖUüDÃOñ3\u0005\u0007Ýñ8\u0014ë*$cÕ/\u001fGWý\u0086\u0012º*ÀSç.°\u00845\u009cÂ\u0093\u001a~\u008eU¾n¶\u0098\u0017\n|É\u0098\u0086_à\u0097\u001c\u0017=\u001a¦0\u00ada\fç4ü\nWU\\Ó0\u008f³\u001a~\u008dßp´WL\u0007öHZÏ\u0096¼:zyÁpyØéø\u0014ëé*ôÄr¦\u001dK\u0019ç\u0019}j¿È\u0015cü\u00ad\u0086ë¸ªá\u0006\u009eÑð\u000e®Ö\u0092[Ã\u001c»£v.\u0095\u00942}Ri\u009b\u008cÆ\u001f\u0097c9SV´UõPÉP\u008cIÎ\u009dir+÷°©\u00039¹¨\u001eã\u000e\u0091´\u008e°gËS§¹\nÓù´ØQ¥¨Z³\u001ey\u0088\u009cÛ\u0087ãµàµ\u001aO\u000fBçMkI\'Æ GÃ>ýÞ \u001bï\u0014=\u009f7r©\u008d\u0091W=Â¶~©\u0084\u0017Ì\u009c\u00adgDô\u00ad\u001e1\b\u0002[¼f(\u0003O\u000b:º½6y\u0085ÙP=ð¸\u009f³J8\u009eJ\u008de³\u0014\u009cÒÇÃü2mç\u0087s\u0000QÑëP0À\u0095\u000fïã\u009a-^^\u001fäúÐ¦5[¼¼þ\u0010êy?\u008cAÊC\u00802\u000e?TjÞHÜ\u0086\u0092¸\u0003ßümøo"@1H1t\u0013ê\u0086\u0018¦XG1r\u0013õ}kÐ\u0014L%×°CÁ\u0015\u009c¤Ð à¯h\u009c¾\u0083&Ú4\u000f\u0005úo!º\u0086\u0007\u0014\f\u0005;\u0082®]LHÒ°e(\u0094ø=\u0002\u001d¡\u008eÀ\u001aZý\u0098[]ÿ×êú;7d\u0090Ãò?\u0082Æk\'W\u00adü¾o£ÔÎÏñ\u009d\fùAþ\u0013Ø\u0085\u0019ì\u0086\u008d=x\u0015\u000fá5Äð:I\u001aá\u008eCü\u000fa£\u0001\u008fb\u0014!Z\u001dÀcx\u009c(\u0013D\u001dÃ\u0011\u0006Ìp1\u008e\'\u0000)\u001dÅ1ÒóaÊ\u001aï\u008eæ8¥\u0013\u0094÷!°NÎü*\u0092*&TþïÀ=t«hTÑÄÕ\u007fÐý_\u0012éP;É=\u009c\'¼\u0092X\u009cáÙ\u0002\u00ad/Ú\u0016ú\u0013Úçý\tF«ÞÆÎ\u0099ù\u0080\u0010ë¥\u0018\u0014bX\u0088\u007f@Çu\t#Bw¶vÉp\u001c§ú\\\u0087}bÈ9¹Ã»¼\u0087x?}\u0007\u009ddüÁ©À¨\u0093\u0095¡\u0080àTò}HH.ßÁÝo!\u0092\u008cîº\u0085ÝsÉè\u001eyë\bV¬ü£«ë\u007fOÞÂC×ËIØ/ë¥\u0017a$\u0010¡\u0017qÖa\u0092\u0015x\u0090A\u000f1\u0015c¬¾ã¤x\u0082\u009a)R_J@\u001c{ñ\u0011& (ü+\u0093}\u009a?Av\u0098ö3x\u008aþG¸û\ff\u0099\u0094\u008d\u0004\b«97\u0001\u00adðßCTE§Bºï"¦¢å]t¸\u008c\u007f\u0094F\u009c×.ã\'¨ññÞ\u009cè»\u0085Ø\u009c \u009bt<ìÃµ2¯\u0011i Êâ1éi\u009b³¡ì_3ã\u0019%\u009c\u0082§ß\u00036ì\r;AØ\u0093÷\u0081ý\u0018\u009eq\u0093÷6ï\u0001A-ÁöV4Rg©\u0091Z¦\u0013l G® \u0018¸¶ºþoÿµrNÚ$«gØ\u0010³dy\u008eE:\u008f\u001eú+\u008e\u008e\u0091ÉN:$\u000eôËÌ\u0095\u009cèÅ³øxU¡\u000bÍ\'\\\u009e5øïB%Ç»6\nZç3¾\u001b]\u001e^á\u009c\u0090\u0088¢kéô>\u001f\u009dl\u009aJþ\r;ï k>Ú\u001d\u0090eÞ\'*ù6zþ\u0092\u0014Eä\u0097\u000eGe¤)ö¤Aù<\u009d],;[í¢ÃS\u0003;\\ô¬Oº\u0016\u0086r\u0017=l8>Y \u008aÃß\u0080ä\u0013\b\u008a^ÚÜ9Ù\u008aÎ\tºðNL\u0006¯ç\u0091vczÂÍ\u00ad&@\u0018SÜ\u0087¹\u001b\u009bÒ\u009ag\u0007\\¬H«VvWc\u0018£ò\u008c\f.¸\u008897\u00ad{ªX\u009a\u0016Å\u0098\u0094ã°\u0097GôoøÛ )\u0010ãªÈ\u0091¶,ÏI8\båsöÈQ¦HI\f0\u001f\u00ad\u009b$Abïs\u008cÖ9û\u008a{ö`_ið\u0096«*^QUt¥\u007f\r\t\u001fÕ\r¢\u009a¹èó\u0089ñûÏ\u001bå\u008c9%ö<\'ì\u000btçE¾B^âKãårÖvs\u000e?ê\u0096Ø`ÙÑAé^EAEXP\tQP\n\u0096dÈ¹ÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000yß\u0005tÚ\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000org/gradle/cli/ParsedCommandLineOption.class\u008dS]OÔ@\u0014=Ý¯îG\u0081eùP\u0004a\u0015\u0084eQª¨ø\u0001"\u0088hHV1Y\u0083Á·awR\u0006»í¦í\u0012á§ðlâ\u008b\u000f\u0098¨\u0004IÔg\u007f\u0094ñN[`Y$ñ¡Ó\u0099Û{Ï=çÜéï?ß\u007f\u0000\u0098Â\u00934²(ª\u0098H#\u0082b\n\u001d¸\u009e¦å\u0086\u008aÉ$ô4\u0012¸\u0099Á-L%q[¾ï¨¸+ßÓr¹§â¾\u008a\u0007\n\u0012[ÌlpWA¶´É¶\u0098Þð\u0084©\u0097\u0084ëÍ(H\u0095\u0085a1¯áp\u0005#-\u009fg\u0083³É,C/{\u008e°\u008c\u00999*IÌ\nKxs\n¢\u0085ñU\u0005±E»JÅ\u001d%añ\u0097\u008dÚ:w^³u\u0093"¹\u0092]aæ*s\u0084<\u0087Á\u0098·!\u0088I¡d;\u0086n8¬jr½b\ný\u0015s\\^]´k5fU%ÔJÝ\u0013¶Eí\u0092\u0006÷V¥\u0000\u0005Ý\u0085ñ³\u0094\u0014´\u0095=Vy÷\u0082ÕÃ\u001e©£\nj\u0094;*i\u0016=z&x\u008eÔ\f«V\u0017\u001c£Qã\u0096§ §p6K:\u0090dÇ)¹\u007fñKn07T@\u0096½U\u0090.Û\r§Â\u009f\tÉvà\u001cé\u0093\u0012IC\u000fz\u0015t\u009d°]p\u001c¶-)kèDNÃ(Æ\u0014\f\u009dt]6Mn0\u0093,ñøÒû\n÷±(#\u0000ÍWmîæ-ÛËo°-\u009egÖvÞ¿\u001c\u0093²Ñ°\u008a\u0087\u001af0« ?L\'æùZÃôDÝäA¦K©\u008f@ÓÏ¶*Õð\u0018ó\u001a\u0016$¡Ñÿ\u001bï)\u0094\u0095õM^!\u000fÛO\u008f\u0086î\u008c+v\u0002ï\u0096i¥áÊQ,7_\u0085 \u0094¬\u008eÒÀZ\u0006\u0015~\u0093¾«Â]ªÕ½m\\¡\u007f(K?\u0018\rLºHï.:EÐ\u008d8íÉrZ/Pd\u000eQÚ\u0001Ùâ>\u0094â!"kû\u0088~Eì³\u009f}\u0091Vù_\u0082*bTÓG;-ÈÇ%ôûø\u0003¸\u001cbí\u0084XÓÅo\u0088ï¢í\u0010\u0089µ\u009cº\u008fäÏâ\u0017Ä\u000e\u0090"¡\u001fÂpú(\u001c=@&\u0082_Ðö¨2êwì%\u008e ^*õè$üAêPÀPS÷é°û =1D:¥\u009a!ä\u0089©ä¡ÓIfÅ%þÞ±\u0090\u0084\u001f\u001cn\u0082\u0089\u00870\u00815W(v\u0095¾\u0007b\u009eRD\n×$ÈÄ\u0001Ú"xÓjÊ\u00182D¬Ï§ìç\u0086xr7\u0082k>\rº½!âó\u0090V.p£]Á.ÔØG²àÓ±ô\u0080ãD\u0013Ç\\\u0093Ô8"Ùy\tRð\u0089\u008cÿ\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vÆB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.class\u009d\u0092KOÂ@\u0014\u0085Ï\u0005\u0004D|?PÃ¢ìÀ\u0004\u009a\u0018uã#Q\u008c+¢$\u0018÷C;\u00961m\u0087\f\u0003\tÿJW&.ü\u0001þ(ã\u0014ª1ØDã,îé\u009c9ßôv¦oï/¯\u0000ö±[@\u0016\u001bylæ±\u0095G)\u0087í\u001cv\bÙ\u0013\u0011\n}FHWkw\u0084LSº\u009c°Ü\u0012!¿\u001e\u0006]®nY×7ÎZK:Ì¿cJDóØÌè\u009e\u0018\u0010\u008eZRy¶§\u0098ësÛñ\u0085ÝVò\u0081;ÚH\u009f+-ø )\u0083\u0080\u0085n´kS\u0086#cruLXõøgh|Ó×B\u0086\u0084\u008dj\u00adõÀFÌöYèÙ\u001d\u00adDè\u0099èÎ\u008fè%×LøÜ%\u0094\u0013Ö\u0006\u008e\u0012ñ\u008e\u0085\u008e\u001c*\u0087_\u0089¨å½?õÖ\u0088:("\u0087<\u0081Ú\u0084b\u007fJÕ\u008dö\t\u0017\u001d®\u00adØ\u008atòfë^*K÷¸Õ\u001d\nßµ¦\rXUÞð\u001aV½\u001d\u008c£Üi0\u001e1\u007fÈk\rÂÁ\u007f\u000e\u008dp8\u0083\u009dw\u0007Z±ß8T0gî?\u001a\u0019Pôa¦Î\u009b\u0099m\u0094\u008cÎí=\u0083\u009eÌC\n\u0005S³\u0013s\u001d\u000b¦\u0016§\u0001£\u008b\u0013|\tË1\\\u008fáôZêq\u0006-}CÓ_èJ\u0002\u009a\u009eEË\u0089èj\u0002\u009a\u0099E+\t¨ùw\'©õ\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\nÏ8=|\u0001\u0000\u0000ü\u0002\u0000\u00009\u0000\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.class\u009d\u0092ËJÃ@\u0014\u0086ÏØ«mµ¶ÖjÕEÜ5B\u0013PÄ\u0085\u0017\u0090\u0016\u0017R/Pé~\u009a\u001eÓ\u0091$\u0013&ÓBÞJW\u0082\u000b\u001fÀ\u0087\u0012\'i\u0010©AÄY\u009c3óÏÿÍ\u009c¹¼\u007f¼¾\u0001À\u0001l\u0097 \u000f\u008d"l\u0014¡Y\u0084Í\u0002l\u0015 E \u007fÊ<&Ï\tdÚú\u0090@¶ËÇH Úg\u001eÞLÝ\u0011\u008a{:r\u0094Rïs\u008b:C*X4NÄ¬\u009c°\u0080ÀQ\u009f\u000bÛ´\u0005\u001d;hZ\u000e3\u0007a Ñ½\u0013ÜG!\u0019\u0006]îºÔ\u001bG\u008bv¹7S"\u008a\u0013\u00025\u001beb\no}É¸G ÑÖû\u008ftFM\u0087z¶9\u0090\u0082y¶²¶~X{()spL`7e.°\u0004KV,\røTXxÉ¢\u008aõ¿\u0094fD\u0005T \u0000E\u0002¤G \u001cÄPÇW\u0014\u0081ã\u0001Jm®h~²\u00adÆ\u001f49Aíjx\u00adµÑ°\r\u00adÓsÃhöÌ\rgÔ\u0099¢n\u00108üÇ5©Û] .F\u0081\u0014Ô\u0092¿s°\u00079õàQË\u0002\u0089Î¢â²\u001a\u0099*\u0013\u0095sû/@\u009eUg\tJ*æc±\u000ee\u0015+s\u0083Ê+1¾\nÕ\u0004î$p¦¾ô´\u00806¿¡\u0099/t-\u0005Í,¢;©h-\u0005Í.¢Z\nª>kìZÿ\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ýØ?¢\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000gradle-cli-classpath.properties+(ÊÏJM.)¶å**Í+ÉÌMµå\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000gradle-cli-parameter-names.properties\u0003\u0000PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m±>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081)\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA\u009b\u0000\u0000\u0000org/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA¿\u0000\u0000\u0000org/gradle/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íAê\u0000\u0000\u0000org/gradle/wrapper/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ªÙfØ\u0003\u0005\u0000\u0000ê\t\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u001d\u0001\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQþ}¢\u0000\u0000\u0000Ò\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081k\u0006\u0000\u0000org/gradle/wrapper/Download$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Çåî©\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081N\u0007\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005¶<\u009bÀ\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081»\t\u0000\u0000org/gradle/wrapper/Download.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L¢¡\u0000\u0000\u0000Ê\u0000\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081º\u0018\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b¶\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ª\u0019\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090ì\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081± \u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67§\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081u#\u0000\u0000org/gradle/wrapper/GradleWrapperMain.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000úâ\u0018æª\u0000\u0000\u0000Û\u0000\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081d-\u0000\u0000org/gradle/wrapper/IDownload.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@áõc\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081N.\u0000\u0000org/gradle/wrapper/Install$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T¨,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ñ5\u0000\u0000org/gradle/wrapper/Install.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ð¿:öo\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\\J\u0000\u0000org/gradle/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011¶\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\bM\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJØâ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0014O\u0000\u0000org/gradle/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007fÍëÂ\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081nV\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ª=©\u000f°\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081~[\u0000\u0000org/gradle/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Gü¨\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081y^\u0000\u0000org/gradle/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Ôe\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081Ôg\u0000\u0000gradle-wrapper-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u00814h\u0000\u0000gradle-wrapper-parameter-names.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA}h\u0000\u0000org/gradle/cli/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ÕÜ?®<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081¬h\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000×\u0083µ³X\u0004\u0000\u0000ì\n\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u00817k\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adÎyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081èo\u0000\u0000org/gradle/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000³ßâú\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081~q\u0000\u0000org/gradle/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\nÕ\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081Þr\u0000\u0000org/gradle/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000üí\u008a¯¥\u0000\u0000\u0000å\u0000\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081$y\u0000\u0000org/gradle/cli/CommandLineParser$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099ÐÆ\u00adN\u0003\u0000\u0000å\t\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u000fz\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¥\u0019D£¢\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081¶}\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¤ÇÇà\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081©\u0080\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000´*«ZM\u0002\u0000\u0000ï\u0004\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0004\u0085\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0006è2\t\u0004\u0007\u0000\u0000Á\u0011\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081µ\u0087\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$Ä¾¢¥\u0002\u0000\u0000ô\u0006\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0014\u008f\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>ª\u0002\u0000\u0000Ä\u0006\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0013\u0092\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%àÌ»\u0002\u0000\u0000ª\u0006\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0018\u0095\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000äfC\u0098§\u0001\u0000\u0000£\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081(\u0098\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¢Æ÷E«\u0002\u0000\u0000¶\u0005\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081%\u009a\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq²\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081!\u009d\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000¸\u0004\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0010 \u0000\u0000org/gradle/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pÍX\rÝ\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081d¢\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009bÔ\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u009e¥\u0000\u0000org/gradle/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008bå>É\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ø·\u0000\u0000org/gradle/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000yß\u0005tÚ\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0005À\u0000\u0000org/gradle/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vÆB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081)Ã\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\nÏ8=|\u0001\u0000\u0000ü\u0002\u0000\u00009\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ýÄ\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ýØ?¢\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ÐÆ\u0000\u0000gradle-cli-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081"Ç\u0000\u0000gradle-cli-parameter-names.propertiesPK\u0005\u0006\u0000\u0000\u0000\u00003\u00003\u0000Ã\u0011\u0000\u0000gÇ\u0000\u0000\u0000\u0000'
          },
          {
            sha: "f3b4dae340056399e69926fa62aba660b3e9404e",
            filename: "gradle/wrapper/gradle-wrapper.properties",
            status: "added",
            additions: 6,
            deletions: 0,
            patch:
              "@@ -0,0 +1,6 @@\n+#Mon Mar 23 21:48:17 CST 2020\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\n+distributionBase=GRADLE_USER_HOME\n+distributionPath=wrapper/dists\n+zipStorePath=wrapper/dists\n+zipStoreBase=GRADLE_USER_HOME",
            rawContent:
              "#Mon Mar 23 21:48:17 CST 2020\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStorePath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\n"
          },
          {
            sha: "8e25e6c19d5748190b8cc39e98c2b56e496a5717",
            filename: "gradlew",
            status: "added",
            additions: 188,
            deletions: 0,
            patch:
              '@@ -0,0 +1,188 @@\n+#!/usr/bin/env sh\n+\n+#\n+# Copyright 2015 the original author or authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the "License");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#      https://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an "AS IS" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+##############################################################################\n+##\n+##  Gradle start up script for UN*X\n+##\n+##############################################################################\n+\n+# Attempt to set APP_HOME\n+# Resolve links: $0 may be a link\n+PRG="$0"\n+# Need this for relative symlinks.\n+while [ -h "$PRG" ] ; do\n+    ls=`ls -ld "$PRG"`\n+    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n+    if expr "$link" : \'/.*\' > /dev/null; then\n+        PRG="$link"\n+    else\n+        PRG=`dirname "$PRG"`"/$link"\n+    fi\n+done\n+SAVED="`pwd`"\n+cd "`dirname \\"$PRG\\"`/" >/dev/null\n+APP_HOME="`pwd -P`"\n+cd "$SAVED" >/dev/null\n+\n+APP_NAME="Gradle"\n+APP_BASE_NAME=`basename "$0"`\n+\n+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n+DEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n+\n+# Use the maximum available, or set MAX_FD != -1 to use that value.\n+MAX_FD="maximum"\n+\n+warn () {\n+    echo "$*"\n+}\n+\n+die () {\n+    echo\n+    echo "$*"\n+    echo\n+    exit 1\n+}\n+\n+# OS specific support (must be \'true\' or \'false\').\n+cygwin=false\n+msys=false\n+darwin=false\n+nonstop=false\n+case "`uname`" in\n+  CYGWIN* )\n+    cygwin=true\n+    ;;\n+  Darwin* )\n+    darwin=true\n+    ;;\n+  MINGW* )\n+    msys=true\n+    ;;\n+  NONSTOP* )\n+    nonstop=true\n+    ;;\n+esac\n+\n+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n+\n+# Determine the Java command to use to start the JVM.\n+if [ -n "$JAVA_HOME" ] ; then\n+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n+        # IBM\'s JDK on AIX uses strange locations for the executables\n+        JAVACMD="$JAVA_HOME/jre/sh/java"\n+    else\n+        JAVACMD="$JAVA_HOME/bin/java"\n+    fi\n+    if [ ! -x "$JAVACMD" ] ; then\n+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation."\n+    fi\n+else\n+    JAVACMD="java"\n+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation."\n+fi\n+\n+# Increase the maximum file descriptors if we can.\n+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n+    MAX_FD_LIMIT=`ulimit -H -n`\n+    if [ $? -eq 0 ] ; then\n+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n+            MAX_FD="$MAX_FD_LIMIT"\n+        fi\n+        ulimit -n $MAX_FD\n+        if [ $? -ne 0 ] ; then\n+            warn "Could not set maximum file descriptor limit: $MAX_FD"\n+        fi\n+    else\n+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n+    fi\n+fi\n+\n+# For Darwin, add options to specify how the application appears in the dock\n+if $darwin; then\n+    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\n+fi\n+\n+# For Cygwin, switch paths to Windows format before running java\n+if $cygwin ; then\n+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n+    JAVACMD=`cygpath --unix "$JAVACMD"`\n+\n+    # We build the pattern for arguments to be converted via cygpath\n+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n+    SEP=""\n+    for dir in $ROOTDIRSRAW ; do\n+        ROOTDIRS="$ROOTDIRS$SEP$dir"\n+        SEP="|"\n+    done\n+    OURCYGPATTERN="(^($ROOTDIRS))"\n+    # Add a user-defined pattern to the cygpath arguments\n+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n+    fi\n+    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n+    i=0\n+    for arg in "$@" ; do\n+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n+\n+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n+        else\n+            eval `echo args$i`="\\"$arg\\""\n+        fi\n+        i=$((i+1))\n+    done\n+    case $i in\n+        (0) set -- ;;\n+        (1) set -- "$args0" ;;\n+        (2) set -- "$args0" "$args1" ;;\n+        (3) set -- "$args0" "$args1" "$args2" ;;\n+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n+    esac\n+fi\n+\n+# Escape application args\n+save () {\n+    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n+    echo " "\n+}\n+APP_ARGS=$(save "$@")\n+\n+# Collect all arguments for the java command, following the shell quoting and substitution rules\n+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n+\n+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\n+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n+  cd "$(dirname "$0")"\n+fi\n+\n+exec "$JAVACMD" "$@"',
            rawContent:
              '#!/usr/bin/env sh\n\n#\n# Copyright 2015 the original author or authors.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG="$0"\n# Need this for relative symlinks.\nwhile [ -h "$PRG" ] ; do\n    ls=`ls -ld "$PRG"`\n    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n    if expr "$link" : \'/.*\' > /dev/null; then\n        PRG="$link"\n    else\n        PRG=`dirname "$PRG"`"/$link"\n    fi\ndone\nSAVED="`pwd`"\ncd "`dirname \\"$PRG\\"`/" >/dev/null\nAPP_HOME="`pwd -P`"\ncd "$SAVED" >/dev/null\n\nAPP_NAME="Gradle"\nAPP_BASE_NAME=`basename "$0"`\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD="maximum"\n\nwarn () {\n    echo "$*"\n}\n\ndie () {\n    echo\n    echo "$*"\n    echo\n    exit 1\n}\n\n# OS specific support (must be \'true\' or \'false\').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase "`uname`" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\n  NONSTOP* )\n    nonstop=true\n    ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n "$JAVA_HOME" ] ; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n        # IBM\'s JDK on AIX uses strange locations for the executables\n        JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n        JAVACMD="$JAVA_HOME/bin/java"\n    fi\n    if [ ! -x "$JAVACMD" ] ; then\n        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\n    fi\nelse\n    JAVACMD="java"\n    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n            MAX_FD="$MAX_FD_LIMIT"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn "Could not set maximum file descriptor limit: $MAX_FD"\n        fi\n    else\n        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n    JAVACMD=`cygpath --unix "$JAVACMD"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=""\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS="$ROOTDIRS$SEP$dir"\n        SEP="|"\n    done\n    OURCYGPATTERN="(^($ROOTDIRS))"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in "$@" ; do\n        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n        else\n            eval `echo args$i`="\\"$arg\\""\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- "$args0" ;;\n        (2) set -- "$args0" "$args1" ;;\n        (3) set -- "$args0" "$args1" "$args2" ;;\n        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n    esac\nfi\n\n# Escape application args\nsave () {\n    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n    echo " "\n}\nAPP_ARGS=$(save "$@")\n\n# Collect all arguments for the java command, following the shell quoting and substitution rules\neval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n\n# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\nif [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n  cd "$(dirname "$0")"\nfi\n\nexec "$JAVACMD" "$@"\n'
          },
          {
            sha: "9618d8d9607cd91a0efb866bcac4810064ba6fac",
            filename: "gradlew.bat",
            status: "added",
            additions: 100,
            deletions: 0,
            patch:
              '@@ -0,0 +1,100 @@\n+@rem\n+@rem Copyright 2015 the original author or authors.\n+@rem\n+@rem Licensed under the Apache License, Version 2.0 (the "License");\n+@rem you may not use this file except in compliance with the License.\n+@rem You may obtain a copy of the License at\n+@rem\n+@rem      https://www.apache.org/licenses/LICENSE-2.0\n+@rem\n+@rem Unless required by applicable law or agreed to in writing, software\n+@rem distributed under the License is distributed on an "AS IS" BASIS,\n+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+@rem See the License for the specific language governing permissions and\n+@rem limitations under the License.\n+@rem\n+\n+@if "%DEBUG%" == "" @echo off\n+@rem ##########################################################################\n+@rem\n+@rem  Gradle startup script for Windows\n+@rem\n+@rem ##########################################################################\n+\n+@rem Set local scope for the variables with windows NT shell\n+if "%OS%"=="Windows_NT" setlocal\n+\n+set DIRNAME=%~dp0\n+if "%DIRNAME%" == "" set DIRNAME=.\n+set APP_BASE_NAME=%~n0\n+set APP_HOME=%DIRNAME%\n+\n+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n+\n+@rem Find java.exe\n+if defined JAVA_HOME goto findJavaFromJavaHome\n+\n+set JAVA_EXE=java.exe\n+%JAVA_EXE% -version >NUL 2>&1\n+if "%ERRORLEVEL%" == "0" goto init\n+\n+echo.\n+echo ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n+echo.\n+echo Please set the JAVA_HOME variable in your environment to match the\n+echo location of your Java installation.\n+\n+goto fail\n+\n+:findJavaFromJavaHome\n+set JAVA_HOME=%JAVA_HOME:"=%\n+set JAVA_EXE=%JAVA_HOME%/bin/java.exe\n+\n+if exist "%JAVA_EXE%" goto init\n+\n+echo.\n+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\n+echo.\n+echo Please set the JAVA_HOME variable in your environment to match the\n+echo location of your Java installation.\n+\n+goto fail\n+\n+:init\n+@rem Get command-line arguments, handling Windows variants\n+\n+if not "%OS%" == "Windows_NT" goto win9xME_args\n+\n+:win9xME_args\n+@rem Slurp the command line arguments.\n+set CMD_LINE_ARGS=\n+set _SKIP=2\n+\n+:win9xME_args_slurp\n+if "x%~1" == "x" goto execute\n+\n+set CMD_LINE_ARGS=%*\n+\n+:execute\n+@rem Setup the command line\n+\n+set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n+\n+@rem Execute Gradle\n+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n+\n+:end\n+@rem End local scope for the variables with windows NT shell\n+if "%ERRORLEVEL%"=="0" goto mainEnd\n+\n+:fail\n+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\n+rem the _cmd.exe /c_ return code!\n+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\n+exit /b 1\n+\n+:mainEnd\n+if "%OS%"=="Windows_NT" endlocal\n+\n+:omega',
            rawContent:
              '@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the "License");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an "AS IS" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if "%DEBUG%" == "" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif "%OS%"=="Windows_NT" setlocal\n\nset DIRNAME=%~dp0\nif "%DIRNAME%" == "" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif "%ERRORLEVEL%" == "0" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist "%JAVA_EXE%" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windows variants\n\nif not "%OS%" == "Windows_NT" goto win9xME_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif "x%~1" == "x" goto execute\n\nset CMD_LINE_ARGS=%*\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif "%ERRORLEVEL%"=="0" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\nexit /b 1\n\n:mainEnd\nif "%OS%"=="Windows_NT" endlocal\n\n:omega\n'
          },
          {
            sha: "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc",
            filename: "settings.gradle",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+/*\n+ * This file was generated by the Gradle 'init' task.\n+ *\n+ * The settings file is used to specify which projects to include in your build.\n+ *\n+ * Detailed information about configuring a multi-project build in Gradle can be found\n+ * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n+ */\n+\n+rootProject.name = 'refactoring-crawler'",
            rawContent:
              "/*\n * This file was generated by the Gradle 'init' task.\n *\n * The settings file is used to specify which projects to include in your build.\n *\n * Detailed information about configuring a multi-project build in Gradle can be found\n * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n */\n\nrootProject.name = 'refactoring-crawler'\n"
          },
          {
            sha: "83d2cfcf9d3fac2cb14ed33d480d729a23bc2d31",
            filename: "src/main/java/refactoring/crawler/Library.java",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+public class Library {\n+    public boolean someLibraryMethod() {\n+        return true;\n+    }\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\npublic class Library {\n    public boolean someLibraryMethod() {\n        return true;\n    }\n}\n"
          },
          {
            sha: "0664cc91a699f71271f0658ea3cf1d299d40d9e9",
            filename:
              "src/main/java/refactoring/crawler/RefactoringCrawler.java",
            status: "added",
            additions: 116,
            deletions: 0,
            patch:
              '@@ -0,0 +1,116 @@\n+package refactoring.crawler;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import refactoring.crawler.detection.RefactoringDetection;\n+import refactoring.crawler.detection.RenameMethodDetection;\n+import refactoring.crawler.project.IProject;\n+import refactoring.crawler.util.*;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class RefactoringCrawler {\n+\n+\tprivate String projectName;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\t// creates an input stream for the file to be parsed\n+\t\tString source = "import detections.Detection;\\n" +\n+\t\t\t"import detections.DetectionFactory;\\n" +\n+\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n+\t\t\t"import utils.*;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"import java.util.List;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"public class RefactoringCrawler {\\n" +\n+\t\t\t"    public static void main(String[] args) {\\n" +\n+\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n+\t\t\t"//        parser.setSource();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n+\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n+\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n+\t\t\t"\\n" +\n+\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n+\t\t\t"            for (Pair pair : pairs) {\\n" +\n+\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n+\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n+\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n+\t\t\t"                    }\\n" +\n+\t\t\t"                }\\n" +\n+\t\t\t"            }\\n" +\n+\t\t\t"        }\\n" +\n+\t\t\t"        return rlog.getResult();\\n" +\n+\t\t\t"    }\\n" +\n+\t\t\t"}\\n";\n+\t\tCompilationUnit cu;\n+\t\t// parse the file\n+\t\tcu = StaticJavaParser.parse(source);\n+\n+\n+\t}\n+\n+\tpublic RefactoringCrawler(String projectName) {\n+\t\tthis.projectName = projectName;\n+\t}\n+\n+\tprivate List<CompilationUnit> parse(List<String> files) {\n+\t\tList<CompilationUnit> resList = new LinkedList<>();\n+\t\tfor (String source : files) {\n+\t\t\tresList.add(StaticJavaParser.parse(source));\n+\t\t}\n+\t\treturn resList;\n+\t}\n+\n+\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n+\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n+\n+\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n+\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n+\t\tSourceNavigator navigator = new SourceNavigator();\n+\t\tnavigator.setShinglesUtil(shinglesUtil);\n+\t\tnavigator.browseProject(projectName, oldVersionCU);\n+\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n+\n+\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n+\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n+\t\tnavigatorForVersion.browseProject(newVersion);\n+\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n+\n+\n+\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n+\n+\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n+\t}\n+\n+\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n+\t                                NamedDirectedMultigraph newVersionGraph) {\n+\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n+\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n+\t\tdetector.setThreshold(tMethod);\n+\n+\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n+\t\tif (renamedMethods.size() > 0) {\n+\t\t\tSystem.out.println(renamedMethods);\n+//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n+//            renameMethodCategory.setName("RenamedMethods");\n+//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n+//            refactoringList.add(renameMethodCategory);\n+\t\t}\n+\t}\n+\n+}',
            rawContent:
              'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.RenameMethodDetection;\nimport refactoring.crawler.project.IProject;\nimport refactoring.crawler.util.*;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RefactoringCrawler {\n\n\tprivate String projectName;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// creates an input stream for the file to be parsed\n\t\tString source = "import detections.Detection;\\n" +\n\t\t\t"import detections.DetectionFactory;\\n" +\n\t\t\t"import org.eclipse.jdt.core.dom.AST;\\n" +\n\t\t\t"import utils.*;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import java.util.List;\\n" +\n\t\t\t"\\n" +\n\t\t\t"import org.eclipse.jdt.core.dom.ASTParser;\\n" +\n\t\t\t"\\n" +\n\t\t\t"public class RefactoringCrawler {\\n" +\n\t\t\t"    public static void main(String[] args) {\\n" +\n\t\t\t"        ASTParser parser = ASTParser.newParser(AST.JLS13);\\n" +\n\t\t\t"//        parser.setSource();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"\\n" +\n\t\t\t"    public String detect(Component component1, Component component2) {\\n" +\n\t\t\t"\\n" +\n\t\t\t"        AbstractGraph originalGraph = ASTUtils.parseToAST(component1);\\n" +\n\t\t\t"        AbstractGraph newVersionGraph = ASTUtils.parseToAST(component2);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        Shingles shingles1 = ShinglesUtils.annotateGraphNodesWithShingles(originalGraph);\\n" +\n\t\t\t"        Shingles shingles2 = ShinglesUtils.annotateGraphNodesWithShingles(newVersionGraph);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        List<Pair> pairs = EntityUtils.findSimilarEntities(shingles1, shingles2);\\n" +\n\t\t\t"\\n" +\n\t\t\t"        RefactoringLog rlog = new RefactoringLog();\\n" +\n\t\t\t"\\n" +\n\t\t\t"        for (Detection detection : DetectionFactory.getDetectionList()) {\\n" +\n\t\t\t"            for (Pair pair : pairs) {\\n" +\n\t\t\t"                if (detection.isRelevant(pair)) {\\n" +\n\t\t\t"                    if (detection.isLikelyRefactoring(pair.getFirst(), pair.getSecond(), rlog)) {\\n" +\n\t\t\t"                        rlog.add(pair.getFirst(), pair.getSecond(), detection);\\n" +\n\t\t\t"                    }\\n" +\n\t\t\t"                }\\n" +\n\t\t\t"            }\\n" +\n\t\t\t"        }\\n" +\n\t\t\t"        return rlog.getResult();\\n" +\n\t\t\t"    }\\n" +\n\t\t\t"}\\n";\n\t\tCompilationUnit cu;\n\t\t// parse the file\n\t\tcu = StaticJavaParser.parse(source);\n\n\n\t}\n\n\tpublic RefactoringCrawler(String projectName) {\n\t\tthis.projectName = projectName;\n\t}\n\n\tprivate List<CompilationUnit> parse(List<String> files) {\n\t\tList<CompilationUnit> resList = new LinkedList<>();\n\t\tfor (String source : files) {\n\t\t\tresList.add(StaticJavaParser.parse(source));\n\t\t}\n\t\treturn resList;\n\t}\n\n\tpublic void detect(List<String> oldVersion, List<String> newVersion) {\n\t\tShinglesUtil shinglesUtil = new ShinglesUtil();\n\n\t\tList<CompilationUnit> oldVersionCU = this.parse(oldVersion);\n\t\tList<CompilationUnit> newVersionCU = this.parse(newVersion);\n\t\tSourceNavigator navigator = new SourceNavigator();\n\t\tnavigator.setShinglesUtil(shinglesUtil);\n\t\tnavigator.browseProject(projectName, oldVersionCU);\n\t\tNamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n\t\tSourceNavigator navigatorForVersion = new SourceNavigator();\n\t\tnavigatorForVersion.setShinglesUtil(shinglesUtil);\n\t\tnavigatorForVersion.browseProject(newVersion);\n\t\tNamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n\n\t\tshinglesUtil.initialize(originalGraph, versionGraph);\n\n\t\tdetectRenameMethod(1, shinglesUtil, originalGraph, versionGraph);\n\t}\n\n\tprivate void detectRenameMethod(double tMethod, ShinglesUtil se, NamedDirectedMultigraph oldVersionGraph,\n\t                                NamedDirectedMultigraph newVersionGraph) {\n\t\tList<Node[]> candidateMethods = se.findSimilarMethods();\n\t\tRefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n\t\tdetector.setThreshold(tMethod);\n\n\t\tList<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n\t\tif (renamedMethods.size() > 0) {\n\t\t\tSystem.out.println(renamedMethods);\n//            RefactoringCategory renameMethodCategory = new RefactoringCategory();\n//            renameMethodCategory.setName("RenamedMethods");\n//            renameMethodCategory.setRefactoringPairs(renamedMethods);\n//            refactoringList.add(renameMethodCategory);\n\t\t}\n\t}\n\n}\n'
          },
          {
            sha: "3a4ac180d4529de1ef206ad58592439d28556c90",
            filename:
              "src/main/java/refactoring/crawler/detection/ChangeMethodSignatureDetection.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.detection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class ChangeMethodSignatureDetection extends MethodDetection {\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        return null;\n    }\n\n    @Override\n    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n}\n"
          },
          {
            sha: "a3f39c027c687155881ad197d953830da6480536",
            filename:
              "src/main/java/refactoring/crawler/detection/MethodDetection.java",
            status: "added",
            additions: 71,
            deletions: 0,
            patch:
              "@@ -0,0 +1,71 @@\n+package refactoring.crawler.detection;\n+\n+import lombok.val;\n+import org.eclipse.core.runtime.NullProgressMonitor;\n+import org.eclipse.jdt.core.IMember;\n+import refactoring.crawler.project.IMethod;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public abstract class MethodDetection extends RefactoringDetection {\n+\n+    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n+        List callers = new ArrayList();\n+        if (this instanceof ChangeMethodSignatureDetection)\n+            callers = SearchHelper.findMethodCallers(node, true);\n+        else\n+            callers = SearchHelper.findMethodCallers(node, false);\n+        for (Object o : callers) {\n+//            IMethod element = (IMethod) o;\n+//            String nodeName = element.getElementName();\n+//            String qualifiername = element.getDeclaringType()\n+//                    .getFullyQualifiedName('.');\n+//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n+//            if (caller != null) {\n+//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n+//                graph.addEdge(edge);\n+//            }\n+        }\n+        node.setCreatedCallGraph();\n+\n+    }\n+\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        val results = new ArrayList<Edge>();\n+        for (final Edge edge : list) {\n+            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n+                results.add(edge);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected void createCallGraph(Node original, Node version) {\n+        if (!original.hasCallGraph()) {\n+            createCallGraph(original, graph1);\n+            original.setCreatedCallGraph();\n+        }\n+        if (!version.hasCallGraph()) {\n+            createCallGraph(version, graph2);\n+            version.setCreatedCallGraph();\n+        }\n+    }\n+\n+    public double analyzeIncomingEdges(Node original, Node version) {\n+        double incomingEdgesGrade;\n+        createCallGraph(original, version);\n+        val incomingEdgesOriginal = filterNamedEdges(graph1\n+                .incomingEdgesOf(original));\n+        val incomingEdgesVersion = filterNamedEdges(graph2\n+                .incomingEdgesOf(version));\n+        incomingEdgesGrade = computeLikelinessIncomingEdges(\n+                incomingEdgesOriginal, incomingEdgesVersion);\n+        return incomingEdgesGrade;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport lombok.val;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.IMember;\nimport refactoring.crawler.project.IMethod;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n\n    protected void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n        List callers = new ArrayList();\n        if (this instanceof ChangeMethodSignatureDetection)\n            callers = SearchHelper.findMethodCallers(node, true);\n        else\n            callers = SearchHelper.findMethodCallers(node, false);\n        for (Object o : callers) {\n//            IMethod element = (IMethod) o;\n//            String nodeName = element.getElementName();\n//            String qualifiername = element.getDeclaringType()\n//                    .getFullyQualifiedName('.');\n//            Node caller = graph.findNamedNode(qualifiername + \".\" + nodeName);\n//            if (caller != null) {\n//                Edge edge = factory.createEdge(caller, node, Node.METHOD_CALL);\n//                graph.addEdge(edge);\n//            }\n        }\n        node.setCreatedCallGraph();\n\n    }\n\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        val results = new ArrayList<Edge>();\n        for (final Edge edge : list) {\n            if (Node.Type.METHOD_CALL.equals(edge.getLabel())) {\n                results.add(edge);\n            }\n        }\n        return results;\n    }\n\n    protected void createCallGraph(Node original, Node version) {\n        if (!original.hasCallGraph()) {\n            createCallGraph(original, graph1);\n            original.setCreatedCallGraph();\n        }\n        if (!version.hasCallGraph()) {\n            createCallGraph(version, graph2);\n            version.setCreatedCallGraph();\n        }\n    }\n\n    public double analyzeIncomingEdges(Node original, Node version) {\n        double incomingEdgesGrade;\n        createCallGraph(original, version);\n        val incomingEdgesOriginal = filterNamedEdges(graph1\n                .incomingEdgesOf(original));\n        val incomingEdgesVersion = filterNamedEdges(graph2\n                .incomingEdgesOf(version));\n        incomingEdgesGrade = computeLikelinessIncomingEdges(\n                incomingEdgesOriginal, incomingEdgesVersion);\n        return incomingEdgesGrade;\n    }\n}\n"
          },
          {
            sha: "4cf9a1a8afa81c2cef5bba0091ad48c4d5e7d3a2",
            filename:
              "src/main/java/refactoring/crawler/detection/MoveMethodDetection.java",
            status: "added",
            additions: 30,
            deletions: 0,
            patch:
              "@@ -0,0 +1,30 @@\n+package refactoring.crawler.detection;\n+\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class MoveMethodDetection extends RefactoringDetection {\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        return null;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node node1, Node node12) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public List<Edge> filterNamedEdges(Set<Edge> list) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n+\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class MoveMethodDetection extends RefactoringDetection {\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        return null;\n    }\n\n    @Override\n    public double computeLikeliness(Node node1, Node node12) {\n        return 0;\n    }\n\n    @Override\n    public List<Edge> filterNamedEdges(Set<Edge> list) {\n        return null;\n    }\n\n    @Override\n    protected void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {\n\n    }\n}\n"
          },
          {
            sha: "2ee90c7dee42de68600be172bfe65d64b1ec21d8",
            filename:
              "src/main/java/refactoring/crawler/detection/RefactoringDetection.java",
            status: "added",
            additions: 370,
            deletions: 0,
            patch:
              '@@ -0,0 +1,370 @@\n+package refactoring.crawler.detection;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.*;\n+\n+public abstract class RefactoringDetection {\n+\n+    @Getter\n+    @Setter\n+    private double threshold;\n+\n+    protected NamedDirectedMultigraph graph1;\n+    protected NamedDirectedMultigraph graph2;\n+\n+\n+    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n+\n+    public abstract double computeLikeliness(Node node1, Node node12);\n+\n+    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n+\n+    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n+\n+    private static Dictionary<String, String> renamingDictionary;\n+\n+    public static Dictionary<String, String> getRenamingDictionary() {\n+        if (renamingDictionary == null)\n+            renamingDictionary = new Hashtable<>();\n+        return renamingDictionary;\n+    }\n+\n+    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n+        List<Node[]> refactoredNodes = new ArrayList<>();\n+        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n+        return pruneFalsePositives(listWithFP);\n+    }\n+\n+    /**\n+     * A default implementation that prunes all those candidates that have the\n+     * same qualified name. Subclasses might reuse this when they implement the\n+     * abstract pruneOriginalCanditates, or they can augment to this initial\n+     * implementation.\n+     *\n+     * @param candidates\n+     * @return\n+     */\n+    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n+        List<Node[]> prunedCandidates = new ArrayList<>();\n+        for (Node[] pair : candidates) {\n+            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n+                    .getFullyQualifiedName()))) {\n+\n+                if (pair[0].isAPI() && pair[1].isAPI()) {\n+                    Node n2inV1 = graph1.findNamedNode(pair[1]\n+                            .getFullyQualifiedName());\n+\n+                    if ((n2inV1 == null)) {\n+                        prunedCandidates.add(pair);\n+                    }\n+                }\n+            }\n+        }\n+        return prunedCandidates;\n+    }\n+\n+    /**\n+     * The client is assumed to be passing it\'s parent to this method to\n+     * determine if they are Modulo Renames of each other.\n+     *\n+     * @param original\n+     * @param version\n+     * @return\n+     */\n+    protected boolean isTheSameModuloRename(String original, String version) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        if (version.equals(dictionary.get(original)))\n+            return true;\n+        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n+            return original.equals(version);\n+        else if (original.substring(original.lastIndexOf(".")).equals(\n+                version.substring(version.lastIndexOf("."), version.length())))\n+            return isTheSameModuloRename(\n+                    extractFullyQualifiedParentName(original),\n+                    extractFullyQualifiedParentName(version));\n+        else\n+            return false;\n+    }\n+\n+    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n+        for (Node[] pair : listWithFP) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n+            if (originalInV2 != null) {\n+                createCallGraph(originalInV2, graph2);\n+                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n+                        .incomingEdgesOf(originalInV2));\n+                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n+                        .incomingEdgesOf(version));\n+                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n+                        .incomingEdgesOf(original));\n+\n+\n+                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n+                List<Node> verCallers = getCallers(verIncomingEdges);\n+                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n+\n+                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n+                // since a call site cannot be calling both the old and the new entity at the same time\n+                for (Iterator iterator = verCallers.iterator(); iterator\n+                        .hasNext(); ) {\n+                    Node node = (Node) iterator.next();\n+                    if (origInV2Callers.contains(node))\n+                        if (!nodesToRemove.contains(pair)) {\n+                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n+                            nodesToRemove.add(pair);\n+                        }\n+                }\n+\n+                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n+                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n+                // should be different\n+                for (Iterator iterator = origInV1Callers.iterator(); iterator\n+                        .hasNext(); ) {\n+                    Node node = (Node) iterator.next();\n+                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n+                            .hasNext(); ) {\n+                        Node callingNode = (Node) iterator1.next();\n+                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n+                            if (!nodesToRemove.contains(pair)) {\n+                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n+                                nodesToRemove.add(pair);\n+                            }\n+                            break;\n+                        }\n+                    }\n+\n+                }\n+\n+            }\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            listWithFP.remove(pair);\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+\n+        pruneOverloadedMethodFP(listWithFP);\n+\n+        return listWithFP;\n+    }\n+\n+\n+    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n+        boolean retval = false;\n+\n+        if (source.getSignature() == null)\n+            return false;\n+\n+        retval = source.getSignature().equals(target.getSignature());\n+\n+        if (!retval && (this instanceof MoveMethodDetection)) {\n+            String sourceParent = extractParentSimpleName(source);\n+            StringTokenizer sourceTokenizer = new StringTokenizer(source\n+                    .getSignature(), "( , )");\n+            StringTokenizer targetTokenizer = new StringTokenizer(target\n+                    .getSignature(), "( , )");\n+            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n+            String[] targetTokens = new String[targetTokenizer.countTokens()];\n+\n+            for (int i = 0; i < sourceTokens.length; i++) {\n+                sourceTokens[i] = sourceTokenizer.nextToken();\n+            }\n+\n+            for (int i = 0; i < targetTokens.length; i++) {\n+                targetTokens[i] = targetTokenizer.nextToken();\n+            }\n+\n+            if (targetTokens.length == sourceTokens.length + 1) {\n+                if (!targetTokens[0].trim().equals(sourceParent))\n+                    return false;\n+                else {\n+                    for (int i = 0; i < sourceTokens.length; i++) {\n+                        if (!sourceTokens[i].trim().equals(\n+                                targetTokens[i + 1].trim()))\n+                            return false;\n+                    }\n+                    retval = true;\n+                }\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    /**\n+     * This helper method takes a string containing the dot separated name of a\n+     * node and it returns the subtring from the beginning up to the last dot\n+     * (e.g. for pack1.class1.method1 it returns class1)\n+     *\n+     * @param original\n+     * @return\n+     */\n+    protected String extractParentSimpleName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        String parentName = originalName.substring(0, originalName\n+                .lastIndexOf("."));\n+        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n+        return parentName;\n+    }\n+\n+    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n+        List<Node[]> nodesToRemove = new LinkedList<>();\n+        for (int i = 0; i < listWithFP.size(); i++) {\n+            boolean hasSameNameAndSignature = false;\n+            Node[] pair = listWithFP.get(i);\n+            Node source = pair[0];\n+            for (int j = i; j < listWithFP.size(); j++) {\n+                Node[] pair2 = listWithFP.get(j);\n+                Node source2 = pair2[0];\n+                if (source.equals(source2)) {\n+                    Node target2 = pair2[1];\n+                    if (source.getSimpleName().equals(target2.getSimpleName()))\n+                        if (signatureEqualsModuloMoveMethod(source, target2))\n+                            hasSameNameAndSignature = true;\n+                }\n+            }\n+            if (hasSameNameAndSignature) {\n+                for (int j = i; j < listWithFP.size(); j++) {\n+                    Node[] pair2 = (Node[]) listWithFP.get(j);\n+                    Node source2 = pair2[0];\n+                    if (source.equals(source2)) {\n+                        Node target2 = pair2[1];\n+                        if (source.getSimpleName().equals(\n+                                target2.getSimpleName()))\n+                            if (!signatureEqualsModuloMoveMethod(source, target2))\n+                                if (!nodesToRemove.contains(pair2))\n+                                    nodesToRemove.add(pair2);\n+                    }\n+                }\n+            }\n+\n+        }\n+        for (Node[] pair : nodesToRemove) {\n+            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n+            listWithFP.remove(pair);\n+\n+            Dictionary<String, String> dictionary = getRenamingDictionary();\n+            dictionary.remove(pair[0].getFullyQualifiedName());\n+        }\n+    }\n+\n+\n+    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n+        Dictionary<String, String> dictionary = getRenamingDictionary();\n+        String fqnParent = extractFullyQualifiedParentName(original);\n+        String possiblyRenamedFQN = dictionary.get(fqnParent);\n+        if (possiblyRenamedFQN != null)\n+            fqnParent = possiblyRenamedFQN;\n+        // TODO implement find name node\n+        Node parentNode = g.findNamedNode(fqnParent);\n+\n+        if (parentNode != null) {\n+            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n+            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n+            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n+                Edge edge = (Edge) iter.next();\n+                Node child = (Node) edge.getTarget();\n+                if (original.getSimpleName().equals(child.getSimpleName()))\n+                    if (original.getSignature() != null) {\n+                        // This handles the method nodes\n+                        if (original.getSignature()\n+                                .equals(child.getSignature()))\n+                            return child;\n+                    } else\n+                        // Classes and packages\n+                        return child;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n+        List<Edge> results = new ArrayList<>();\n+        for (Edge o : list) {\n+            if (label.equals(o.getLabel())) {\n+                results.add(o);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    protected String extractFullyQualifiedParentName(Node original) {\n+        String originalName = original.getFullyQualifiedName();\n+        return extractFullyQualifiedParentName(originalName);\n+    }\n+\n+    public String extractFullyQualifiedParentName(String originalName) {\n+        String fqParentName = "";\n+        int lastIndex = originalName.lastIndexOf(".");\n+        if (lastIndex > 0)\n+            fqParentName = originalName.substring(0, lastIndex);\n+        return fqParentName;\n+    }\n+\n+    private List<Node> getCallers(List incomingEdges) {\n+        List<Node> callers = new ArrayList<Node>();\n+        for (Object incomingEdge : incomingEdges) {\n+            Edge edge = (Edge) incomingEdge;\n+            callers.add(edge.getSource());\n+        }\n+        return callers;\n+    }\n+\n+    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n+        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n+        boolean foundNewRefactoring = false;\n+        for (Object prunedCandidate : prunedCandidates) {\n+            Node[] pair = (Node[]) prunedCandidate;\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            double likeliness = computeLikeliness(original, version);\n+            if (likeliness >= threshold) {\n+                if (!refactoredNodes.contains(pair)) {\n+                    refactoredNodes.add(pair);\n+                    foundNewRefactoring = true;\n+                }\n+            }\n+        }\n+\n+        if (foundNewRefactoring) {\n+            doDetectRefactorings(candidates, refactoredNodes);\n+        }\n+        return refactoredNodes;\n+    }\n+\n+    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n+        double count = 0;\n+\n+        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n+\n+        for (Edge edge1 : edges1) {\n+            Node node1 = edge1.getSource();\n+            for (int i = 0; i < arrEdge2.length; i++) {\n+                Edge edge2 = arrEdge2[i];\n+                if (edge2 != null) {\n+                    Node node2 = (Node) edge2.getSource();\n+                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n+                            node2.getFullyQualifiedName())) {\n+                        count++;\n+                        // we mark this edge as already counted so that we don\'t\n+                        // count it\n+                        // twice when there are multiple edges between two nodes\n+                        arrEdge2[i] = null;\n+                    }\n+                }\n+            }\n+        }\n+\n+        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n+        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n+\n+        return (fraction1 + fraction2) / 2.0;\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.detection;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic abstract class RefactoringDetection {\n\n    @Getter\n    @Setter\n    private double threshold;\n\n    protected NamedDirectedMultigraph graph1;\n    protected NamedDirectedMultigraph graph2;\n\n\n    public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n    public abstract double computeLikeliness(Node node1, Node node12);\n\n    public abstract List<Edge> filterNamedEdges(Set<Edge> list);\n\n    protected abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n    private static Dictionary<String, String> renamingDictionary;\n\n    public static Dictionary<String, String> getRenamingDictionary() {\n        if (renamingDictionary == null)\n            renamingDictionary = new Hashtable<>();\n        return renamingDictionary;\n    }\n\n    public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n        List<Node[]> refactoredNodes = new ArrayList<>();\n        List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n        return pruneFalsePositives(listWithFP);\n    }\n\n    /**\n     * A default implementation that prunes all those candidates that have the\n     * same qualified name. Subclasses might reuse this when they implement the\n     * abstract pruneOriginalCanditates, or they can augment to this initial\n     * implementation.\n     *\n     * @param candidates\n     * @return\n     */\n    public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n        List<Node[]> prunedCandidates = new ArrayList<>();\n        for (Node[] pair : candidates) {\n            if (!(pair[0].getFullyQualifiedName().equals(pair[1]\n                    .getFullyQualifiedName()))) {\n\n                if (pair[0].isAPI() && pair[1].isAPI()) {\n                    Node n2inV1 = graph1.findNamedNode(pair[1]\n                            .getFullyQualifiedName());\n\n                    if ((n2inV1 == null)) {\n                        prunedCandidates.add(pair);\n                    }\n                }\n            }\n        }\n        return prunedCandidates;\n    }\n\n    /**\n     * The client is assumed to be passing it\'s parent to this method to\n     * determine if they are Modulo Renames of each other.\n     *\n     * @param original\n     * @param version\n     * @return\n     */\n    protected boolean isTheSameModuloRename(String original, String version) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        if (version.equals(dictionary.get(original)))\n            return true;\n        if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n            return original.equals(version);\n        else if (original.substring(original.lastIndexOf(".")).equals(\n                version.substring(version.lastIndexOf("."), version.length())))\n            return isTheSameModuloRename(\n                    extractFullyQualifiedParentName(original),\n                    extractFullyQualifiedParentName(version));\n        else\n            return false;\n    }\n\n    public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n        for (Node[] pair : listWithFP) {\n            Node original = pair[0];\n            Node version = pair[1];\n            Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n            if (originalInV2 != null) {\n                createCallGraph(originalInV2, graph2);\n                List<Edge> origIncomingEdges = filterNamedEdges(graph2\n                        .incomingEdgesOf(originalInV2));\n                List<Edge> verIncomingEdges = filterNamedEdges(graph2\n                        .incomingEdgesOf(version));\n                List<Edge> origInVer1IncomingEdges = filterNamedEdges(graph1\n                        .incomingEdgesOf(original));\n\n\n                List<Node> origInV2Callers = getCallers(origIncomingEdges);\n                List<Node> verCallers = getCallers(verIncomingEdges);\n                List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n                // remove those pairs where N1InV2 has at least one call site as N2inV2.\n                // since a call site cannot be calling both the old and the new entity at the same time\n                for (Iterator iterator = verCallers.iterator(); iterator\n                        .hasNext(); ) {\n                    Node node = (Node) iterator.next();\n                    if (origInV2Callers.contains(node))\n                        if (!nodesToRemove.contains(pair)) {\n                            System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n                            nodesToRemove.add(pair);\n                        }\n                }\n\n                //check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the pair\n                //is a false positive (since there should be either no more callers for N1inV2 or their call sites\n                // should be different\n                for (Iterator iterator = origInV1Callers.iterator(); iterator\n                        .hasNext(); ) {\n                    Node node = (Node) iterator.next();\n                    for (Iterator iterator1 = origInV2Callers.iterator(); iterator1\n                            .hasNext(); ) {\n                        Node callingNode = (Node) iterator1.next();\n                        if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n                            if (!nodesToRemove.contains(pair)) {\n                                System.out.println("2nd Prune in RD:" + pair[0] + pair[1]);\n                                nodesToRemove.add(pair);\n                            }\n                            break;\n                        }\n                    }\n\n                }\n\n            }\n        }\n        for (Node[] pair : nodesToRemove) {\n            listWithFP.remove(pair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n\n        pruneOverloadedMethodFP(listWithFP);\n\n        return listWithFP;\n    }\n\n\n    private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n        boolean retval = false;\n\n        if (source.getSignature() == null)\n            return false;\n\n        retval = source.getSignature().equals(target.getSignature());\n\n        if (!retval && (this instanceof MoveMethodDetection)) {\n            String sourceParent = extractParentSimpleName(source);\n            StringTokenizer sourceTokenizer = new StringTokenizer(source\n                    .getSignature(), "( , )");\n            StringTokenizer targetTokenizer = new StringTokenizer(target\n                    .getSignature(), "( , )");\n            String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n            String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n            for (int i = 0; i < sourceTokens.length; i++) {\n                sourceTokens[i] = sourceTokenizer.nextToken();\n            }\n\n            for (int i = 0; i < targetTokens.length; i++) {\n                targetTokens[i] = targetTokenizer.nextToken();\n            }\n\n            if (targetTokens.length == sourceTokens.length + 1) {\n                if (!targetTokens[0].trim().equals(sourceParent))\n                    return false;\n                else {\n                    for (int i = 0; i < sourceTokens.length; i++) {\n                        if (!sourceTokens[i].trim().equals(\n                                targetTokens[i + 1].trim()))\n                            return false;\n                    }\n                    retval = true;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This helper method takes a string containing the dot separated name of a\n     * node and it returns the subtring from the beginning up to the last dot\n     * (e.g. for pack1.class1.method1 it returns class1)\n     *\n     * @param original\n     * @return\n     */\n    protected String extractParentSimpleName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        String parentName = originalName.substring(0, originalName\n                .lastIndexOf("."));\n        parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n        return parentName;\n    }\n\n    private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n        List<Node[]> nodesToRemove = new LinkedList<>();\n        for (int i = 0; i < listWithFP.size(); i++) {\n            boolean hasSameNameAndSignature = false;\n            Node[] pair = listWithFP.get(i);\n            Node source = pair[0];\n            for (int j = i; j < listWithFP.size(); j++) {\n                Node[] pair2 = listWithFP.get(j);\n                Node source2 = pair2[0];\n                if (source.equals(source2)) {\n                    Node target2 = pair2[1];\n                    if (source.getSimpleName().equals(target2.getSimpleName()))\n                        if (signatureEqualsModuloMoveMethod(source, target2))\n                            hasSameNameAndSignature = true;\n                }\n            }\n            if (hasSameNameAndSignature) {\n                for (int j = i; j < listWithFP.size(); j++) {\n                    Node[] pair2 = (Node[]) listWithFP.get(j);\n                    Node source2 = pair2[0];\n                    if (source.equals(source2)) {\n                        Node target2 = pair2[1];\n                        if (source.getSimpleName().equals(\n                                target2.getSimpleName()))\n                            if (!signatureEqualsModuloMoveMethod(source, target2))\n                                if (!nodesToRemove.contains(pair2))\n                                    nodesToRemove.add(pair2);\n                    }\n                }\n            }\n\n        }\n        for (Node[] pair : nodesToRemove) {\n            System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n            listWithFP.remove(pair);\n\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(pair[0].getFullyQualifiedName());\n        }\n    }\n\n\n    private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n        Dictionary<String, String> dictionary = getRenamingDictionary();\n        String fqnParent = extractFullyQualifiedParentName(original);\n        String possiblyRenamedFQN = dictionary.get(fqnParent);\n        if (possiblyRenamedFQN != null)\n            fqnParent = possiblyRenamedFQN;\n        // TODO implement find name node\n        Node parentNode = g.findNamedNode(fqnParent);\n\n        if (parentNode != null) {\n            List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n            List filteredEdges = filterNamedEdges(parentEdges, Node.Type.METHOD);\n            for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n                Edge edge = (Edge) iter.next();\n                Node child = (Node) edge.getTarget();\n                if (original.getSimpleName().equals(child.getSimpleName()))\n                    if (original.getSignature() != null) {\n                        // This handles the method nodes\n                        if (original.getSignature()\n                                .equals(child.getSignature()))\n                            return child;\n                    } else\n                        // Classes and packages\n                        return child;\n            }\n        }\n        return null;\n    }\n\n    protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n        List<Edge> results = new ArrayList<>();\n        for (Edge o : list) {\n            if (label.equals(o.getLabel())) {\n                results.add(o);\n            }\n        }\n        return results;\n    }\n\n    protected String extractFullyQualifiedParentName(Node original) {\n        String originalName = original.getFullyQualifiedName();\n        return extractFullyQualifiedParentName(originalName);\n    }\n\n    public String extractFullyQualifiedParentName(String originalName) {\n        String fqParentName = "";\n        int lastIndex = originalName.lastIndexOf(".");\n        if (lastIndex > 0)\n            fqParentName = originalName.substring(0, lastIndex);\n        return fqParentName;\n    }\n\n    private List<Node> getCallers(List incomingEdges) {\n        List<Node> callers = new ArrayList<Node>();\n        for (Object incomingEdge : incomingEdges) {\n            Edge edge = (Edge) incomingEdge;\n            callers.add(edge.getSource());\n        }\n        return callers;\n    }\n\n    private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n        List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n        boolean foundNewRefactoring = false;\n        for (Object prunedCandidate : prunedCandidates) {\n            Node[] pair = (Node[]) prunedCandidate;\n            Node original = pair[0];\n            Node version = pair[1];\n            double likeliness = computeLikeliness(original, version);\n            if (likeliness >= threshold) {\n                if (!refactoredNodes.contains(pair)) {\n                    refactoredNodes.add(pair);\n                    foundNewRefactoring = true;\n                }\n            }\n        }\n\n        if (foundNewRefactoring) {\n            doDetectRefactorings(candidates, refactoredNodes);\n        }\n        return refactoredNodes;\n    }\n\n    public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n        double count = 0;\n\n        Edge[] arrEdge2 = edges2.toArray(new Edge[edges2.size()]);\n\n        for (Edge edge1 : edges1) {\n            Node node1 = edge1.getSource();\n            for (int i = 0; i < arrEdge2.length; i++) {\n                Edge edge2 = arrEdge2[i];\n                if (edge2 != null) {\n                    Node node2 = (Node) edge2.getSource();\n                    if (isTheSameModuloRename(node1.getFullyQualifiedName(),\n                            node2.getFullyQualifiedName())) {\n                        count++;\n                        // we mark this edge as already counted so that we don\'t\n                        // count it\n                        // twice when there are multiple edges between two nodes\n                        arrEdge2[i] = null;\n                    }\n                }\n            }\n        }\n\n        double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n        double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n        return (fraction1 + fraction2) / 2.0;\n    }\n}\n'
          },
          {
            sha: "cbe3a28746d3df68550f245b019a9aa42d979ea9",
            filename:
              "src/main/java/refactoring/crawler/detection/RenameMethodDetection.java",
            status: "added",
            additions: 39,
            deletions: 0,
            patch:
              "@@ -0,0 +1,39 @@\n+package refactoring.crawler.detection;\n+\n+import org.jgrapht.graph.AbstractBaseGraph;\n+import refactoring.crawler.util.Edge;\n+import refactoring.crawler.util.NamedDirectedMultigraph;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.*;\n+\n+public class RenameMethodDetection extends MethodDetection {\n+\n+    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n+\n+    }\n+\n+    @Override\n+    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n+        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n+        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n+        for (Node[] pair : prePrunedMethods) {\n+            Node original = pair[0];\n+            Node version = pair[1];\n+            String parentClassOriginal = extractFullyQualifiedParentName(original);\n+            String parentClassVersion = extractFullyQualifiedParentName(version);\n+            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n+                    && (!(original.getSimpleName().equals(version\n+                    .getSimpleName()))))\n+                candidatesWithSameParentClass.add(pair);\n+        }\n+\n+        return candidatesWithSameParentClass;\n+    }\n+\n+    @Override\n+    public double computeLikeliness(Node oldVersion, Node newVersion) {\n+        return super.analyzeIncomingEdges(oldVersion, newVersion);\n+    }\n+\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.jgrapht.graph.AbstractBaseGraph;\nimport refactoring.crawler.util.Edge;\nimport refactoring.crawler.util.NamedDirectedMultigraph;\nimport refactoring.crawler.util.Node;\n\nimport java.util.*;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n    public RenameMethodDetection(NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n\n    }\n\n    @Override\n    public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n        List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n        List<Node[]> candidatesWithSameParentClass = new LinkedList<>();\n        for (Node[] pair : prePrunedMethods) {\n            Node original = pair[0];\n            Node version = pair[1];\n            String parentClassOriginal = extractFullyQualifiedParentName(original);\n            String parentClassVersion = extractFullyQualifiedParentName(version);\n            if (isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n                    && (!(original.getSimpleName().equals(version\n                    .getSimpleName()))))\n                candidatesWithSameParentClass.add(pair);\n        }\n\n        return candidatesWithSameParentClass;\n    }\n\n    @Override\n    public double computeLikeliness(Node oldVersion, Node newVersion) {\n        return super.analyzeIncomingEdges(oldVersion, newVersion);\n    }\n\n}\n"
          },
          {
            sha: "0ee7ed647e5ce12c67fe481dc6b3225c519765ab",
            filename:
              "src/main/java/refactoring/crawler/detection/SearchHelper.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package refactoring.crawler.detection;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import refactoring.crawler.util.Node;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class SearchHelper {\n+    public static List findMethodCallers(Node node, boolean withSignature) {\n+        return new LinkedList();\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.detection;\n\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport refactoring.crawler.util.Node;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class SearchHelper {\n    public static List findMethodCallers(Node node, boolean withSignature) {\n        return new LinkedList();\n    }\n}\n"
          },
          {
            sha: "d294a5f56dad1dba561bfd8d25bd70a7ccaa5d42",
            filename: "src/main/java/refactoring/crawler/project/IClass.java",
            status: "added",
            additions: 22,
            deletions: 0,
            patch:
              "@@ -0,0 +1,22 @@\n+package refactoring.crawler.project;\n+\n+import java.util.List;\n+\n+public interface IClass {\n+\n+    public List<IMethod> getMethods();\n+\n+    public List<IField> getFields();\n+\n+    public String getFullyQualifiedName();\n+\n+    public int getFlags();\n+\n+    public boolean getIsDeprecated();\n+\n+    public boolean getIsInterface();\n+\n+    public boolean isPublic();\n+\n+    public boolean isProtected();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IClass {\n\n    public List<IMethod> getMethods();\n\n    public List<IField> getFields();\n\n    public String getFullyQualifiedName();\n\n    public int getFlags();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsInterface();\n\n    public boolean isPublic();\n\n    public boolean isProtected();\n}\n"
          },
          {
            sha: "dbe2bf76763338d11712c8cb049d27ddc89620bb",
            filename: "src/main/java/refactoring/crawler/project/IField.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+package refactoring.crawler.project;\n+\n+public interface IField {\n+\n+    public String getSource();\n+\n+    public String getElementName();\n+\n+    public int getFlags();\n+\n+    public String getTypeSignature();\n+\n+    public boolean getIsDeprecated();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IField {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public int getFlags();\n\n    public String getTypeSignature();\n\n    public boolean getIsDeprecated();\n}\n"
          },
          {
            sha: "aa5a6b80cb38b51776c717580c642edfd62ca7dd",
            filename: "src/main/java/refactoring/crawler/project/IMethod.java",
            status: "added",
            additions: 18,
            deletions: 0,
            patch:
              "@@ -0,0 +1,18 @@\n+package refactoring.crawler.project;\n+\n+public interface IMethod {\n+\n+    public String getSource();\n+\n+    public String getElementName();\n+\n+    public boolean getIsPublic();\n+\n+    public boolean getIsDeprecated();\n+\n+    public boolean getIsProtected();\n+\n+    public int getFlags();\n+\n+    public String[] getParameterTypes();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\npublic interface IMethod {\n\n    public String getSource();\n\n    public String getElementName();\n\n    public boolean getIsPublic();\n\n    public boolean getIsDeprecated();\n\n    public boolean getIsProtected();\n\n    public int getFlags();\n\n    public String[] getParameterTypes();\n}\n"
          },
          {
            sha: "dab45c8026bdcaef0dfeb04913e60d8153553ec3",
            filename: "src/main/java/refactoring/crawler/project/IPackage.java",
            status: "added",
            additions: 16,
            deletions: 0,
            patch:
              "@@ -0,0 +1,16 @@\n+package refactoring.crawler.project;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+\n+import java.util.List;\n+\n+public interface IPackage {\n+\n+    public List<IClass> getClasses();\n+\n+    public List<IPackage> getChildrenPackages();\n+\n+    public String getElementName();\n+\n+//    public List<CompilationUnit> getCompilationUnit();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport java.util.List;\n\npublic interface IPackage {\n\n    public List<IClass> getClasses();\n\n    public List<IPackage> getChildrenPackages();\n\n    public String getElementName();\n\n//    public List<CompilationUnit> getCompilationUnit();\n}\n"
          },
          {
            sha: "1757c698aee63ab8c2e194f2656032cf614d9f39",
            filename: "src/main/java/refactoring/crawler/project/IProject.java",
            status: "added",
            additions: 10,
            deletions: 0,
            patch:
              "@@ -0,0 +1,10 @@\n+package refactoring.crawler.project;\n+\n+import java.util.List;\n+\n+public interface IProject {\n+\n+    public List<IPackage> getPackages();\n+\n+    public String getProjectName();\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport java.util.List;\n\npublic interface IProject {\n\n    public List<IPackage> getPackages();\n\n    public String getProjectName();\n}\n"
          },
          {
            sha: "e5a3c3b50a35f8f1f21593a3bc3548800599fb37",
            filename:
              "src/main/java/refactoring/crawler/project/RCProject.java",
            status: "added",
            additions: 45,
            deletions: 0,
            patch:
              "@@ -0,0 +1,45 @@\n+package refactoring.crawler.project;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import lombok.Getter;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+public class RCProject implements IProject {\n+\n+\t@Getter\n+\tprivate String projectName;\n+\n+\tprivate List<CompilationUnit> units;\n+\n+\tprivate List<IPackage> packages;\n+\n+\tpublic RCProject(String projectName, List<String> fileSources) {\n+\t\tthis.projectName = projectName;\n+\t\tthis.units = new LinkedList<>();\n+\t\tfor (String source : fileSources) {\n+\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n+\t\t\tthis.units.add(compilationUnit);\n+\t\t}\n+\t}\n+\n+\n+\tprivate void browsePackages(){\n+\t\tfor(CompilationUnit unit: this.units){\n+\t\t\tunit.\n+\t\t}\n+\t}\n+\n+\n+\t@Override\n+\tpublic List<IPackage> getPackages() {\n+\t\tif (null != packages) {\n+\t\t\tbrowsePackages();\n+\t\t}\n+\t}\n+}",
            rawContent:
              "package refactoring.crawler.project;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class RCProject implements IProject {\n\n\t@Getter\n\tprivate String projectName;\n\n\tprivate List<CompilationUnit> units;\n\n\tprivate List<IPackage> packages;\n\n\tpublic RCProject(String projectName, List<String> fileSources) {\n\t\tthis.projectName = projectName;\n\t\tthis.units = new LinkedList<>();\n\t\tfor (String source : fileSources) {\n\t\t\tCompilationUnit compilationUnit = StaticJavaParser.parse(source);\n\t\t\tthis.units.add(compilationUnit);\n\t\t}\n\t}\n\n\n\tprivate void browsePackages(){\n\t\tfor(CompilationUnit unit: this.units){\n\t\t\tunit.\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic List<IPackage> getPackages() {\n\t\tif (null != packages) {\n\t\t\tbrowsePackages();\n\t\t}\n\t}\n}\n"
          },
          {
            sha: "d6fae800777369e76bd1270cd1dc09563d8cd0cd",
            filename:
              "src/main/java/refactoring/crawler/util/DirectedEdge.java",
            status: "added",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -0,0 +1,4 @@\n+package refactoring.crawler.util;\n+\n+public class DirectedEdge {\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class DirectedEdge {\n}\n"
          },
          {
            sha: "8ed1aa2b553e7aa5e07e802ed1ddf31bbac4f227",
            filename: "src/main/java/refactoring/crawler/util/Edge.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              '@@ -0,0 +1,31 @@\n+package refactoring.crawler.util;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.jgrapht.graph.DefaultEdge;\n+\n+public class Edge extends DefaultEdge {\n+\n+    @Getter\n+    @Setter\n+    private Node.Type label;\n+\n+    public Edge(Node.Type label) {\n+        this.label = label;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n+    }\n+\n+    @Override\n+    public Node getSource() {\n+        return (Node) super.getSource();\n+    }\n+\n+    @Override\n+    public Node getTarget() {\n+        return (Node) super.getTarget();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n    @Getter\n    @Setter\n    private Node.Type label;\n\n    public Edge(Node.Type label) {\n        this.label = label;\n    }\n\n    @Override\n    public String toString() {\n        return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n    }\n\n    @Override\n    public Node getSource() {\n        return (Node) super.getSource();\n    }\n\n    @Override\n    public Node getTarget() {\n        return (Node) super.getTarget();\n    }\n}\n'
          },
          {
            sha: "f9c3e922b3febe11864095e3ac7ce7ad280e705a",
            filename:
              "src/main/java/refactoring/crawler/util/FactorOf2Strategy.java",
            status: "added",
            additions: 28,
            deletions: 0,
            patch:
              "@@ -0,0 +1,28 @@\n+package refactoring.crawler.util;\n+\n+public class FactorOf2Strategy implements ShinglesStrategy {\n+\n+    /**\n+     *\n+     */\n+    public FactorOf2Strategy() {\n+        super();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @Override\n+     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n+     */\n+    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n+        return s_base + (2 * loc);\n+    }\n+\n+    public int upperBoundForClassShingles(int numMethods, int s_base) {\n+        return s_base + (2 * numMethods);\n+    }\n+\n+    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n+        return s_base + (2 * numClasses);\n+    }\n+\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n    /**\n     *\n     */\n    public FactorOf2Strategy() {\n        super();\n    }\n\n    /* (non-Javadoc)\n     * @Override\n     * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n     */\n    public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n        return s_base + (2 * loc);\n    }\n\n    public int upperBoundForClassShingles(int numMethods, int s_base) {\n        return s_base + (2 * numMethods);\n    }\n\n    public int upperBoundForPackageShingles(int numClasses, int s_base) {\n        return s_base + (2 * numClasses);\n    }\n\n}\n"
          },
          {
            sha: "28d14a892748261ace56edbd47ef89599c251dac",
            filename:
              "src/main/java/refactoring/crawler/util/NamedDirectedMultigraph.java",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+package refactoring.crawler.util;\n+\n+import org.jgrapht.graph.DirectedMultigraph;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n+\n+    private Map<String, Node> namedVertexMap = new HashMap<>();\n+\n+    public NamedDirectedMultigraph() {\n+        super(Edge.class);\n+    }\n+\n+    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n+        super(vertexSupplier, edgeSupplier, weighted);\n+    }\n+\n+    public boolean addNamedVertex(Node v) {\n+        if (!addVertex(v))\n+            return false;\n+        namedVertexMap.put(v.getFullyQualifiedName(), v);\n+        return true;\n+    }\n+\n+    public Node findNamedNode(String name) {\n+        return namedVertexMap.get(name);\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n    private Map<String, Node> namedVertexMap = new HashMap<>();\n\n    public NamedDirectedMultigraph() {\n        super(Edge.class);\n    }\n\n    public NamedDirectedMultigraph(Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n        super(vertexSupplier, edgeSupplier, weighted);\n    }\n\n    public boolean addNamedVertex(Node v) {\n        if (!addVertex(v))\n            return false;\n        namedVertexMap.put(v.getFullyQualifiedName(), v);\n        return true;\n    }\n\n    public Node findNamedNode(String name) {\n        return namedVertexMap.get(name);\n    }\n}\n"
          },
          {
            sha: "4b07c12c621dc8ab22d3c950d6c1f96229b7f0e6",
            filename: "src/main/java/refactoring/crawler/util/NamedGraph.java",
            status: "added",
            additions: 8,
            deletions: 0,
            patch:
              "@@ -0,0 +1,8 @@\n+package refactoring.crawler.util;\n+\n+public class NamedGraph {\n+\n+    public Node findNamedNode(String name) {\n+        return null;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic class NamedGraph {\n\n    public Node findNamedNode(String name) {\n        return null;\n    }\n}\n"
          },
          {
            sha: "4504a1ebed11d791cc0e676301d079e352a28dde",
            filename: "src/main/java/refactoring/crawler/util/Node.java",
            status: "added",
            additions: 88,
            deletions: 0,
            patch:
              '@@ -0,0 +1,88 @@\n+package refactoring.crawler.util;\n+\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+\n+\n+public class Node {\n+\n+    public boolean hasCallGraph() {\n+        return false;\n+    }\n+\n+    public void setCreatedCallGraph() {\n+    }\n+\n+    public static enum Type {\n+        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n+    }\n+\n+\n+    @Getter\n+    @Setter\n+    private String fullyQualifiedName;\n+\n+    @Setter\n+    @Getter\n+    private Node.Type type;\n+\n+    @Setter\n+    @Getter\n+    private int[] shingles;\n+\n+    @Setter\n+    @Getter\n+    private boolean hasCallGraph;\n+\n+    @Setter\n+    @Getter\n+    private String projectName;\n+\n+    @Setter\n+    @Getter\n+    private boolean isAPI = false;\n+\n+    @Setter\n+    @Getter\n+    private String signature;\n+\n+    @Setter\n+    @Getter\n+    private int flags;\n+\n+    @Setter\n+    @Getter\n+    private boolean deprecated = false;\n+\n+    @Setter\n+    @Getter\n+    private boolean isInterface = false;\n+\n+    /**\n+     * @param fullyQualifiedName fullyQualifiedName\n+     * @param type               type\n+     */\n+    public Node(String fullyQualifiedName, Node.Type type) {\n+        this.fullyQualifiedName = fullyQualifiedName;\n+        this.type = type;\n+    }\n+\n+    public String getSimpleName() {\n+        int pos = fullyQualifiedName.lastIndexOf(".");\n+        if (pos != -1) {\n+            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n+                    .length());\n+        }\n+        return fullyQualifiedName;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (getSignature() != null)\n+            return getType() + "= " + getFullyQualifiedName() + getSignature();\n+        else\n+            return getType() + "= " + getFullyQualifiedName();\n+    }\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\n\n\npublic class Node {\n\n    public boolean hasCallGraph() {\n        return false;\n    }\n\n    public void setCreatedCallGraph() {\n    }\n\n    public static enum Type {\n        PROJECT, PACKAGE, CLASS, METHOD, FIELD, METHOD_CALL, IMPORT, CLASS_REFERENCE, FIELD_REFERENCE\n    }\n\n\n    @Getter\n    @Setter\n    private String fullyQualifiedName;\n\n    @Setter\n    @Getter\n    private Node.Type type;\n\n    @Setter\n    @Getter\n    private int[] shingles;\n\n    @Setter\n    @Getter\n    private boolean hasCallGraph;\n\n    @Setter\n    @Getter\n    private String projectName;\n\n    @Setter\n    @Getter\n    private boolean isAPI = false;\n\n    @Setter\n    @Getter\n    private String signature;\n\n    @Setter\n    @Getter\n    private int flags;\n\n    @Setter\n    @Getter\n    private boolean deprecated = false;\n\n    @Setter\n    @Getter\n    private boolean isInterface = false;\n\n    /**\n     * @param fullyQualifiedName fullyQualifiedName\n     * @param type               type\n     */\n    public Node(String fullyQualifiedName, Node.Type type) {\n        this.fullyQualifiedName = fullyQualifiedName;\n        this.type = type;\n    }\n\n    public String getSimpleName() {\n        int pos = fullyQualifiedName.lastIndexOf(".");\n        if (pos != -1) {\n            return fullyQualifiedName.substring(pos + 1, fullyQualifiedName\n                    .length());\n        }\n        return fullyQualifiedName;\n    }\n\n    @Override\n    public String toString() {\n        if (getSignature() != null)\n            return getType() + "= " + getFullyQualifiedName() + getSignature();\n        else\n            return getType() + "= " + getFullyQualifiedName();\n    }\n}\n'
          },
          {
            sha: "83dcc9cfbd0cd773712c1ec4e47d2efee5371374",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesStrategy.java",
            status: "added",
            additions: 9,
            deletions: 0,
            patch:
              "@@ -0,0 +1,9 @@\n+package refactoring.crawler.util;\n+\n+public interface ShinglesStrategy {\n+    int upperBoundLimitForShinglesBag(int loc, int s_base);\n+\n+    int upperBoundForClassShingles(int numMethods, int s_base);\n+\n+    int upperBoundForPackageShingles(int numClasses, int s_base);\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\npublic interface ShinglesStrategy {\n    int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n    int upperBoundForClassShingles(int numMethods, int s_base);\n\n    int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n"
          },
          {
            sha: "d6c31c95601aeca5d514d4627237ca39d3c44999",
            filename:
              "src/main/java/refactoring/crawler/util/ShinglesUtil.java",
            status: "added",
            additions: 130,
            deletions: 0,
            patch:
              "@@ -0,0 +1,130 @@\n+package refactoring.crawler.util;\n+\n+import org.jgrapht.graph.DirectedMultigraph;\n+import org.jgrapht.traverse.BreadthFirstIterator;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+public class ShinglesUtil {\n+    private ShinglesStrategy shinglesStrategy;\n+\n+    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n+\n+    private DirectedMultigraph<Node, Edge> newVersionGraph;\n+\n+    private List<Node[]> similarMethods;\n+\n+    private List<Node> oldVersionPackageList;\n+    private List<Node> oldVersionClassList;\n+    private List<Node> oldVersionMethodList;\n+    private List<Node> oldVersionFieldList;\n+\n+    private List<Node> newVersionPackageList;\n+    private List<Node> newVersionClassList;\n+    private List<Node> newVersionMethodList;\n+    private List<Node> newVersionFieldList;\n+\n+    private double methodThreshold;\n+\n+    public ShinglesUtil() {\n+        this.shinglesStrategy = new FactorOf2Strategy();\n+    }\n+\n+    public int[] computeMethodShingles(String str) {\n+        return null;\n+    }\n+\n+    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n+        this.oldVersionGraph = oldVersionGraph;\n+        this.newVersionGraph = newVersionGraph;\n+\n+        this.oldVersionPackageList = new ArrayList<>();\n+        this.oldVersionClassList = new ArrayList<>();\n+        this.oldVersionMethodList = new ArrayList<>();\n+        this.oldVersionFieldList = new ArrayList<>();\n+\n+        this.newVersionPackageList = new ArrayList<>();\n+        this.newVersionClassList = new ArrayList<>();\n+        this.newVersionMethodList = new ArrayList<>();\n+        this.newVersionFieldList = new ArrayList<>();\n+\n+        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n+                oldVersionPackageList, oldVersionFieldList);\n+\n+        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n+    }\n+\n+    /**\n+     * For the passed graph, fills the respective arrays for packages, classes,\n+     * methods and fields by using a breadth first iterator.\n+     *\n+     * @param graph\n+     * @param methods\n+     * @param classes\n+     * @param packages\n+     * @param fields\n+     */\n+    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n+                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n+        // Create a BreadthFirstIterator for the graph\n+        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n+        while (bfi.hasNext()) {\n+            Node n = bfi.next();\n+            if (n.getType().equals(Node.Type.CLASS)) {\n+                classes.add(n);\n+            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n+                packages.add(n);\n+            } else if (n.getType().equals(Node.Type.METHOD)) {\n+                methods.add(n);\n+            } else if (n.getType().equals(Node.Type.FIELD)) {\n+                fields.add(n);\n+            }\n+        }\n+    }\n+\n+    public List<Node[]> findSimilarMethods() {\n+        if (this.similarMethods.isEmpty()) {\n+            List<Node[]> similarMethods = new ArrayList<>();\n+            for (Node m : this.oldVersionMethodList) {\n+                if (!m.isAPI())\n+                    continue;\n+\n+                for (Node m2 : this.newVersionMethodList) {\n+                    if (!m2.isAPI())\n+                        continue;\n+\n+                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n+                        Node[] arr = {m, m2};\n+                        // if (!isThisArrayInTheList(simMet, arr))\n+                        similarMethods.add(arr);\n+                    }\n+                }\n+            }\n+            this.similarMethods = similarMethods;\n+        }\n+        return this.similarMethods;\n+    }\n+\n+    public double howMuchAlike(int[] arr1, int[] arr2) {\n+        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n+        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n+        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n+        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n+        return finalGrade;\n+    }\n+\n+    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n+        int[] tempArr = (int[]) arr2.clone();\n+        double grade = 0.0;\n+        for (int value : arr1) {\n+            for (int j = 0; j < tempArr.length; j++) {\n+                if (value == tempArr[j]) {\n+                    grade += 1.0 / arr1.length;\n+                    tempArr[j] = Integer.MIN_VALUE;\n+                    break;\n+                }\n+            }\n+        }\n+        return grade;\n+    }\n+}",
            rawContent:
              "package refactoring.crawler.util;\n\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class ShinglesUtil {\n    private ShinglesStrategy shinglesStrategy;\n\n    private DirectedMultigraph<Node, Edge> oldVersionGraph;\n\n    private DirectedMultigraph<Node, Edge> newVersionGraph;\n\n    private List<Node[]> similarMethods;\n\n    private List<Node> oldVersionPackageList;\n    private List<Node> oldVersionClassList;\n    private List<Node> oldVersionMethodList;\n    private List<Node> oldVersionFieldList;\n\n    private List<Node> newVersionPackageList;\n    private List<Node> newVersionClassList;\n    private List<Node> newVersionMethodList;\n    private List<Node> newVersionFieldList;\n\n    private double methodThreshold;\n\n    public ShinglesUtil() {\n        this.shinglesStrategy = new FactorOf2Strategy();\n    }\n\n    public int[] computeMethodShingles(String str) {\n        return null;\n    }\n\n    public void initialize(DirectedMultigraph<Node, Edge> oldVersionGraph, DirectedMultigraph<Node, Edge> newVersionGraph) {\n        this.oldVersionGraph = oldVersionGraph;\n        this.newVersionGraph = newVersionGraph;\n\n        this.oldVersionPackageList = new ArrayList<>();\n        this.oldVersionClassList = new ArrayList<>();\n        this.oldVersionMethodList = new ArrayList<>();\n        this.oldVersionFieldList = new ArrayList<>();\n\n        this.newVersionPackageList = new ArrayList<>();\n        this.newVersionClassList = new ArrayList<>();\n        this.newVersionMethodList = new ArrayList<>();\n        this.newVersionFieldList = new ArrayList<>();\n\n        initializeElementsLists(oldVersionGraph, oldVersionMethodList, oldVersionClassList,\n                oldVersionPackageList, oldVersionFieldList);\n\n        initializeElementsLists(newVersionGraph, newVersionMethodList, newVersionClassList, newVersionPackageList, newVersionFieldList);\n    }\n\n    /**\n     * For the passed graph, fills the respective arrays for packages, classes,\n     * methods and fields by using a breadth first iterator.\n     *\n     * @param graph\n     * @param methods\n     * @param classes\n     * @param packages\n     * @param fields\n     */\n    private void initializeElementsLists(DirectedMultigraph<Node, Edge> graph, List<Node> methods,\n                                         List<Node> classes, List<Node> packages, List<Node> fields) {\n        // Create a BreadthFirstIterator for the graph\n        BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n        while (bfi.hasNext()) {\n            Node n = bfi.next();\n            if (n.getType().equals(Node.Type.CLASS)) {\n                classes.add(n);\n            } else if (n.getType().equals(Node.Type.PACKAGE)) {\n                packages.add(n);\n            } else if (n.getType().equals(Node.Type.METHOD)) {\n                methods.add(n);\n            } else if (n.getType().equals(Node.Type.FIELD)) {\n                fields.add(n);\n            }\n        }\n    }\n\n    public List<Node[]> findSimilarMethods() {\n        if (this.similarMethods.isEmpty()) {\n            List<Node[]> similarMethods = new ArrayList<>();\n            for (Node m : this.oldVersionMethodList) {\n                if (!m.isAPI())\n                    continue;\n\n                for (Node m2 : this.newVersionMethodList) {\n                    if (!m2.isAPI())\n                        continue;\n\n                    if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n                        Node[] arr = {m, m2};\n                        // if (!isThisArrayInTheList(simMet, arr))\n                        similarMethods.add(arr);\n                    }\n                }\n            }\n            this.similarMethods = similarMethods;\n        }\n        return this.similarMethods;\n    }\n\n    public double howMuchAlike(int[] arr1, int[] arr2) {\n        double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n        similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n        similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n        finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n        return finalGrade;\n    }\n\n    private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n        int[] tempArr = (int[]) arr2.clone();\n        double grade = 0.0;\n        for (int value : arr1) {\n            for (int j = 0; j < tempArr.length; j++) {\n                if (value == tempArr[j]) {\n                    grade += 1.0 / arr1.length;\n                    tempArr[j] = Integer.MIN_VALUE;\n                    break;\n                }\n            }\n        }\n        return grade;\n    }\n}\n"
          },
          {
            sha: "685341106012f3c9808aa7cf285e282fb1cde756",
            filename:
              "src/main/java/refactoring/crawler/util/SourceNavigator.java",
            status: "added",
            additions: 180,
            deletions: 0,
            patch:
              '@@ -0,0 +1,180 @@\n+package refactoring.crawler.util;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.val;\n+import org.eclipse.jdt.core.Signature;\n+import refactoring.crawler.project.*;\n+\n+import javax.annotation.Nonnull;\n+\n+public class SourceNavigator {\n+\n+\t@Getter\n+\tprivate NamedDirectedMultigraph graph;\n+\n+\tprivate ShinglesUtil shinglesUtil;\n+\n+\tprivate String projectName;\n+\n+\tprivate int packageCounter = 0;\n+\n+\tprivate int allMethodsCounter = 0;\n+\n+\tprivate int allClassCounter = 0;\n+\n+\tprivate int apiClassCounter = 0;\n+\n+\tprivate int apiMethodCounter = 0;\n+\n+\tpublic static boolean useJavadocComments = false;\n+\n+\tpublic SourceNavigator() {\n+\t\tgraph = new NamedDirectedMultigraph();\n+\t}\n+\n+\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n+\t\tthis.shinglesUtil = shinglesUtil;\n+\t}\n+\n+\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n+\t\tthis.projectName = projectName;\n+\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n+\t\tval packages = compilationUnits.stream()\n+\t\t\t.map(CompilationUnit::getPackageDeclaration)\n+\t\t\t.filter(p -> !p.isPresent())\n+\t\t\t.collect(Collectors.toList());\n+//        this.graph.addVertex(projectNode);\n+\t\tthis.graph.addNamedVertex(projectNode);\n+\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n+\t}\n+\n+\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n+\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n+\t\tchildrenPackages.forEach(childrenPackage -> {\n+\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n+\t\t\tpackageNode.setProjectName(this.projectName);\n+//            graph.addVertex(packageNode);\n+\t\t\tgraph.addNamedVertex(packageNode);\n+//            graph.addEdge(projectNode, packageNode);\n+\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n+\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n+\t\t\tthis.packageCounter += 1;\n+\t\t});\n+\t}\n+\n+\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n+\t\tval classes = pckg.getClasses();\n+\t\tclasses.forEach(clz -> {\n+\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n+\t\t\tclassNode.setProjectName(this.projectName);\n+\t\t\tclassNode.setFlags(clz.getFlags());\n+//            graph.addVertex(classNode);\n+//            graph.addEdge(packageNode, classNode);\n+\t\t\tgraph.addNamedVertex(classNode);\n+\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n+\t\t\tthis.browseClass(clz, classNode);\n+\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n+\t\t\tclassNode.setInterface(clz.getIsInterface());\n+\t\t\tthis.allClassCounter += 1;\n+\t\t\tif (clz.isProtected() || clz.isPublic()) {\n+\t\t\t\tclassNode.setAPI(true);\n+\t\t\t\tthis.apiClassCounter += 1;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n+\t\tval methods = clz.getMethods();\n+\t\tbrowseMethods(methods, classNode);\n+\t\tval fields = clz.getFields();\n+\t\tbrowseFields(fields, classNode);\n+\t}\n+\n+\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n+\t\tmethods.forEach(method -> {\n+\t\t\tString statementBody = "";\n+\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n+\t\t\t\tstatementBody = method.getSource().trim();\n+\t\t\t} else\n+\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n+\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n+\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n+\t\t\t\t+ method.getElementName();\n+\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n+\n+\t\t\tallMethodsCounter += 1;\n+\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n+\t\t\t\tmethodNode.setAPI(true);\n+\t\t\t\tthis.apiMethodCounter += 1;\n+\t\t\t}\n+\t\t\tif (method.getIsDeprecated())\n+\t\t\t\tmethodNode.setDeprecated(true);\n+\t\t\tmethodNode.setProjectName(projectName);\n+\t\t\tmethodNode.setShingles(shingles);\n+\t\t\tmethodNode.setFlags(method.getFlags());\n+\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n+//            graph.addVertex(methodNode);\n+//            graph.addEdge(classNode, methodNode);\n+\t\t\tgraph.addNamedVertex(methodNode);\n+\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n+\t\t});\n+\t}\n+\n+\n+\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\n+\t\tbuffer.append(\'(\');\n+\n+\t\tString[] types = method.getParameterTypes();\n+\t\tfor (int i = 0; i < types.length; i++) {\n+\t\t\tif (i > 0)\n+\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n+\t\t\tString typeSig = Signature.toString(types[i]);\n+\t\t\tbuffer.append(typeSig);\n+\t\t}\n+\t\tbuffer.append(\')\');\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n+\t\tfields.forEach(field -> {\n+\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n+\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n+\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n+\t\t\tfieldNode.setProjectName(this.projectName);\n+\t\t\tfieldNode.setShingles(shingles);\n+\t\t\tfieldNode.setFlags(field.getFlags());\n+\t\t\tfieldNode.setSignature(field.getTypeSignature());\n+\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n+//            graph.addVertex(fieldNode);\n+//            graph.addEdge(classNode, fieldNode);\n+\t\t\tgraph.addNamedVertex(fieldNode);\n+\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * This prunes away the javadoc comments\n+\t *\n+\t * @param source\n+\t * @return\n+\t */\n+\tprivate String statementBody(String source) {\n+\t\tint lastAtChar = source.lastIndexOf("@");\n+\t\tif (lastAtChar == -1)\n+\t\t\tlastAtChar = 0;\n+\t\tint openingBracket = source.indexOf("{", lastAtChar);\n+\t\tint closingBracket = source.lastIndexOf("}");\n+\t\tif (openingBracket != -1)\n+\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n+\t\treturn source;\n+\t}\n+}',
            rawContent:
              'package refactoring.crawler.util;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport org.eclipse.jdt.core.Signature;\nimport refactoring.crawler.project.*;\n\nimport javax.annotation.Nonnull;\n\npublic class SourceNavigator {\n\n\t@Getter\n\tprivate NamedDirectedMultigraph graph;\n\n\tprivate ShinglesUtil shinglesUtil;\n\n\tprivate String projectName;\n\n\tprivate int packageCounter = 0;\n\n\tprivate int allMethodsCounter = 0;\n\n\tprivate int allClassCounter = 0;\n\n\tprivate int apiClassCounter = 0;\n\n\tprivate int apiMethodCounter = 0;\n\n\tpublic static boolean useJavadocComments = false;\n\n\tpublic SourceNavigator() {\n\t\tgraph = new NamedDirectedMultigraph();\n\t}\n\n\tpublic void setShinglesUtil(ShinglesUtil shinglesUtil) {\n\t\tthis.shinglesUtil = shinglesUtil;\n\t}\n\n\tpublic void browseProject(@NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n\t\tthis.projectName = projectName;\n\t\tval projectNode = new Node(projectName, Node.Type.PROJECT);\n\t\tval packages = compilationUnits.stream()\n\t\t\t.map(CompilationUnit::getPackageDeclaration)\n\t\t\t.filter(p -> !p.isPresent())\n\t\t\t.collect(Collectors.toList());\n//        this.graph.addVertex(projectNode);\n\t\tthis.graph.addNamedVertex(projectNode);\n\t\tpackages.forEach(p -> this.browseInPackageRoot(p, projectNode));\n\t}\n\n\tprivate void browseInPackageRoot(@NonNull PackageDeclaration packageDeclaration, @NonNull Node projectNode) {\n\t\tList<PackageDeclaration> childrenPackages = packageDeclaration.getChildNodes();\n\t\tchildrenPackages.forEach(childrenPackage -> {\n\t\t\tNode packageNode = new Node(childrenPackage.get, Node.Type.PACKAGE);\n\t\t\tpackageNode.setProjectName(this.projectName);\n//            graph.addVertex(packageNode);\n\t\t\tgraph.addNamedVertex(packageNode);\n//            graph.addEdge(projectNode, packageNode);\n\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n\t\t\tthis.packageCounter += 1;\n\t\t});\n\t}\n\n\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n\t\tval classes = pckg.getClasses();\n\t\tclasses.forEach(clz -> {\n\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n\t\t\tclassNode.setProjectName(this.projectName);\n\t\t\tclassNode.setFlags(clz.getFlags());\n//            graph.addVertex(classNode);\n//            graph.addEdge(packageNode, classNode);\n\t\t\tgraph.addNamedVertex(classNode);\n\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\t\t\tthis.browseClass(clz, classNode);\n\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n\t\t\tclassNode.setInterface(clz.getIsInterface());\n\t\t\tthis.allClassCounter += 1;\n\t\t\tif (clz.isProtected() || clz.isPublic()) {\n\t\t\t\tclassNode.setAPI(true);\n\t\t\t\tthis.apiClassCounter += 1;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n\t\tval methods = clz.getMethods();\n\t\tbrowseMethods(methods, classNode);\n\t\tval fields = clz.getFields();\n\t\tbrowseFields(fields, classNode);\n\t}\n\n\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n\t\tmethods.forEach(method -> {\n\t\t\tString statementBody = "";\n\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n\t\t\t\tstatementBody = method.getSource().trim();\n\t\t\t} else\n\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n\t\t\t\t+ method.getElementName();\n\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n\n\t\t\tallMethodsCounter += 1;\n\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n\t\t\t\tmethodNode.setAPI(true);\n\t\t\t\tthis.apiMethodCounter += 1;\n\t\t\t}\n\t\t\tif (method.getIsDeprecated())\n\t\t\t\tmethodNode.setDeprecated(true);\n\t\t\tmethodNode.setProjectName(projectName);\n\t\t\tmethodNode.setShingles(shingles);\n\t\t\tmethodNode.setFlags(method.getFlags());\n\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n//            graph.addVertex(methodNode);\n//            graph.addEdge(classNode, methodNode);\n\t\t\tgraph.addNamedVertex(methodNode);\n\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n\t\t});\n\t}\n\n\n\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\tbuffer.append(\'(\');\n\n\t\tString[] types = method.getParameterTypes();\n\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n\t\t\tString typeSig = Signature.toString(types[i]);\n\t\t\tbuffer.append(typeSig);\n\t\t}\n\t\tbuffer.append(\')\');\n\n\t\treturn buffer.toString();\n\t}\n\n\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n\t\tfields.forEach(field -> {\n\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n\t\t\tfieldNode.setProjectName(this.projectName);\n\t\t\tfieldNode.setShingles(shingles);\n\t\t\tfieldNode.setFlags(field.getFlags());\n\t\t\tfieldNode.setSignature(field.getTypeSignature());\n\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n//            graph.addVertex(fieldNode);\n//            graph.addEdge(classNode, fieldNode);\n\t\t\tgraph.addNamedVertex(fieldNode);\n\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n\t\t});\n\t}\n\n\t/**\n\t * This prunes away the javadoc comments\n\t *\n\t * @param source\n\t * @return\n\t */\n\tprivate String statementBody(String source) {\n\t\tint lastAtChar = source.lastIndexOf("@");\n\t\tif (lastAtChar == -1)\n\t\t\tlastAtChar = 0;\n\t\tint openingBracket = source.indexOf("{", lastAtChar);\n\t\tint closingBracket = source.lastIndexOf("}");\n\t\tif (openingBracket != -1)\n\t\t\treturn source.substring(openingBracket + 1, closingBracket);\n\t\treturn source;\n\t}\n}\n'
          },
          {
            sha: "725ef3d6de620acbc3d0eeed586e1bc21cc5f2b6",
            filename:
              "src/main/java/refactoring/crawler/visitor/ClassVisitor.java",
            status: "added",
            additions: 8,
            deletions: 0,
            patch:
              "@@ -0,0 +1,8 @@\n+package refactoring.crawler.visitor;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+public class ClassVisitor extends VoidVisitorAdapter<Object> {\n+\n+}",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class ClassVisitor extends VoidVisitorAdapter<Object> {\n\n}\n"
          },
          {
            sha: "da212c011daa35711a7bc770b3a8647fd26e91a3",
            filename:
              "src/main/java/refactoring/crawler/visitor/MethodVisitor.java",
            status: "added",
            additions: 518,
            deletions: 0,
            patch:
              "@@ -0,0 +1,518 @@\n+package refactoring.crawler.visitor;\n+\n+import com.github.javaparser.ast.*;\n+import com.github.javaparser.ast.body.*;\n+import com.github.javaparser.ast.comments.*;\n+import com.github.javaparser.ast.expr.*;\n+import com.github.javaparser.ast.modules.*;\n+import com.github.javaparser.ast.stmt.*;\n+import com.github.javaparser.ast.type.*;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+public class MethodVisitor extends VoidVisitorAdapter<Object> {\n+\n+    public void visit(MethodDeclaration n, Object arg) {\n+        System.out.println(n.getBody());\n+        System.out.println(n.getName());\n+    }\n+\n+    @Override\n+    public void visit(AnnotationDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AnnotationMemberDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayAccessExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayCreationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayInitializerExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AssertStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(AssignExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BinaryExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BlockComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BlockStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BooleanLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(BreakStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CastExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CatchClause n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CharLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ClassOrInterfaceType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(CompilationUnit n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ConditionalExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ConstructorDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ContinueStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(DoStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(DoubleLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EmptyStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnclosedExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnumConstantDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(EnumDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ExpressionStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(FieldAccessExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(FieldDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ForEachStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ForStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IfStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(InitializerDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(InstanceOfExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IntegerLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LabeledStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LineComment n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LongLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MarkerAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MemberValuePair n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MethodCallExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NameExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NormalAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NullLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ObjectCreationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(PackageDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Parameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(PrimitiveType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Name n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SimpleName n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ArrayCreationLevel n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(IntersectionType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnionType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ReturnStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(StringLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SuperExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchEntry n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SynchronizedStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ThisExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ThrowStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TryStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LocalClassDeclarationStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TypeParameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnaryExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnknownType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VariableDeclarationExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VariableDeclarator n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VoidType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(WhileStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(WildcardType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(LambdaExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(MethodReferenceExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TypeExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(NodeList n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ImportDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleDeclaration n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleRequiresDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleExportsDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleProvidesDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleUsesDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ModuleOpensDirective n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(UnparsableStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(ReceiverParameter n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(VarType n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(Modifier n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(SwitchExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(TextBlockLiteralExpr n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(YieldStmt n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocBlockTag n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocContent n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocDescription n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocInlineTag n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+\n+    @Override\n+    public void visit(JavadocSnippet n, Object arg) {\n+        super.visit(n, arg);\n+    }\n+}\n\\ No newline at end of file",
            rawContent:
              "package refactoring.crawler.visitor;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.modules.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\npublic class MethodVisitor extends VoidVisitorAdapter<Object> {\n\n    public void visit(MethodDeclaration n, Object arg) {\n        System.out.println(n.getBody());\n        System.out.println(n.getName());\n    }\n\n    @Override\n    public void visit(AnnotationDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AnnotationMemberDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayInitializerExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssertStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(AssignExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BinaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BlockStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BooleanLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(BreakStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CastExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CatchClause n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CharLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ClassOrInterfaceType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(CompilationUnit n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConditionalExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ConstructorDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ContinueStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(DoubleLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EmptyStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnclosedExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumConstantDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(EnumDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ExpressionStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldAccessExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(FieldDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForEachStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ForStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IfStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InitializerDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(InstanceOfExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntegerLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LabeledStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LineComment n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LongLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MarkerAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MemberValuePair n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodCallExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NameExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NormalAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NullLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ObjectCreationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PackageDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Parameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(PrimitiveType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Name n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SimpleName n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(IntersectionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReturnStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SingleMemberAnnotationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(StringLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SuperExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchEntry n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SynchronizedStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThisExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ThrowStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TryStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LocalClassDeclarationStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnaryExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarationExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VariableDeclarator n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VoidType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WhileStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(WildcardType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(NodeList n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ImportDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleDeclaration n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleRequiresDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleExportsDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleProvidesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleUsesDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ModuleOpensDirective n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnparsableStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ReceiverParameter n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(VarType n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(Modifier n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(SwitchExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TextBlockLiteralExpr n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(YieldStmt n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocBlockTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocContent n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocDescription n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocInlineTag n, Object arg) {\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(JavadocSnippet n, Object arg) {\n        super.visit(n, arg);\n    }\n}"
          },
          {
            sha: "1f2ec2d8c7de952487f2f8c7cf6e125976d6ad20",
            filename: "src/test/java/refactoring/crawler/LibraryTest.java",
            status: "added",
            additions: 14,
            deletions: 0,
            patch:
              "@@ -0,0 +1,14 @@\n+/*\n+ * This Java source file was generated by the Gradle 'init' task.\n+ */\n+package refactoring.crawler;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class LibraryTest {\n+    @Test void testSomeLibraryMethod() {\n+        Library classUnderTest = new Library();\n+        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n+    }\n+}",
            rawContent:
              "/*\n * This Java source file was generated by the Gradle 'init' task.\n */\npackage refactoring.crawler;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LibraryTest {\n    @Test void testSomeLibraryMethod() {\n        Library classUnderTest = new Library();\n        assertTrue(classUnderTest.someLibraryMethod(), \"someLibraryMethod should return 'true'\");\n    }\n}\n"
          }
        ]
      }
    ],
    trees: [
      {
        subTrees: [
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "3663e804b7832ea04bf4a3ff8eafea32070498dd",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "6d45cd03f52a582ed4925ce83d7c0dfa088209e3",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "original",
                                sha: "fe217450e9ba950dba99855d78dd89bb0f6213de"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "2dc66023a72d428c6c21fd74e2234072326a49e2",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "701f29bc236e688897a8a591086c04fde5b966e9",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "986e673462260d92feac4b036a4d2b48af19cb71",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "newVersion",
                                sha: "035ccb7d43d00146cd15659487a15ab390b263c9"
                              }
                            ],
                            type: "FOLDER",
                            path: "testPushDownMethod",
                            sha: "5d3fb22bf9533e1d01f9985765f21cbe7738af45"
                          },
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "0a06f9b4447e64347de6217bb6a2a1ff9d57c920",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "4b759f877b4483f21723c98d6fe5403d7f6cd4df",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "7e973976b15ab8576eeb05a552ef14b85f64a6cd",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "original",
                                sha: "c71faa28699f5ec81e575876f0e2c145dc66d068"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "Soldier.java",
                                    sha:
                                      "dd83f48f6ade0ae1135e1142522e3d14895cb000",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Tank.java",
                                    sha:
                                      "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "Unit.java",
                                    sha:
                                      "e4e3a2ff422284c53ab262608b26088f45ae47e1",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "newVersion",
                                sha: "6d258ff24af96d8479adda2b4740222a9f826199"
                              }
                            ],
                            type: "FOLDER",
                            path: "testPullUpMethod",
                            sha: "b43a61966d7e6aa4a1a660bd5b8629d7ffc1ceb9"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "Array.java",
                                sha: "e27bc744f35db7816a16656ad51b777fb11c089b",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ArrayStack.java",
                                sha: "b5111703d0e7e2b56393115af91c30d85537e93d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Stack.java",
                                sha: "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "testMoveMethod",
                            sha: "40afa68dfbb3a131f33f7d93793faba0bb9d2ab1"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "Array.java",
                                sha: "3d04b5375c95bfa076ffba2211b24cb079563585",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ArrayStack.java",
                                sha: "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Stack.java",
                                sha: "b3512976aa6de01f87c5d7e929b59a137bdc69a3",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "original",
                            sha: "2a15a3a12d34a74a2027ea661a9b101a9cfdecb5"
                          },
                          {
                            type: "FILE",
                            path: "RefactoringCrawlerTest.java",
                            sha: "95c782cd777d56e3441b65345697ee273f34fff4",
                            subTrees: []
                          },
                          {
                            type: "FILE",
                            path: "TestUtils.java",
                            sha: "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92",
                            subTrees: []
                          }
                        ],
                        type: "FOLDER",
                        path: "crawler",
                        sha: "98288f4e7f0e172bba7041ec831758b368b93522"
                      }
                    ],
                    type: "FOLDER",
                    path: "refactoring",
                    sha: "9ef8d49f98d995b8170df85355997b662966490b"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "c6e539a4b86cac1acfe92f4e91aa259dfc190d7b"
              }
            ],
            type: "FOLDER",
            path: "test",
            sha: "7f203f941c443c15f09bdcd85fa5ccb07f43081b"
          },
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "RefactoringCategory.java",
                                sha: "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "SourceNavigator.java",
                                sha: "15111aaeb3dee736e91cde79219e6eafa796ca62",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "util",
                            sha: "38e8428da312e0bec4049f16f56d2a589097a5d1"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "BloomFilter.java",
                                sha: "98bf2210121031f53e8caf7f8f89645f6b1dcc86",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "DefaultStrategy.java",
                                sha: "3be706f1ea9ded9a332de32c31f99eedf4652de0",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "FactorOf2Strategy.java",
                                sha: "55e796c451fb63675bae1000f41dd15b720bbb42",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ShinglesStrategy.java",
                                sha: "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "ShinglesUtil.java",
                                sha: "088d9845fab60669cca75fe6233c0e37d1280b6d",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "shingles",
                            sha: "56f30a8ca8fb903827e3db90ee5cfce4f85dd4d7"
                          },
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "ClassNode.java",
                                sha: "66cc05cc40337a87d4835854e19c62d19d2c4067",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Edge.java",
                                sha: "7774ec8b37feef6882a868e2660021a320eeaa54",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "FieldNode.java",
                                sha: "51d845ea135825c28660aac7c258adde05243914",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "MethodNode.java",
                                sha: "e2919264f5aa7154db6f0c0501950564a730a1e3",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "NamedDirectedMultigraph.java",
                                sha: "5c0ac895baf10b75181e22675a8b7840b08fb90d",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "Node.java",
                                sha: "4397227e131372600696f0c613eaab9d7bf41229",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "graph",
                            sha: "cdb7155a52f9d60fb5a72d377603dd2835433ded"
                          },
                          {
                            subTrees: [
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "ChangeMethodSignatureDetection.java",
                                    sha:
                                      "6f93400dab485c9315236a4fe01494f3d3b2aef8",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MethodDetection.java",
                                    sha:
                                      "9e492fa56e3b1f654735d03da1b18778ea4a3c5e",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveMethodDetection.java",
                                    sha:
                                      "76a947129555279bb0423f831c949f1899b2074a",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "PullUpMethodDetection.java",
                                    sha:
                                      "2c24f295bf40887025a35ce694a69c056b81a7a3",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "PushDownMethodDetection.java",
                                    sha:
                                      "296bce275d7968716d7f0bed80da373e18210114",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "RenameMethodDetection.java",
                                    sha:
                                      "ad4c2988b4aa75b00ee844d54a74c441abebf9d0",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "methodDetection",
                                sha: "d71d6fbc9a38fa530fa48d80ee1f73e6581da619"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "FieldDetection.java",
                                    sha:
                                      "67bf6cf86456904a46c7d568fe0527ed920c971f",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveFieldDetection.java",
                                    sha:
                                      "184ff327f5f763cae4d3307e3cf0ae9b0391eb70",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "fieldDetection",
                                sha: "d2cf92424145905798c99058040596a8b5fdce12"
                              },
                              {
                                subTrees: [
                                  {
                                    type: "FILE",
                                    path: "ClassDetection.java",
                                    sha:
                                      "072aa07a114622cd395391b740b9a1e46b64fb70",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "MoveClassDetection.java",
                                    sha:
                                      "e753da375cfabc5fb57d8d5440f95671d7bf42f9",
                                    subTrees: []
                                  },
                                  {
                                    type: "FILE",
                                    path: "RenameClassDetection.java",
                                    sha:
                                      "f069e44153341cbf9da6818393293f5e7e9ac108",
                                    subTrees: []
                                  }
                                ],
                                type: "FOLDER",
                                path: "classDetection",
                                sha: "9f0ced53fce008209a00bde46ea3f4a4bbc74301"
                              },
                              {
                                type: "FILE",
                                path: "RefactoringDetection.java",
                                sha: "6ba49588fd9f84df7d87869b64cfedcf10d88ed0",
                                subTrees: []
                              },
                              {
                                type: "FILE",
                                path: "SearchHelper.java",
                                sha: "d81bb74b671cc12037d7efe46ea3c7faacae2b31",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "detection",
                            sha: "0f9b16b7f833ff07de2f31c4765a6be1dfda06f3"
                          },
                          {
                            type: "FILE",
                            path: "RefactoringCrawler.java",
                            sha: "4eb81739758717c8ca09b89db317ccc7d09c6c46",
                            subTrees: []
                          }
                        ],
                        type: "FOLDER",
                        path: "crawler",
                        sha: "69f6c6e48f58bcdf616b290b9e6b24a59a184dcd"
                      }
                    ],
                    type: "FOLDER",
                    path: "refactoring",
                    sha: "275d87f15d039923db87aed2db9adaf509dfb986"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "5d2a8220cfc3d7c2f673c01a0ba4a7a9db4fbf35"
              }
            ],
            type: "FOLDER",
            path: "main",
            sha: "1b5651eecd5c551bb2843bc7bfc4f9c595ff5e06"
          }
        ],
        type: "FOLDER",
        path: "src",
        sha: "f3a6fbab422f5dd563c43cab155e7a0fc34d04eb"
      },
      {
        subTrees: [
          {
            subTrees: [
              {
                type: "FILE",
                path: "gradle-wrapper.jar",
                sha: "5c2d1cf016b3885f6930543d57b744ea8c220a1a",
                subTrees: []
              },
              {
                type: "FILE",
                path: "gradle-wrapper.properties",
                sha: "f3b4dae340056399e69926fa62aba660b3e9404e",
                subTrees: []
              }
            ],
            type: "FOLDER",
            path: "wrapper",
            sha: "51f47f1a365e3bb394f7c705f95fb406d5a30c00"
          }
        ],
        type: "FOLDER",
        path: "gradle",
        sha: "82921f678d2459e9e22ae47b07d34dfa858ec085"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "org.eclipse.buildship.core.prefs",
            sha: "e8895216fd3c0c3af4c4522334775f41b7deb42e",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".settings",
        sha: "66e551dc6b35c2e0b562f48158c0916684323c66"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "compiler.xml",
            sha: "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d",
            subTrees: []
          },
          {
            type: "FILE",
            path: "gradle.xml",
            sha: "a64b2758bd03a20260566a40b58c116679055c17",
            subTrees: []
          },
          {
            type: "FILE",
            path: "jarRepositories.xml",
            sha: "4fed64e0de33c78035aa4aa1eb052668eb85c6d4",
            subTrees: []
          },
          {
            type: "FILE",
            path: "misc.xml",
            sha: "b1662faf91f158c3fc95e7f294260c2ea0cdbc12",
            subTrees: []
          },
          {
            type: "FILE",
            path: "uiDesigner.xml",
            sha: "e96534fb27b68192f27f985d3879e173ec77adb8",
            subTrees: []
          },
          {
            type: "FILE",
            path: "workspace.xml",
            sha: "0f5826ff690d76f8961058a4fd1cf25f380882c3",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".idea",
        sha: "cd26532d3e2893606d8764f108082f9c98f2996f"
      },
      {
        subTrees: [
          {
            type: "FILE",
            path: "config.yml",
            sha: "d45b35fe7e96659467ab36d569bede38ef6d8956",
            subTrees: []
          }
        ],
        type: "FOLDER",
        path: ".circleci",
        sha: "ddf3d2658c7739b92c394d54f0ffd22ef945ac1d"
      },
      {
        type: "FILE",
        path: ".gitattributes",
        sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".gitignore",
        sha: "ea419d85c301b292fbadf5b1f4da2c8350a1c0f1",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".project",
        sha: "669e8aabbeb973fc803553332427c4c3309bf0b6",
        subTrees: []
      },
      {
        type: "FILE",
        path: "README.md",
        sha: "b34fbf6028059b5e0f654d1d1645aef6f2400c75",
        subTrees: []
      },
      {
        type: "FILE",
        path: "build.gradle",
        sha: "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750",
        subTrees: []
      },
      {
        type: "FILE",
        path: "gradlew",
        sha: "8e25e6c19d5748190b8cc39e98c2b56e496a5717",
        subTrees: []
      },
      {
        type: "FILE",
        path: "gradlew.bat",
        sha: "9618d8d9607cd91a0efb866bcac4810064ba6fac",
        subTrees: []
      },
      {
        type: "FILE",
        path: "settings.gradle",
        sha: "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc",
        subTrees: []
      }
    ],
    branches: [
      {
        name: "circleci-project-setup",
        commitHeadSha: "2a8ff280c4626e929dec89adc0992be9af6c2c55"
      },
      {
        name: "develop",
        commitHeadSha: "7a8b2816009772c17420794bb3de9cc0a81d5e8c"
      },
      {
        name: "master",
        commitHeadSha: "27447784904e85b61609a78983e4ecbecaf37c4f"
      }
    ],
    shaFileContentMap: {
      "3663e804b7832ea04bf4a3ff8eafea32070498dd":
        'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "6d45cd03f52a582ed4925ce83d7c0dfa088209e3":
        'package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "59b5d1ed6eaa3cbab0ceee2eac457f60a3505813":
        "package refactoring.crawler.testPushDownMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n",
      "2dc66023a72d428c6c21fd74e2234072326a49e2":
        'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "701f29bc236e688897a8a591086c04fde5b966e9":
        'package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "986e673462260d92feac4b036a4d2b48af19cb71":
        "package refactoring.crawler.testPushDownMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n",
      "0a06f9b4447e64347de6217bb6a2a1ff9d57c920":
        'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "4b759f877b4483f21723c98d6fe5403d7f6cd4df":
        'package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "7e973976b15ab8576eeb05a552ef14b85f64a6cd":
        "package refactoring.crawler.testPullUpMethod.original;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n}\n",
      dd83f48f6ade0ae1135e1142522e3d14895cb000:
        'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:50\n */\npublic class Soldier extends Unit {\n\n  public Soldier() {\n    super();\n  }\n\n  public Soldier(String name) {\n    super(name, "Solider");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      "442c3ac49a5903f0023bb7d1b6de93a344e3ad8a":
        'package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:53\n */\npublic class Tank extends Unit {\n\n  public Tank() {\n    super();\n  }\n\n  public Tank(String name) {\n    super(name, "Tank");\n  }\n\n  public void printUnitInfo() {\n    System.out.println(this.getName() + this.getHealth());\n  }\n}\n',
      e4e3a2ff422284c53ab262608b26088f45ae47e1:
        "package refactoring.crawler.testPullUpMethod.newVersion;\n\n/**\n * @program: refactoring-crawler\n * @description: Class for testing push up method\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-30 14:48\n */\npublic class Unit {\n\n  private String name;\n  private String unitType;\n\n  protected int health;\n\n  public Unit() {}\n\n  public Unit(String name, String unitType) {\n    this.name = name;\n    this.unitType = unitType;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getUnitType() {\n    return this.unitType;\n  }\n\n  public int getHealth() {\n    return this.health;\n  }\n}\n",
      e27bc744f35db7816a16656ad51b777fb11c089b:
        'package refactoring.crawler.testMoveMethod;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n',
      b5111703d0e7e2b56393115af91c30d85537e93d:
        'package refactoring.crawler.testMoveMethod;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printLast() {\n    System.out.println(this.peek());\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n',
      "4b1dc8f457e40242723ac8a6fe2ad98b9aa90b6d":
        "package refactoring.crawler.testMoveMethod;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n",
      "3d04b5375c95bfa076ffba2211b24cb079563585":
        'package refactoring.crawler.original;\n\npublic class Array<E> {\n\n  private E[] data;\n  private int size;\n\n  // æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cä¼ å\u0085¥æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacityæ\u009e\u0084é\u0080 Array\n  public Array(int capacity) {\n    data = (E[]) new Object[capacity];\n    size = 0;\n  }\n\n  public void printLast() {\n    System.out.println(this.getLast());\n  }\n\n  // æ\u0097 å\u008f\u0082æ\u0095°ç\u009a\u0084æ\u009e\u0084é\u0080 å\u0087½æ\u0095°ï¼\u008cé»\u0098è®¤æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008fcapacity=10\n  public Array() {\n    this(10);\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ç\u009a\u0084å®¹é\u0087\u008f\n  public int getCapacity() {\n    return data.length;\n  }\n\n  // è\u008e·å\u008f\u0096æ\u0095°ç»\u0084ä¸\u00adç\u009a\u0084å\u0085\u0083ç´ ä¸ªæ\u0095°\n  public int getSize() {\n    return size;\n  }\n\n  // è¿\u0094å\u009b\u009eæ\u0095°ç»\u0084æ\u0098¯å\u0090¦ä¸ºç©º\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  // å\u009c¨indexç´¢å¼\u0095ç\u009a\u0084ä½\u008dç½®æ\u008f\u0092å\u0085¥ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ e\n  public void add(int index, E e) {\n\n    if (index < 0 || index > size)\n      throw new IllegalArgumentException("Add failed. Require index >= 0 and index <= size.");\n\n    if (size == data.length) resize(2 * data.length);\n\n    for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];\n\n    data[index] = e;\n\n    size++;\n  }\n\n  // å\u0090\u0091æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0090\u008eæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addLast(E e) {\n    add(size, e);\n  }\n\n  // å\u009c¨æ\u0089\u0080æ\u009c\u0089å\u0085\u0083ç´ å\u0089\u008dæ·»å\u008a ä¸\u0080ä¸ªæ\u0096°å\u0085\u0083ç´ \n  public void addFirst(E e) {\n    add(0, e);\n  }\n\n  // è\u008e·å\u008f\u0096indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ \n  public E get(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Get failed. Index is illegal.");\n    return data[index];\n  }\n\n  public E getLast() {\n    return get(size - 1);\n  }\n\n  public E getFirst() {\n    return get(0);\n  }\n\n  // ä¿®æ\u0094¹indexç´¢å¼\u0095ä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ ä¸ºe\n  public void set(int index, E e) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Set failed. Index is illegal.");\n    data[index] = e;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adæ\u0098¯å\u0090¦æ\u009c\u0089å\u0085\u0083ç´ e\n  public boolean contains(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return true;\n    }\n    return false;\n  }\n\n  // æ\u009f¥æ\u0089¾æ\u0095°ç»\u0084ä¸\u00adå\u0085\u0083ç´ eæ\u0089\u0080å\u009c¨ç\u009a\u0084ç´¢å¼\u0095ï¼\u008cå¦\u0082æ\u009e\u009cä¸\u008då\u00ad\u0098å\u009c¨å\u0085\u0083ç´ eï¼\u008cå\u0088\u0099è¿\u0094å\u009b\u009e-1\n  public int find(E e) {\n    for (int i = 0; i < size; i++) {\n      if (data[i].equals(e)) return i;\n    }\n    return -1;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤indexä½\u008dç½®ç\u009a\u0084å\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E remove(int index) {\n    if (index < 0 || index >= size)\n      throw new IllegalArgumentException("Remove failed. Index is illegal.");\n\n    E ret = data[index];\n    for (int i = index + 1; i < size; i++) data[i - 1] = data[i];\n    size--;\n    data[size] = null; // loitering objects != memory leak\n\n    if (size == data.length / 4 && data.length / 2 != 0) resize(data.length / 2);\n    return ret;\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤ç¬¬ä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeFirst() {\n    return remove(0);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤æ\u009c\u0080å\u0090\u008eä¸\u0080ä¸ªå\u0085\u0083ç´ , è¿\u0094å\u009b\u009eå\u0088 é\u0099¤ç\u009a\u0084å\u0085\u0083ç´ \n  public E removeLast() {\n    return remove(size - 1);\n  }\n\n  // ä»\u008eæ\u0095°ç»\u0084ä¸\u00adå\u0088 é\u0099¤å\u0085\u0083ç´ e\n  public void removeElement(E e) {\n    int index = find(e);\n    if (index != -1) remove(index);\n  }\n\n  @Override\n  public String toString() {\n\n    StringBuilder res = new StringBuilder();\n    res.append(String.format("Array: size = %d , capacity = %d\\n", size, data.length));\n    res.append(\'[\');\n    for (int i = 0; i < size; i++) {\n      res.append(data[i]);\n      if (i != size - 1) res.append(", ");\n    }\n    res.append(\']\');\n    return res.toString();\n  }\n\n  // å°\u0086æ\u0095°ç»\u0084ç©ºé\u0097´ç\u009a\u0084å®¹é\u0087\u008få\u008f\u0098æ\u0088\u0090newCapacityå¤§å°\u008f\n  private void resize(int newCapacity) {\n\n    E[] newData = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) newData[i] = data[i];\n    data = newData;\n  }\n}\n',
      "4c5c80ee3f2f20c9329c6b3e165735bbdcf93e0d":
        'package refactoring.crawler.original;\n\npublic class ArrayStack<E> implements Stack<E> {\n\n  private Array<E> array;\n\n  public ArrayStack(int capacity) {\n    array = new Array<>(capacity);\n  }\n\n  public ArrayStack() {\n    array = new Array<>();\n  }\n\n  public void printFirstAndLast() {\n    E first = this.array.getFirst();\n    System.out.println(first);\n    this.array.printLast();\n  }\n\n  @Override\n  public int getSize() {\n    return array.getSize();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return array.isEmpty();\n  }\n\n  public int getCapacity() {\n    return array.getCapacity();\n  }\n\n  @Override\n  public void push(E e) {\n    array.addLast(e);\n  }\n\n  @Override\n  public E pop() {\n    return array.removeLast();\n  }\n\n  @Override\n  public E peek() {\n    return array.getLast();\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    res.append("Stack: ");\n    res.append(\'[\');\n    for (int i = 0; i < array.getSize(); i++) {\n      res.append(array.get(i));\n      if (i != array.getSize() - 1) res.append(", ");\n    }\n    res.append("] top");\n    return res.toString();\n  }\n}\n',
      b3512976aa6de01f87c5d7e929b59a137bdc69a3:
        "package refactoring.crawler.original;\n\npublic interface Stack<E> {\n\n  int getSize();\n\n  boolean isEmpty();\n\n  void push(E e);\n\n  E pop();\n\n  E peek();\n}\n",
      "95c782cd777d56e3441b65345697ee273f34fff4":
        '/*\n * This Java source file was generated by the Gradle \'init\' task.\n */\npackage refactoring.crawler;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\nclass RefactoringCrawlerTest {\n\n  private static Dictionary<RefactoringCrawler.Settings, Double> settings;\n\n  @BeforeAll\n  static void setUp() {\n    settings = new Hashtable<>();\n\n    settings.put(RefactoringCrawler.Settings.T_CHANGE_METHOD_SIGNATURE, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_MOVE_METHOD, 0.5);\n    settings.put(RefactoringCrawler.Settings.T_PUSH_DOWN_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_PULL_UP_METHOD, 0.6);\n    settings.put(RefactoringCrawler.Settings.T_RENAME_CLASS, 0.7);\n  }\n\n  @Test\n  void testRenameMethod() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo12() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo12();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    assertEquals("RenamedMethods", categories.get(0).getName());\n    Node[] nodes = categories.get(0).getRefactoringPairs().get(0);\n    assertEquals("refactoring.crawler.Library.foo", nodes[0].getFullyQualifiedName());\n    assertEquals("refactoring.crawler.Library.foo12", nodes[1].getFullyQualifiedName());\n  }\n\n  @Test\n  void testChangeMethodSignature() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo(int i) {\\n"\n            + "\\t\\tSystem.out.println(i);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo(1);\\n"\n            + "\\t}\\n"\n            + "}\\n";\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(source, newVersion);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("ChangedMethodSignatures", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.Library.foo()", nodes[0].toString());\n    assertEquals("METHOD= refactoring.crawler.Library.foo(int)", nodes[1].toString());\n  }\n\n  @Test\n  void testRenameClass() {\n    String source =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(11111);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String source2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library();\\n"\n            + "}\\n";\n    String newVersion =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.crawler;\\n"\n            + "\\n"\n            + "public class Library123 {\\n"\n            + "\\tprivate int a;\\n"\n            + "\\tprivate int b;\\n"\n            + "\\n"\n            + "\\tpublic void foo() {\\n"\n            + "\\t\\tSystem.out.println(1);\\n"\n            + "\\t}\\n"\n            + "\\n"\n            + "\\tpublic void bar() {\\n"\n            + "\\t\\tthis.foo();\\n"\n            + "\\t}\\n"\n            + "}\\n";\n    String newVersion2 =\n        "/*\\n"\n            + " * This Java source file was generated by the Gradle \'init\' task.\\n"\n            + " */\\n"\n            + "package refactoring.a;\\n"\n            + "import refactoring.crawler.Library123;\\n"\n            + "public class A {\\n"\n            + "private Library library = new Library123();\\n"\n            + "}\\n";\n\n    List<String> originals = new LinkedList<>();\n    List<String> newVersions = new LinkedList<>();\n\n    originals.add(source);\n    originals.add(source2);\n\n    newVersions.add(newVersion);\n    newVersions.add(newVersion2);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("TEST", settings);\n    refactoringCrawler.detect(originals, newVersions);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals(1, categories.size());\n    assertEquals("RenamedClasses", refactoringCategory.getName());\n    assertEquals("CLASS= refactoring.crawler.Library", nodes[0].toString());\n    assertEquals("CLASS= refactoring.crawler.Library123", nodes[1].toString());\n  }\n\n  @Test\n  void testMoveMethod() throws IOException {\n    String originalArray = TestUtils.readFile("original", "Array.java", null, null);\n    String originalArrayStack = TestUtils.readFile("original", "ArrayStack.java", null, null);\n    String originalStack = TestUtils.readFile("original", "Stack.java", null, null);\n\n    String newVersionArray =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Array.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionArrayStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "ArrayStack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n    String newVersionStack =\n        TestUtils.readFile(\n            "testMoveMethod",\n            "Stack.java",\n            "package refactoring.crawler.testMoveMethod",\n            "package refactoring.crawler.original;");\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalArray);\n    originalList.add(originalStack);\n    originalList.add(originalArrayStack);\n\n    newVersionList.add(newVersionArray);\n    newVersionList.add(newVersionStack);\n    newVersionList.add(newVersionArrayStack);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("testMoveMethod", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("MovedMethods", refactoringCategory.getName());\n    assertEquals("METHOD= refactoring.crawler.original.Array.printLast()", nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.original.ArrayStack.printLast()", nodes[1].toString());\n  }\n\n  @Test\n  void testPullUpMethod() throws IOException {\n    String originalFolder = "testPullUpMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPullUpMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPullUpMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPullUpMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler = new RefactoringCrawler("test push up method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PulledUpMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Tank.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPullUpMethod.original.Unit.getHealth()",\n        nodes[1].toString());\n  }\n\n  @Test\n  void testPushDownMethod() throws IOException {\n    String originalFolder = "testPushDownMethod/original";\n    String originalUnit = TestUtils.readFile(originalFolder, "Unit.java", null, null);\n    String originalTank = TestUtils.readFile(originalFolder, "Tank.java", null, null);\n    String originalSoldier = TestUtils.readFile(originalFolder, "Soldier.java", null, null);\n\n    String newVersionFolder = "testPushDownMethod/newVersion";\n    String originalPackage = "package refactoring.crawler.testPushDownMethod.original";\n    String newVersionPackage = "package refactoring.crawler.testPushDownMethod.newVersion";\n\n    String newVersionUnit =\n        TestUtils.readFile(newVersionFolder, "Unit.java", newVersionPackage, originalPackage);\n    String newVersionTank =\n        TestUtils.readFile(newVersionFolder, "Tank.java", newVersionPackage, originalPackage);\n    String newVersionSoldier =\n        TestUtils.readFile(newVersionFolder, "Soldier.java", newVersionPackage, originalPackage);\n\n    List<String> originalList = new ArrayList<>();\n    List<String> newVersionList = new ArrayList<>();\n\n    originalList.add(originalUnit);\n    originalList.add(originalTank);\n    originalList.add(originalSoldier);\n\n    newVersionList.add(newVersionUnit);\n    newVersionList.add(newVersionTank);\n    newVersionList.add(newVersionSoldier);\n\n    RefactoringCrawler refactoringCrawler =\n        new RefactoringCrawler("test pull down method", settings);\n    refactoringCrawler.detect(originalList, newVersionList);\n    List<RefactoringCategory> categories = refactoringCrawler.getRefactoringCategories();\n    assertEquals(1, categories.size());\n    RefactoringCategory refactoringCategory = categories.get(0);\n    Node[] nodes = refactoringCategory.getRefactoringPairs().get(0);\n    assertEquals("PushedDownMethods", refactoringCategory.getName());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Unit.getHealth()",\n        nodes[0].toString());\n    assertEquals(\n        "METHOD= refactoring.crawler.testPushDownMethod.original.Tank.getHealth()",\n        nodes[1].toString());\n  }\n}\n',
      "2472ba0a5dc1ae8ea4b338dff6295d273a09ba92":
        'package refactoring.crawler;\n\nimport java.io.*;\n\n/**\n * @program: refactoring-crawler\n * @description: Utils Class For Testing\n * @author: laikinmeng\n * @package: ${IntelliJ IDEA}\n * @create: 2020-03-29 13:55\n */\npublic class TestUtils {\n  public static String readFile(\n      String folder, String filename, String replacePackage, String packageName)\n      throws IOException {\n    String filePath = String.format("src/test/java/refactoring/crawler/%s/%s", folder, filename);\n    BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(filePath)));\n    String st;\n    StringBuilder sb = new StringBuilder();\n    while ((st = bufferedReader.readLine()) != null) {\n      sb.append(st);\n      sb.append(System.getProperty("line.separator"));\n    }\n    String fileContent = sb.toString();\n    if (packageName != null) {\n      fileContent = fileContent.replace(replacePackage, packageName);\n    }\n    return fileContent;\n  }\n}\n',
      "80feda7acc40edd8e5ce9e231afbdc43d9f1fd5e":
        'package refactoring.crawler.util;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.graph.Node;\n\npublic class RefactoringCategory {\n\n  @Getter @Setter private String name;\n\n  @Getter @Setter private List<Node[]> refactoringPairs;\n\n  public Node[][] getElements() {\n    Node[][] elements = new Node[refactoringPairs.size()][];\n    int i = 0;\n    for (Node[] pair : refactoringPairs) {\n      elements[i++] = pair;\n    }\n    return elements;\n  }\n\n  public String toString() {\n    return name + printElements(getElements());\n  }\n\n  private String printElements(Node[][] array) {\n    StringBuilder res = new StringBuilder();\n    for (Node[] nodes : array) {\n      res.append("[").append(nodes[0]).append(",").append(nodes[1]).append("]");\n    }\n    return res.toString();\n  }\n}\n',
      "15111aaeb3dee736e91cde79219e6eafa796ca62":
        'package refactoring.crawler.util;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.val;\nimport refactoring.crawler.graph.*;\nimport refactoring.crawler.shingles.ShinglesUtil;\n\npublic class SourceNavigator {\n\n  @Getter private NamedDirectedMultigraph graph;\n\n  private ShinglesUtil shinglesUtil;\n\n  private String projectName;\n\n  private int packageCounter = 0;\n\n  private int allMethodsCounter = 0;\n\n  private int allClassCounter = 0;\n\n  private int apiClassCounter = 0;\n\n  private int apiMethodCounter = 0;\n\n  public static boolean useJavadocComments = false;\n\n  public SourceNavigator() {\n    graph = new NamedDirectedMultigraph();\n  }\n\n  public void setShinglesUtil(ShinglesUtil shinglesUtil) {\n    this.shinglesUtil = shinglesUtil;\n  }\n\n  public void browseProject(\n      @NonNull String projectName, @NonNull List<CompilationUnit> compilationUnits) {\n    this.projectName = projectName;\n    val projectNode = new Node(projectName, Node.Type.PROJECT);\n    this.graph.addNamedVertex(projectNode);\n    compilationUnits.forEach(\n        cu -> {\n          val packageDeclaration = cu.getPackageDeclaration();\n          val importDeclarations = cu.getImports();\n\n          val classesImported = new LinkedList<String>();\n\n          importDeclarations.forEach(\n              importDeclaration -> {\n                classesImported.add(importDeclaration.getName().asString());\n              });\n\n          if (packageDeclaration.isPresent()) {\n            val packageName = packageDeclaration.get().getNameAsString();\n            val packageNode = new Node(packageName, Node.Type.PACKAGE);\n            packageNode.setProjectName(projectName);\n            this.graph.addNamedVertex(packageNode);\n            this.graph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n            cu.getTypes()\n                .forEach(\n                    type -> {\n                      if (type.isClassOrInterfaceDeclaration()) {\n                        val classOrInterfaceDeclaration = type.asClassOrInterfaceDeclaration();\n                        val className = classOrInterfaceDeclaration.getFullyQualifiedName();\n                        if (className.isPresent()) {\n                          val classNode = new ClassNode(className.get());\n                          classNode.setProjectName(projectName);\n\n                          List<String> extendedClasses =\n                              classOrInterfaceDeclaration\n                                  .getExtendedTypes()\n                                  .stream()\n                                  .map(extendType -> extendType.resolve().getQualifiedName())\n                                  .collect(Collectors.toList());\n\n                          classNode.setStatic(classOrInterfaceDeclaration.isStatic());\n                          classNode.setSuperClasses(extendedClasses);\n                          classNode.setClassesImported(classesImported);\n                          classNode.setDeprecated(\n                              classOrInterfaceDeclaration\n                                  .getAnnotationByClass(Deprecated.class)\n                                  .isPresent());\n                          classNode.setInterface(classOrInterfaceDeclaration.isInterface());\n\n                          this.allClassCounter += 1;\n                          if (classOrInterfaceDeclaration.isProtected()\n                              || classOrInterfaceDeclaration.isPublic()) {\n                            classNode.setAPI(true);\n                            this.apiClassCounter += 1;\n                          }\n                          graph.addNamedVertex(classNode);\n                          graph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n\n                          // methods\n                          List<MethodDeclaration> methodDeclarations =\n                              classOrInterfaceDeclaration.getMethods();\n\n                          // filed fqn -> methods fqn\n                          Map<String, List<String>> fieldReferenceToMethods = new HashMap<>();\n\n                          methodDeclarations.forEach(\n                              method -> {\n                                String statementBody = "";\n                                val methodBody = method.getBody();\n\n                                if (methodBody.isPresent()) {\n                                  if (classNode.isInterface() || (useJavadocComments)) {\n                                    statementBody = methodBody.get().toString().trim();\n                                  } else\n                                    statementBody =\n                                        statementBody(methodBody.get().toString()).trim();\n                                  int[] shingles =\n                                      shinglesUtil.computeMethodShingles(statementBody);\n                                  String qualifiedName =\n                                      classNode.getFullyQualifiedName()\n                                          + "."\n                                          + method.getNameAsString();\n                                  MethodNode methodNode = new MethodNode(qualifiedName);\n\n                                  List<String> methodReferencedFields =\n                                      method\n                                          .findAll(FieldAccessExpr.class)\n                                          .stream()\n                                          .map(\n                                              fieldAccessExpr ->\n                                                  classNode.getFullyQualifiedName()\n                                                      + "."\n                                                      + fieldAccessExpr.resolve().getName())\n                                          .collect(Collectors.toList());\n\n                                  methodReferencedFields.forEach(\n                                      field -> {\n                                        if (fieldReferenceToMethods.containsKey(field)) {\n                                          List<String> methods = fieldReferenceToMethods.get(field);\n                                          methods.add(qualifiedName);\n                                          fieldReferenceToMethods.put(field, methods);\n                                        }\n                                      });\n\n                                  List<MethodNode.CalledMethod> calledMethodList =\n                                      method\n                                          .findAll(MethodCallExpr.class)\n                                          .stream()\n                                          .map(MethodCallExpr::resolve)\n                                          .map(\n                                              resolved ->\n                                                  new MethodNode.CalledMethod(\n                                                      resolved.getQualifiedName(),\n                                                      resolved.getQualifiedSignature()))\n                                          .collect(Collectors.toList());\n\n                                  methodNode.setCalledInside(calledMethodList);\n\n                                  allMethodsCounter += 1;\n                                  if (method.isPublic() || method.isProtected()) {\n                                    methodNode.setAPI(true);\n                                    this.apiMethodCounter += 1;\n                                  }\n                                  if (method.getAnnotationByClass(Deprecated.class).isPresent())\n                                    methodNode.setDeprecated(true);\n                                  methodNode.setStatic(method.isStatic());\n                                  methodNode.setProjectName(projectName);\n                                  methodNode.setShingles(shingles);\n                                  //\t\t\t\t\t\t\t\t\tmethodNode.setFlags(method.getFlags());\n                                  methodNode.setSignature(method.getSignature().toString());\n                                  graph.addNamedVertex(methodNode);\n                                  graph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n                                }\n                              });\n\n                          // fields\n                          List<FieldDeclaration> fieldDeclarations =\n                              classOrInterfaceDeclaration.getFields();\n                          fieldDeclarations.forEach(\n                              field -> {\n                                int[] shingles =\n                                    this.shinglesUtil.computeMethodShingles(\n                                        field.getVariables().toString());\n                                String fullyQualifiedName =\n                                    classNode.getFullyQualifiedName()\n                                        + "."\n                                        + field.getVariables().toString();\n                                FieldNode fieldNode = new FieldNode(fullyQualifiedName);\n                                fieldNode.setFieldReferenceToMethod(\n                                    fieldReferenceToMethods.get(fullyQualifiedName));\n                                fieldNode.setProjectName(this.projectName);\n                                fieldNode.setShingles(shingles);\n                                //\t\t\t\t\t\t\t\tfieldNode.setFlags(field.getFlags());\n                                fieldNode.setStatic(field.isStatic());\n                                fieldNode.setSignature(field.getCommonType().asString());\n                                fieldNode.setDeprecated(\n                                    field.getAnnotationByClass(Deprecated.class).isPresent());\n                                graph.addNamedVertex(fieldNode);\n                                graph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n                              });\n                        }\n                      }\n                    });\n          }\n        });\n\n    //\t\tval packages = compilationUnits.stream()\n    //\t\t\t.map(CompilationUnit::getPackageDeclaration)\n    //\t\t\t.filter(Optional::isPresent)\n    //\t\t\t.collect(Collectors.toList());\n    ////        this.graph.addVertex(projectNode);\n    //\t\tthis.graph.addNamedVertex(projectNode);\n    //\t\tpackages.forEach(p -> p.ithis.browseInPackageRoot(p, projectNode));\n  }\n\n  //\tprivate void browseInPackageRoot(@NonNull IPackage iPackage, @NonNull Node projectNode) {\n  //\t\tval childrenPackages = iPackage.getChildrenPackages();\n  //\t\tchildrenPackages.forEach(childrenPackage -> {\n  //\t\t\tNode packageNode = new Node(childrenPackage.getElementName(), Node.Type.PACKAGE);\n  //\t\t\tpackageNode.setProjectName(this.projectName);\n  ////            graph.addVertex(packageNode);\n  //\t\t\tgraph.addNamedVertex(packageNode);\n  ////            graph.addEdge(projectNode, packageNode);\n  //\t\t\tgraph.addEdge(projectNode, packageNode, new Edge(Node.Type.PACKAGE));\n  //\t\t\tthis.browseInPackage(childrenPackage, packageNode);\n  //\t\t\tthis.packageCounter += 1;\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseInPackage(@NonNull IPackage pckg, @Nonnull Node packageNode) {\n  //\t\tval classes = pckg.getClasses();\n  //\t\tclasses.forEach(clz -> {\n  //\t\t\tval classNode = new Node(clz.getFullyQualifiedName(), Node.Type.CLASS);\n  //\t\t\tclassNode.setProjectName(this.projectName);\n  //\t\t\tclassNode.setFlags(clz.getFlags());\n  ////            graph.addVertex(classNode);\n  ////            graph.addEdge(packageNode, classNode);\n  //\t\t\tgraph.addNamedVertex(classNode);\n  //\t\t\tgraph.addEdge(packageNode, classNode, new Edge(Node.Type.CLASS));\n  //\t\t\tthis.browseClass(clz, classNode);\n  //\t\t\tclassNode.setDeprecated(clz.getIsDeprecated());\n  //\t\t\tclassNode.setInterface(clz.getIsInterface());\n  //\t\t\tthis.allClassCounter += 1;\n  //\t\t\tif (clz.isProtected() || clz.isPublic()) {\n  //\t\t\t\tclassNode.setAPI(true);\n  //\t\t\t\tthis.apiClassCounter += 1;\n  //\t\t\t}\n  //\t\t});\n  //\t}\n\n  //\tprivate void browseClass(@NonNull IClass clz, @NonNull Node classNode) {\n  //\t\tval methods = clz.getMethods();\n  //\t\tbrowseMethods(methods, classNode);\n  //\t\tval fields = clz.getFields();\n  //\t\tbrowseFields(fields, classNode);\n  //\t}\n  //\n  //\tprivate void browseMethods(@NonNull List<IMethod> methods, @NonNull Node classNode) {\n  //\t\tmethods.forEach(method -> {\n  //\t\t\tString statementBody = "";\n  //\t\t\tif (classNode.isInterface() || (useJavadocComments)) {\n  //\t\t\t\tstatementBody = method.getSource().trim();\n  //\t\t\t} else\n  //\t\t\t\tstatementBody = statementBody(method.getSource()).trim();\n  //\t\t\tint[] shingles = shinglesUtil.computeMethodShingles(statementBody);\n  //\t\t\tString qualifiedName = classNode.getFullyQualifiedName() + "."\n  //\t\t\t\t+ method.getElementName();\n  //\t\t\tNode methodNode = new Node(qualifiedName, Node.Type.METHOD);\n  //\n  //\t\t\tallMethodsCounter += 1;\n  //\t\t\tif (method.getIsPublic() || method.getIsProtected()) {\n  //\t\t\t\tmethodNode.setAPI(true);\n  //\t\t\t\tthis.apiMethodCounter += 1;\n  //\t\t\t}\n  //\t\t\tif (method.getIsDeprecated())\n  //\t\t\t\tmethodNode.setDeprecated(true);\n  //\t\t\tmethodNode.setProjectName(projectName);\n  //\t\t\tmethodNode.setShingles(shingles);\n  //\t\t\tmethodNode.setFlags(method.getFlags());\n  //\t\t\tmethodNode.setSignature(getUnqualifiedMethodSignature(method));\n  ////            graph.addVertex(methodNode);\n  ////            graph.addEdge(classNode, methodNode);\n  //\t\t\tgraph.addNamedVertex(methodNode);\n  //\t\t\tgraph.addEdge(classNode, methodNode, new Edge(Node.Type.METHOD));\n  //\t\t});\n  //\t}\n  //\n  //\n  //\tprivate String getUnqualifiedMethodSignature(IMethod method) {\n  //\t\tStringBuilder buffer = new StringBuilder();\n  //\n  //\t\tbuffer.append(\'(\');\n  //\n  //\t\tString[] types = method.getParameterTypes();\n  //\t\tfor (int i = 0; i < types.length; i++) {\n  //\t\t\tif (i > 0)\n  //\t\t\t\tbuffer.append(", "); //$NON-NLS-1$\n  //\t\t\tString typeSig = Signature.toString(types[i]);\n  //\t\t\tbuffer.append(typeSig);\n  //\t\t}\n  //\t\tbuffer.append(\')\');\n  //\n  //\t\treturn buffer.toString();\n  //\t}\n  //\n  //\tprivate void browseFields(@NonNull List<IField> fields, @NonNull Node classNode) {\n  //\t\tfields.forEach(field -> {\n  //\t\t\tint[] shingles = this.shinglesUtil.computeMethodShingles(field.getSource());\n  //\t\t\tString fullyQualifiedName = classNode.getFullyQualifiedName() + "." + field.getElementName();\n  //\t\t\tNode fieldNode = new Node(fullyQualifiedName, Node.Type.FIELD);\n  //\t\t\tfieldNode.setProjectName(this.projectName);\n  //\t\t\tfieldNode.setShingles(shingles);\n  //\t\t\tfieldNode.setFlags(field.getFlags());\n  //\t\t\tfieldNode.setSignature(field.getTypeSignature());\n  //\t\t\tfieldNode.setDeprecated(field.getIsDeprecated());\n  ////            graph.addVertex(fieldNode);\n  ////            graph.addEdge(classNode, fieldNode);\n  //\t\t\tgraph.addNamedVertex(fieldNode);\n  //\t\t\tgraph.addEdge(classNode, fieldNode, new Edge(Node.Type.FIELD));\n  //\t\t});\n  //\t}\n  //\n\n  /**\n   * This prunes away the javadoc comments\n   *\n   * @param source\n   * @return\n   */\n  private String statementBody(String source) {\n    int lastAtChar = source.lastIndexOf("@");\n    if (lastAtChar == -1) lastAtChar = 0;\n    int openingBracket = source.indexOf("{", lastAtChar);\n    int closingBracket = source.lastIndexOf("}");\n    if (openingBracket != -1) return source.substring(openingBracket + 1, closingBracket);\n    return source;\n  }\n}\n',
      "98bf2210121031f53e8caf7f8f89645f6b1dcc86":
        'package refactoring.crawler.shingles;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.URL;\n\n/**\n * Implementation of a Bloom Filter data structure, an elegant alternative to the lookup hash table.\n *\n * <p>Bloom filters allow you to perform membership tests in just a fraction of the memory you\'d\n * need to store a full list of keys. As you might suspect, the savings in space comes at a price:\n * you run an adjustable risk of false positives, and you can\'t remove a key from a filter once\n * you\'ve added it in. But in the many cases where those constraints are acceptable, a Bloom filter\n * can make a useful tool.\n *\n * <p>Bloom filters are named after Burton Bloom, who first described them in a 1970 paper entitled\n * <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/time trade-offs\n * in hash coding with allowable errors</a>. In those days of limited memory, Bloom filters were\n * prized primarily for their compactness; in fact, one of their earliest applications was in spell\n * checkers.\n *\n * <p>A Bloom filter consists of two components: a set of <code>k</code> hash functions and a bit\n * vector of a given length. We choose the length of the bit vector and the number of hash functions\n * depending on how many keys we want to add to the set and how high an error rate we are willing to\n * put up with.\n *\n * <p>All of the hash functions in a Bloom filter are configured so that their range matches the\n * length of the bit vector. For example, if a vector is 200 bits long, the hash functions return a\n * value between 1 and 200. It\'s important to use high-quality hash functions in the filter to\n * guarantee that output is equally distributed over all possible values -- "hot spots" in a hash\n * function would increase our false-positive rate.\n *\n * <p>To enter a key into a Bloom filter, we run it through each one of the k hash functions and\n * treat the result as an offset into the bit vector, turning on whatever bit we find at that\n * position. If the bit is already set, we leave it on. There\'s no mechanism for turning bits off in\n * a Bloom filter.\n *\n * <p>Checking to see whether a key already exists in a filter is exactly analogous to adding a new\n * key. We run the key through our set of hash functions, and then check to see whether the bits at\n * those offsets are all turned on. If any of the bits is off, we know for certain the key is not in\n * the filter. If all of the bits are on, we know the key is probably there.\n *\n * <p>As you might expect, the false-positive rate depends on the bit vector length and the number\n * of keys stored in the filter. The roomier the bit vector, the smaller the probability that all k\n * bits we check will be on, unless the key actually exists in the filter. The relationship between\n * the number of hash functions and the false-positive rate is more subtle. If you use too few hash\n * functions, there won\'t be enough discrimination between keys; but if you use too many, the filter\n * will be very dense, increasing the probability of collisions. You can calculate the\n * false-positive rate for any filter using the formula:\n *\n * <p><code>c = ( 1 - e(-kn/m) )k</code>\n *\n * <p>Where c is the false positive rate, k is the number of hash functions, n is the number of keys\n * in the filter, and m is the length of the filter in bits.\n *\n * <p>When using Bloom filters, we very frequently have a desired false-positive rate in mind and we\n * are also likely to have a rough idea of how many keys we want to add to the filter. We need some\n * way of finding out how large a bit vector is to make sure the false-positive rate never exceeds\n * our limit. The following equation will give us vector length from the error rate and number of\n * keys:\n *\n * <p><code>m = -kn / ( ln( 1 - c ^ 1/k ) )</code>\n *\n * <p>You\'ll notice another free variable here: k, the number of hash functions. However, it\'s\n * possible to use calculus to find a minimum for k. You can also find lookup tables for various\n * combinations of error rate, filter size, and number of hash functions at <a\n * href="http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html#tab:bf-config-1">Bloom Filters\n * -- the math</a>.\n *\n * <p>This implementation uses the <code>hashCode()</code> method supplied for all Java objects,\n * which produces a 32-bit signed int number. For example, in <code>String</code> Objects, the\n * hashcode is usually computed by adding up the character values with an prime multiplier (31, in\n * the case of JDK 1.4).\n *\n * <p>Alternatively, this class can also use an implementation of a hash function based on Rabin\n * fingerprints, which can efficiently produce a 32-bit hash value for a sequence of bytes. It does\n * so by considering strings of bytes as large polynomials with coefficients of 0 and 1 and then\n * reducing them modulo some irreducible polynomial of degree 32. The result is a hash function with\n * very satisfactory properties. In addition the polynomial operations are fast in hardware, and\n * even in this Java implementation the speed is reasonable.\n *\n * <p>The implementation is derived from the paper "Some applications of Rabin\'s fingerprinting\n * method" by Andrei Broder. See <a\n * href="http://server3.pa-x.dec.com/SRC/publications/src-papers.html">\n * http://server3.pa-x.dec.com/SRC/publications/src-papers.html</a> for a full citation and the\n * paper in PDF format.\n *\n * <p>Included in this class are additional methods that can compute the Rabin hash value for any\n * serializable <code>Object</code>, <code>String</code>, <code>File</code>, or resource denoted by\n * <code>URL</code>.\n *\n * <p>As for the multiple hash functions for the Bloom Filter, these are based on the module of the\n * initial value multiplied by a list of distinct values.\n *\n * @see java.lang.Object#hashCode()\n * @see java.util.Map\n * @author Bruno Martins\n */\npublic class BloomFilter implements Cloneable {\n\n  /** A buffer for the Rabin fingerprinting algorithm. */\n  private byte[] buffer;\n\n  /**\n   * The 32 bits of this integer represent the coefficients of the degree 32 irreducible polynomial\n   * over GF(2); that is, every coefficient is 0 or 1. However, a degree 32 polynomial has 33\n   * coefficients; the term of degree 32 is assumed to have a coefficient of 1. Therefore, the\n   * high-order bit of the <code>int</code> is the degree 31 term\'s coefficient, and the low-order\n   * bit is the constant coefficient.\n   *\n   * <p>For example the integer 0x00000803, in binary, is:\n   *\n   * <p><code>00000000 00000000 00001000 00000011</code>\n   *\n   * <p>Therefore it correponds to the polynomial:\n   *\n   * <p><code>x<sup>32</sup> + x<sup>11</sup> + x + 1</code>\n   */\n  private static int POLYNOMIAL = 0x000001C7;\n\n  /** Internal values for the Rabin fingerprinting algorithm. */\n  private static int[] table32, table40, table48, table54;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int P_DEGREE = 32;\n\n  /** The size of the buffer for the Rabin fingerprinting algorithm. */\n  private static int READ_BUFFER_SIZE = 2048;\n\n  /** The degree for the irreducible polynomial used by the Rabin fingerprinting algorithm. */\n  private static int X_P_DEGREE = 1 << (P_DEGREE - 1);\n\n  /** The bit vector for the Bloom Filter. */\n  private boolean keys[];\n\n  /** Use Rabin\'s fingerprinting algorithm ( default is true ). */\n  private boolean useRabin = true;\n\n  /** The number of hash functions. */\n  private int numFunctions;\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and the default\n   * length for the bit vector (1000).\n   */\n  public BloomFilter() {\n    table32 = new int[256];\n    table40 = new int[256];\n    table48 = new int[256];\n    table54 = new int[256];\n    buffer = new byte[READ_BUFFER_SIZE];\n    // We want to have mods[i] == x^(P_DEGREE+i)\n    int[] mods = new int[P_DEGREE];\n    mods[0] = POLYNOMIAL;\n    for (int i = 1; i < P_DEGREE; i++) {\n      // x^i == x(x^(i-1)) (mod P)\n      mods[i] = mods[i - 1] << 1;\n      // if x^(i-1) had a x_(P_DEGREE-1) term then x^i has a\n      // x^P_DEGREE term that \'fell off\' the top end.\n      // Since x^P_DEGREE == P (mod P), we should add P\n      // to account for this:\n      if ((mods[i - 1] & X_P_DEGREE) != 0) {\n        mods[i] ^= POLYNOMIAL;\n      }\n    }\n    for (int i = 0; i < 256; i++) {\n      int c = i;\n      for (int j = 0; j < 8 && c != 0; j++) {\n        if ((c & 1) != 0) {\n          table32[i] ^= mods[j];\n          table40[i] ^= mods[j + 8];\n          table48[i] ^= mods[j + 16];\n          table54[i] ^= mods[j + 24];\n        }\n        c >>>= 1;\n      }\n    }\n    mods = null;\n    this.keys = new boolean[1000];\n    this.numFunctions = 10;\n    for (int i = 0; i < 1000; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs a Bloom Filter from a string representation.\n   *\n   * @see #toString()\n   */\n  public BloomFilter(String filter) {\n    this();\n    int index1 = filter.indexOf(":");\n    int index2 = filter.lastIndexOf(":");\n    numFunctions = new Integer(filter.substring(0, index1)).intValue();\n    keys = new boolean[new Integer(filter.substring(index1, index2)).intValue()];\n    for (int i = index2 + 1; i < filter.length(); i++) {\n      if (filter.charAt(i) == \'1\') keys[i] = true;\n      else keys[i] = false;\n    }\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given length for the bit vector, guarenteeing a maximum\n   * error rate.\n   *\n   * @param errorRate The maximum error rate (false positives) for the Bloom Filter.\n   */\n  public BloomFilter(int numKeys, double errorRate) {\n    this();\n    double lowest_m = Double.MAX_VALUE;\n    int best_k = 1;\n    for (int k = 1; k <= 100; k++) {\n      double m = (-1 * k * numKeys) / (Math.log(1 - (Math.pow(errorRate, (1 / k)))));\n      if (m < lowest_m) {\n        lowest_m = m;\n        best_k = k;\n      }\n    }\n    this.keys = new boolean[numKeys];\n    this.numFunctions = best_k;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Constructs an empty BloomFilter with the default number of hash functions (10) and a given\n   * length for the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   */\n  public BloomFilter(int numKeys) {\n    this(numKeys, 10);\n  }\n\n  /**\n   * Constructs an empty BloomFilter with a given number of hash functions and a given length for\n   * the bit vector.\n   *\n   * @param numKeys The length of the bit vector.\n   * @param numHashFunctions The number of hash functions.\n   */\n  public BloomFilter(int numKeys, int numHashFunctions) {\n    this();\n    this.keys = new boolean[numKeys];\n    this.numFunctions = numHashFunctions;\n    for (int i = 0; i < numKeys; i++) this.keys[i] = false;\n  }\n\n  /**\n   * Internal method for producing the hash value for a given function number.\n   *\n   * @param fnum The number of the hash function.\n   * @param original The original value for the hash of the object.\n   * @see java.lang.Object#hashCode()\n   * @return Returns the hash code value for the given function number.\n   */\n  private int getHash(int fnum, int original) {\n    // int hash = ((int)(Math.pow(2,fnum)) * original) % keys.length;\n    // int hash = ((fnum * fnum + 1) * original) % keys.length;\n    int hash[] = {original};\n    if (!useRabin) for (int i = 0; i < fnum; i++) hash[0] = (new Integer(hash[0])).hashCode();\n    else for (int i = 0; i < fnum; i++) hash[0] = hashRabin(hash);\n    hash[0] = hash[0] % keys.length;\n    if (hash[0] < 0) hash[0] = -hash[0];\n    return hash[0];\n  }\n\n  /**\n   * Returns true if this Bloom Filter contains the specified key.\n   *\n   * @param obj The key whose presence in this Bloom Filter is to be tested.\n   * @return true if this Bloom Filter contains a mapping for the specified key.\n   */\n  public boolean hasKey(Object obj) {\n    boolean result = true;\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions && result; i++) {\n      result &= keys[getHash(i, hashCodeObject)];\n    }\n    return result;\n  }\n\n  /**\n   * Adds the specified key in this Bloom Filter.\n   *\n   * @param obj The key to be added to this Bloom Filter.\n   */\n  public void put(Object obj) {\n    int hashCodeObject;\n    if (!useRabin) hashCodeObject = obj.hashCode();\n    else\n      try {\n        hashCodeObject = hashRabin(obj);\n      } catch (Exception e) {\n        useRabin = false;\n        hashCodeObject = obj.hashCode();\n      }\n    for (int i = 0; i < numFunctions; i++) {\n      keys[getHash(i, hashCodeObject)] = true;\n    }\n  }\n\n  /**\n   * Returns a string representation of this Bloom Filter. The string representation consists of an\n   * integer specifying the number of hash Functions, an integer specifying the length of the bit\n   * vector, and a sequence of 0s and 1s specifying the bit vector. These 3 fields are separated by\n   * the character ":".\n   *\n   * <p>This implementation creates an empty string buffer, and iterates over the bit vector,\n   * appending the value of each bit in turn. A string is obtained from the stringbuffer, and\n   * returned.\n   *\n   * @return A string representation of this Bloom Filter.\n   */\n  public String toString() {\n    StringBuffer aux = new StringBuffer(numFunctions + ":" + keys.length + ":");\n    for (int i = 0; i < keys.length; i++) {\n      if (keys[i]) aux.append("1");\n      else aux.append("0");\n    }\n    return aux.toString();\n  }\n\n  /**\n   * Returns a copy of this Bloom Filter instance.\n   *\n   * @see java.lang.Object#clone()\n   */\n  public Object clone() {\n    return new BloomFilter(this.toString());\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @return The Rabin hash value for the array of bytes.\n   */\n  public int hashRabin(byte[] arr) {\n    return hashRabin(arr, 0, arr.length, 0);\n  }\n\n  /**\n   * Return the Rabin hash value of an array of bytes.\n   *\n   * @param arr An array of bytes.\n   * @param offset Index of the first byte of the array to hash.\n   * @param length Number of bytes to hash.\n   * @param ws ??\n   * @return The Rabin hash value for the array of bytes.\n   */\n  private int hashRabin(byte[] arr, int offset, int length, int ws) {\n    int w = ws;\n    int start = length % 4;\n    for (int s = offset; s < offset + start; s++) {\n      w = (w << 8) ^ (arr[s] & 0xFF);\n    }\n    for (int s = start + offset; s < length + offset; s += 4) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ (arr[s] << 24)\n              ^ ((arr[s + 1] & 0xFF) << 16)\n              ^ ((arr[s + 2] & 0xFF) << 8)\n              ^ (arr[s + 3] & 0xFF);\n    }\n    return w;\n  }\n\n  /**\n   * Return the Rabin hash value of an array of chars.\n   *\n   * @param arr An array of chars.\n   * @return The Rabin hash value for the array of chars.\n   */\n  public int hashRabin(char[] arr) {\n    int w = 0;\n    int start = 0;\n    if (arr.length % 2 == 1) {\n      w = arr[0] & 0xFFFF;\n      start = 1;\n    }\n    for (int s = start; s < arr.length; s += 2) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ ((arr[s] & 0xFFFF) << 16)\n              ^ (arr[s + 1] & 0xFFFF);\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a <code>File</code>.\n   *\n   * @param f A <code>File</code>.\n   * @return The Rabin hash value for the contents of the File.\n   * @throws FileNotFoundException If the file cannot be found.\n   * @throws IOException If an error occurs while reading the file.\n   */\n  public int hashRabin(File f) throws FileNotFoundException, IOException {\n    FileInputStream fis = new FileInputStream(f);\n    try {\n      return hashRabin(fis);\n    } finally {\n      fis.close();\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of the data from an <code>InputStream</code>.\n   *\n   * @param is An InputStream.\n   * @return The Rabin hash value for the contents read from the InputStream.\n   * @throws IOException if an error occurs while reading from the InputStream.\n   */\n  public int hashRabin(InputStream is) throws IOException {\n    int hashValue = 0;\n    int bytesRead;\n    synchronized (buffer) {\n      while ((bytesRead = is.read(buffer)) > 0) {\n        hashValue = hashRabin(buffer, 0, bytesRead, hashValue);\n      }\n    }\n    return hashValue;\n  }\n\n  /**\n   * Returns the Rabin hash value of an array of integers. This method is the most efficient of all\n   * the hash methods, so it should be used when possible.\n   *\n   * @param arr An array of integers.\n   * @return int The Rabin hash value for the array of integers.\n   */\n  public int hashRabin(int[] arr) {\n    int w = 0;\n    for (int s = 0; s < arr.length; s++) {\n      w =\n          table32[w & 0xFF]\n              ^ table40[(w >>> 8) & 0xFF]\n              ^ table48[(w >>> 16) & 0xFF]\n              ^ table54[(w >>> 24) & 0xFF]\n              ^ arr[s];\n    }\n    return w;\n  }\n\n  /**\n   * Computes the Rabin hash value of a given Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If Object serialization fails.\n   */\n  public int hashRabin(Object obj) throws IOException {\n    return hashRabin((Serializable) obj);\n  }\n\n  /**\n   * Computes the Rabin hash value of a given serializable Object.\n   *\n   * @param obj An Object.\n   * @return The Rabin hash value for the Object.\n   * @throws IOException If serialization fails.\n   */\n  public int hashRabin(Serializable obj) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = null;\n    try {\n      oos = new ObjectOutputStream(baos);\n      oos.writeObject(obj);\n      return hashRabin(baos.toByteArray());\n    } finally {\n      oos.close();\n      baos.close();\n      oos = null;\n      baos = null;\n    }\n  }\n\n  /**\n   * Computes the Rabin hash value of a String.\n   *\n   * @param s A <code>String</code>.\n   * @return The Rabin hash value for the String.\n   */\n  public int hashRabin(String s) {\n    return hashRabin(s.toCharArray());\n  }\n\n  /**\n   * Computes the Rabin hash value of the contents of a Web document, specified by an URL.\n   *\n   * @param url The URL of the document to be hashed.\n   * @return The Rabin hash value for the document.\n   * @throws IOException If an error occurs while reading the document.\n   */\n  public int hashRabin(URL url) throws IOException {\n    InputStream is = url.openStream();\n    try {\n      return hashRabin(is);\n    } finally {\n      is.close();\n    }\n  }\n}\n',
      "3be706f1ea9ded9a332de32c31f99eedf4652de0":
        "package refactoring.crawler.shingles;\n\n/** @author Can Comertoglu */\npublic class DefaultStrategy implements ShinglesStrategy {\n\n  /** */\n  public DefaultStrategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base;\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base;\n  }\n}\n",
      "55e796c451fb63675bae1000f41dd15b720bbb42":
        "package refactoring.crawler.shingles;\n\npublic class FactorOf2Strategy implements ShinglesStrategy {\n\n  /** */\n  public FactorOf2Strategy() {\n    super();\n  }\n\n  /* (non-Javadoc)\n   * @Override\n   * @see edu.uiuc.detectRefactorings.util.Strategy#computeNumShingles(int, int)\n   */\n  public int upperBoundLimitForShinglesBag(int loc, int s_base) {\n    return s_base + (2 * loc);\n  }\n\n  public int upperBoundForClassShingles(int numMethods, int s_base) {\n    return s_base + (2 * numMethods);\n  }\n\n  public int upperBoundForPackageShingles(int numClasses, int s_base) {\n    return s_base + (2 * numClasses);\n  }\n}\n",
      "48e3af28f18b6c77e3f8c6ce5a8fa923f2e5f3b9":
        "package refactoring.crawler.shingles;\n\npublic interface ShinglesStrategy {\n  int upperBoundLimitForShinglesBag(int loc, int s_base);\n\n  int upperBoundForClassShingles(int numMethods, int s_base);\n\n  int upperBoundForPackageShingles(int numClasses, int s_base);\n}\n",
      "088d9845fab60669cca75fe6233c0e37d1280b6d":
        'package refactoring.crawler.shingles;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DirectedMultigraph;\nimport org.jgrapht.traverse.BreadthFirstIterator;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ShinglesUtil {\n\n  private int w = 2;\n  private int sClass = 10;\n  private int sMethod = 8;\n  private double classThreshold = 0.0;\n\n  @Getter @Setter private double methodThreshold = 0.0;\n\n  private ShinglesStrategy shinglesStrategy;\n\n  private NamedDirectedMultigraph oldVersionGraph;\n\n  private NamedDirectedMultigraph newVersionGraph;\n\n  private List<Node[]> similarMethods = new LinkedList<>();\n  private List<Node[]> similarClasses = new LinkedList<>();\n\n  private List<Node> oldVersionPackageList;\n  private List<Node> oldVersionClassList;\n  private List<Node> oldVersionMethodList;\n  private List<Node> oldVersionFieldList;\n\n  private List<Node> newVersionPackageList;\n  private List<Node> newVersionClassList;\n  private List<Node> newVersionMethodList;\n  private List<Node> newVersionFieldList;\n\n  public ShinglesUtil() {\n    this.shinglesStrategy = new DefaultStrategy();\n    //\t\tthis.shinglesStrategy = new FactorOf2Strategy();\n  }\n\n  public List<String> tokenizer(String s) {\n    List<String> list = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(s, " \\t \\n . \\r \\" ");\n    while (st.hasMoreElements()) {\n      list.add(st.nextToken());\n    }\n    return list;\n  }\n\n  private List<List<String>> computeSlidingWindowTokens(List<String> tokenList) {\n\n    List<List<String>> bagOfTokensList = new ArrayList<>();\n    ListIterator<String> iter = tokenList.listIterator();\n    while (iter.nextIndex() <= (tokenList.size() - w))\n    // W=2, iterIndex = size - W identifies the last window\n    {\n      List<String> tempList = new ArrayList<>();\n      for (int i = 1; i <= w; i++) // W=3\n      {\n        tempList.add(iter.next());\n      }\n      bagOfTokensList.add(tempList);\n      for (int i = 1; i <= w - 1; i++)\n        // i<= W-1\n        iter.previous();\n    }\n    return bagOfTokensList;\n  }\n\n  private int findNumberOfLines(String str) {\n    int retval = 0;\n    char[] c = str.toCharArray();\n    for (char value : c) {\n      if (value == \'\\n\') retval++;\n    }\n    return retval;\n  }\n\n  public int[] computeMethodShingles(String str) {\n    return computeMethodShingles(\n        str,\n        w,\n        this.shinglesStrategy.upperBoundLimitForShinglesBag(findNumberOfLines(str), this.sMethod));\n  }\n\n  public int[] computeMethodShingles(String str, int window, int upperBoundLimit) {\n    /*\n     * We are now introducing the idea of finding the number of lines in the\n     * method, and incorporate that into the calculation of shingles, so\n     * that, if there are more lines, then there are going to be more\n     * shingles associated with the method. However, a 1-1 correspondance\n     * will be misleading, thus another method is required.\n     */\n    BloomFilter bloomFilter = new BloomFilter();\n    List<String> tokenList = tokenizer(str);\n    List<List<String>> bagOfWindowedTokens = computeSlidingWindowTokens(tokenList);\n\n    int[] shinglesValues = new int[bagOfWindowedTokens.size()];\n    int numberOfWindowedTokens = 0;\n\n    for (List<String> tempList : bagOfWindowedTokens) {\n      StringBuilder tokensInOneWindow = new StringBuilder();\n      for (int i = 0; i < window; i++) {\n        tokensInOneWindow.append(tempList.get(i));\n        if (i != window - 1) tokensInOneWindow.append(" ");\n      }\n      int shingle = bloomFilter.hashRabin(tokensInOneWindow.toString());\n      shinglesValues[numberOfWindowedTokens] = shingle;\n      numberOfWindowedTokens++;\n    }\n\n    Arrays.sort(shinglesValues);\n\n    int correctNumberOfShingles = Math.min(upperBoundLimit, numberOfWindowedTokens);\n\n    int[] retVal = new int[correctNumberOfShingles];\n    System.arraycopy(shinglesValues, 0, retVal, 0, correctNumberOfShingles);\n    return retVal;\n  }\n\n  public void initialize(\n      NamedDirectedMultigraph oldVersionGraph, NamedDirectedMultigraph newVersionGraph) {\n    this.oldVersionGraph = oldVersionGraph;\n    this.newVersionGraph = newVersionGraph;\n\n    this.oldVersionPackageList = new ArrayList<>();\n    this.oldVersionClassList = new ArrayList<>();\n    this.oldVersionMethodList = new ArrayList<>();\n    this.oldVersionFieldList = new ArrayList<>();\n\n    this.newVersionPackageList = new ArrayList<>();\n    this.newVersionClassList = new ArrayList<>();\n    this.newVersionMethodList = new ArrayList<>();\n    this.newVersionFieldList = new ArrayList<>();\n\n    initializeElementsLists(\n        oldVersionGraph,\n        oldVersionMethodList,\n        oldVersionClassList,\n        oldVersionPackageList,\n        oldVersionFieldList);\n\n    initializeElementsLists(\n        newVersionGraph,\n        newVersionMethodList,\n        newVersionClassList,\n        newVersionPackageList,\n        newVersionFieldList);\n  }\n\n  private void initializeElementsLists(\n      DirectedMultigraph<Node, Edge> graph,\n      List<Node> methods,\n      List<Node> classes,\n      List<Node> packages,\n      List<Node> fields) {\n    // Create a BreadthFirstIterator for the graph\n    BreadthFirstIterator<Node, Edge> bfi = new BreadthFirstIterator<>(graph);\n    while (bfi.hasNext()) {\n      Node n = bfi.next();\n      if (n.getType().equals(Node.Type.CLASS)) {\n        classes.add(n);\n      } else if (n.getType().equals(Node.Type.PACKAGE)) {\n        packages.add(n);\n      } else if (n.getType().equals(Node.Type.METHOD)) {\n        methods.add(n);\n      } else if (n.getType().equals(Node.Type.FIELD)) {\n        fields.add(n);\n      }\n    }\n  }\n\n  public List<Node[]> findSimilarMethods() {\n    if (this.similarMethods.isEmpty()) {\n      List<Node[]> similarMethods = new ArrayList<>();\n      for (Node m : this.oldVersionMethodList) {\n        if (!m.isAPI()) continue;\n\n        for (Node m2 : this.newVersionMethodList) {\n          if (!m2.isAPI()) continue;\n\n          if (howMuchAlike(m.getShingles(), m2.getShingles()) > methodThreshold) {\n            Node[] arr = {m, m2};\n            // if (!isThisArrayInTheList(simMet, arr))\n            similarMethods.add(arr);\n          }\n        }\n      }\n      this.similarMethods = similarMethods;\n    }\n    return this.similarMethods;\n  }\n\n  public double howMuchAlike(int[] arr1, int[] arr2) {\n    double finalGrade, similarityFromArr1ToArr2, similarityFromArr2ToArr1;\n    similarityFromArr1ToArr2 = howMuchIs1Like2(arr1, arr2);\n    similarityFromArr2ToArr1 = howMuchIs1Like2(arr2, arr1);\n    finalGrade = (similarityFromArr1ToArr2 + similarityFromArr2ToArr1) / 2.0;\n    return finalGrade;\n  }\n\n  private double howMuchIs1Like2(int[] arr1, int[] arr2) {\n    int[] tempArr = arr2.clone();\n    double grade = 0.0;\n    for (int value : arr1) {\n      for (int j = 0; j < tempArr.length; j++) {\n        if (value == tempArr[j]) {\n          grade += 1.0 / arr1.length;\n          tempArr[j] = Integer.MIN_VALUE;\n          break;\n        }\n      }\n    }\n    return grade;\n  }\n\n  /**\n   * @param classes\n   * @param graph <br>\n   *     For each class nodes in classes, find the shingles by concatenating shingles in methods of\n   *     its subtree. The parameter s_class will determine the maximum size of shingles\n   */\n  private void computeClassShingles(List<Node> classes, NamedDirectedMultigraph graph) {\n    for (Node clasz : classes) {\n      // We will keep the number of methods for the class with the\n      // numberOfMethods variable.\n      int numberOfMethods = 0;\n      List<Edge> outEdges = new ArrayList<>(graph.outgoingEdgesOf(clasz));\n      int methodsTotalShingleSize = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          methodsTotalShingleSize += neighbor.getShingles().length;\n          // Here we update the method count.\n          numberOfMethods++;\n        }\n      }\n\n      // fill allShinglesFromMethods with shingles from all the methods in\n      // the class\n      int[] allShinglesFromMethods = new int[methodsTotalShingleSize];\n      Arrays.fill(allShinglesFromMethods, Integer.MAX_VALUE);\n      int index = 0;\n      for (Edge e : outEdges) {\n        Node neighbor = e.oppositeVertex(clasz);\n        if (neighbor.getType().toString().compareToIgnoreCase(Node.Type.METHOD.toString()) == 0) {\n          for (int j = 0; j < neighbor.getShingles().length; j++) {\n            allShinglesFromMethods[index] = neighbor.getShingles()[j];\n            index++;\n          }\n        }\n      }\n\n      int upperBoundForClassShingles =\n          this.shinglesStrategy.upperBoundForClassShingles(numberOfMethods, sClass);\n      Arrays.sort(allShinglesFromMethods);\n\n      upperBoundForClassShingles =\n          Math.min(upperBoundForClassShingles, allShinglesFromMethods.length);\n\n      int[] retVal = new int[upperBoundForClassShingles];\n      if (upperBoundForClassShingles >= 0)\n        System.arraycopy(allShinglesFromMethods, 0, retVal, 0, upperBoundForClassShingles);\n      clasz.setShingles(retVal);\n    }\n  }\n\n  public List<Node[]> findSimilarClasses() {\n    if (this.similarClasses.isEmpty()) {\n      computeClassShingles(oldVersionClassList, oldVersionGraph);\n      computeClassShingles(newVersionClassList, newVersionGraph);\n      List<Node[]> simClass = new ArrayList<>();\n      for (Node c : this.oldVersionClassList) {\n        if (!c.isAPI()) continue;\n\n        for (Node c2 : this.newVersionClassList) {\n          if (!c2.isAPI()) continue;\n\n          if (howMuchAlike(c.getShingles(), c2.getShingles()) > classThreshold) {\n            Node[] arr = {c, c2};\n            simClass.add(arr);\n          }\n        }\n      }\n      this.similarClasses = simClass;\n    }\n    return this.similarClasses;\n  }\n\n  public List<Node[]> findPullUpMethodCandidates() {\n    return findSimilarMethods();\n  }\n\n  public List<Node[]> findPushDownMethodCandidates() {\n    return findSimilarMethods();\n  }\n}\n',
      "66cc05cc40337a87d4835854e19c62d19d2c4067":
        "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class ClassNode extends Node {\n\n  @Getter @Setter private List<String> classesImported = new LinkedList<>();\n\n  @Getter @Setter private List<String> superClasses = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public ClassNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.CLASS);\n  }\n}\n",
      "7774ec8b37feef6882a868e2660021a320eeaa54":
        'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.jgrapht.graph.DefaultEdge;\n\npublic class Edge extends DefaultEdge {\n\n  @Getter @Setter private Node.Type label;\n\n  public Edge(Node.Type label) {\n    this.label = label;\n  }\n\n  @Override\n  public String toString() {\n    return "(" + getSource() + " : " + getTarget() + " : " + label + ")";\n  }\n\n  @Override\n  public Node getSource() {\n    return (Node) super.getSource();\n  }\n\n  @Override\n  public Node getTarget() {\n    return (Node) super.getTarget();\n  }\n\n  public Node oppositeVertex(Node n) {\n    Node source = this.getSource();\n    Node target = this.getTarget();\n    return n.equals(source) ? target : source;\n  }\n}\n',
      "51d845ea135825c28660aac7c258adde05243914":
        "package refactoring.crawler.graph;\n\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class FieldNode extends Node {\n\n  @Getter @Setter private List<String> fieldReferenceToMethod;\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public FieldNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.FIELD);\n  }\n}\n",
      e2919264f5aa7154db6f0c0501950564a730a1e3:
        "package refactoring.crawler.graph;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class MethodNode extends Node {\n\n  @AllArgsConstructor\n  public static class CalledMethod {\n    @Getter @Setter private String fullyQualifiedNameWithoutSignature;\n\n    @Getter @Setter private String fullyQualifiedNameWithSignature;\n  }\n\n  @Setter @Getter private List<CalledMethod> calledInside = new LinkedList<>();\n\n  /** @param fullyQualifiedName fullyQualifiedName */\n  public MethodNode(String fullyQualifiedName) {\n    super(fullyQualifiedName, Type.METHOD);\n  }\n}\n",
      "5c0ac895baf10b75181e22675a8b7840b08fb90d":
        "package refactoring.crawler.graph;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport lombok.Getter;\nimport org.jgrapht.graph.DirectedMultigraph;\n\npublic class NamedDirectedMultigraph extends DirectedMultigraph<Node, Edge> {\n\n  @Getter private Map<String, Node> namedVertexMap = new HashMap<>();\n\n  public NamedDirectedMultigraph() {\n    super(Edge.class);\n  }\n\n  public NamedDirectedMultigraph(\n      Supplier<Node> vertexSupplier, Supplier<Edge> edgeSupplier, boolean weighted) {\n    super(vertexSupplier, edgeSupplier, weighted);\n  }\n\n  public boolean addNamedVertex(Node v) {\n    if (!addVertex(v)) return false;\n    namedVertexMap.put(v.getFullyQualifiedName(), v);\n    return true;\n  }\n\n  public Node findNamedNode(String name) {\n    return namedVertexMap.get(name);\n  }\n\n  public boolean hasNamedNode(String name) {\n    return namedVertexMap.containsKey(name);\n  }\n}\n",
      "4397227e131372600696f0c613eaab9d7bf41229":
        'package refactoring.crawler.graph;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class Node {\n\n  public boolean hasCallGraph() {\n    return false;\n  }\n\n  public void setCreatedCallGraph() {}\n\n  public static enum Type {\n    PROJECT,\n    PACKAGE,\n    CLASS,\n    METHOD,\n    FIELD,\n    METHOD_CALL,\n    IMPORT,\n    CLASS_REFERENCE,\n    FIELD_REFERENCE\n  }\n\n  @Getter @Setter private String fullyQualifiedName;\n\n  @Setter @Getter private Node.Type type;\n\n  @Setter @Getter private int[] shingles;\n\n  @Setter @Getter private boolean hasCallGraph;\n\n  @Setter @Getter private String projectName;\n\n  @Setter @Getter private boolean isAPI = false;\n\n  @Setter @Getter private String signature;\n\n  @Setter @Getter private int flags;\n\n  @Setter @Getter private boolean deprecated = false;\n\n  @Setter @Getter private boolean isInterface = false;\n\n  @Getter @Setter private boolean isStatic = false;\n\n  /**\n   * @param fullyQualifiedName fullyQualifiedName\n   * @param type type\n   */\n  public Node(String fullyQualifiedName, Node.Type type) {\n    this.fullyQualifiedName = fullyQualifiedName;\n    this.type = type;\n  }\n\n  public String getSimpleName() {\n    int pos = fullyQualifiedName.lastIndexOf(".");\n    if (pos != -1) {\n      return fullyQualifiedName.substring(pos + 1, fullyQualifiedName.length());\n    }\n    return fullyQualifiedName;\n  }\n\n  @Override\n  public String toString() {\n    if (getSignature() != null)\n      return getType()\n          + "= "\n          + getFullyQualifiedName()\n          + getSignature().substring(getSignature().indexOf("("));\n    else return getType() + "= " + getFullyQualifiedName();\n  }\n}\n',
      "6f93400dab485c9315236a4fe01494f3d3b2aef8":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ChangeMethodSignatureDetection extends MethodDetection {\n\n  /**\n   * @param graph\n   * @param graph2\n   */\n  public ChangeMethodSignatureDetection(\n      NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We need to go from the node to the AST and get the actual method. Then we will call\n   * getSignature() on the IMethod to get the signature. We have to make sure the call graphs are\n   * checked, since we do not want to detect polymorphism as change method signature.\n   */\n  public double computeLikeliness(Node original, Node version) {\n    // Need to find out if in V2 there is a node with the same signature\n    // as the original\n    if (isDeprecatedOrRemoved(new Node[] {original, version})) return 1.0;\n    else {\n      // This is when we have a method overload or deprecated. So when\n      // we can check deprecated methods we need to add it here\n      return analyzeIncomingEdges(original, version);\n    }\n  }\n\n  /** This will handle the same name condition, explained above. */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (pair[0].getSignature().equals(pair[1].getSignature())) continue;\n\n      if (!(pair[0].isAPI() && pair[1].isAPI())) continue;\n\n      boolean hasSameNameAndSignature = hasTheSameSignatureAndName(pair);\n\n      if (hasSameNameAndSignature) continue;\n\n      if (isTheSameModuloRename(pair[0].getFullyQualifiedName(), pair[1].getFullyQualifiedName()))\n        prunedCandidates.add(pair);\n    }\n    return prunedCandidates;\n  }\n\n  private boolean hasTheSameSignatureAndName(Node[] pair) {\n    // TODO here we have to take into account the RenamigsDictionary\n    String parentClassOfVersion = extractFullyQualifiedParentName(pair[1]);\n    Node n2ParentInV1 = graph1.findNamedNode(parentClassOfVersion);\n\n    boolean hasSameNameAndSignature = false;\n\n    if (n2ParentInV1 != null) {\n      // Calling the overloaded method\n      List<Edge> allMethodEdges =\n          filterNamedEdges(new ArrayList<>(graph1.outgoingEdgesOf(n2ParentInV1)), Node.Type.METHOD);\n      for (Edge methodEdge : allMethodEdges) {\n        Node targetMethod = methodEdge.getTarget();\n        if (targetMethod.getSimpleName().equals(pair[1].getSimpleName())\n            && targetMethod.getSignature().equals(pair[1].getSignature()))\n          hasSameNameAndSignature = true;\n      }\n    }\n    return hasSameNameAndSignature;\n  }\n\n  private boolean isDeprecatedOrRemoved(Node[] pair) {\n    Node source = pair[0];\n    String parentOfOriginal = extractFullyQualifiedParentName(source);\n    parentOfOriginal = extractPotentialRename(parentOfOriginal);\n    Node parentOfOriginalInV2 = graph2.findNamedNode(parentOfOriginal);\n    boolean isDeprecated = false;\n    boolean isRemoved = true;\n    if (parentOfOriginalInV2 != null) {\n      List<Edge> methodEdges =\n          filterNamedEdges(\n              new LinkedList<>(graph2.outgoingEdgesOf(parentOfOriginalInV2)), Node.Type.METHOD);\n      for (Edge edge : methodEdges) {\n        Node methodNode = edge.getTarget();\n        if (methodNode.getSimpleName().equals(source.getSimpleName())\n            && methodNode.getSignature().equals(source.getSignature())) {\n          isRemoved = false;\n          isDeprecated = methodNode.isDeprecated();\n        }\n      }\n    }\n\n    return isDeprecated || isRemoved;\n  }\n\n  @Override\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    //  List prunedInParent= super.pruneFalsePositives(listWithFP);\n    List<Node[]> goodResults = new ArrayList<Node[]>();\n\n    for (Node[] pair : listWithFP) {\n      String signatureN1 = pair[0].getSignature();\n      String signatureN2 = pair[1].getSignature();\n      if (!isTheSameSignature(signatureN1, signatureN2)) goodResults.add(pair);\n    }\n    return goodResults;\n  }\n\n  private boolean isTheSameSignature(String signatureN1, String signatureN2) {\n    // TODO filters out (IPluginDescriptor) with\n    // (org.eclipse.core.runtime.IPluginDescriptor)\n    // right now this is checked only for case when there is a one argument\n    String simpleName1 = extractSimpleName(signatureN1.substring(1, signatureN1.length() - 1));\n    String simpleName2 = extractSimpleName(signatureN2.substring(1, signatureN2.length() - 1));\n    return simpleName1.equals(simpleName2);\n  }\n\n  private String extractSimpleName(String fqn) {\n    int lastIndex = fqn.lastIndexOf(".");\n    if (lastIndex < 0) return fqn;\n    else return fqn.substring(lastIndex + 1);\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      "9e492fa56e3b1f654735d03da1b18778ea4a3c5e":
        "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.MethodNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class MethodDetection extends RefactoringDetection {\n  public MethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.METHOD_CALL.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    List<String> callers;\n    if (this instanceof ChangeMethodSignatureDetection)\n      callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, true);\n    else callers = SearchHelper.findMethodCallers(graph, (MethodNode) node, false);\n    for (String s : callers) {\n      Node callerNode = graph.findNamedNode(s);\n      if (callerNode != null) {\n        graph.addEdge(callerNode, node, new Edge(Node.Type.METHOD_CALL));\n      }\n    }\n    node.setCreatedCallGraph();\n  }\n\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n",
      "76a947129555279bb0423f831c949f1899b2074a":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.*;\nimport refactoring.crawler.RefactoringCrawler;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.util.RefactoringCategory;\n\npublic class MoveMethodDetection extends MethodDetection {\n\n  private Node targetClassInVerGraph;\n\n  private Node targetClassInOrigGraph;\n\n  private RefactoringCrawler crawler;\n\n  /**\n   * Checks for MoveMethod\n   *\n   * <p>1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   *\n   * <p>2. Check that the new target class is either a previous argument or a field in the old class\n   */\n  public MoveMethodDetection(\n      RefactoringCrawler crawler, NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n    this.crawler = crawler;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    double edgeGrade = 0.0;\n\n    double referenceGrade = 0.0;\n\n    if (isTargetARenameOfSourceClass(original, version)) return 0.0;\n\n    // FIXME: Potential problem when we subtract 0.01 from reference grade\n    referenceGrade = referencesRemoved(original, version);\n    edgeGrade = analyzeIncomingEdges(original, version);\n    return (edgeGrade + (referenceGrade - 0.01)) / 2.0;\n  }\n\n  private boolean isTargetARenameOfSourceClass(Node original, Node version) {\n    String sourceInOriginal = extractFullyQualifiedParentName(original);\n    String targetInVersion = extractFullyQualifiedParentName(version);\n    // treat case 1\n    return (isTheSameModuloRename(sourceInOriginal, targetInVersion));\n  }\n\n  /**\n   * 1. Check that from the old method, all the references to objects having the same type as the\n   * destination class were removed\n   */\n  private double referencesRemoved(Node original, Node version) {\n    String targetInVersion = extractFullyQualifiedParentName(version);\n\n    targetClassInVerGraph = graph2.findNamedNode(targetInVersion);\n    targetClassInOrigGraph = graph1.findNamedNode(targetInVersion);\n    // treat case 2\n    if (targetClassInOrigGraph == null) {\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      Enumeration<String> keys = dictionary.keys();\n      for (; keys.hasMoreElements(); ) {\n        String aKey = keys.nextElement();\n        String aValue = dictionary.get(aKey);\n        if (targetInVersion.equals(aValue)) {\n          targetClassInOrigGraph = graph1.findNamedNode(aKey);\n        }\n      }\n\n      // treat case 3\n      if (targetClassInOrigGraph == null) return 1.0;\n    }\n\n    // treat case 2 and 4\n    if (!targetClassInVerGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInVerGraph, graph2);\n      targetClassInVerGraph.setCreatedCallGraph();\n    }\n    if (!targetClassInOrigGraph.hasCallGraph()) {\n      createClassReferenceGraph(targetClassInOrigGraph, graph1);\n      targetClassInOrigGraph.setCreatedCallGraph();\n    }\n\n    List<Edge> originalClassReferences =\n        new ArrayList<>(graph1.getAllEdges(original, targetClassInOrigGraph));\n    List<Edge> versionClassReferences =\n        new ArrayList<>(graph2.getAllEdges(version, targetClassInVerGraph));\n    if (originalClassReferences.size() == 0) {\n      if (original.isStatic()) return 1.0;\n      if (isTargetClassAFieldInSourceClass(original, targetClassInOrigGraph)) return 1.0;\n      if (versionClassReferences.size() == 0) return 1.0;\n      return 0.0;\n    } else\n      return Math.abs(\n          ((originalClassReferences.size() - versionClassReferences.size())\n              / originalClassReferences.size()));\n  }\n\n  private boolean isTargetClassAFieldInSourceClass(Node original, Node theTargetClassInOrigGraph) {\n    Node parentClass = graph1.findNamedNode(extractFullyQualifiedParentName(original));\n    List<Edge> edges = new ArrayList<>(graph1.outgoingEdgesOf(parentClass));\n    List<Node> fields = new ArrayList<Node>();\n    for (Edge value : edges) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        fields.add((Node) value.getTarget());\n      }\n    }\n\n    return fields.contains(theTargetClassInOrigGraph);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n\n      // Prune toString since the SearchEngine finds all the toString()\n      // methods, even those that are called from different classes\n      if ("toString".equals(original.getSimpleName())) continue;\n\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  /** Overriden here to prune false positives due to overlapping PullUp and PushDown detection */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> withoutFP = removePairsDetectedInPUM_PDM(listWithFP);\n    withoutFP = addPairsFromMMtoPUM_PDM(withoutFP);\n    return withoutFP;\n  }\n\n  private List<Node[]> addPairsFromMMtoPUM_PDM(List<Node[]> withoutFP) {\n    boolean needsOneMorePass = false;\n    List<Node[]> addToPUM = new ArrayList<>();\n    List<Node[]> addToPDM = new ArrayList<>();\n    for (Node[] pair : withoutFP) {\n      String parentClassOfM1 = extractFullyQualifiedParentName(pair[0]);\n      String parentClassOfM2 = extractFullyQualifiedParentName(pair[1]);\n      Node sourceClass = graph2.findNamedNode(parentClassOfM1);\n      Node destinationClass = graph2.findNamedNode(parentClassOfM2);\n      if (sourceClass != null && destinationClass != null) {\n        if (ClassDetection.isSuperClassOf(sourceClass, destinationClass)) addToPDM.add(pair);\n        else if (ClassDetection.isSuperClassOf(destinationClass, sourceClass)) addToPUM.add(pair);\n      }\n    }\n\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n\n    RefactoringCategory pulledUpCategory = null;\n    RefactoringCategory pushedDownCategory = null;\n    // TODO this only checks whether we already have such a category\n    // created. It might be\n    // that such a category has not been created previously (because no\n    // results were found\n    // for that category. In this case, will need to create a brand new\n    // Category object.\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")) pulledUpCategory = category;\n      else if (category.getName().equals("PushedDownMethods")) pushedDownCategory = category;\n    }\n\n    for (Node[] pair : addToPDM) {\n      if (pushedDownCategory != null) pushedDownCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n\n    for (Node[] pair : addToPUM) {\n      if (pulledUpCategory != null) pulledUpCategory.getRefactoringPairs().add(pair);\n      withoutFP.remove(pair);\n      needsOneMorePass = true;\n    }\n    if (needsOneMorePass) return pruneFalsePositives(withoutFP);\n    else return withoutFP;\n  }\n\n  private List<Node[]> removePairsDetectedInPUM_PDM(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    List<Node[]> pairsToRemove = new ArrayList<>();\n    List<RefactoringCategory> refactoringsList = this.crawler.getRefactoringCategories();\n    for (RefactoringCategory category : refactoringsList) {\n      if (category.getName().equals("PulledUpMethods")\n          || category.getName().equals("PushedDownMethods")) {\n        for (Node[] pair : category.getRefactoringPairs()) {\n          for (Node[] prunedPair : prunedList) {\n            // The OR below takes care about n->1 and 1->n\n            // overlappings\n            // between PullUp/PushDown and MoveMethod\n            if (prunedPair[0] == pair[0] || prunedPair[1] == pair[1]) pairsToRemove.add(prunedPair);\n          }\n        }\n      }\n    }\n    for (Node[] pair : pairsToRemove) {\n      prunedList.remove(pair);\n    }\n    return prunedList;\n  }\n}\n',
      "2c24f295bf40887025a35ce694a69c056b81a7a3":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PullUpMethodDetection extends MethodDetection {\n\n  public PullUpMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  /**\n   * We should now check for the same method being in the parent class, thus for the two nodes,\n   * check if the version now resides in the superclass of the original method\'s parent class.\n   */\n  // TODO: Check why we get a null pointer exception with parentclassver and\n  // parent class orig)\n  public double computeLikeliness(Node original, Node version) {\n    double incomingEdgesGrade = 0.0;\n    boolean isSuperclass = false;\n    // TODO: Think about possible different cases that this might be\n    // an error. pack2.Class1.main vs. pack2.Runner.main, it cannot\n    // find it.\n    // TODO: Think about the NULL case. Return 0.0 if you find null,\n    // since clearly they are not "like" each other.\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassOrig is a subclass of\n    // parentClassVer\n    if (ClassDetection.isSuperClassOf(parentClassVer, parentClassOrig)) isSuperclass = true;\n\n    if (isSuperclass) {\n      incomingEdgesGrade = analyzeIncomingEdges(original, version);\n      return incomingEdgesGrade;\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      "296bce275d7968716d7f0bed80da373e18210114":
        'package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.classDetection.ClassDetection;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class PushDownMethodDetection extends MethodDetection {\n\n  public PushDownMethodDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    boolean superClassGrade = false;\n    String parentClassOriginal = extractFullyQualifiedParentName(original);\n    String parentClassVersion = extractFullyQualifiedParentName(version);\n    parentClassOriginal = extractPotentialRename(parentClassOriginal);\n    Node parentClassOrig = graph2.findNamedNode(parentClassOriginal);\n    if (parentClassOrig == null) return 0.0;\n    Node parentClassVer = graph2.findNamedNode(parentClassVersion);\n    // Now we should check if parentClassVer is a subclass of\n    // parentClassOrig\n    if (parentClassOriginal.contains("Priority") || parentClassOriginal.contains("Level"))\n      System.out.println("stop");\n    if (ClassDetection.isSuperClassOf(parentClassOrig, parentClassVer)) superClassGrade = true;\n    if (superClassGrade) {\n      return (analyzeIncomingEdges(original, version));\n    } else return 0.0;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractParentSimpleName(original);\n      String parentClassVersion = extractParentSimpleName(version);\n      if (!isTheSameModuloRename(parentClassOriginal, parentClassVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n\n    return candidatesWithDifferentParentClass;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n}\n',
      ad4c2988b4aa75b00ee844d54a74c441abebf9d0:
        "package refactoring.crawler.detection.methodDetection;\n\nimport java.util.ArrayList;\nimport java.util.Dictionary;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameMethodDetection extends MethodDetection {\n\n  public RenameMethodDetection(\n      NamedDirectedMultigraph oldVersion, NamedDirectedMultigraph newVersion) {\n    super(oldVersion, newVersion);\n  }\n\n  /**\n   * @param candidates List containing clone methods\n   * @return A List containing only the candidate methods that are in the same class\n   */\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedMethods = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedMethods) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isTheSameModuloRename =\n          isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n      boolean isSimpleNameEquals = original.getSimpleName().equals(version.getSimpleName());\n      if (isTheSameModuloRename && !isSimpleNameEquals) candidatesWithSameParentClass.add(pair);\n    }\n\n    return candidatesWithSameParentClass;\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    // createCallGraph(original, version);\n    // return computeLikelinessConsideringEdges(original, version);\n    return analyzeIncomingEdges(original, version);\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n\n  /**\n   * Prune further for cases that have n-to-1 mappings. (eg. {start, end, pointAt} ->\n   * getStartConnector) in JHD5.3 )\n   */\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> prunedList = super.pruneFalsePositives(listWithFP);\n    for (int i = 0; i < prunedList.size(); i++) {\n      Node[] pair = prunedList.get(i);\n      Node target = pair[1];\n      String targetName = target.getSimpleName().toLowerCase().trim();\n      List<Node[]> allPairsWithSameTarget = new ArrayList<Node[]>();\n      for (Node[] nodes : prunedList) {\n        Node potentialTarget = (nodes)[1];\n        if (target == potentialTarget) allPairsWithSameTarget.add(nodes);\n      }\n      if (allPairsWithSameTarget.size() > 1) {\n        for (Object o : allPairsWithSameTarget) {\n          Node[] sameTargetPair = (Node[]) o;\n          Node sourceNode = sameTargetPair[0];\n          String sourceName = sourceNode.getSimpleName().toLowerCase().trim();\n          // Changed from || to && and changed the !='s to =='s\n          if ((!targetName.contains(sourceName)) && (!sourceName.contains(targetName))) {\n            prunedList.remove(sameTargetPair);\n            Dictionary<String, String> dictionary = getRenamingDictionary();\n            dictionary.remove(sourceNode.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return prunedList;\n  }\n}\n",
      "67bf6cf86456904a46c7d568fe0527ed920c971f":
        "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.FieldNode;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class FieldDetection extends RefactoringDetection {\n\n  public FieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2) {}\n\n  @Override\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.FIELD_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  @Override\n  public boolean isRename() {\n    return false;\n  }\n\n  protected void createFieldReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    final List<String> results = SearchHelper.findFieldReferences((FieldNode) originalNode);\n\n    for (String result : results) {\n      //\t\t\t\tIMember resultNode = (IMember) result;\n      //\t\t\t\tString callingNode = null;\n      //\t\t\t\tif (resultNode instanceof IMethod) {\n      //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n      //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + rsm1.getElementName();\n      //\t\t\t\t} else if (resultNode instanceof Initializer) {\n      //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n      //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n      // ASTNodes\n      //\t\t\t\t\t\t.getParent(initializer,\n      //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n      //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n      //\t\t\t\t\tcallingNode = resultNode.getDeclaringType()\n      //\t\t\t\t\t\t.getFullyQualifiedName('.');\n      //\t\t\t\t\tcallingNode += \".\" + simpleName.getFullyQualifiedName();\n      //\t\t\t\t}\n\n      Node callerNode = graph.findNamedNode(result);\n      if (callerNode != null)\n        graph.addEdge(callerNode, originalNode, new Edge(Node.Type.FIELD_REFERENCE));\n    }\n  }\n\n  public void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createFieldReferenceGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createFieldReferenceGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public double analyzeIncomingEdges(Node original, Node version) {\n    double incomingEdgesGrade;\n    createCallGraph(original, version);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n    incomingEdgesGrade =\n        computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return incomingEdgesGrade;\n  }\n}\n",
      "184ff327f5f763cae4d3307e3cf0ae9b0391eb70":
        "package refactoring.crawler.detection.fieldDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveFieldDetection extends FieldDetection {\n\n  /*\n   * We already have Class - Field edges. So we need to make sure that they\n   * are different parents, and also make sure that their call graph is still\n   * the same.\n   */\n\n  public MoveFieldDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node original, Node version) {\n    return analyzeIncomingEdges(original, version);\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedFields = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithDifferentParentClass = new ArrayList<>();\n    for (Node[] pair : prePrunedFields) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentClassOriginal = extractFullyQualifiedParentName(original);\n      String parentClassVersion = extractFullyQualifiedParentName(version);\n      boolean isModRen = isTheSameModuloRename(parentClassOriginal, parentClassVersion);\n\n      if (!isModRen && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithDifferentParentClass.add(pair);\n      }\n    }\n    return candidatesWithDifferentParentClass;\n  }\n}\n",
      "072aa07a114622cd395391b740b9a1e46b64fb70":
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.SearchHelper;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class ClassDetection extends RefactoringDetection {\n\n  public ClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  @Override\n  public double computeLikeliness(Node node1, Node node12) {\n    // TODO Auto-generated method stub\n    return 0;\n  }\n\n  @Override\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    // TODO Auto-generated method stub\n    return null;\n  }\n\n  @Override\n  public boolean isRename() {\n    // TODO Auto-generated method stub\n    return false;\n  }\n\n  public List<Edge> filterNamedEdges(List<Edge> list) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge value : list) {\n      if (Node.Type.CLASS_REFERENCE.equals(value.getLabel())) {\n        results.add(value);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * We need to find all the places that the original and version classes are instantiated. We will\n   * incorporate this into the likeliness grade.\n   */\n  protected void createCallGraph(Node original, Node version) {\n    if (!original.hasCallGraph()) {\n      createCallGraph(original, graph1);\n      original.setCreatedCallGraph();\n    }\n    if (!version.hasCallGraph()) {\n      createCallGraph(version, graph2);\n      version.setCreatedCallGraph();\n    }\n  }\n\n  public void createCallGraph(Node node, NamedDirectedMultigraph graph) {\n    createClassReferenceGraph(node, graph);\n    node.setCreatedCallGraph();\n  }\n\n  /**\n   * Accepts two class nodes, and determines if first parameter is a superclass of the second\n   * parameter.\n   */\n  public static boolean isSuperClassOf(Node node1, Node node2) {\n    List<String> superClasses = SearchHelper.findSuperClassesOf((ClassNode) node2);\n    for (String superClass : superClasses) {\n      if (superClass.equals(node1.getFullyQualifiedName())) return true;\n    }\n    return false;\n  }\n}\n",
      e753da375cfabc5fb57d8d5440f95671d7bf42f9:
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class MoveClassDetection extends ClassDetection {\n\n  public MoveClassDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    super(graph, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new LinkedList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new LinkedList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePrunedClasses = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesInDifferentPackages = new ArrayList<>();\n    for (Node[] pair : prePrunedClasses) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractFullyQualifiedParentName(original);\n      String parentPackageVersion = extractFullyQualifiedParentName(version);\n      if (!isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && ((original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesInDifferentPackages.add(pair);\n      }\n    }\n    return candidatesInDifferentPackages;\n  }\n\n  public boolean isRename() {\n    return false;\n  }\n}\n",
      f069e44153341cbf9da6818393293f5e7e9ac108:
        "package refactoring.crawler.detection.classDetection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic class RenameClassDetection extends ClassDetection {\n\n  public RenameClassDetection(NamedDirectedMultigraph graph1, NamedDirectedMultigraph graph2) {\n    super(graph1, graph2);\n  }\n\n  public double computeLikeliness(Node nodeOriginal, Node nodeVersion) {\n    return doEdgeAnalysis(nodeOriginal, nodeVersion);\n  }\n\n  /**\n   * Calls createCallGraph in ClassDetection Calls filterNamedEdges in ClassDetection Calls\n   * computeLikelinessIncomingEdges in RefactoringDetection\n   *\n   * @param nodeOriginal\n   * @param nodeVersion\n   * @return\n   */\n  private double doEdgeAnalysis(Node nodeOriginal, Node nodeVersion) {\n    double edgeGrade;\n    createCallGraph(nodeOriginal, nodeVersion);\n    List<Edge> incomingEdgesOriginal =\n        filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(nodeOriginal)));\n    List<Edge> incomingEdgesVersion =\n        filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(nodeVersion)));\n    edgeGrade = computeLikelinessIncomingEdges(incomingEdgesOriginal, incomingEdgesVersion);\n    return edgeGrade;\n  }\n\n  public List<Node[]> pruneOriginalCandidates(List<Node[]> candidates) {\n    List<Node[]> prePruned = super.pruneOriginalCandidatesImpl(candidates);\n    List<Node[]> candidatesWithSameParentPackage = new ArrayList<>();\n    for (Node[] pair : prePruned) {\n      Node original = pair[0];\n      Node version = pair[1];\n      String parentPackageOriginal = extractParentSimpleName(original);\n      String parentPackageVersion = extractParentSimpleName(version);\n      if (isTheSameModuloRename(parentPackageOriginal, parentPackageVersion)\n          && (!(original.getSimpleName().equals(version.getSimpleName())))) {\n        candidatesWithSameParentPackage.add(pair);\n      }\n    }\n\n    return candidatesWithSameParentPackage;\n  }\n\n  @Override\n  public boolean isRename() {\n    return true;\n  }\n}\n",
      "6ba49588fd9f84df7d87869b64cfedcf10d88ed0":
        'package refactoring.crawler.detection;\n\nimport java.util.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport refactoring.crawler.detection.methodDetection.MoveMethodDetection;\nimport refactoring.crawler.graph.ClassNode;\nimport refactoring.crawler.graph.Edge;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\n\npublic abstract class RefactoringDetection {\n\n  @Getter @Setter private double threshold;\n\n  protected NamedDirectedMultigraph graph1;\n\n  protected NamedDirectedMultigraph graph2;\n\n  private double lowerThreshold;\n\n  /** Dictionary contains <Original, Version> pairs for the renaming. */\n  private static Dictionary<String, String> renamingDictionary;\n\n  public static Dictionary<String, String> getRenamingDictionary() {\n    if (renamingDictionary == null) renamingDictionary = new Hashtable<>();\n    return renamingDictionary;\n  }\n\n  public RefactoringDetection(NamedDirectedMultigraph graph, NamedDirectedMultigraph graph2) {\n    this.graph1 = graph;\n    this.graph2 = graph2;\n  }\n\n  public abstract double computeLikeliness(Node node1, Node node12);\n\n  public abstract List<Edge> filterNamedEdges(List<Edge> list);\n\n  public abstract List<Node[]> pruneOriginalCandidates(List<Node[]> candidates);\n\n  public abstract void createCallGraph(Node originalInV2, NamedDirectedMultigraph graph2);\n\n  public abstract boolean isRename();\n\n  /**\n   * TEMPLATE METHOD Describes the algorithm for detecting any particular refactoring The original\n   * candidates are prunned (for getting rid of obvious extraneous ones, then the likeliness of each\n   * pair is computed. In the end we eliminate FalsePositives. Subclasses must override\n   * computeLikeliness and pruneOriginalCandidates.\n   */\n  public List<Node[]> detectRefactorings(List<Node[]> candidates) {\n\n    List<Node[]> refactoredNodes = new ArrayList<>();\n    List<Node[]> listWithFP = doDetectRefactorings(candidates, refactoredNodes);\n    return pruneFalsePositives(listWithFP);\n  }\n\n  protected String extractPotentialRename(String parentClassOriginal) {\n    String renamedName = getRenamingDictionary().get(parentClassOriginal);\n    return renamedName == null ? parentClassOriginal : renamedName;\n  }\n\n  private List<Node[]> doDetectRefactorings(List<Node[]> candidates, List<Node[]> refactoredNodes) {\n    // List<Node[]> potentialRefactorings = new ArrayList<Node[]>();\n    List<Node[]> prunedCandidates = pruneOriginalCandidates(candidates);\n    boolean foundNewRefactoring = false;\n    for (Node[] pair : prunedCandidates) {\n      Node original = pair[0];\n      Node version = pair[1];\n      double likeliness = computeLikeliness(original, version);\n      if (likeliness >= threshold) {\n        if (!refactoredNodes.contains(pair)) {\n          refactoredNodes.add(pair);\n          foundNewRefactoring = true;\n        }\n        // candidates.remove(pair); acivating this line would fail to\n        // detect those cases when two\n        // types of refactorings happened to the same node\n        //        updateFeedbackLoop(pair);\n      }\n    }\n    if (foundNewRefactoring) {\n      doDetectRefactorings(candidates, refactoredNodes);\n    }\n    return refactoredNodes;\n  }\n\n  /** @param pair */\n  private void updateFeedbackLoop(Node[] pair) {\n    if (isRename()) {\n      Node original = pair[0];\n      Node renamed = pair[1];\n      Dictionary<String, String> dict = getRenamingDictionary();\n      dict.put(original.getFullyQualifiedName(), renamed.getFullyQualifiedName());\n    }\n  }\n\n  public List<Node[]> pruneFalsePositives(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<Node[]>();\n    for (Node[] pair : listWithFP) {\n      Node original = pair[0];\n      Node version = pair[1];\n      Node originalInV2 = findNamedNodeWithSignature(graph2, original);\n      if (originalInV2 != null) {\n        createCallGraph(originalInV2, graph2);\n        List<Edge> origIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(originalInV2)));\n        List<Edge> verIncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph2.incomingEdgesOf(version)));\n        List<Edge> origInVer1IncomingEdges =\n            filterNamedEdges(new ArrayList<>(graph1.incomingEdgesOf(original)));\n\n        List<Node> origInV2Callers = getCallers(origIncomingEdges);\n        List<Node> verCallers = getCallers(verIncomingEdges);\n        List<Node> origInV1Callers = getCallers(origInVer1IncomingEdges);\n\n        // remove those pairs where N1InV2 has at least one call site as N2inV2.\n        // since a call site cannot be calling both the old and the new entity at the same time\n        for (Node node : verCallers) {\n          if (origInV2Callers.contains(node))\n            if (!nodesToRemove.contains(pair)) {\n              //              System.out.println("1st Prune in RD:" + pair[0] + pair[1]);\n              nodesToRemove.add(pair);\n            }\n        }\n\n        // check to see whether the N1inV1 has at least one call site as N1inV2. If it has, then the\n        // pair\n        // is a false positive (since there should be either no more callers for N1inV2 or their\n        // call sites\n        // should be different\n        for (Node node : origInV1Callers) {\n          for (Node callingNode : origInV2Callers) {\n            if (node.getFullyQualifiedName().equals(callingNode.getFullyQualifiedName())) {\n              if (!nodesToRemove.contains(pair)) {\n                nodesToRemove.add(pair);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      listWithFP.remove(pair);\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n\n    pruneOverloadedMethodFP(listWithFP);\n\n    return listWithFP;\n  }\n\n  private List<Node> getCallers(List<Edge> incomingEdges) {\n    List<Node> callers = new ArrayList<>();\n    for (Edge edge : incomingEdges) {\n      callers.add(edge.getSource());\n    }\n    return callers;\n  }\n\n  /**\n   * This prunes cases like m(i) -> m\'(i) m(i) -> m\'(S)\n   *\n   * <p>This method prunes away the pair m(i)->m\'(S) since it is likely that this is generated\n   * because of a method overload.\n   *\n   * <p>This method is never called in the ChangeMethodSignature detection.\n   */\n  private void pruneOverloadedMethodFP(List<Node[]> listWithFP) {\n    List<Node[]> nodesToRemove = new ArrayList<>();\n    for (int i = 0; i < listWithFP.size(); i++) {\n      boolean hasSameNameAndSignature = false;\n      Node[] pair = listWithFP.get(i);\n      Node source = pair[0];\n      for (int j = i; j < listWithFP.size(); j++) {\n        Node[] pair2 = listWithFP.get(j);\n        Node source2 = pair2[0];\n        if (source.equals(source2)) {\n          Node target2 = pair2[1];\n          if (source.getSimpleName().equals(target2.getSimpleName()))\n            if (signatureEqualsModuloMoveMethod(source, target2)) hasSameNameAndSignature = true;\n        }\n      }\n      if (hasSameNameAndSignature) {\n        for (int j = i; j < listWithFP.size(); j++) {\n          Node[] pair2 = listWithFP.get(j);\n          Node source2 = pair2[0];\n          if (source.equals(source2)) {\n            Node target2 = pair2[1];\n            if (source.getSimpleName().equals(target2.getSimpleName()))\n              if (!signatureEqualsModuloMoveMethod(source, target2))\n                if (!nodesToRemove.contains(pair2)) nodesToRemove.add(pair2);\n          }\n        }\n      }\n    }\n    for (Node[] pair : nodesToRemove) {\n      System.out.println("2nd REMOVE: " + pair[0] + ", " + pair[1]);\n      listWithFP.remove(pair);\n\n      Dictionary<String, String> dictionary = getRenamingDictionary();\n      dictionary.remove(pair[0].getFullyQualifiedName());\n    }\n  }\n\n  /**\n   * This takes into account the possible renaming in the parent of the node\n   *\n   * @param g is the Version2 graph\n   * @param original is a node from Version1\n   * @return\n   */\n  private Node findNamedNodeWithSignature(NamedDirectedMultigraph g, Node original) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    String fqnParent = extractFullyQualifiedParentName(original);\n    String possiblyRenamedFQN = dictionary.get(fqnParent);\n    if (possiblyRenamedFQN != null) fqnParent = possiblyRenamedFQN;\n    Node parentNode = g.findNamedNode(fqnParent);\n\n    if (parentNode != null) {\n      List<Edge> parentEdges = new LinkedList<>(g.outgoingEdgesOf(parentNode));\n      List<Edge> filteredEdges = new LinkedList<>(filterNamedEdges(parentEdges, Node.Type.METHOD));\n      for (Iterator iter = filteredEdges.iterator(); iter.hasNext(); ) {\n        Edge edge = (Edge) iter.next();\n        Node child = (Node) edge.getTarget();\n        if (original.getSimpleName().equals(child.getSimpleName()))\n          if (original.getSignature() != null) {\n            // This handles the method nodes\n            if (original.getSignature().equals(child.getSignature())) return child;\n          } else\n            // Classes and packages\n            return child;\n      }\n    }\n    return null;\n  }\n\n  protected List<Edge> filterNamedEdges(List<Edge> list, Node.Type label) {\n    List<Edge> results = new ArrayList<>();\n    for (Edge edge : list) {\n      if (label.equals(edge.getLabel())) {\n        results.add(edge);\n      }\n    }\n    return results;\n  }\n\n  protected String extractFullyQualifiedParentName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    return extractFullyQualifiedParentName(originalName);\n  }\n\n  public String extractFullyQualifiedParentName(String originalName) {\n    String fq_parentName = "";\n    int lastIndex = originalName.lastIndexOf(".");\n    if (lastIndex > 0) fq_parentName = originalName.substring(0, lastIndex);\n    return fq_parentName;\n  }\n\n  /**\n   * eg. IWorkbenchPage.openEditor(IFile) is signatureEqualsModuloMoveMethod\n   * IDE.openEditor(IWorkbenchPage, IFile)\n   */\n  private boolean signatureEqualsModuloMoveMethod(Node source, Node target) {\n    boolean retval = false;\n\n    if (source.getSignature() == null) return false;\n\n    retval = source.getSignature().equals(target.getSignature());\n\n    if (!retval && (this instanceof MoveMethodDetection)) {\n      String sourceParent = extractParentSimpleName(source);\n      StringTokenizer sourceTokenizer = new StringTokenizer(source.getSignature(), "( , )");\n      StringTokenizer targetTokenizer = new StringTokenizer(target.getSignature(), "( , )");\n      String[] sourceTokens = new String[sourceTokenizer.countTokens()];\n      String[] targetTokens = new String[targetTokenizer.countTokens()];\n\n      for (int i = 0; i < sourceTokens.length; i++) {\n        sourceTokens[i] = sourceTokenizer.nextToken();\n      }\n\n      for (int i = 0; i < targetTokens.length; i++) {\n        targetTokens[i] = targetTokenizer.nextToken();\n      }\n\n      if (targetTokens.length == sourceTokens.length + 1) {\n        if (!targetTokens[0].trim().equals(sourceParent)) return false;\n        else {\n          for (int i = 0; i < sourceTokens.length; i++) {\n            if (!sourceTokens[i].trim().equals(targetTokens[i + 1].trim())) return false;\n          }\n          retval = true;\n        }\n      }\n    }\n    return retval;\n  }\n\n  /**\n   * This helper method takes a string containing the dot separated name of a node and it returns\n   * the substring from the beginning up to the last dot (e.g. for pack1.class1.method1 it returns\n   * class1)\n   */\n  protected String extractParentSimpleName(Node original) {\n    String originalName = original.getFullyQualifiedName();\n    String parentName = originalName.substring(0, originalName.lastIndexOf("."));\n    parentName = parentName.substring(parentName.lastIndexOf(".") + 1);\n    return parentName;\n  }\n\n  public double computeLikelinessIncomingEdges(List<Edge> edges1, List<Edge> edges2) {\n    double count = 0;\n\n    Edge[] arrEdge2 = edges2.toArray(new Edge[0]);\n\n    for (Edge edge1 : edges1) {\n      Node node1 = edge1.getSource();\n      for (int i = 0; i < arrEdge2.length; i++) {\n        Edge edge2 = arrEdge2[i];\n        if (edge2 != null) {\n          Node node2 = (Node) edge2.getSource();\n          if (isTheSameModuloRename(node1.getFullyQualifiedName(), node2.getFullyQualifiedName())) {\n            count++;\n            // we mark this edge as already counted so that we don\'t\n            // count it\n            // twice when there are multiple edges between two nodes\n            arrEdge2[i] = null;\n          }\n        }\n      }\n    }\n\n    double fraction1 = (edges1.size() == 0 ? 0 : count / edges1.size());\n    double fraction2 = edges2.size() == 0 ? 0 : count / edges2.size();\n\n    return (fraction1 + fraction2) / 2.0;\n  }\n\n  protected boolean isTheSameModuloRename(String original, String version) {\n    Dictionary<String, String> dictionary = getRenamingDictionary();\n    if (version.equals(dictionary.get(original))) return true;\n    if (original.lastIndexOf(".") == -1 || version.lastIndexOf(".") == -1)\n      return original.equals(version);\n    else if (original\n        .substring(original.lastIndexOf("."))\n        .equals(version.substring(version.lastIndexOf("."))))\n      return isTheSameModuloRename(\n          extractFullyQualifiedParentName(original), extractFullyQualifiedParentName(version));\n    else return false;\n  }\n\n  public List<Node[]> pruneOriginalCandidatesImpl(List<Node[]> candidates) {\n    List<Node[]> prunedCandidates = new ArrayList<>();\n    for (Node[] pair : candidates) {\n      if (!(pair[0].getFullyQualifiedName().equals(pair[1].getFullyQualifiedName()))) {\n\n        if (pair[0].isAPI() && pair[1].isAPI()) {\n          Node n2inV1 = graph1.findNamedNode(pair[1].getFullyQualifiedName());\n\n          if ((n2inV1 == null)) {\n            prunedCandidates.add(pair);\n          }\n        }\n      }\n    }\n    return prunedCandidates;\n  }\n\n  // TODO this is bug pruned\n  protected void createClassReferenceGraph(Node originalNode, NamedDirectedMultigraph graph) {\n    //\t\ttry {\n    List<String> results = SearchHelper.findClassReferences(graph, (ClassNode) originalNode);\n    results.forEach(\n        result -> {\n          if (graph.hasNamedNode(result))\n            graph.addEdge(\n                graph.findNamedNode(result), originalNode, new Edge(Node.Type.CLASS_REFERENCE));\n        });\n    // Possible change to methods that instantiate classes\n    // from class -> class edges.\n    //\t\t\tfor (String result : results) {\n    ////\t\t\t\tIJavaElement resultNode = (IJavaElement) result;\n    //\t\t\t\tNode resultNode = graph.findNamedNode(result);\n    //\t\t\t\tString callingNode = null;\n    //\t\t\t\tif (resultNode instanceof IMethod) {\n    //\t\t\t\t\tIMethod rsm1 = (IMethod) resultNode;\n    //\t\t\t\t\tcallingNode = rsm1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + rsm1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof IType) {\n    //\t\t\t\t\tIType rst = (IType) resultNode;\n    //\t\t\t\t\tcallingNode = rst.getFullyQualifiedName(\'.\');\n    //\t\t\t\t} else if (resultNode instanceof IField) {\n    //\t\t\t\t\tIField rsf1 = (IField) resultNode;\n    //\t\t\t\t\t// Workaround\n    //\t\t\t\t\tcallingNode = rsf1.getDeclaringType()\n    //\t\t\t\t\t\t.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += ".";\n    //\t\t\t\t\tcallingNode += rsf1.getElementName();\n    //\t\t\t\t} else if (resultNode instanceof Initializer) {\n    //\t\t\t\t\tInitializer initializer = (Initializer) resultNode;\n    //\t\t\t\t\tVariableDeclarationFragment fieldDeclarationFragment = (VariableDeclarationFragment)\n    // ASTNodes\n    //\t\t\t\t\t\t.getParent(initializer,\n    //\t\t\t\t\t\t\tVariableDeclarationFragment.class);\n    //\t\t\t\t\tSimpleName simpleName = fieldDeclarationFragment.getName();\n    //\t\t\t\t\tIType parentType = (IType) ASTNodes.getParent(initializer,\n    //\t\t\t\t\t\tIType.class);\n    //\t\t\t\t\tcallingNode = parentType.getFullyQualifiedName(\'.\');\n    //\t\t\t\t\tcallingNode += "." + simpleName.getFullyQualifiedName();\n    //\t\t\t\t}\n    //\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// ImportDeclaration\n    //\t\t\t\t// TODO treat the case when resultNode is instance of\n    //\t\t\t\t// Initializer\n    //\t\t\t\t// this appears in Loj4j1.3.0 in class LogManager, references to\n    //\t\t\t\t// Level\n    //\t\t\t\tif (callingNode == null) {\n    //\t\t\t\t\tSystem.out.print("");\n    //\t\t\t\t}\n    //\t\t\t\tif (callingNode != null) {\n    //\t\t\t\t\tNode callerNode = graph.findNamedNode(callingNode);\n    //\t\t\t\t\tif (callerNode != null)\n    //\t\t\t\t\t\tgraph.addEdge(callerNode, originalNode,\n    //\t\t\t\t\t\t\tNode.CLASS_REFERENCE);\n    //\t\t\t\t}\n    //\n    //\t\t\t}\n    //\n    //\t\t} catch (CoreException e) {\n    //\t\t\tJavaPlugin.log(e);\n    //\t\t}\n  }\n}\n',
      d81bb74b671cc12037d7efe46ea3c7faacae2b31:
        "package refactoring.crawler.detection;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport refactoring.crawler.graph.*;\n\npublic class SearchHelper {\n  public static List<String> findFieldReferences(FieldNode node) {\n    return node.getFieldReferenceToMethod();\n  }\n\n  public static List<String> findSuperClassesOf(ClassNode node) {\n    return node.getSuperClasses();\n  }\n\n  public static List<String> findClassReferences(\n      NamedDirectedMultigraph graph, ClassNode classNode) {\n    //    return node.getClassesImported();\n    List<String> res = new LinkedList<>();\n    for (Node n : graph.vertexSet()) {\n      if (n.getType() == Node.Type.CLASS) {\n        for (String imported : ((ClassNode) n).getClassesImported()) {\n          if (imported.equals(classNode.getFullyQualifiedName())) {\n            res.add(n.getFullyQualifiedName());\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  public static List<String> findMethodCallers(\n      NamedDirectedMultigraph graph, MethodNode node, boolean withSignature) {\n    return graph\n        .vertexSet()\n        .stream()\n        .filter(n -> (n instanceof MethodNode))\n        .map(methodNode -> (MethodNode) methodNode)\n        .filter(\n            methodNode ->\n                methodNode\n                    .getCalledInside()\n                    .stream()\n                    .anyMatch(\n                        calledMethod -> {\n                          String expect =\n                              withSignature\n                                  ? calledMethod.getFullyQualifiedNameWithSignature()\n                                  : calledMethod.getFullyQualifiedNameWithoutSignature();\n                          String actual =\n                              withSignature\n                                  ? node.getFullyQualifiedName() + node.getSignature()\n                                  : node.getFullyQualifiedName();\n                          return expect.equals(actual);\n                        }))\n        .map(\n            methodNode -> {\n              return withSignature\n                  ? methodNode.getFullyQualifiedName() + methodNode.getSignature()\n                  : methodNode.getFullyQualifiedName();\n            })\n        .collect(Collectors.toList());\n  }\n}\n",
      "4eb81739758717c8ca09b89db317ccc7d09c6c46":
        'package refactoring.crawler;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport java.util.*;\nimport lombok.Getter;\nimport refactoring.crawler.detection.RefactoringDetection;\nimport refactoring.crawler.detection.classDetection.RenameClassDetection;\nimport refactoring.crawler.detection.methodDetection.*;\nimport refactoring.crawler.graph.NamedDirectedMultigraph;\nimport refactoring.crawler.graph.Node;\nimport refactoring.crawler.shingles.ShinglesUtil;\nimport refactoring.crawler.util.*;\n\npublic class RefactoringCrawler {\n\n  public static enum Settings {\n    T_RENAME_METHOD,\n    T_RENAME_CLASS,\n    T_MOVE_METHOD,\n    T_PULL_UP_METHOD,\n    T_PUSH_DOWN_METHOD,\n    T_CHANGE_METHOD_SIGNATURE\n  }\n\n  private String projectName;\n  private Dictionary<Settings, Double> settings;\n\n  @Getter private List<RefactoringCategory> refactoringCategories = new LinkedList<>();\n\n  public RefactoringCrawler(String projectName, Dictionary<Settings, Double> settings) {\n    this.projectName = projectName;\n    this.settings = settings;\n  }\n\n  private static List<CompilationUnit> parse(List<String> files) {\n\n    TypeSolver typeSolver = new ReflectionTypeSolver();\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(typeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    MemoryTypeSolver memoryTypeSolver = new MemoryTypeSolver();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      NodeList<TypeDeclaration<?>> typeDeclarations = cu.getTypes();\n      ClassOrInterfaceDeclaration classOrInterfaceDeclaration = null;\n      for (TypeDeclaration<?> typeDeclaration : typeDeclarations) {\n        if (typeDeclaration.isClassOrInterfaceDeclaration()) {\n          classOrInterfaceDeclaration = typeDeclaration.asClassOrInterfaceDeclaration();\n        }\n      }\n      if (null != classOrInterfaceDeclaration) {\n        Optional<String> fullyQualifiedName = classOrInterfaceDeclaration.getFullyQualifiedName();\n        if (fullyQualifiedName.isPresent()) {\n          ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration =\n              classOrInterfaceDeclaration.resolve();\n          memoryTypeSolver.addDeclaration(\n              fullyQualifiedName.get(), resolvedReferenceTypeDeclaration);\n        }\n      }\n    }\n\n    typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), memoryTypeSolver);\n    StaticJavaParser.getConfiguration().setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n    List<CompilationUnit> resList = new LinkedList<>();\n    for (String source : files) {\n      CompilationUnit cu = StaticJavaParser.parse(source);\n      resList.add(cu);\n    }\n    return resList;\n  }\n\n  public void detect(String oldVersion, String newVersion) {\n    List<String> oldVersionList = new LinkedList<>();\n    List<String> newVersionList = new LinkedList<>();\n\n    oldVersionList.add(oldVersion);\n    newVersionList.add(newVersion);\n\n    this.detect(oldVersionList, newVersionList);\n  }\n\n  public void detect(List<String> oldVersion, List<String> newVersion) {\n    ShinglesUtil shinglesUtil = new ShinglesUtil();\n\n    List<CompilationUnit> oldVersionCU = parse(oldVersion);\n    List<CompilationUnit> newVersionCU = parse(newVersion);\n    SourceNavigator navigator = new SourceNavigator();\n    navigator.setShinglesUtil(shinglesUtil);\n    navigator.browseProject(projectName, oldVersionCU);\n    NamedDirectedMultigraph originalGraph = navigator.getGraph();\n\n    SourceNavigator navigatorForVersion = new SourceNavigator();\n    navigatorForVersion.setShinglesUtil(shinglesUtil);\n    navigatorForVersion.browseProject(projectName, newVersionCU);\n    NamedDirectedMultigraph versionGraph = navigatorForVersion.getGraph();\n\n    shinglesUtil.initialize(originalGraph, versionGraph);\n\n    // must in this order\n\n    double tRenameMethod = this.settings.get(Settings.T_RENAME_METHOD);\n    this.detectRenameMethod(tRenameMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tRenameClass = this.settings.get(Settings.T_RENAME_CLASS);\n    detectRenameClass(tRenameClass, shinglesUtil, originalGraph, versionGraph);\n\n    double tMoveMethod = this.settings.get(Settings.T_MOVE_METHOD);\n    detectMoveMethod(tMoveMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPullUpMethod = this.settings.get(Settings.T_PULL_UP_METHOD);\n    detectPullUpMethod(tPullUpMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tPushDownMethod = this.settings.get(Settings.T_PUSH_DOWN_METHOD);\n    detectPushDownMethod(tPushDownMethod, shinglesUtil, originalGraph, versionGraph);\n\n    double tChangeMethodSignature = this.settings.get(Settings.T_CHANGE_METHOD_SIGNATURE);\n    detectChangeMethodSignature(tChangeMethodSignature, shinglesUtil, originalGraph, versionGraph);\n  }\n\n  private void detectChangeMethodSignature(\n      double tChangeMethodSignature,\n      ShinglesUtil shinglesUtil,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateChangedMethodSignatures = shinglesUtil.findSimilarMethods();\n    RefactoringDetection detector = new ChangeMethodSignatureDetection(originalGraph, versionGraph);\n    detector.setThreshold(tChangeMethodSignature);\n    List<Node[]> changedMethodSignatures =\n        detector.detectRefactorings(candidateChangedMethodSignatures);\n    if (changedMethodSignatures.size() > 0) {\n      RefactoringCategory changeSignatureCategory = new RefactoringCategory();\n      changeSignatureCategory.setName("ChangedMethodSignatures");\n      changeSignatureCategory.setRefactoringPairs(changedMethodSignatures);\n      this.refactoringCategories.add(changeSignatureCategory);\n    }\n  }\n\n  private void detectRenameMethod(\n      double tMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph oldVersionGraph,\n      NamedDirectedMultigraph newVersionGraph) {\n    List<Node[]> candidateMethods = se.findSimilarMethods();\n    RefactoringDetection detector = new RenameMethodDetection(oldVersionGraph, newVersionGraph);\n    detector.setThreshold(tMethod);\n\n    List<Node[]> renamedMethods = detector.detectRefactorings(candidateMethods);\n    if (renamedMethods.size() > 0) {\n      RefactoringCategory renameMethodCategory = new RefactoringCategory();\n      renameMethodCategory.setName("RenamedMethods");\n      renameMethodCategory.setRefactoringPairs(renamedMethods);\n      this.refactoringCategories.add(renameMethodCategory);\n    }\n  }\n\n  public void detectRenameClass(\n      double tClass,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidateClasses = se.findSimilarClasses();\n    RefactoringDetection detector = new RenameClassDetection(originalGraph, versionGraph);\n    detector.setThreshold(tClass);\n    List<Node[]> renamedClasses = detector.detectRefactorings(candidateClasses);\n    if (renamedClasses.size() > 0) {\n      RefactoringCategory renameClassCategory = new RefactoringCategory();\n      renameClassCategory.setName("RenamedClasses");\n      renameClassCategory.setRefactoringPairs(renamedClasses);\n      this.refactoringCategories.add(renameClassCategory);\n    }\n  }\n\n  public void detectMoveMethod(\n      double tMoveMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> methodCandidates = se.findSimilarMethods();\n    se.findSimilarClasses();\n    RefactoringDetection detector = new MoveMethodDetection(this, originalGraph, versionGraph);\n    detector.setThreshold(tMoveMethod);\n    List<Node[]> movedMethods = detector.detectRefactorings(methodCandidates);\n    if (movedMethods.size() > 0) {\n      RefactoringCategory moveMethodCategory = new RefactoringCategory();\n      moveMethodCategory.setName("MovedMethods");\n      moveMethodCategory.setRefactoringPairs(movedMethods);\n      this.refactoringCategories.add(moveMethodCategory);\n    }\n  }\n\n  public void detectPullUpMethod(\n      double tPullUpMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePullUpMethods = se.findPullUpMethodCandidates();\n    RefactoringDetection detector = new PullUpMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPullUpMethod);\n    List<Node[]> pullUpMethodResults = detector.detectRefactorings(candidatePullUpMethods);\n    if (pullUpMethodResults.size() > 0) {\n      RefactoringCategory pullUpCategory = new RefactoringCategory();\n      pullUpCategory.setName("PulledUpMethods");\n      pullUpCategory.setRefactoringPairs(pullUpMethodResults);\n      this.refactoringCategories.add(pullUpCategory);\n    }\n  }\n\n  public void detectPushDownMethod(\n      double tPushDownMethod,\n      ShinglesUtil se,\n      NamedDirectedMultigraph originalGraph,\n      NamedDirectedMultigraph versionGraph) {\n    List<Node[]> candidatePushDownMethods = se.findPushDownMethodCandidates();\n    RefactoringDetection detector = new PushDownMethodDetection(originalGraph, versionGraph);\n    detector.setThreshold(tPushDownMethod);\n    List<Node[]> pushDownMethodResults = detector.detectRefactorings(candidatePushDownMethods);\n    if (pushDownMethodResults.size() > 0) {\n      RefactoringCategory pushDownCategory = new RefactoringCategory();\n      pushDownCategory.setName("PushedDownMethods");\n      pushDownCategory.setRefactoringPairs(pushDownMethodResults);\n      this.refactoringCategories.add(pushDownCategory);\n    }\n  }\n}\n',
      "5c2d1cf016b3885f6930543d57b744ea8c220a1a":
        'PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m±>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MFóMÌËLK-.Ñ\rK-*ÎÌÏ³R0Ô3àåòÌ-ÈIÍMÍ+I,\u0001\nê\u0086d\u0096ä¤Z)¸\u0017%¦ä¤*\u0084\u0017%\u0016\u0014¤\u0016ñrñr\u0001\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/gradle/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000org/gradle/wrapper/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ªÙfØ\u0003\u0005\u0000\u0000ê\t\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.class\u008dV[W\u0013W\u0014þ\u008e\u0099d`\u001c\u0005c@\u0083\u008a\u00837\u0012.\u0089µÖV°´J½ \u0001-\u0001lDÛ\u000eÉ!\u008cNfÒÉÄKï\u0017{ý\u0007¾ö¥O]«}\t´®ÚÕ×þ\u008bþ\u008b>i÷\u0099É@\u0012\u0082«,Ö\u00993ûìÛ÷í}öäïg¿?\u0005p\n?(\u0088â\u0082\u0082\u0001LÊxKÆE\u0005½¸¤à2®(\u0098ÂU±L+\b!£`\u0006³b¹Ö\u0081ëBòv\u0007ædde\u008c(èÂ¼\u008c\u0005\u0005g±(ãÆNÄð\u008e\u008c\\\u0007n\nwKb¹%\u0096Û\u001dxWÁ{x_\u0086Þ\u0081e±Í+8\u0084\u0082\fÎ\u00109gX\u0086;Á\u0010J$\u0017\u0019¤I»@Ò®\u008cañÙji\u0099;óú²I\u0092hÆÎëæ¢î\u0018â½.\u0094ÜU£Â\u0090ÌØN1]tô\u0082ÉÓ÷\u001d½\\æNú\u0082m»\u0015\u0097^ftÃÊººãrg\u009c!\\\u0011[\u0086c\u0089¥Ì\u001dý\u009e\u009e6u«\u0098Îº\u008ea\u0015Ç}\u0089a§/\u0019&\u001f÷òÑ\u009d"EØÛF\u0099AñC^±K\u0094Ëîfc\u0086NÿôªîPöyÛrù\u0003wÒÔ+\u0095\u008c\u00ad\u00178\tã¾\u0085ÅÝôÂ\\¦áH\u0018\u0097(kOÄ°§!¶\'\u0012¡Åù\fwWí\u0002C_\u0083\u0082ÃWL\u009ewÓþ\u0019iö6\u0013÷°\u001c\u0090\u0017ku{nh\u0082ôw\u0011Wù»3zÙS\u0093±BÁ.>Èó²kØVEF\u0091ª³bX\u0085\u008c^µò«Üñðõ\'Z¨k%CZ1\u0084³Ur\u0096µ«N\u009e\u000b9QÐ®J)a«â\b\u008eª8\u0087×\u0019ömÃ\u0013\u0083Úx¢ÂÀ\u001d\u0019wU\u0098(É°TØ(«ø@,GàÈ¨¨pQUq\u000f÷)eê\u0099\u0094_¢\u0094YÇ\u0092ºì½\u008b\\T<ÀCÊ[ðL\u0088[¨Rñ!>bèÞ\u0014_[¾C´«ø\u0018\u009fPÅ\u0002ô\u0093¦]á\u0082G\u0015\u009fâh\u0090o\u009d\u0016êyÓX\u0016¹}¦âs|¡âK|Ehý¤F\u0083¤FSC·\u0088\u0012Êÿ\u0091\u008a¯ñ\rÕ{3ì\\Õr\u008d\u0012ß(\u0010ÃÅI»j\u00164Ëv5\u0093*ïrÍ]å\u009a\u000fL\u000b|jWÏÏi\u0086\u0015\u0088\u000b\u0006ÕÀX®\n\u000fÚàñÊ`JÅ·øN¤ö=Ãàÿ¼]\fû·ëCºA\u009bG\rÉv-µ6JØµ\u0017æ¦\u0088ÚD²ñzL\u008d7\u0017{ª®\u0099Ù¢\u0099!Í\u009e\u0096r\u0005í\u0012+r7û°âòRóE\f<´Zx·\u0098»×u\u0087[43\u0092ÁÌ\b"mc%\u0006GCkÌ¯:\\\'\nvå«\u008ep\u0014¼Ç\u009aÂúR\u0091|\u0085»\u0093mÆE_â\u0005á:MÚ×çÅñÄÖaµ\u0005`\u001dZP\u009e7ÛØ,m±I¾hÐD\fë\u009e}\u0097ºúl£/ÿ^4ùª\u008b\u0092[ETÔ¼¸1\fG[\u0006J\u001bD\u001ejj\\q.¦d"¹¥\u0099dB8«\u008béÜÌõÆ\u0004ïn\u0095\u0091MIwé\u008a\u0090Ç\u009ev<Þ$ +¶CJ-@Û\u0090Ö\u0006èFä¶Î\u0017é\u0093<@ßfñ\u0017\u0002\u0013#\u0090Öcô\u0096¦\'£gxh\rìWÚìÀqZ#\u009ep?NÐªú\n\u0018D\u0082\u009eÔ\u00ad\u0018"-2f\u0003¤\'\u0093\u008c\u000f\u008d¬aÇì\u0013\u0084rÒ\u001f\u0090r¡Ñ\u001aÂ5D²ë\u0090kèXCç\u0098´\u000e%.Õ°3.EÕ\u001av\u008d\u0085ãáènÒîÊ\u0085¢ÝÙ\u001aö\u008cEâ\u0011F\u0082h.4Lï{oÄ¥¿\u0010{,Ì~C\u000f\u0083HNò\u0092;\u0081NZû(ø\u0001Âq\u0010ÃôÑ?\u008d~\\Âa,@ÃmÂZ \u0013\u0091ü\u0015?Ázòb7\u008c\u0011\u000f\u0010Ç(R\u0004$B¿\u001bÒ´\u000b\u0091Å\u0005\u009cÄK\u0014å4\u00ad§ð2\u0081\u0016>Oã\u0015Ò:S§Â?{\u0095Î^#I?Øs\n&Ë\u0018\u0090Ñ-£×û\u000fÉè\u0092é÷\u000b0æeÍ0N\u0091è\u009bSgýgÊ*BÏé\'èÍ\rG÷\u00ada\u007f\rñ\u0099\u0091§\u0013¡3R\u008ftèG\u001c\u001eé\u0091N\t\u0092jè\u008b\u001e¨áàcDâá_\u001eIì§çÿ<Á¡\\´?àj\u001d\u0087× ýé\u0095VÐÓK©\t\u00924\u0002=J°OÒþ\fÁ\u0016th¤£¡\u001b\u0013\u0004XhMo\u00103íÑÁ<P»\u0011z\u0086\u0098\u008c7\u0018;ð/éÑ5ö:ãü\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQþ}¢\u0000\u0000\u0000Ò\u0000\u0000\u0000#\u0000\u0000\u0000org/gradle/wrapper/Download$1.class}\u008cM\nÂ0\u0010\u0085ßh5µ*v/\u0082\u000b×\u0006½\u0082?àB\\x\u0082Ø\u0086Ø\u0012\u0092\u0092T{7\u0017\u001eÀC\u0089)âÖ\u0019æ\r\u000f¾÷^ïÇ\u0013À\u001aC\u0006Æ0 $g{s\u0099Ü\u0017Z\u0012Æ[Û\u0018mE¾,Å]\u0010&;\u0093ië\u000b£\u008e²¾Ú\u009c!!Ì¬S\\9\u0091kÉ\u001b\'ªJ:þË-V\u0084ÑÁ\u0018é6Zx/=!m«¸\u0016FñÓ¥\u0094YM\u0098þiHç tð\u009dnX\u0004\u0017¡\u0017~\u0084~Ð8\\\u0012\u0018j\u00814þ\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Çåî©\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.class\u0095S]O\u0013A\u0014=³-l]¶XWmEäC@Ü¢v\u008b_ÑÔ\u0098\u0090\u001a\u0012\u0093jHP\u0012ÃÓÐNÚ5ËN3\u009dZú\u008fLÐD_\u0084hâ\u000fðG\u0019ï\u0094\u0082\r4E÷agæÞsÎ=wnæ×ïï?\u0001ÜÇc\u0007\u0013\u0098uàbÖÆ\\\nó\u000enb!\u0085Å\u0014\u0096Ìö\u0096\u0083eÜv\u0090\u0080ocÅÆ\u001d\u0086ñga\u001cêç\f\t?¿Å\u0090,Ë\u009a`¸X\tcñº½»#Ô\u001b¾\u0013QÄ«È*\u008f¶¸\nÍ¹\u001fLêFØ¢Ü\u0086\u0092{Ýµ¶n\u0088X\u0087U®¥bp_Æ±På\u0088·Z\u00820Å\u008aTõ ®x-\u0012AGñfS¨à\u0085ìÄ\u0091äµ¥³\u0002%\u0086©ºÐ\u001bDïHU\u001bÈ\u00852fXôó\u0095÷ü\u0003\u000fb¡\u0083á \u0092\u008d»\f\u000bþÈÂ«%ÓµµWd\u0098;\u0007ÈàlÊ¶ª\u008aõÐô\u009e>N\u0015\u008c\u000f\u0017iL\u0092Æ9\u009e\u0018&\u001bZ7\u000bMÓïÛ\u0096P6î¹(  Kü\u009b8æ2À$\u008b6V]\u009aî\u0003Sä¡\u008dG\f\u0085ÿ»L\u0086ì\u0089±S\u0089\u0099\u0091M3dzÄ\u0088Çõ`³ÛÒb\u0097aÂÌEIBê.Ã²_\u0019\u0080h\u0015ÆõRþl\u0088áÉ\u0010à?R3§cdBËr\u0083«5¥8\u0099Húùí2CnH\u0089í²\u0099ðô\u008861O¯Æ\u0085ù\u0012°Ì A/\u0080N\u0001\u00ad4\u0003\u008c\u00ad\u001cÀúJ\u001b\u000b\u0019ú\u008f÷\u0082\u001fq\tf>=\u0000<\\¥5\u0089,r}ò+\u008a\u009a\\î\u0007\u0012ï¼ä!Æ¼qÏ>Dê\u001b.\u001cÀùr"ç\u0011\rØ\'ÙOtþL\u0012û\u0003Ò¹#i\u0002¦1Õ\u0097~J«Õ÷Å\u0086ûÊ\u001e\u0001ú¾Ìî:¦{´\u001b=ü\f®ôJ[Ôz\u001e\u0097áà\u009a\u0081eR\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005¶<\u009bÀ\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000org/gradle/wrapper/Download.class\u009dY\t|\\ÇYÿ\u007fÒî¾§ÕÓáõ¹¾²NìXÖi;\u008e\u001dË\u0089\u0013K¾dË\u0092¬\u0095äÊvâ<IOÒÚ«]åí[ÛJJCJ\r¥%\u0084£4ÍÑ¤@Û@)à´õÊ\u008dÚ&\u0004ê@\u0081rS å(PÎPî\u0016hZ÷?³\u0087v¥\u00adHë_4oæ\u009boæ»ÿ3³ùÜ·^ú\f\u0080\u009dòÖ Öã×\u0082èÁg«Ø»¡\u009a×Tóëªù\r5û9\u0013¿\u0019Äoá·\r|>\u0088 ~\'\u0088ßÅï\u0005ñ\f~_5\u007f xþP5\u007f\u0014Ä\u000eü±\u0081/\u0018ø\u0093 \u0096ãO\u0083\báÏ\u0082x\u001e_TÓ_RÍ\u009f\u009bø\u008b Þ\u008f¿TÍ_\u0019ø²úþu\u0010Ïáo\u0082ø[|E5\u007fWEi\u007foâ\u001f\u0082øGü\u0093\u0081\u007f6ñz\u0010\u009bñ/~¨\u007fõ\u0080\u0089¯\u0006ñ¯ø·jü;þ#\u0088gñ\u009f&þKQþ[íô5Eù\u009a\u0081¯+}þG5ÿ«\u009aÿSÍ7Tó\u0086j¾©\u009ao)\u009dn\u009aB³úEL©0¥Ò\u0010_\u0010ûñYSüüJ\u0080,b¨\u009eI7IU\u0010]\u00124¥:\u0088kb\u0099RcH\u00ad"Õ\u0099RoÊ2\u0003O\u0018\u0012\nÊrYaÊJµë*CV\u001b²Æ\u0094°)k\rYgÊú \u0086d\u0083)\u001bM¹Eí\u001b¡&²É\u0094[M¹Í\u0094Í¦l1åvS¶\u009aÒ 6ØfH£!M\u0002«+\u0091pÜÎ¸\u009dJ9)A¨ÏM^\u009e9\u0090ö&\u009d\u0084\u0017\u001bµ½¤+¨\u001bì9ÞÓ{ªçÜÐ¡þhWo\u000fÙºÏÛ\u0017í¶¸\u009d\u0098h\u008bzn,1±OPÓ\u0099L¤<;á\rÙñ´cJ³ ¶¯¿÷Hÿ¡hô\\çQn"\u0090®JåkAuÇàáÃ\u0087úÏE»N\u001fª\u0004\u001aH\nÄ\u0093\u0013\u0013\u000eå\u00adëNº\u0013m\u0013®=\u0016wÚ.¹öô´ã¶uëI\u008a18î±§\u001cú\u0097½!ÇMÅ\u0092\tAý´\u009b\u009cp\u009dTª;\u0096ò\u009c\u0084Ú§¥Ü>\u0007\u0093\u0097\u0012ñ¤=Ö·\u0080\u009d;\u0007î\u008e%bÞ~AGÃ\u0012\u001a,6}1eÛ\u0090À×\u0099\u001c£\u0092uÝ±\u0084Ó\u0093\u009e\u001aqÜ\u0001{$î(ç%Gíø\u0090íÆÔ8Gôy\u00931ú\u007fÃR*SÅä\u0092\u009a}7æ¾Y3Ö\u008f&\u0013ã±\u0089´ë,L\ríöÊ\u0006ÅT\u0013õìÑ\u000b\'ìé\u009c5æXN¬à\u0096\u0086ì¾\tÇk\u001bìïÊI\u0089%Û\u000eÇâ\u008e\u0096`ØccJ5¦K)+³dÌIy±DNVméZ&À¡Ë£Î´\u009aäâú¼Ì®\u0084ç¸\t;NåÒn|Á®Ý\\V\u009bN9î\u0081\t\'\u0097©\füHz|\\eLÅ\u0099\u000eê\u0093HOõ;J÷\u001aÚNoyÝNbÂ\u009bd,ó9Ö\u0099L+!Ìçcä"\u007fÞÍ\u000eWù¸\u008aÚ®)\u0011ËÚH8£JU*P\u0099L{\u0082U\u0005szÓÞtÚ£Ó\u001d{\u008aÓ\u00151._Y\u0098íJÌO\u001aÒbH«!m\u0086l7d\u0087!;©oÊ\u001ew\u0006Ý\u0098`ã\u0002_o[èO:$fÈ\u001d\u0094M\u009fwØ©ØèÂxn+\u001b®ÅF¨À\u0005G\u000bc\u0086\\9µ+1\u009e$¦\u008cØ)g÷®C\u0089Q]\u0001·7\u0094É¬r\u0000R?áxÙEî\tÇ\u009bLÒ\u0097k\u008bø\\g<NimÙ9ò[\u008efÎó\u001aÙ¡[\nO½#ç¹HE]Ñîìu\u000fÙn<¦¸V\u0016q\u0015\u0012)Ï¸§\u00881 #ËÎê¢\u0015\u001a2»õ\u0004£²K°\u008cE=\u009a\u008eÛ\u009e3XðÄ\u00adå\u0003Rj¶ö\\B#\u009a9ÍM/%]Z\u0013*ÙNg«`ECÙ\u001d\u0082\u008a6ä$Æ\u0014ZWg\u00079X\\6?U \u0005\u0092©,\u0080V%SÅÄ\u0003î(\u0093<\u0018M¦ÝQG\u0095\u0018s;\u009fØ\u00adj\u001f\u000b\u0097ñ¨j\u001e³à"eÁÃy\u000biÕ\\Ä%\u000bß\u008fÇè¾IÏ\u009bn\u009dV`¡47äNKvã#\u0082Ö%àióâs\u0087rd\u008f!wY²WÚ-Ù\'w[r\u008fì·ð.¼ÃÂOãg,¹Wî#@åë¤C\u0017±3V\\M,ÃbÌ(\u009eRû\u001fPM\u0087%\u009drÐÂ\u0087ða\u000b/a\u008e.P\u008a·h\u009f[rH\u000e[rD\u008eò\\ZÂ\u0000Kºä\u0098%Ç¥Û\u0090\u0013\u0096ôH¯%}JÛ\'å$c\u0012Spá¦§=gÌ\u0090~K¢2 X^¨ðÞBþ\tÂù-#\u0097ìT¤ha«R\u0096ËTý\u000fZ2$§\fy\u008b%ÃrÚ\u00923rV\u0000Kî\u0097\u0001K\u001ePa°\u008a\u0013Ï\u0092s\u0098³äAÕØJÏ\u0011Õ\u001bUÍ\u0018\u001bîëXÈ`VàWÑKY2.\u0013\u0082+§\u000eô÷tõ\u001c\u0089\f¦\u0098h\u0091£\u0003\u0003}\u0011\u008d\u001a\u0091RØ\u0088$/:nÄNPÛ\u00943Ê£"2\u008f\f\u0011/\u0019É#s\u0084\u008b"G´\u0003#c<\u0088ÜØHZñ´Fúâ\u000e1C-KÅXQ\u0091tA`´\u0095Y¨Ä%ÝØÃ9\u0090Z½°\u0006:Ò±¸®Ð@V=å\u009dI\u000b?\u008f\u008fX\u0012SV\u009e\u0097\u000b\u0096Ä\u0085ùP¯Ö¶Rl¼µCÃ\u0094%\ta©\u0006çÁ\u0087@¿ Î-\u0099\u0096\u0087r¹T¼vsaEm\u0016|\u0006\u0092Y\u0085rr\u008a!È\u0010×\u0092\u0094°\u008aý\u0083\u0003\u0087[\u0098×i¹XÂ\u0097_º¼\f.\t"\u008az¹õòT¼u$\u0096\u0018k=h{¶73í\u0010\u0094é}}\u001a-\u009bæ\u0006^Vµ\u000e\u001e\u009bî\f\u0011t~³~\u001eZ±)§hÏûó¹¦¼]&0©È¥\u00987¹Dàc©H"éERééé$u\u0018\u008b\u00906Cü\u0088\u001c\u001b:¡óõ\u0012\u0091,[2\u00ad¹\u0092QµÅ\u0003¨\u0094Ø\u0097Ã=\u0015¸Ë\u0096Ì¨*Ô@Öz1\u0007kVn\u0094\u0083«ºìpj\u009eb$S\u00adY\u0014\r²WB¶5°\u00adÛ\u0092jÛ\u0092\u008a4lIíÓÿm+êZò°<B,)Sá]\u0007\u000bw\u0099\rK!Ø\u000eVæö|Ýåð\u0086\u0088]î\u008c§ùå\u008fÕbLH\u0014±\u0017\u0017swI\u0082\fLºÉKÙK×ºâ\u008a\u008fÎ$<ûrQ¨W\u0096=ºJóo\u0086wCJ«f)\u0010\u008fi\u009d7£Ï°%ÍÖW\u0081y{\u0016¼\u001d\u0082)Ç;è\u008cÛé8\u0013\u007f]ÑqXÂ§÷¨Qbm\u0097Ä¬ëêó\u0087Ýü\u0085/0ua,æ¦ôµó4\u000bÉKj\u007f\u00148çïxË\u001a\u0016_4Ã\råo\\j®\u0096æ&\u008a\u0003±vÁ\u009e%\u0017¸\u0010\u00adêw\u001eJóv:ï¨\u00adeî9åïÔµ´´$¾«\u008bL-¾îeïD\u009d¥·PÚÞÅ[¦«¯¨þ\u00863\u001djX_\u0092\u0012¹ÛkÚUÞÌ\u008fK/\u000fYªz¶ÅR]ó\u0087LñÅ³O¡IA\u0093åeÈ\u0094¯!\u0087«Ê]ò\u0094Ï¿ãs\u0085ÑTÃ\u0004En/^Ü9i»QåÛÄ¨Sra: ¹U®S\u009b¦ïâ\u00adCíò\'\u0010ß)^:E\u0011\u0089\teëò\u0005÷³cÇ\u0094ÎþKnÌc\u0002\u001aômW\u0097¢TòiJúh<\u0099R×&Æ$::é(¬1Ø?\u009aLyÙ^\u001fA0×³U¨LöN¦\u001d\u0085Ãª¨\u000e»öÄ\u0094¾ÈM¿©\\YLéúÞ\u0096)\u001b\u0002ô©\u001dO-\bUîz¬ª©åMÝÓsG\u00adº·z\u0085ÃNÙ©QE¹tÛÂ[ò¾lÆ\u0097ÀNx1[î2MÿªHå¶Ûòÿ(\u0095\u0017 b\u0092\u007f\bÜWfÍ\u0099Ek\u008awYô´Xó\u009dæèÇXâbò\u0002C¿·\u008c\u001fÏ\u0094qm¹Ç\u0088rXÇ\u008c§~rYUÎBõ\u000em\\:G\nÈ\u009f}¦7t.\u0015+\u0095}óÏ\u0092ÀxÒ\u009d²½\u0005&\u0094ñT\u0019\u0013r\\Ø\u0084õè\u0081À\u0081\u00810b8Ïþ\u0005\u0000\u0015\u0088c-¦\u0090(\u008c\u0093\u001cO\u0017\u008d\u001fBH½\u001eØ\u000f©\u0007\u0084þ¦s_>#ø\r\u0092÷2fØ>ÌÑ üðñ[ÕØ$Í-³\u0090\u0017õ6\u008fhÆ\n¶\u009b`âV¼\u0095½Æ,#¾\u000foÓ?ëUiA¢{JT\u0085î)a\u0095ZÄ£9\u0011ïä\u008cú!pcã,*\u001a\u009b®¡²±å\u001a|\u008daß5ø\u001b\u009b¯!À\tc^îF\u001a\rl¦´-ÜïvÔb+V \u0081\u008eØ\u0086\rÔBé²+»cA\u0097\u008d\u0005]6j3+tÏÓº¨\u009eÒÊG*\u001fQ9\u00adzµ\u0096À\u008a\u0090y\u001dU7P;\u0087à°Ì¢ú:,¥K¥Ö¥V¯o¡\u000fZ±\u001cÛµl+».\'ûí\u009aW\u0096\u0093ø\u0003x\u0007Ed½Z©\u0017Ö5gP\u0093Aí©Æ¦æYÔÍÛ\u0098Ý÷\u000eî»\u008bý;õ¾\u0091ì\u0092\u0082Mu¸\u0082\u001fÔ²êðCÚ\u008b?Ì¾\u008f\u0094(ûïÊ\u000b«Ü\u0084\u0080þÙ¯\u0086\u000f£v\u007fÓuÔg°¬=0\u0087Ðð\u001c\u0096\u000fSð\u008aY¬ì\t\u00072XÕîkl\nûf±\u009a._Ón\u0084}¡pØÈ`mØ\u0097Áºvÿ²\u0006|Êl7ÕhÃî`Õ\u009eêª=5a\u007fØÌ`ãðîª\u008aç1u\u001d·d\u0010y\n+?\u0086M¡[3¸m\u000e\u009b\u0087C[fqûË«jVV]±÷Ô¬ªÖßêUÕ+°uªê=Ï¡©ñ\u0013¨\fmË ñ\u0094&:{ªI\tÜ@H}\u009aV\u0006¯¬ªù$\u009a\u0002h\t\u009b\u0095+«2h~áæ»õ\u009a\u0096\fZÃþ\u001b0Ãþ\fÚZn \u0091\u0094í/à¶öºòó\u0086\u009a\u000f×½ü¢NºÏãuºìu|U\u007f³!}/Ó\nØËù}ä¸\u0087îßÏ\u0004¹\u0097ÔûÐ\u008c\u0003Ø\u0089\u000eÎt²=\u0088.\u001cF\u001f\u008eÐáG1ÄÑ\u0018\u008e±ú\u008e3\u009dº\u0099Þ=\fK/\u009e ÇÓ8\u0089\u000f¢\u001f\u001f%çÇ1\u0080Wq\u008a²Oã\u000b8\u0083/á,¾\u008c\u0007ð\u0015\u009c£\u0016§ñuÒÞÀY\u0011< ~\u009c\u0093*ØbaD§À\u008fR\u009bZ¼\u0082wãG\u0018Ô\u009dx\u0016\u008f3q\rJ¾Â¹\'\u0098.\u000f²Ö\u007f\u008c\u007fU\u0094ú6ü8{AÊ|\u0004?\u0081\u009fD5u¼\u008c÷°WCk^ÃOÑV\u009fJ\u008c|J±\u0097K)ö²)U!Õx\u0012ïC¥¨´Î®ð\u008b\u0089§h\u0093_\'÷«¨ºÉ\u008dk\f¬7°ÃÀ3\u0006\u009e5ð~\u0003Ï\u0019xÞ@¿\u0081\u0013\u0010\u001fåÜd\u008d.Å%\u009aë\u001bè¸IM\u0003\u008b\u0019\tQ7iMÉ\f\u0014]\f|à&\u000b®~ÑLþ\u001f\u0019ØÜ¤=e÷-*\u001cSý¸\u0091«Òãô¢*¯MsØ1Ü\u0098ÁNas\u0007ÿvñïNþíæß\u009eYÜuµP·\u0001½àB\u0011\u000elÂÏÒ¥ó">HÎ\u000fáÃ9\u0011¿\u0098\u0083×ý\u008dM³ØÛÓò\u001a|/\u0086Ú\u009b(+\u0083}OÃÒI|7\u0093¸9tÏ\u001cö\u000fÏâÞÐ}\u0019\u001ch$\u0014wð\u009bA\'«s\u001e\u008f²Ø\u0098¤\u001eÓtÕCtd\n«\u0089s\u0011¢Þ=Ä½y\u009cÞ_À\u0091ý\u0005\u001cÙ\u008f\u0017\u0018`:\twáç46¾]cvÅ\u001b¨f\u008cV\u0014\u008cØL&¾ï³P)q\n\rpæqºã`\u0006\u0087N4\u0087\u000egp$t´òÓèÊàXOsè¸\u001awû8\u001e®\f\u009d\u0088\u0092Øîk\u0011Î÷dÐÛî\u000fûÂ~Nö\fW6\u0085ú28I\u0086ÞWÐ\u007f\u0095+\u0007ÔÊÁÒ\u0095a\u009f\u0094ãn÷Íah8tJ\u0001Ø[^¦\u008a&\u008bà$\u0083ÚOK\u001få7ë£Fz\u0006´Ùd\u008a¯a\u0092·Ò¬½ÄË\u0093,«~\u0016Ô$KéQ\u0016Óc,$å¯³ôÀ\u001arü\u0002Ë·\u0092Ü·1j\u001f¥\u001bö\u0092úKøeFp\u0092>ÎÒ\u001ecÔ¯âEöú\t\u0012\u001fcOaöã\u0005_?®ýÊ+\bå\u007f\u001c\u009f \u008eÊÃM¨¸Iñ\u0095:7Y\n×TJGoò\\ñ\u0015H$h*\u0097d0\u009b;¤\u009eæH\u0005sGh\u0098\u0087Ô\u0089Ði¶=Í7p\u000b\u0091n]._xÄ\u001c¨oÏàLK6_®2»Î^-dÌ*}R¾\u0097\u0001|\u0092º¿\u008feô\u0014aî\u0099¢LÙQÐ~\u0087Îe^a¨ñu}¢[\u0004\u0092O\u00162¥\u001aòM4k}û9ù\u0012ærz~\u0091BTbÞ\u001fº\u009f\u001av\u0087\u001eÐÚ\u009eSÚ\u0086\u001edÛî\u000bÙêã\u000f\u008d¨O 4Zoê\u00003ÿ}Ña\u001f?þè0Ó$:\u001c\b³g\u0084\u0003Ña³):\\\u001fhfc´D¯cl¾\n³Uð<õü\u0000Ô¯\u0095!\u0096t\u0098ºGX}[Y}Ê¶£Y\u0085r¶\u0005\bÈ\u009fÒ\u0091±\u0018\u0088OkÛB\u0004\u0080ÏhÛÂ\u0084ú\u0097õ\r!Â*z\u0085=?÷Ù\u008d_a/@ÎWµä_Å\u0084¾FU`\\ÿ_M\u0013êÿEN"ømPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L¢¡\u0000\u0000\u0000Ê\u0000\u0000\u00001\u0000\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classu\u008dÁ\n\u0082@\u0014Eï+Ój\u0015DËöEÐ@Û\u0096E\u0090\bERûI\u001f¦\u0088#3cþ[\u008b> \u008f\u008a4Úv\u0017\u0087»9\u009c×ûñ\u0004°ÂÀ\u0083ç¡O\u0098Äª.r%ãÐJ[\u0099ÍM\u0016\tÇ\u0084ñ,Èä]\u008a\u0082\u00ad8\u009fökß\u009f_\bÃPU:â]\u009a3aºý©G\u00ad\u0012ÍÆ\u0004©±\\°^¶&a¡t"\u0012-ã\u009cE\u00adeY²\u0016ÿ\u0014Âè\u009bË\u009b¼8\\3\u008e¬K tÐ\u008e\u001cB\u0017NûÐkØ\u0081û\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b¶\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.class\u0095WÛs\u001bW\u0019ÿ\u001dYÒÚ«u|iªVÍMNZ*;±\u0095\u0006J\u008alB\u001c×NåK\u009cÆ\u008e[\u0097\u0090t-\u009dØ\u001b¯vÅj\u0015ÇÜS\u009aB[(·¶ÐP`x¡\u000f\f3íL«$x\u0086ô©Ì0Ã\u001b\f\u007f\u0001\u008f}á\u0085\u0019\u00180¿³+9¾%L=öÙs¾óÝ¿ß÷íúOÿýý\u001f\u0000\u001cÁ¯t<\u008agZ ãYµÌjxNG\u0014_ÔpNG\u001cÏ¨Ã\u0097Ôî¼\u0086\u000bÍx^mME\u009cSKA-EµH\r\u0017\u009b1¯¶\u000b::`éÔvIÃb3l\u001dIÅ\u009eDIG\u001e\u008eºqu\u0094ñåfxJ_¥\u0019~\u0002O¡ªc\u0014\u0097u,áJ\fê§íÄñ\u0004\u0096ñ\u0015\r_Õð5\u0081öñÉ¡±\u000b#ùñá\u000bSgGFòÏ\nt\u008e_2/\u009bYÛtæ³S¾g9óý\u0002\u00adC®SñMÇ\u009f1íª\u0014hñ\u00ad\u0092t«þDE@ä\u0005v\u0094]ÛÎ;¾ô.\u009b¶"Æ\u0007,Çò\u008f\tÄ2ù|÷\u008c@tÈ-R°mÜrä©jiNzÓæ\u009c-\u0095=·`Ú3¦g©s\u009d\u0018õ\u0017,jÉ\u008e»Þ|vÞ3\u008b¶Ì.yf¹,½ìð\u0095\u0082]\u00adX\u0097å\u0088eËÁBAV*\u0013¦cÎK\u008f\u008eÆÍ\u0080 0\u0098\tã°Ü¬âë\u000fOUß²³\u0005×)T=O:~vÈ´me±¿{]Ô\u0093s\u0097dÁWÊä\u0095²å-3ÄQºd»\u0085E\u0081Ý!£C½\u0085\u0005Óq¤]\t\f0\u008aE\u0095(¹Þ;&f£\u0017*2³B5ûþ\u008f?\u0002ÍÊ^¨¤£±}Òòè\u0099«\\j÷L§è\u0096ÂøC¶\u0087Öl\u009dÙtGuZÝÛ5Ó["\u0018\n\u000fäMn,Ér¹Q\u0096\u0087ïíõÀôtÿ1\u0095\u0084)ß,,N\u0098å@LÃ×5|CÃ75|K@gùdÙ·\u0088\'ÂhÊ\u009awL¿êQ÷ÄÀtnk\u0011\u008e}¢2\u0086\u000ets¥\u0013óÒ\u009f&J\',ÛVXjÊt³\u008a\u001d%syN\u000eÙnE>]µ¤o3\u0095É;6\u0082\u008b\u0010\u0010ÄlK¡q\u0014¸o\u001b\u001eF3åV½B½Öûî\u008eÌ>%l \u000fW\r\u001cÄ!\u0003½8$`¬\u000fÍÀ\u000bø¶À\u0003\u009b»ïDÕ²\u008bÒ3ð"®\u0019x\tß\u0011èýD]AÌõÙ\u0085E\u0003ßU\núð²\u0081Wðª\u0081ï©åûx\u0095À¹cóLÕQ\u00ad½V$\u0081ÃCnÕ.¦\u001d×O\u0017<iú2]6UÒÓÅ\u0006\u0018Ó\u0017]/\u00ad \u009a¾HÛi\u0003¯\u0085\u0086~``\u0012§\u0005\u001e¼\u001b,\u0005"Þ\u0092\u0081\u001fâG\u0006~\u008c\u009f\u0018x\u001ag4¼nà\r¼)\u0090\u0098\u000egLÚ½\u0098V\u0081ÿ\u0094ó M\u000f\n\u000b²\u0098^2-\u009fÉ\tL¯µ\\:lþ´ï\u0006\u009eä(ö3¼eà:®jø¹\u0081·qZÃ/\fü\u0012WYÐ;A¯\u008b¶}3\u0002\u0005öÜ\u0013r\u008dû»µS#»Û\u000e\u008c\r^L/xîR¨\u0092X\u009d\t\u0011|:Èu\u0098¬öL÷æi¢\u0091å\u0094YâåÎL÷v\u0083;®Ðá\u0014\u0089\u0099ÌÖë\u00ad\u0012u°©ñã»!IàÀ¶=¸A\u0011½\u008d\u0097\u0016\u0089\u0088°Ñ\u009e\u000bf§UñyLX\u0095uc«\u008d\u000e\u000fÎU\\»êËÓ¦¿ pÿv\u008eQ\u009fNÎµ\u001cv5¢»ÇÔÒ|o9LêÞ»r×§tû\u0086¬K\u0093ù\u0089Ul)Ëì\u0095Ì¨²¾;\u0093¿Wv¢\u009c\u008föæ¤¯½74OÚÒ¬È\r\u0086¦\u0096+¾,1±\u008eé¸\nÚ\u001cF[F\ný\bf\u000eº >#\u0080&¤\u0090A7\u0004zx\u008a \u0081N5@¸ïT3\u0084Ï(ïú\u0090åz\u0098§Yò4©\u0017}Ï\r\u0088\u009e]\u001f Ò³û\u00034½\u0017\b?\u0016\u0088E¹vqÝ\u008f\u0016\u001cÀ\u000e<Ì\u008f\u0016 \u001d\u008aáÓøLø¥\u0010\u0098\u0011ÁN\u0019\u008apÿ8>K.\u009a\u0089ü\u00191´\u0002â\u0089\u0015Dg\u000fÖ\u0010[A|ö\u00064n\u009bkhéLp©Á¸\u0081ÖS½¼ÍESÑ\u001av\\ÇcêÙö\u0016\u0012êÙ~\u001d]+è\u0098\u00adËvvR\u0088Ü÷5dwÞ\u0016¹\u0098ÈÅ\u0019Êý=ï#rÍ<ª\u0089\\Kªå\u008f\u0018T´¤öúÛ8º\u0082äloç\u00037ð`.\u0096\u008aÕ\u0090ÊÅSñ\u001a\u001e\n\u0018Wÿ\u009a\u008aßÄ®T\u008c\u000bU4]»\u0089Ýï¬~¨Tô®7½\u00876\u0095\u0089\u001aövîãþà\u00067\u000eÝBZ §§Hè\n\u0014Ò«@\'\u001d¼c ¥¿\u009bKlÏ\u0093¸\u009d3Ö1\u001a·\u0099ÿ¿ãcÑÆ\u001c¶\u0089\u000eõDQDDwp>¨\u009eäPõz\u0013\u008fp}\u0094ÕÊ\u0004@8B \u001cgmÎ³*&\u000b_$W\u0099Ô\nëö\u0002+ô\u001akô\u0006\u008erÖ}\u000e¿F\u000e¿A?~\u008b\u0001Ô(µ\u0082AZ\u001dÆÇ8\u0089\u007fðÃñ\u009fü:ü\u0017Æ°\u008aq\u0011Á¤Ð8\u00ad\r\fÓ\u009b\u0093"\u0089¼Ø\u0085Q±\u0017câ\u0000ï?\u0085\tz5)\u000e\u0093çq\u000ej\u0085\u0099sDP\u0019·hí\thô F\u009b9Ò\u0088\u008b\u0006\u008e¸ë§u\u0011ì>\u008fcÄÑ~êþ\u0002iMÈ\u0088vz5ÀHMü\u008d¾\u009d ª\u008aø\u000b\u0086ð$?b\u0087)n¬I\u008ePò$)SÐþ\u0083ã\u001a¢üÝ³\u008a\u009dhÑ \u0007Ç§B¢\u0086¤\u0086<\u001f£À¿q¢ÏÒ0¶Ê.Ò¶å\u0003\u0083\u001eÃx½\u008f\u0018dÐ(§øÇWW½§\u008e\u0004w@óMìß\u0089\u0003¥ß\u00ad5S< \u009f\r\u0092a\u0084<õÀuõ.«Ë\u009fç3\u0012ôäGhí¹\u0085G\u0004ÞAtü=\u0092£dl¥Ù¦@]\u0012± \u0085ùß\u0002éçys\u008eýùü:õm\u008c\u007f\u009aO\u0095\t\r\u0091\t\u008d²¼8\u001bx4ó?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090ì\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.class\u008dSÛNÛ@\u0010=\u000b$v\u008c\u0081Ô\u0094K\n\u0014J)$´Ä\u0005ÚÒ\u000bE¢`@"\\\u0094@¤<E&Y\u0005\u0083±#Ç¡¢_Õ\u008b\u0004¨H}ìC¿©ª:ë\u0084K \u000fäaföäìÌ9ëÝ?ÿ~þ\u00020\u0083\u0005\u0005Q\u008cIx&c\\Á\u0004â\u0012\u0012\nB\u0098\u0094ñ\\¬_DÐ\u0082)\tI\u0005\nÆdè"¿\u00941-ò\u008c\u0084Y\u0086þeceq7µ\u0093_M/.§\u008cünÆHç×¶6\f\u0006-u`\u001e\u009bºm:%=ã{\u0096SúÀ0t\u009b\u0097ßNom\u001bé\u009d\\~ÝÈ1t,¹NÅ7\u001d?kÚUNýïð\u008dÍl\u008d\u001a\u009e·\u001cË_`h\u008d\'²\fmKn\u00916t¥,\u0087oV\u008fö¸·cîÙ\\èp\u000b¦\u009d5=K¬ë`\u009b¿oU\u0018\u0012)×+é%Ï,Ú\\ÿì\u0099å2÷ôÕ`¹[áÞ\u009a{ÄS®{X-\u0093ôÎR\u0003Î\u0010\u008d\'j\u0016-W_±lN\u009c\u008e\u008co\u0016\u000e7Ìr0FÂ+\u0006y¾`×\u0085*\u0019·ê\u0015¸à2Ä\u009a\u008dI\u008a~*zÑÇ0qOi$¤ÆJV\tOîÓ\u001f\u0012^«x\u00839\u0006õ¦@Ñø-Ño\u009f©\u008aw\u0098Sñ\u0000\u001aCßí\u008fö©jÙEî1D®Ú«x\u000f2+ëÉÚ`\u0015óøH}¯·ní\u001dð\u0082ß\u0000Õº5B\'\u0015\u009f\u001f1´\u0097¸¿í¹dÐ?a\u0018\u008fß½8\u0089fw©§\u0019\u0091nB\u0098Úqç\u0098\nqhN\u0091aê^-ëN\u00853ß½\u0094û0Þd6\u009eÐÃ\u0088Ò\u001bjEL\u001c\u001bU1tS&>Õ-\u0001Þsc-\u0011ÂÄg¥ØO\u0088N\u0099Q\u000eM\u009e\u0081}\u000b(1\u008aá\u0000ìÁ#\u008aj\u008d\u0080\u0001\fR\u008e`\b\u008fë\u009b¿\u0004Í\u0080i\u00adõ\u001cm¹õßP/\u0010ÊQ«ðWM:\u0087Ü\b\u0089â;"¢¬+\u0006)\tQ\u001c¤g<Dº\u0087)\u008e`\u001c£W\u0083%L\u0012&|\r\u0007Ã[þ¢[Â\u0088\u0006\u0099¬_\u009a\u0098%Õâ7p\u0001%w\u0086vM%9§èÐ:)\u009c¢ë\u0007"Â\u001a»a\u00ad\u0097âh`÷é\u007fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67§\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000org/gradle/wrapper/GradleWrapperMain.class\u009dX\u0007x\u0014Ç\u0015þ\u0007\u009d´§Õ"¡\u0013íh>c@\'Q\u0084)\u0006\u008bf!\tIp @\u0002"p\u0080å´H\u0007w·bo\u008f\u00928=N%Å¤Ú\u0089Ó\u0013;\u001dRN²\u0015 ½8½÷êôÞC\u0012ÇÉ?»§Ó\u0095\u0005éË÷¡¹\u009d7oþWç½\u0019\u001eyüá+\u0000V\u0089\u0005\n\u009e¡b3\u009e©BÅ³äðl9Ü\u00adà9**$¹\u0002ÏUð<\u0005Ï÷ã\u0005~¼P\u0012Î«x\u0011^ìÇKüx©\u0082{TÔJÆZ\\\u0090\u008b/Sñr¼BÁ+UÌtÉ¯RñjÜ+aï\u0093ÃkäðZ\u0015÷ãu\n^ïÇ\u001büx£\n\u00817)x³\u008a\u0085x\u008b\u008a\u0005x«\u0082·©X,\u0001îÇ\u0003\n\u001eôãí*Âx\u0087\u008awâ]òëÝrx\u008f\u001cÞëÇE?.©¨Äûäüý*>\u0080\u000fªÈ`XÅ\b\u001eRñ0F\u0015|HÁe\u0015ëqEÅ]¸êÇ\u0087å\u0086\u008føñQ\u0005\u001f\u0093\u009f\u001f\u0097\u008b\u009fPñI|ª\n\u009fÆg\u0014<"9?+!Iþ\u001c>/\u0087/¨ø"¾¤âËø\u008a\u0082¯ªØ\u008e¯\tÌêØÛÒ\u0016i?²¯§}ï\u0091Îî\u009díGºw÷vuï\u0012\bDNè§õ¦¸\u009e\u001chê±\u00adXr`\u0083ÀÔV3\u0099²õ¤½_\u008f§\r\u0081PÉö¶öÞ\u0096®H{[\u000e§.Ë²g_W{o\u008e:¯\u0080Z²©bc,\u0019³7\u000b\u0094\u0085\u001bö\u000bøZÍ~J«\u0089Ä\u0092Æ®tâ\u0098aõêÇâ\u0086TÒ\u008cêñýº\u0015\u0093ó,Ñg\u000fÆR\u0002K"¦5Ð4`éýq£é\u008c¥\u000f\r\u0019VS\u00873=àÎvê±$\u008dò%ø+03|¨ÔdGºn\r\u0010¯ÎcY@Í"o×-\u0081j\u0097#f6m\u008bÅ\r®V\u000fY&\u0017í\u0098\u0091\u0092\u0014\u0001Å2M»-FÞ\u008a!ÝJ\u0019üX\u0098¯g4\u001ekj5\u0013\t=Ù/\u008dÝíð\u0010¨2j&O\u0013HnX[¼¡ç\\Ê6\u0012»s¢ò\u0000ZÇ¶\u0011C1\u0087ì\u0018ãç!Ò\u0091Ó\u009f·\u008fìÓRE°t\u0091k_Ú\u008eÅ\u009bÆéÒN\u0017k\u001f\u0095í4\u0013´³"n\u000e\fHeçzE!â,r_M\u0096Ò~Ö\u0088¦m\u0093ü\u008b¼ø\u000f\u0014rI··\u009f\u008d\u001a®9\n¾ÎàèýýÅn\u0010¸)\\\u0018\u0090Â\u0099\u008c\u00adêJr\u0095^PÄÞP\u001cÎÚ¬Bù2¦\u0085KØüqf¥Ô-\u0097\u0011IÃnÚ··\u008bk\u0082ræ\u0017\u0010{Î%mýlÎ\u001eò\u0084ò\u0012m\u0097Ù\u001a×S©6ãø63\u009dìo·,Çþ©=¶\u001e=¹S\u001frr^Á7\u0004V\u0085\'\u008ej\u0089ª[&µéF!T{Ì´\u00155Üô\u009eYr¾VH\u0081L\u0003\u000f\u00886óL2nêý\u001aö¢GÃ\u0013\u0091Ö`#¥á(è×ÐD§BÃ7ñ-ú¿øP2\u0087&sð\u0019\n²NsÙ\u0096§\t¸|\u0090Y áÛø\u008e\u0082ïjø\u001e¾O\u009eS\u0002å§Ò1Ã\u0016Xý\u007f\u001c;\r?À\u000f5ü\b?Vð\u0013\r\u008fâ§Ì¢ñCÔ©§\u0006\u0019D\r?ÃÏ\u0015üBÃ/ñ+\r1<EÃ\u0010Ni8\u0081§*øµ\u0086ßà·\u0002s<Ìê\u0092å8\u001eçáv\u0017ÎPå\u0095Ò¡¿+ôà\u0018ÿnÝ\u001elI¥\u008c\u0004³Æ\u0092|¿\u0097Ã\u001f\u0004ê=\u0098·²V¥lN¤¿\u0098p®A\u007fÄ\u009f\u0004´ü<¢IîÎ\u0015ãåNÂþYÁ_4ü\u0015\u007fÓðw\u0019Ü\u007fà\u009a\u0086\u007fâ\u001aËÃ\u009dÌ\u000bk\u0091@UÁ\u0096\u007fáßrßc\nþ£áqüW¡ !Ä\u0014E\u0094iÂ\'Ê\u0015Q¡\tEø\u0099O78AôÔxNìM\'íXÂÈ-\u0012_TjB\u0095Zø\u008eSyMT\tM`s«\u009eL\u009av¨ß \u0091\t\u00860\u0014\u0095çn\u0088þ\n\u001d7\u00adPÖ\'!ÖùÐqËL\u0084¢lIÇô\u0094\u0011ª_\u009cª_Q\u0090\u0087ÝÇN\u0018Q[\u0013SEµ\u0014W£\u0088i\u009a¨\u0015\u0001EÔib:Ò¬47>à\u009a\u0098\u0081k\u008a\u0098©\u0089Yb63R\u0004\u00151G\u0013s%q\u009eÌ\u000fB\u0004¯{(¥Ìù,\u0089ã2ò\\£å;NÖÍxÜ<³/y2ÉÃØ=Ö\u001f\u0016\u0085\u001b&Ó\u0094*Ì,è:ÏÖy\u0003\u0088î\\©\u009b\u0088\u0087)2¨§Z¬\u0081tÂHÚ\u0013©\u0096Ã\u0095ýòxl m19\u0017\u0097Ô¸Rcd/(w:òd\u00adñl\u0099yÛ\u009câÀB=`ØùíböX»(m¢J¶Ç\u000bl\u009dDUÎCa\u0005ÙÐP4\u0017\u0098î%FÞ;Òv\u008b¬\u0018\u0081p1\u0004}°pâîK\u001bx \u000e\u0014wB·\u0010¬)i¡\u0093jç\u0085\u0006\u0017õ\u0098Ò`xßÓj\u008be\u0093vø\u0086À^\u0005u¬+y®\u0016\u0094OG\u0080b8VÐôC^iã)Â\u00adÙ\u009ek^%×\u0091s\u008bçU¦Ø\u0005\u008d\u001e\u0090Åmª\u0093\u0019\u0014\u0097W³:¦æÄw¦ÒÄrRZ·x\u001cÝ\u0098WææLº±ô.¼%+dÙ¥Ë;\u0096f\u0019Cq]Þ\u0017¬\u0014ù×\u0087\'\u0015]/ÌúÉm¥WjÆ©N\u00aduM§Ñ6Ë4ëE\u009bé¾\u0000\u0016\u008e)\u009fbH\u00ad\u0098}®©\u0098gÃXé¾.\u0087ë\u001eù^qïE|ê\u0094 \u008e¯\u0012oöõÖXù\u0088\u0014É]%s\u0017M·xG6\u0014\u0016ó\b\u000b\u0098m:E½\u0088S^;gç;«wÐ2ÏÈ{£ã\u001d\u0019¾\u009eè á\\Û\u008dSi=N\u0007ÍÈçwûÙ\u0086\u0086\u0083dàÑOè\fÜí\u001eÞ?ä±Ç+r3<öJMÜ\u008e\u0095dæÉÆì\u001c6ªR6`8u¿Ð¤1\u000bó\u0099\t\u001d(¥RiÛÌ¾¾\u009cL\u0095¤â¾SR_é\u0017ö\u009d±\u001eä©1Ý±Ñ\u008b>aíÎu©%\u0093ãä\u008b\u0082\u008ag\u009fÜ^\u0017µ\u008e\u0082×WÄ4O¦\u0087x½\t\u001flØ\u008f\u009b!ÿ\u0097\u0004ð!\u0088\bvB`\u0017gSPÅywÞ\\ã|wÞ¼\u0086ó=yóiðó\u009b7u\u008e½¤4ñWð·¼q\u0018S.9,û8V8Ä\u0010ösÔ\\\u0006\u001cÀ\u0013ø[\u0089>\u001c$\u00177\u008b{¨T\u0015iWGP\u0016Y:\u0002ßN\u000eå»FQÑ7\f¥Ù\u0017ôeà?\u0010ô\u0095_Fe_Y ª§Ï\u0017Ðz2\u0098\u009aAõ8¹F\u0092§Iò\u0081QÔrg ¹<X.÷Ö\u0005}\u008d\u0019Lo®\u0018Á\u008cf%¨\u0090Z1\u008a\u0099d\u0099\u0095Áì\f\u0082A®Ìiö\u0007ýËG0WNæ5W.\u001bÁüf5¨6\u008ebA_°r\u0014\u0082cà¦@h\u00187\u008fba_Ð?\u008c[\u0086±h\u0014\u008b\t´$\u0083úq³·#À±\u009e^\u000eÓÐ\u0006Tc)fa\u0019æc9Ö`\u0005:±\u0092Þ¼\u0095\u008eXÍçÍZ\u0018¸\rg±\u001eOC3îÆF\u009cg\u008c.`\u000b® ÕqÝ\u0090ë\u001e\u001cÂ\u009dNìFù<:LwV"\u0083#ü\u009aB\t\u0097\u0088t\u0018e\u0094ó t\u001c#×\u001e$\u0011E?]~\u0094\\\u0006\u008e3\u001c\u0006\u009d>\u0080A(\u0094u\u0007¯\u008e\u0087\u0019ÇóÔâ\u0004N\u0012í\u0002õ\u008b#Áp$\u001d9\u0002&¿ùöÈF9J¬)Ò2:r\u0014á¾Æ@Ã0\u001aG°\u0094>Ì\u0092\u0096æ\u0091Æ\u001dRMÅ\u0080m¨C\u0007\u0096Ð|iÔL\u0017\n\u0016\u0095\u0080óuÔ1J\u0095/¾¬ÀµÙ´ªbü\u0096¹ÿ.\u0016%×\u008e¼äªrü\u0002BØ9\u0088\u0096,ß,Gá\f\u0096óoE )°2\u0083[\u0087±ª\u0018®;\u000fnV\u000e\u008e¯Ñ,Ü£t\u009dÔ»7 f°:\u00835\u0019¬Íà¶\u001d\u000f`jd\u0014ëû\u0096\u000eãö«\u0014Ñ\u001cØ\u0090ÁÆû0[\u0012\u0003\u009b|\u0097±¹¯¬±g\u0004[\u0086qÇU:¨å!l\u0015¸\u0018ÉªÕ6\u008cö\u008b\u000er\r\u0093g\u001d6Ñ[\u001d\f\u007f\u0099£Û\u0012\u0006\u0007üªaÊ\u0004¨a\u001dOÑ<\u009e 0Ã¹\u0089ÚuPÏN\u0006YêÞÈÀÕpßi\u009cá¬\u008e;Ïâ\u001cµï¤Ugñ$~Ícª¹«Oæ_-|{\u0015¬{\f\u0095\nî\nu)\u0014ªÊGgÖà>\'\u000f\u0080\u0005\u008d\u0081ª\f¶Ý\u008bénä9éÈ Sª=\u0082.éÆ²¼P÷S¬\u00819Ìµqw.prÐ\u0015Z\u00061\u0087bø¢Í\u008aY\u009f\u0015S=\u008aíD¯¡¨aì(\u008eÎÉ<¸ê,\u009c`*K®§ÿ\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000úâ\u0018æª\u0000\u0000\u0000Û\u0000\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/IDownload.classE\u008dÁ\nÂ0\f\u0086ÿÌéæ\u0014\u0011¼\n^õbÁë®*\f\u0004AÑ{ÝÊØ(í¨Óùl\u001e|\u0000\u001fJìTf $_òçÏóu\u007f\u0000X ï¡ë! ø\u0089®\u0094Ô<!L¦\u009b\u009c_9S¢d\u0087]\u0014~)Ól\u009dI\u0011Î\u008e\u0084`u\u008bEQfZ\u009d=ô,ïõÅÄ¢Þ\u0013\u0006Ñòg5¯\u000f\tcmR\u0096\u001a\u009eHÁ*Ã\u008bB\u0018Öh\bÃ\u008f½ä*eÛS.â\u00920ú\u008f\u009aO\u001d\u0002ÁA\u001dä\u0012Zp-·-ÕµcÓ³½\u0003ÿ\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@áõc\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000org/gradle/wrapper/Install$1.class\u009dWù\u007f\u001ce\u001d~Þì1ÓÍ\u0084¦\u0081\u0006\u0097¶\u0010¥ÐÍ\u0096d{ÐÖ¦\u0007-I+\u0091MZ\u0092&¡¡(\u0093Ýéf\u009aÉÌ:;Û\u0003\u000f<ðV\u0014/\b§\'EE)ØlSª\u0080¢¨\u0088\nÊ¯þ\u001d~>\u0002êóÎìn6\u009bmlýaßó{<ïû}¾ßwöµ\u007f¿ð"\u0080Mxk\u0019\u001bC6Ge\u0093\u0093Í¤lLÙ\u001c\u008ba3¦\u0014X1¨\u0098V`Ç\u0010Ã\u0094\u009c8r\u0094Wñ\u0011Ù»r¥ \u001bO6EÙ\u001c\u008f!\u0083\u00131\u009cÄ)\u0015÷Ê\u0095\u008fÊ\u0095\u008f©ø¸TùD\f÷á\u0093råSÍø4>#\u0005î\u0097ÓÏ6ã0>×\u008cq|^6_PñE¹ü¥\u0018¾\u008c¯Äp§t\u0096ÁWeó\u0080\u0082¯©øº\u008a\u0007U|CÅ7cèÄ·äÆ·¥µïÄx\u0080\u0087\u0014<¬`FÁ#\u0002\u00adÇuk\u00adådtkÜÌï7-Cà\u008aô1ý¸\u009e2\u009d\u0094\u009cï\u0010h\u00962Y³àõ\u0099®À\u0095\u0095\u0099kN\u0014=Ó±G\\«ªd\u001b^jd¨\u009fJ+¤XÆ±\u008f\u009a¹¢«K9\u0081Î´ãæR9WÏZFê\u0084«çó\u0086\u009b\u001a\u000búÞZQêÇëÝ\fOê\u009b¶l\u001d.N\u000b´\u0005Î,ÝÎ¥\u0086)`ç¨\u0010õ&ÍÂÚ\r\u0002«\u001byé·\u000b\u009enYRn§i\u009bÞn\u0081û\u0013K\t.¼\u0084F³ÊY/ùP\u008bQw\u008e\n\u0084{\u009d,o}yÚ´\u008dÁâô\u0084á\u001eÒ\'d\u001cÚÒ2,£ºkÊyy1,O) õÛ6Í[z¡`pzí\u0012\'Y»\u0091\u0087\u000eÓ\u0012£Ô\u009aè¬\u000fnÌ\u009bÎWC\u001fÊÊ\b\u000b\u008eVVåú\u000fì;\u00991òå°Ä¦uwÊp\u0003ñ\u0016Û0²\u0085>ç\u0084m9z\u0096\u008aã¤GA?jôÕÓCó\u009c|Ú8nX¤\u0010ñ¶\u0006Ö¹o¥Ò\u0094\u0095\b]Çñ\u0004Ú\u0017\u001eúT¾rð\u008e:\u0095\u009d\u000b\u000f²\u009b&Z\u0086==35 ç}\u0015\u0005\u008f*xLÁã\u0004]=AAÁ\u0013\u0002WU®Á\u008fÅ\u0081\u0089cFFBX6lælÝ+ºt·w±@\r\u0000ò:St]ÃöR½¼Xé®\u0001\u009eØ°St3FpWZ9\u001cÝR\u008cáÞgg,§@\u0012\f\u0018Þ¤\u0093Uð¤\u0086ïâ{\u001avã\u0016\r[°UÃ6Ù¼\u001fÛ5ô`\u0087\u0086\u009dØ¥a\u000f¾O[µ®4ü\u0000ý\u0002W×\u0093ëÖ¢ie\rWÃ\u000fñ#\rOá4ÃÛíLixZÎ÷àÇ\u001a~\u0082\u009fjxF6?\u0093k?Ç³\nÎhx\u000eÏ\u000bDºóºëiø\u0085Ü>\u008bYz\u00ad\u0004\u009aÆ;¤Å\u0092\u0082s\u001aæp^Ã\u000b¸ à\u0097\u001a~\u0085\u00175¼\u0084\u00975ü\u001a¿Ñð\n~«áwÒÂ«¸\u009bÜè3,Ã\u0093êä\u0019¯ÔqOÑÐïñ\u0007\u0005\u007fÔð\u001aþ¤áuüYÃ_ðW\n7  \u0099Óë\u0014\u00adl\u0087íx\u001dEû^3ßAætx\u000e;Ñ- \u000e\u0019zÁ±{hõ\ry¢7ñ7\r\u007f\u0097þo\u0093w´z©,¡íú\u0090\u000b¬Y2æ\u0095H\u0094+\u0001«àB\u008e2\u0087ç\u0017ú=\u0083uÀq+\'óýÔ\u009cì\u009a\u008b\u0083#\u00952®¡{~^\tloX¸\u001a\u0096\u009cEé\u001eJÈ\u009aÓ\u00923¼\u0083º<K@N\u0085óA}Ú¨O\u008dùâ*mÛLñ®D\u0083*¶h©Ì=*ª\u009e\u0013,\t\\\u009fhTEëËa³Yè«\u0090Ã\u0087Ë\u009a\u00125\u000b\u0001ÎåÄ¹w¢àXEÏ8¨{\u0093¼\u0018=\u00931\n¬û\u001bXùÓ\u0097]Ñ\u001b\u001ccþ®V506_ì\u0014YèF\\\u0093Õ7±ðAè¬\u007f\u000b£YÉ{c\u001eíF\u0089¶q\u0018+h\u001b¾\u0095i\'\u0097ó¯uA\u0018Êõi©0Ä/j\u008cwl9\u008cÎÊF\u0081\u001d\u009d\u0087¼IBÞyù\u0090û+7¶ã"ù7\u007f£j¶:¼®îJ\u0017\u0086FâRÉ^2ö\u0090ÃO\u008d:bIÊT`oþß°ë\u0094\u0017?MªYMÝöDí~%¥)£Lê\u0085Aã$³3lû]\u0005ÀÍ\u0012@×å\u0000 úu\u0097\u0098ßAFÔ¾¶5oü<ÿ*X¶H,w\\\u0002\u0096Z\u0012\\JÒV\u001cl\u0095\u000evüßßU¾)\u001eh\u0080¶ô\\M¾l»ìK\u0094E.¨\u0099\u0083Æ\t¹\u0084\u000e~ùn\u0086ÀÍ\u0088¶¶Ê\u0007\u0016`¿\u00adÜó\u0099õ{¾´~ÏÇÖïù\u001aó/A\u0088¿=ØKí[9\u001aG\u0013\u0014ö7&×ÏB$o\u009aES²k\u0016¡d<<\u008bp2\u001e\u0099E$\u0019\u008fÎ"\u009a<\u0007å9J6¡\u0097m\u0094úÀ\u0006ô±mç\u001a-`\u001f>\u0000ø#é\u0089¯\u0098|©¸G?Mo#"ý\u0088·.@=\u009c<\u008b¦\u0012\u0096]@ìð94\u00073\u00ad\u0084\u0096¶+Ø\u0094°ü\u001c?ª¸\u001a*aÅ\fÖ¬/¡m\u0006í\\\u0010r1Ø¸r\u000eW\u009d\t4Û\u001e\u0081\u0012>\u008dph\u0017çá9¬\u001c\\=\u0083©%ý´Wýô\u0084ãá\u0012®\u001e\u0093Öçð\u009e²h[\u009c\u0002]%\\C¡\u0012V\u0005\u009b«¥ùxø<Ö\u0084\u0010\u000f\u0007Ö®\u001d«À\u009aÃu=þ.\u009fï\u009eH<r\u001eï\u0015\u0098Á.9z\u009fÀËP{¢uN®§\u0093x\u0094g\tÐ\u0094\u001dÅ£sX;vú?/\u0095-GJ¸¡ÄøÐ\u001f\u007fÜ\\WÞh\nÜ&Nã\u009e\u009eH\u009dé$M\u0006\b¥ñ¶õÁ4T\u009eÞ´Àa\u008dZ\u0097DD\u0087ÝU\u0081x¤\u0082#ÄÍ\u001byë\u0081¯xd\u000e)\u009aÝ0\u0016\u008f\u009c\u0081\u0010½bH\u008cðïYØg\u0087\u008dUþ\u009fÏ\u0004Yº\u009d,M\u0093\u009bGÈË,99IV>HN>DV\u009e%S^%WÞ GþAÍwÐ\'Ö`\u009fX\u0087ý"\u0089ÛD/n\u0017C8HËi1\u0086\u0001ñ\u0000\u0006Å³8 \u009eÇ\u0090x\u0005Ãâu\u001c\u0012obÔgá\u0011,£Ý[ðAfA\u0098\u0096Öãv\u008e¢Ô»\u008bþ\u0007È?²¯ÌÑ\u0084x\u0006\u0083Ü\u00158"Nâ\u0000\u000e\u0092¥Y\u0091Ç\u001dD\u001b"\u0092\u007fb\bÃ\bÓÇ\n\u001c¢\\\u0004#ÔÒ(\u001fì\u008dÒÃ\u0018Wn\u0080ú\u000eÒ\nÔ\u0096=â]xBÁ\u009dïb¥\u0082Ã\nÆÿ\u0085Þc\n:ß&°»(\u001a\u0096ÎZ÷2%î\u000eR\u0002)?EÀü*aã\u0099\u0086\u0099¥\u0005\u0002eÔU3l?äË\u007f\u0018÷ø½\u008e\t\u007f/Ã\u001bÞÏQ\u008cR\u009bü\\Ä\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T¨,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000org/gradle/wrapper/Install.class\u009dY\t|TÕÕ?\'³¼ÉðØ\u0002!\fë\u0088\u0004²\u0087\u001d\t\u0088\u0084$H4\tHX\u008c\u0014áeæ%\u0019\u0099%Î¼!\tµj-Vkµ\u00ad[-Z×ªh¥UP\u0012 \u008akÕZÜª\u00adÚM«¶Öª\u009f¶ý\u0016ý\u008a¦ÿóÞÌd\u0092\f\u0002ò#÷½w\u0097sÏò?Ë½óÜ\u0017\u0007\u000f\u0011Ñ\u001cþÈMÛy¸4#¤\u0019)Í(iFg£É\u0091f\u008c|\u008euS!ç*<ÎFüêcnrs\u009e\u008c\u008d\u0097Æãæ\t<Q\u009aIn\u009eÌSÜt\u0003O\u0095Æ«ðIn\u001aËÓdþÉ\nOwq¾\u009b\u001eà\u0019\nÏtÓ\u0004.pÓ\u001e.\u0094\u009e"i\u008a\u0015.qÓTÎus)\u0097¹©\u0092Ëås\u00964³¥\u00993\u008c\u000eò\\\u0085ç¹x¾Â\u000bdÆB7ÍäS¤\u007f\u0091\u008b+ä¹XØ]"c§º)\u008f\u0097ºø4y.ËæJ^îæ*®vã\u00adFá\u0015nZ\u0088½0vº4+¥©\u0015\ng\b\u00853]\\\'=õ\n7(¼ÊÅ«]|\u0096t¬qÓ2n\u0094f\u00ad\u009b^ãu\n¯Wx\u0083¼\u009eí¦ZnrÓJ>Gá\u008dnª\u0017ê+ùk.Þ$\u001fçJ3GáÍnjä-\nknnf\u009f4~7\u00ad\u0093\u001eÝMM\u009cëâ\u0016y¶J3ÇÍm\u001cpñy.Þ*l\u0007³9Äa\u0011.ââvy\u009e/<E\u0015\u008e¹©U\u0014ÚÊÆ0ú\u0098ãÒlS¸ÃMA®\u0095¦S&v)¼]á¯»é|\u0099ÛÎ\u0017È\u0082o\u0088¼\u0017ºé\u0013¾H>/\u0092·\u008bÅ4\u0017)üM&µ6\u001cÖ£UA-\u0016ÓcL\u009eê\u009a\u0015\u0095ëêÖn®®m\\»¦vùºµµ«\u001a6¯®\\»\u0092)§î<m\u009bV\u001eÔÂ\u00adå\u008dF4\u0010n]Ì4¼*\u0012\u008e\u0019ZØX¯\u0005ãº\u008b/ar\u0006#\u00ad\u00adz\u0094ib]$ÚZÞ\u001aÕüA½¼#ªµ·ëÑò:s\u0010+]þHG8\u0018ÑüLS2M¬\u00adN\u008cË.í\u009aÑV\t\u0016CÍA¡<-Ó\u0082Õés°h\u0082Þé\u000bÆc\u0081mú\u008a@P¯ôùôX¬^\u000bk&oå\u0099(Ô\u001cu\u0001È9\u0097\u0004Â\u0001c)Ó¹\u0005_"×\u0097Krl¶\u000b×3Ù«"~\u009did] ¬7ÄCÍzt\u00ad\u0086A±@Ä§\u0005×kÑ\u0080|\':íF[\u0000\u0096\u009b\u0094qg±M0\bîÝ¾¨®\u0019zu f0-Ê(Á\u0006ë\t\u0083¶\u0004ZãQÍ\bDÂ\u008b\u000b-£\u0007"å¢\u00131\u0085/}\u009c©ð¸IA"?¶\u008f\u0006\u009aãò½.\u001ad\u001aa\u0091\u000fëFùº5µ\u0098\u0092\u009b>¥±M\u009b3\u007fAc<Ä4:(¢W§\r*ü-t×\rîf\u009awL-O\u001f²\n;+²su \u009abª_fÕÜü\u009c@»|C\u0097À\u0089Þ.Ëb\nï\u0080Y0è\u008b\u0007¡Þ4\u0086§\u0015\f¤R\u0098É{lmz\'\u0013\u0007ðW\u000bK¶\u0098ä³Bp\u0089ÉÖô\u0098î\u008bG\u0003FWy=°\b V\u0007Zõ\u0098!+[Äè¹©=jÃíq\u0003tu-\u0084Q\u0086\u001a\u009cÍñ\u0096\u0016\u0081zÖÆåð¶æ.X_34¦lljqÀ4~\bWËÍUbèFCóm\u00ad×ÚM\u009c)|©ÂßVè> \u00adU7*Ãþõz4ÐÒ\u0095®Ä5\u0091\bÀ5k\u0090àCå\u001e\u0082©¼t£Wë1_4ÐnÙÒî\u000fD!ç(k\u0005Æ\u0083åu\u0001S\u0001ã\u0006úBW{Ò\u001f¼\u0083æ.\u0019¸ÛÒÅ\n_\u0086åÛ,ö\u0013\u009eYÕ¦û¶ÆÄnó\u000b\u00862|L\u0081à´JÈ²\u0010ô«ù\u008c¸\u00164Q\u0090\u001d\u008bÄ£>ÝÄú0½³]÷\u0019ºß\u001cq\u0005-¸A:of¨ôK«ðå Õ\u0018h\rkF<ª\u000fÕñà\u0015Cd\u0086¥cºQÓ\t8\u0019¢¦Õz4\u0014\u0088Å\u0004Âp¢ÁÔ N\u0096Àk|ªßB\u0085î_£k~+\u001aÆ\f\u007f$n¤ hn½"\u0012\ri\u0086aN°\u0007\u0011½@§½\u0019\u00918Me«£\u0011\u0089«Ëã\u0081 E\u0089Û\u0099Æ\f\u009d #ú\u0000\u0084¯J¹Ýâ\u0094\u0095Í\u0015µal\u0019\u008d·CµéSÜV\bX\u0019\t\u0081Îpë£*\u0012\niaø\u0097\u008a\u0015\u0091hÂ«\u0014þ\u000eô\u001b\u0088m\b\u0084\u0091\u0094 ¸\u00ad ð\u001cÈ\u0018\u00895h²8Û¯\u0007u\t\u009eÑ\fÊÂD%\u00167\u0093\u0005XÆ\u0097Ë×\u0006Ù¢:à;fcF¯\u0007¨\u0015z\u008bÉ\u0011\u000fo\u000f@ü©\u0019]&Ý\u001c\u000e=lD»R\u00161µ\u008d¥å\u0088I52"A\næHÅ\u0000ñ\u008f$\u0091Uiý\u0012ç\u0084T@\u0092}^\u001a±\u009ap<¤§\u0002µÍdËî×%[(Û\u0093\u0081/oèî&\u0087\n_¡ðw\u0015¾\u0012!Þ\u0017iïJ\u000bFLe\u0005\u0019\u0083Tfö,èAs6\u0013\\¶ hÑ\u00ad\u0099Ú\u009d>kÖ,¦º\u008c¹+\u0099èN8ôduÎ\u0092f¶4sú·\u009a-[eN\u0093É\u00ad2&¾Tu\u0093$4G\b-9qBéÕO\u0092ÖÜcÓ:F é§5Oh\u0095\u009e\b\u00adsú\u0017Ï\u0097Åg\u001dÇâ\u0013\r¢Y\u009dsûwY »,>as§»M\u0092ÔÂ\u0013\u0096V\u00167\u009a±Û\u0082¾\u009a\u0098W&ÓTz\u009a\u009eQé\u001dzW¥^zX¥ßÓ\u001fTz\u009c\u009ePé\u0012ú\u0096J\u0017Ó7Uz\u0090\u001eRér¾\n\u001b\u009fP©)\u008b¾§Ò·é2\u0095v\u0010²î÷Uþ\u0001_\u00adò5|\u00adÂ×ÉÇõ*ÿ\u0090oPùG|\u0003ÒñÑ\u0085\u009a>[\u0088íTùF¾\t"¤K\b·n\\YY\u008ajEå\u001fóÍðíôÑ4G\u0005\u0005ÈÊ·ð\u00ad*ßÆ·«|\u0007ÿ\u0004Ñ%sÙ ð\u009d*ßÅw«¼\u008bïQù^þ©4÷©¼\u009b¯Uùgô\u0006rAÿÊ5ñ°\u0011\bé©\u0098Í´åtS\u000eoz=à\u009d\u0099\u001f\u009béõGô\u00987\u001c1¼(?\r-\u0010öjá.L\u008b"¡F$\u009a\u0095yk\u0012ÙÕkD¼-\bä^½\u0013\u00898Øå\u009d\u009d\u009a×U\u0086R¢\u007fÿUÍç¡[å\u009fóý¢§\u0007TÞÃ÷0m:*\u0013\u0089½cØ"â\r}5\u000eTÞË\u000fªt+Ý¦òC¼Oånh\u0085ÛÌj*à3\u0003°7ÒâÍÄC\u008b\u0006ÓøOÊ\u000fç\u0087\u009b\u0000Í\u008csBZ\u0097·MÛ¦{\u009bu=ì5´P»¤moGÀh+Ë\u000f\u009b\u0005y4ä5Ú4\u0003\u008dî\u009d\u0099±Ü\u009eém\u008fF°ÐèòBÓ]²\u0097\u0005°Ò\u0004ÀÊ\u0012ã\u0010Û+E«7\u0010\u0083r¢"#\fã\u0097%^-\nÖ\u0012A\f\u00001·K,÷¶D#!¯æ5¢ñ\u0098èË*\u0092ÊD0ozAéEÝTáÍ\u008få\u0087\u0093ÑÐ+U\u009f\fYÝ)\u008dû\u0012õ[\u0085i(\u0090ñV\u009aEØ\u0090\u0001\u0095{Ä\u008dö«|\u0080\u000f*Ü«òÃbøGø\u0010²u\u007f´¬\u008cFµ.\t\u0099*?Jo¨ü\u0018?®ò\u0013òö$lF¯\u000b\u0092ÝÍ\u0081pÂñ\u0004>O!;\u001f\u00adÌ\u0019\u0000»dííðµ\u0085"(El\u000bçÏWù\u0017ð\u0010PyZågøY\u0095\u007f)H\u001c\u0097¹üÂ1=CFµÆT~\u008e\u007f%\u0084\u000eKóü\u0000¡Rå\u0099Ê/ðµÈï¢B\u0081ÿ\u008bÉi\u0003Ë,\u0095_\u0092iS¾¼ÒRøe\u0095\u007fÍ¯¨üª\u0004»¼¡\u0091!¡\u0082¢ªH<è7\u009d\u0018µ(\u009c#Y\u008czÛû«QoK$Zá\u0095¨ñ\u001b\u0085\u007f«òkü\u0000\u0012ñê ®Å\u0004N^9ì\u008aëÁ¶p¬@\u008b\tµ\u000e-l\u0088ÓÅ1G`\u0096p\u008cuµðw%\u0012+\u000b£\u008aSùu~Cáß©ü{þ\u0083Ê\u007fä?a¬Ã*øT~\u0093ßRùÏü6\nÎ\u008c%\u008eJïó;*¿+\bø\u000bÿ5i\u009a!u\u0098ÊïI¤û\u009bàcÒ`ë\u00ad\u001aP \u008dO\u000f¸éCb¸÷Å\u008e\u007fWé\u009fô/\u0095?à«Tþ\u0090oGð<z¬G\u0089\u009bì\u0011\u009fFy7çÄ\u008fÁI\u001c\u0098æK\u008bË\u0013¿ä0\u009a\u008e\u009dôºoÄÀÚ\u0003¥áÆÁÅ×è!þ2@ÿi5)ÓØLõâ\u0000~×¶E#\u001dÖ\u0019\u0010õ»\u0014Í\u0005µµò\u009cy\u009c7\u0014`\u0011GÛ\u0081ú\u0018UP8ø\u008abü Ii\u0087þ±\u0005\u0019\u008fùÞcY\u0082ió\u0089\\É|¥û\u008d\u009cAl\u009b§\u0099\u0094xýFqc^êªcÇW.¿\u0006jí¸\u0085Ë\\\u0017:µÄùª2ãIÉD\u000b\u00923à\u0089c\u0097Q^\u0005æ\u0004\b\u0003.]¬l\u000f\u0001\u0087A@S\u0082°\u000f\u0012ÎÎpÞ/<Æå\u008b\u001dØó\u000b¾6./¬\u0005wñv¿fHI\u0085\u000e\u000brN\u007fÂ7ì\u0005\u0085rý2z`\f5¯ \u0087\u0019\u0091\u0095ý71¹\u0005µ\u0019±ãÄ\u0011¨Õh31-{\u0089Îä\u0000;± jèüÔåMÉÑ¥Ê4ÝeD\u0092|(\u0081XM¨ÝÀYÓÙbæ\u000bó\u001c4\u0084ØÆ¡\u009aÍÈ~n&Fä\u008e3\u0016Ø.\u008e\n[\f\u0091=e)§~>â|l\u0010\u0095ävrB·\u000eæ\u0096ãV6Ç"Á¸¡\u008b+\fL¸]¨2à\u009d6ä®ô\u001b\u0085Õà¦ÿ\\<&C7ÔÑ._A¹\u008aÒ;\u0003¦A-\u0003ãË\u008c²Ùr\u008f#X4/R\n\u0087Ä¸a\u0081Xu²ø\u0003\u000b\u009a\u001f¶;ùØWdØb\u0014dªÒÂ\u00910ÊÂ %Ô¸\u0082\f\u0017\nf¨\u0003\u009c£¦&Ó\u0015Ù\u007f\u0095¢th\u0001\u0003ù\u001faÙD\u007fZ\u0004ÍK\u000b\u0001\u0003o\u0011Çg>¹Ë~cú\u0087\u0012WBÒë\u0012¿¨3ï}\u0096\u009c\u0010f\u0086Ü\u001eI\u0010ªO^¨¥\u0099\u00121Þt½á\tWO~\u000f\f¼Vïb¹ÓI\u0016,æñï¸\\"y/å9êñ^î%"\u00adV Y\u009d(\u0094\u0099f\u001c\u0017ýÅIq¬Ä(qZnÉÖ5¦~_I\u001bXl\u0006\u0089ºH\u0007¢$ê\u009fþ=ÒçdÜCAa£w®j9\u008a\u0003Ö\u009a÷s1\u000b0\u0019ï¨<\u0005é¦\u0019x;4²M\u008bÕG¢zMP\u000fÁ\u0006\u0000þ°°Þi$>\u0007\u001b#åÍ\nÔeÝ§9C[\u00ad{]O?\u008c\u0086\\\u0003\u0095§Ë:à®ëhxuø\u0082\u0011Ñ\u0092£\u0003Q[§\u0093h;\u0015\u0012\u0091\u0083<t\u0001}\u0083\u0098.ÄW\u0016]D9rBÇ{\u008e\u001c×Í\'\u000eÚæ\u0013§n<Ç`îåô\u001d´WàëbP°ã9½¨\u0087²\u008bzÉÝ\u00943l4=ÛCê>\u001a^T¼\u008f\u0094¢\u0092}ä,*ÝG#ö\u0098;|\u0017í\u0004r¢\u009d\u0086\u0095^\u001aK\'\u0083\u0087é4\u0085òñ6\u0083®ÄH\u0091E\u0093®¢ï\u0011\u0099oÂ\u0013\u009boÂU\u0096ù&|ÙÐû}ú\u0001z\u0084\u009býä&\u0005Ï¥ÅÝ4²\u001eÍ¨\u0086¢\u0087h\u0004^FWØ=önÊ©pÈcL\u0085\u0013ýÃ=Î^\u001aÛTäqz\u001c%Å¥=\u0094ÛMã\u001e£¼\u0007\u0006ñY\b\u0019\u008b@¹\u0004¼\u0096ÒD*\u0003ç³L>WZ»¥ø\\JWÓ5àÈA\u008bèZº\u000eTÜ4\u008f®\u0087~mX[D?¤\u009d\u0090l"ä¼\u0091nÂ¬i4\u0089~\u008c7\'Ý\u008cÕv¬¼\u0005kpüµäá\u000bÐçÆÈ¥9ã÷\u0093§¾\u0097&4\u0015÷ÐÄ\u0006Û\u0002ûèQô°«Â\u0091kÏº\u0095&\u0095z\u001cÝ4i\u0081=×~Kß\'%\u001e\u0087-\u0017BNÞÕ÷nI7M©\u0080\u0094S\u009bzÈ[¡Ø\u0016¸r]\u001eç¡;hÖhêó8s]s/ÜO\'Ud{²»i\u009aý6\u001aæQFÍê¦\u00937x\u0014é\u009a¾a\u0087\u008bwõ½àQº)_Ôb3Õ²\u0082F£Ý\u0004¶Ï¥\u0091´\u0019ÐØ\u0002\u0013j4\u0095\u009ai&ù (?\u009dB\u00adPG\u0080N§óh\rmÅ\u008c ¾Bt>E¨\u000b}\u0017QÔTa\u000b\u0004\u0094Õ·CIÙt\u0006Í§;è\'ä\u0012¡Sj½\u0094î\u0084\u0092à\u001aXu\u0017Ý\rå\u008c¤m´\u008bî\u0001?9\u0014£{±Â\u000e\u001aAú)Ý\u0007µ.Å®»ñæÄs)ý\u008c~\u000e3Ý\u000f:¥äèÃ4§BÛ\u0015ÊSè\u0001\u0085ö°B{\u0089¦|A£ñ¢ÐT>B3\u0014ªü\u008c\u0086\u000f°É\u0083ôP\u0002c¿\u00021AgC\u0011Láh(=@3\u0018f\u001dßK3\u009br\nì\u008fPa\u0093\u00ad¤q?Á!\u008a\u001fÅh\tÂÉ\u00ad\u0089áÒÁÃ¶\u0003T\u0096E\tÌÙÓ0×\u0081¶\u0013bv\u0001ç_\u0007â. *xh¿o4¤\u0094Ó`b\u0089Í·}Pb\u0016V®¤nê\u0081rö£W5\u0015\'=\u0007Ð#jÈ¦¬#4]¡\u0083S\u0006\u0088ØK\u000f\'D|\t:\u0014&jJ\u009f¦ª¢\u0092\u001e*¯°\u0097\u008aßÌº\u0091æ\u0002R³7äÌQLI\u008a\u001b\u009bìè\u0098ÛØä(mlrzì"Y\u0085c/Í\u0013DÎ·ï§\u0005{R°)2±|\t6ÜAÃ`Ô±\u0088(\u001eÄ\u0094\u0019ðß¹x\u009e\u0002ßY\u0006¿©\u0086\u009f\\iz\u0093\u0013}*=\u0002©\u001cX±\u0088\u000eáM¤¯II_C\u008f\u009aÑKÞÄ\u0093²Ì·ÇL\u008f»ß\u008coüo\u0010L\u0097óqz"!ç«x\u008a\u0003WöÒB8È)\u00121\u0016í¤¹xT4\u0094\u001eZ`·-päÂÅî oi®cN\u0085Óãì¦Å;I-ñ8\u000fÐ\u0092,Ú°Ã\u0001÷x³¤ßzSL\u0082;\u0001à\u001ba½\u009b¨\u0000\\ÍÂö\u008bð~\u001a@\u009e´`\u0001\\èNÓó±}J\u009aÊ\u0084-]\u0098/\u0016ÌJYÐê9\u0080\u001e\u0091j"ÙúÐ¤\u0080|P¡\'\u0019J\u0098ü)\u0004~Ê\f_¿ÀßÓô\u008c\u0015¦³\u0086c£lô\u001f\u0006ìNE\fÚÓKyMÅ9K{è´znè¥eMÎG¨²É\u0096³\u001c\u0006Í©\u00829aÕêÆ\u001eª±âæ\nÄM\u0018ôô\u009d´¢\u0097V6õRm\u0093|\u009fÑCgöP\u009dD\u0098z(°¡B\u0011\r\u00adjªp=My\u001e%gµ\u0085w\u008f«±\u009bÎÚ\u0080x$\u0081dMÃ.\u009ad\u0091]\u008bWDæý´¾\u009b6HÇÙ\r\u0080\\!b³ÒKM xNÎÆnú\u009a \f\u008fnÚÔMçÊ`Îf¼ì\u0081\u0084¹\u0080ÑåÔh>¯¥u\t \u009dKyhï\u0082)î\u0086âîAÊº\u00173î\u0003ÈvS\u0005âÁrD\u0084\rPä\u0016Ú\u0083È´\u0017Qå!¬ï\u0005¥nh«\u0007pì\u0005µý\bÜ\u0007`\u008e\u00830ÛÃ ö\bps\bîÿ\u0098iÄv\u0000r\u0003\u001cóYú%t»\u0005Éë934´Ñd:\fø¹°Û\u001az\u009e^\u0080±+èLzÑôª+0÷eú5ú®\u0087Y_¦WL8\u001fN\u0001à00)\u0000\u0018\u0083\u009d\u007fcÂ9\u0017üü6\u0005ç\u001ar¹ú°¯+iyü¯Th\u0099B¯)´R¡z¢#4\u0005}}\u0092\u0097Ó\'\u0011-W¨ñ\f\u0085Ö\r/\u0004Ù×é\u008dD\u0006oÃ\u0097xÍ\u0084\u009c-ûIÛKÍÝä«+Îñw\u0093\u009eu\'9ì»m»S\u001e\u009cc²û$X\u007f\u008aÆ\u0001bã\u00010QÆ8\u008bBB\f\u0095FÐïL¯\u0014\u0096]\u0084\u0090:^8È\u0092\u009f\u0002\u0012»î\u0087"\u001cx.,6=ª\f\u008f\u0096zÛÒÉ%ÈM\'\u0015\u0099è,\u0099<\u0007ðì!»äµ\u001bÉaÛ½Ã&Þ\u0086©³ûY\u009afæ\nÑüalü<\u0082Ê\u000b°Å\u008bp²\u0097\u0090\u0087\u009e§9Ð\u009e°8\u000fÛåcÖ\u001féO\u0010b\u0004Âªä\u0019\u001bÖÌ 7é-S\u0080\u0085);,¤?\u009bv\u0010\u0001\u0086\u0093ís\u001a¡ÐÛ<ù3\u0010É\u0092\u009f6\u0012ùùel.nuM/µJfn³`\u001d\u0090¬p\u009ed\u0085\u0000^¶2 \u0013´\u001c(´\u0093òD¸\u0012ù\bC¼n\u008aÀ/^é¥v8ÕùM\u0003Æz(ÚC1\u0094*\u001e»t\u0019\u001eg\u000fÅÅÁ¶í¢á\u0096«mó(\u008fîê»N6í\u0090N\u0097ùæq=º\u0007BnB\u009a\u008d\u0082»(\u0019æÓ\r K\u0005w\u0019ª·ËR\nl\u0000Ø\b\u0096qC5£ \n\u000f\u00941\u009dÞ\u0086òÞ¡S!é2z\u000f\u0094Þ\u0007\u00ad\u000f\u0090º?\u0004¥\u000f\u0090\u0095>DFú\bô>F,ÿ\u0004Ô>\u0086â>Aõó\u000fSÙk \u0097ét6ý\u0085þ\n\u008dmBað\u001eý\r\u0016\u001f\u0085¼ö>ý\u001d;Cg)e_\u0003\u008aV\u0006»\u0006t\u0005ôWãË\u009aç\u0086S~Dÿ\u0005iÄ\u0014\u001a)\u009fÓ(\u0085>V¨õ\b\u0095+\u0014ì£Ù¤¤á\\FÐ\u00ad\u0080\u0019dö\u007f|FÙY}°º#5\u0005\u001f\u00adæP\u001f,ç\u0018´\u0012[$3E#Øø\'ý+\u0091)nF\u009fÀ5\u007f´\u001deWCq)Ê\u00ad¦\u0005ö\u009bhDI©Yluîêû\bÀìB¨ÚÖ\u009fñ¬\\þßhÿ\u000fñþST{ÿFÅ\u008bäK\u009f§@\t¢)Mäcî=¦&òé\u007f 1ÉåSÍ¢Æ\u0006ÈæÑÿ\u009a\u0085Îý¦\u008f!\u0087#þï=B¹ÜÏô(\u0017vú4Át\rV\u0089¦\u0095¢bäpW\u007fYë4·\u0098h²àµ¦Ðg\t\u0016\u0014úÿ\u00841\u00140+åD*w\u0082ø\u00110n9p9\u009e2Ë!ñ83iÕ\u009a`\u0091Æâ/¨/Ãbçq-Æ|N,®H\u0004,§Y\u0080e^m\u0005$gJ*§%\u0015èd±-\u0013\u001dûî\u0013¤cgGBÍ«¡\u001d\t\u008b.¨\u0019\u0087\bÛ\u009e\u008c\u0094¬²Í\u0095¢ä\u0002%«pqAÏVáâb§\u0019éÓ4Î\n»2\u009a3+ó6_nÎ\u009bÒÌ\t¬p6»3)\u00833Ó>\u008a2(\u008b\u0087É|VQ©J\u008eÈB\u0010¶þÝÀ\u0093éGÄÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ð¿:öo\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000org/gradle/wrapper/Logger.class\u0085\u0093koÒ`\u0014Çÿ\u000f\u0097Unc\u008cá@Ø&s*\u0017]7¼\u008b11$KHð\u0092°`²wÏÊ\u0093®³´¬\u0014\u008d_ÅO¡Fgâ\u000b?\u0080\u001fÊx\u009eR\u0019\u008e5KÓÓçrÎÿw.éï??\u007f\u0001h \u0019G\f·b¸\u0082Û1TP\u008d£\u0086º4w¤¹+Í¶\u0002UÁ\u008e\u0082]\u0086èÉØ\u0010.\u0003;`XxfX\u0086û\u009c!R9¨öèÓ²û\u0082!Ý1,ñj<8\u0014Î>?4éd¹ckÜìqÇ\u0090{ÿ0â\u001e\u0019#\u0086bÇvtUwxß\u0014ê\u0007\u0087\u000f\u0087ÂQ;¶®\u000b§É\u00106m\u009d!Wé\u001có÷\\5¹¥«]×1,½)\u0081Ê@\u008cF\\÷\bs\u000e\f©®Ëµw/ùÐ\'.Hq«Ï°3«×:âNW\u009c\u008c\u0085¥\u0089fuæâ\u0085ç-Ce"Úè\u0084!\u001f\u0014ÇÐ\bÔl·\u0003U£#\u0097;²\u009bm"x©\u0015*\u00ad@o¦ÑÛb\u0088wí±£\u0089=C\u0016\u0095\u0098ôj[Æ$\u0091B#\u0089\u0004\u0092\nî%q\u001f\u000f\u0014<Lâ\u0011rI\u0014ðX\u009a\'Ò<%N`×\u0019\u0096Îø¯\u000f\u008f\u0085F\t®\\\u0094\u0012å\\\u0091c\u0098ñï~\u001c¹b@\u0017ö\u0098¢r\u0093J\f[}C#qi0\u0082\u000f¨\u0090ì\u0005Ç4Í¡Ü\u0099\u0016\u0083zÙ|æ\u0014w/ïþ\\L~ÚêsW(Óß\u0010\u00035\u009aÞeÙNúS¢´Na\u0091l\u009av{\bÑ\u0003Äk?ÀjÅï\b}¡]\bKd\u0017\u0011&{\u0015\u0011¬\u0092J\u001e\u0019oçy\u0093Z\u0016ðVR\u0095Æ\u0089\u0015ä|Í}_3]û\u0086Ð\'Ä¿"\\?ED\n\u0087g\u0084\u008bPP¢õú\u008cpz*\u009c¦\u0093U\u0012Ì{QLæ[À5\u009fÐó\t\u0099\t!1!DßÖ>\u009fc\u0094\u0089±I![3\u008cÌ\u0094\u0091¡\u001cJg\u008c´ÇXó\u0019&Õ\u001d¡ovÂHIFií\u0014\u000bó\u0094\nQª¤V÷(µIØ\u0094\u0092õ)rµ\u008e\r/\u0087,®Ó*ü\u008f\u009cñÈåàê\u008a§Pæ¹*qw(¤\u0011PÝ&nü_Ý\u00967Û\u009b\u007f\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011¶\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.class\u0095R[K\u001bA\u0014þÎf³«éVãª½ÙK¢>Äõ²EúÖR\b\u008aP\b¶ÐâCß&É\u0090L\\wÃd£ø¯\u0014\fB\u001fú\u0003ú£JÏLB1V\b}\u00983çö\u009dï\u009bÃüúýã\'\u0080}lÌ£\u0088\u0017%xX3ÞKc^ùxã£BðÛj\u0090\u007fW}ÂB£\'ÎE¬²øH%òý¤t¨4ÁË»j°ù\u0096°ÞÈt\'îhÑNd|¡E¿/uüEäÝú` Ï\u009a\u0089Ô\u008có>¨Tå\u001f\tõÚìöiÒéhë\u0084à\u001edmIXl¨T\u001e\u000fÏ\u009aR\u007f\u0013\f$\u0084\u008d¬%\u0092\u0013¡\u0095\u0089\'I×\b%,ÙÚ!Ë×ª9ÌU\u0096\u0012\u0082Oi*õA"\u0098\u009a[ÞÍ\u0094¶ùÏ\u0010~[Ø\u0091ùÝ\u0094]O¹¶u\u007fw%îã\u00ad\u009a\u0088\u0083¯ÙP·ä8\b§Hö\f.@\t\u008f\u0002\u0004¨\u0006\u0098Ç\\\u0000\u001fs>Ö\tûÿ¯\u0091ÕX)\u0089H;ñçfO¶rB¡fVY\u00995\rUþ\u0019\u001eÿ\u0099\u0002B£\u0081½Ð\b\u0002Êe#ÑVx\u0093xÌv\u0081£.\u001c¸|¯DÛ#Pt\u000b\'Ú\u0019¡\u0010í\u008eà^sÞÁ¢\u009daz\u0014Oê1ê\u0014ËHPæL4Æb\u0089\u000f¬g8Èz\u0086Õ±\u009eÑaXWñdÂ\u001aómº\u008aÑ\r\nW\u007fi<\u009bÔvt0n\u0098\u008c&<}\u0010ìÞ\u0007_>\u0000vðÌÚç¬\u001b¬\u0090¸ò\u009aßD\u007f\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJØâ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/wrapper/PathAssembler.class\u0095Vic\u001bW\u0015=cK\u001aY\u001eÇ\u008eb\'µc\u0017Å1\u00ad,Ù\u0016\t4@Ü\u0006¼5QkÙÁ[qÒÖ\u001d[\u0013y\u0012y¤\u008eF\u0089\re)\u0090\u0096})P(\u0094²CÙ]h¤P\u0003ýÎob;wf,Ù®LÛ\u000fzï¾§ûî9wy÷Í?ÿóÆ?\u0000\u009cÅß#\u001cr-\u0088c=\u0002\u0013×#\u0094nÈ\u0090\u0097aC\u0085%Û\u0005Y\u0014U<\u001dA\u00049Ù±E*\u0085áÈ\\\u008e@ÅMÙ¾%Ã¦\u008a\u00ad\b\u008eá\u0013\u0011|Rþ\u008bã\u00990>\u0015Á§ñ\u0099\bt|V¤gU|NæÏGp\u0012_\u0090á¶\u008açT<\u001fÆ\u0017#\u0088áKa|Y\u0094¿"ÃWÅÐ×Dúº\u008ao\u0084ñM\u0011¿\u0015Æ\u000ba|;\u0082ïà»\u0082ÿb\u0018ß\u000bãûrøE\u0015/)8:]XÓó\u0093fÉ±ÍÕ²c\u0016,\u0005ZÚ²\f{"¯\u0097JFIÁ\u0089\u008bsc\u0093ÓS+\u008bóSs+\u0097f3S+ó\u000bsé\u0099\u008b\n¢Ó×õ\u009bz*¯[¹Ô<\rX¹Q\u0005m\u0013\u0005«äè\u0096³¤çË\u0086\u0082#\u0097çf\u001f\u0099\u009aX¨\u009d:\u0092³õlÞX,\u0019ö¥Â\u0086hxfÌBêa3oÐDèAÓ2\u009d\u000b\n\u009aã\u0083K\n\u0002\u0013\u0085,ÕÚ§MË\u0098)o¬\u001aö\u0082¾\u009a7\u0004_È/é¶)k\u007f3à¬\u009bdÝ?]°s)\u000f*uËÖ\u008bEÃN]Ö\u009dõ1zµAM\u009b@Gãû¡\u0005\u00ad=g8ûã±\u0012odë1o¦·×Ì\\ÙÖEwtðmQ\u0007Þ\u0012p\u0089ÙÚ^+\n\u001a\u009ai\b¨ ¼ª\u0097\u008c\u0019]\u0002\u0019ÎÒ¬\'¶Ú\u0085\u0002Ý°½\u0095*\u007fpåKWÌ¢\u0082Ùø[³÷.ül\u0090yµlç/é¥uJ\u008c¡\'Ý×\u0000¥áá¶\r£TÒsÆ¤\u00993J\u008e\u0082>O©d¬\u0095mÓÙJeöþMýàê\u0096#ÕÙtu\\\u0081B\u001f»öX\u009dÚ\\3\u008a~|B%\u0017\u0082\bó\u008e¾v#£\u0017ýBi·\u008d\u008dÂMcjÓ1¬\u0092\u001bö\u0080åFKat\u00944cèW\u0082\u0017Ã~ß\u0013ËpR\u008bséCB á]´óµ¢ÞÕ¦ñ"Ë@Å\u000f\u0014Dhw\u009cIs\u0013Ò\u007fx\u0080ê\u0017" 9æÁùBÙ^3d\u0093Å¿¯¬Fä\u0084\u0086Q<¨áÃ8¯â\u0087\u001a&ð²\u0086Çñ\u0084\u0086\u008fcVC\u001aÓ¼Û{-kø\u0011^Ñ°\u008a5Þò\u0083,ÆËf>kØ\u001a~,:?ÁO\u0019\u0094\u0094\u0086\u009fÉj\u0014?×ð\u000b\u0091~\u0089W\u0014\u009c}÷E/6~¥â×\u001af0Ë\u008b\u009e\u0099|@Å«\u001a~\u0083ßjø\u001d~¯á\u000fø£\u0082N\u0097Õ\u0006m¥ÆÍ\\Úr\u008c\u009cPú\u0093(\u008cb[è¼¦àX\u0083Ì+è©ïÎ\u0095-ÇÜ0öüÙ;Q(ç³1«àÄÖY¨1Ó*\u0096\u009d\u0098W*#bûÏt\u0097Â_ðº\u0086;¨h¨\u008a»w\u0004.övî*è8Ø35ÜÅ_Y\u001f~3ä]-³ÿ\u008ddM[Å\u001b\u001av$A£ø\u001bËU*ã|\u008cÕ\u00173K±²uÃ*Ü"ß\u008eº3³«×\u008d5gßÖ¼_â÷¿ÃûËÃñÁ\u0083\u0005zì@ã\u001bwk®3Þ°Ð\u000f*\u008bÿ$/PVVÁð;ºö~\u0089I\u0013s\n»>\u009c>Ð\u0093\u001b\u0018Zòî\u0010Û\u0098ÇÑ_x\u001cÆ\u001avëý\u009d¿\u0011ÂÞ7@Û\u001b\u001a\u0005\'ÿO+òÚDÚ}òÖÈåÌá\u009e\u001fÚËÂÒ\u0010¼v\u0016\u0088\u000fJC\u000b\u0095\u008bYÝ¡¹`üê¸0\ne}´P<íítÅÓ\r3\u0093hÔ×ë;\u000bëvá\u00964@×ÑV>ò$\u009f56g¯\u0089É\u0006Üé\u007fK©¼ºÛE\u008fÇÓ\u008dq¥çûU`<]Öó¥\u0003ö¼²\u001d\u001d¼²¿r·J\u008e±á\u0005ñ²]`ª\u009c\u00adC\u0088,á\u0014¿\u0092Îò\u008b¬\u0019Ýx\u0000ç à\u0083\\5a\u0090ë\u000fíY\'ùc\u0013¤\u001cæ\u001e{"Ç\u0087¸z?g\u0085s0Q\u0085ò\u009a«z\u0081c\u00843Ð\u0087\u0000îÅG(i\u009e\u0012>\u008a1Îb`Ü7ð05E7"\u0006\u0012É;hª[9BZàwU\u00804[ÐïZ:îiû\u0096D\u0012ZBb\u0002\u0093¾Íÿ\u0012Iå|;\u0091¬ ¹\u008a@&1TEp&1\u009c¬"t>°\u0003uYþ\nWÑ²\u0083Èr\u0015\u00ad\\i\u0015´E\u008fpè\u000ep¨ ½\u008a\u008eóÁ]Ý£ût£ût]i¨~(´\u0083cË\u0089î`w¨\u008aÎí\u009a;=\bq\u008cÓ\u0095A´#\u0081\u0013\u008cê\u0004\u0086°\u0089a×µK\u001eé\u009ak·1Åð°Vð\f.2\u0017M<u\u0093Zç\u0018\u0096\u0013°øú\u009cch&\u0018ÊG\u0018\u0082 í´áQJ!jòeò\u0083Qä*Ày A\u0086Í\u0015tUq|¦î\u0089G~Ø#¿} \u0081g\u0098¸³.·\u0084g£ÆmÀå¡¸Ò\u0094\u009bD\r÷ ãrk\u0092\u0007ÈG\u007f\u0095çääHôÄ]Ü\u0093!`÷Ì\u0010Ñzvpr9@F½Uôu\fTpïvf\u0007±åè)fªÿM×ò)¦ü=´W\u008fÝ\u0018Çq´Òç\u000e&»\u009fÈ§\u0089-ü>@ÿCèÅe|\u008cø\u00ad\u008cÏ\u001cæyö4å\u0005,ºÞ\u008cÔØ\u008f`Éeÿ\u0018å\u0010\u0094U\u00958Mò¤û¬¯ó¤\u0094^g2zº\u0082\u0081\u0087z_F0¹\u009dlî\u00adà½Ûîm\u0011NQ×³G\u0099µi¢d\u0018ýY\u0097KÌ;[CëÄ²\u008b¦Rã\n®\u0012ÉÇý\u0017Úøµ%ß\u0013>î³<)6{\u0018§û2C\u0092\u009a\u0081\u000b}\u0004\u001fÚ\u001eê\u000b<UÁýuôãô\u0018ô1Hÿ4zØA\u009f¢ô¡\u009e\u00ad\u009e\u001a\u0083\u001e<\u0089\u0015b\u0004Ñ\u0085§ÜJÒx¹\u0084K³Ë¥\u0005Ê¿\u0011U¡\u000b\u001d~»øt^ \u0019\tÜd2:XAâ%\u0084\u0013¯£i;\u0019Mº«\u000e¹\u001bÑ¡»\u0018®bd[²ç\u0097U4Årrkë}»\u0097âÌ\u009b\u0007\u0088?NÐ\'HâI¦j\u0085E¤ï¹Ý\u00935â\u0093ÈÖ\u0012E.Gºø¿á\u0016é5¦\\Ê\u0094ï&¯\u0014ÛÐÿ\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007fÍëÂ\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.class\u008dVÝS\u001bU\u0014ÿ]\u0092°!,-Ð\u0002\rÒ\u0016\u008b-á3\u00ad\u008aTR°\u0096\u0006\u0089ò%A(õ£.a\u009b,\u0084Ý¸Ù\u0094âWý~ì\u0093ãL}ðÍÁ\u0019Ç\u0099ú\u0092\u000e2cÇWÿ¤Ú±þî&\r$¤µ\u000f9÷Üs~çÜs\u007fçÞ\u009býûß?þ\u0004ð"¾\u000b \u0013Q\u0005\u0013\u0001Ô \u001aÀ\u0018ÞP0\u0019\u0080O\u001ac\u0001(xSNÞ\u0092Ú\u0094\u0082i\u00053\nf\u0003h@Ô\u008f99¾-Å¼\u0014ñ\u0000T,Hø;õXÄR=.â\u008a\u0014Ër\u0091¸\u0082«~¼\u001bÀ{x_\u008a\u000f¤¸&Ñ\u001fÖc\u0014\u009a\u0082\u0015\u0081æør|!:}mn~v\u008e":\u0011»BãÔ\u009avC\u000b§53\u0019\u008e;¶a&#\u0002\rã\u0096\u0099u4ÓYÔÒ9] ö\u0082a\u001aÎ\u0098\u0080\'Ô³(à\u001d·Vi=<e\u0098úLncE·\u0017´\u0095´.\u0093Y\t-½¨Ù\u0086\u009c\u0017\u008d^\'ed\u0005ú§,;\u0019NÚÚjZ\u000foÚZ&£ÛáøVÖÑ7æl\u008b\u0013ÇÐ³\u0093\u009aI·Í\u0012\u008e$u§Ò+p2T(×°Â\u0013FZ\u008fô\u0014¦9ÇH\u0087§µ\fãü\u0086ÉmèÚ\u0086@°\f\u001b339§à"L°°\u0096\u0092?6\u001b½\u0099Ð3\u008ea\u0099ôyÖõ-&ÒìdnC7\u009dr\u008efWÖô\u0084CÔ¡L©.\u0099\u009e\u0086òÒ\u0004ê\u008b\u0088-V&Ùª,5\u0090Ù·³Ö}î½\u001dG¤£\u008cÓ\u00adÌc^\u0087Ê\u0013^8ØÈ\u0083\u00961ÙÜ¸£%Ö\u0019áæQ\u0090P°ª\u0080Êu\u0081º¸\u009145\'g3\u007fôé\\?óz\u0081¸\u0095³\u0013z\u0081¤\u008e\'t|P\u0086ªx\u0001§\u0005\u009aöÖ\u0099Ô²)®¥"\u0089\u0094ÀÑj\u0014\t´=¡Í2\u009d¡b\rë*Ò2ñ\u0091*ý\u0016hß«z>g:Æ\u0086¾ÏÙV¹¥K9#½ªÛ\u0002]QÛ¶ìÎÍ\u0094nv¦-m\u0095¾Î½\u0086v^g-£*6`Ja©Èà#Y\u0090\u00ad"\u000bGANÅ\rlª¸\u0089\u0094\u008a-|,Ðûì÷\u0083g+[ò\f*øDÅ§øLÅç¸¥â\u000b|©â+|\u00adâ\u001b|+ÐXyvy\u0002Ê\u001a) î\'ð1MnÄBÊ¶6\u008bw{/(æè¶æX,£Ö(\u001e~>\fWÙ¹Ê##\u001f\u000bI\u008eÀ±=×þ\u009b(\u0011¾DÚÊÊWFîÙ$v tð$õ\u001c0\u0015;\u0011©À\u0017/èÓð~Ç*\u0098x¤B\u0007\u0081DôV©`ª\n-nýµ|/âº#·¿ÿ\u008eÐ\u0014)ãÚÅø\u008d\u0012y\u00adeðÇ¤2FIiÙ\u0019ý&Ñ^Ó\u001dÊ«,=A\u008d\u00955ò²ñÙ¶\u009dì\u0092áð¾´Tã\u0091mªMëfR\u0002Øµ\u0018/}6·\u0092-Æ·\u0084bU\tñ$eñgþ\u0087èRe\u001evXà|\u0015ø3%Àó\bò_\rà¹¡~\u008ac\u0017g5hçOÈW\u0082ò\f-a\u008e\u0082£¯÷\u001eÄï.¤\u009b²Ö5\u0006\u0011¢T\u000b\u0000ô \u0097c\u001dúÐO\u0014\u0083Å_ð\u0012\tü¶\u008b\u009aå{ðLõæáý\u0011¾¾»»ðÑP;½\u000be\u0099\u0099ý3ý\u0003yÔñ\u0017Ø\u0086:â\u0095JÐ{\u007f\u001b\u009d3»P\u0097wÑ@ô¡æÃy42ES\u001eÍ\u0003÷pä~\u007f\u001eGwÐ"03°\u0083V\u0081;¸L¥M`Ä\u001bôæq¬¹=\u008fçî ¿4éÈãø\u0088/è£ö\u0013Zú\u0082>×u\u0082Þ\u001d\u009cô`iûÑNß]xÈG7\u0006Yø Îºc\u0010Ã\u0018A=·#7?\u008f£\u0094ÇáÇ\t\u001cÆI4¹lv1ê4ýÝ$ Ä¨n¼Ìq\u0098³\u0011R\u0013!9K\u0018\u0080MÏ-²z\u009b\u0099\u007fÀ9üBÔ¯\u0018r\u0089\u009cäWÊ)´\u00105È\u001a"è î,µÛìÊ9z|\u008c~\u0085_=/±\u000e\u0092ÊÈ!\u008e~üLë0\u009b\u0010Ä÷8\u008fWIþH±-\u0005_\u0084Ú\u0005÷{Éÿ\u0010M\nF\u001f1µWÁ\u0018U\u0005>\u0085Ë\n\u0005¯=\u0080ÿ\u0092\u0082ú\u008e\u0087¨Spñ\u001fL<`¦×Ý\u0096_b\u0086qW»ü\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ª=©\u000f°\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000org/gradle/wrapper/WrapperConfiguration.class\u008d\u0093mO\u0013A\u0010Çg¡ôÚãJK\u009f\u0004|\u0002\u0015i\u000fá¤\n\n"\tHUL\u0015C\u0005\u0012ß\u0090-\u009cåH¹\u0092»«&~*M$&¾ð\u0003ø¡\u008c3w\u000b\u0094e\u009b\u0098&3³3ó\u009fýíîõÏß_¿\u0001 \u0002Ë:¤ÀÒàa\u0002æ\u0092`@E\u0083G\txLá<\u0099\u00052OÈ<%³¨Á\u0092\u0006Ï\u0018\u0018\u0007\u008e\u001fxN£\u00138m\u0097ÁPí\u0088\u007fæ\u0096k\u0007ÖöÖ\u0006Ö3Ýõ5îÛ\f²QO\u008b»M«\u008e5·)÷½çÁ!\u0083Bwª~È+ó\u000bõÎ1\u0003í«s\u0012M¢(ê\u008d/;®\u0013¬0è/\u0095w\u0018Ä^´\u000f°\u009e®9®ý®sÜ°½\u000f¼Ñ\n÷nïóÖ\u000e÷\u001cZ\u008bd,8t|\u0006åZÛkZM\u008f\u001f´lë\u008bÇONlÏÚ\u008dü\u008b¶ûÉiv<N,\u0088\u009bnÚÁú¥\u0093gJeùìi_n\u001a.]î!Ö\u009c4*:ZþlÜåkÊùªæBéj¯jttWò\u008c(;"õv]ø\u0088ß³¤£êãÙsè~÷"ªDÃEE,êí\u008e·o¿tèîGU\u0017<K§1 \b×\u0018\u008c+\u001e\u0085æ¬ú¾}\u008cÏçáÕ¿ÚZ]¯U÷¶ëÕ\u00ad½×\u009bo«\u0006d`\u0098Á\u0098Bºáú\u0001oµ\u0018¤Î2ô\u0095ù\u0006daØ\u0080<\u0099\u0002\u0099!H\u001b\u0090£)SÿùU ÇÅ#l6\u008eìý\u0000&ð¯\u0092ÂÿW\u001cúh"F}\u0084\u0016ú¬ð9áóÂ\u0017B\u009f\u0002FçG;\u0082«]Ì3ô7Í\u009fÀÌlÿ)ÄÌlü\u0014´0N\u0084qò{(\u001fE[\u0084\u0001´y\u0088a¤ã\u0090\ff\u008b0\u0086?@ p\u0010\\\u0087\u001bè\u0019F·Ä&\u0016zª\r\u0098?@ÿv>,.\u0004\u0017â\u0081sñm\u0018\u0017â\u0015ìî£nsú\u0014ô\u000b\u0014=ÌN æN8¡\u0018u\u0089\t\u0014Ñ½ÐÆ\u0013Øq\u0015$&\u0083L*AîÂ=\u0015HL\u0006)£Æì\u0001B\u000fC\u001bO*A4\u0019dF\tr_\r¢É s¨©ô\u0000É\n\u0090)%È \f2¯\u0004)©A\u0006e\u0090EÔ,õ\u0000É\t\u0090²\u0012$!\u0083<W\u0082\u0098j\u0090\u0084\f²\u008a\u009aµ\u001e y\u00012\u00ad\u0004IÊ U%È\u00035HR\u0006Ù@Í\u009b\u001e \u0005\u00012\u0013jfÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Gü¨\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000org/gradle/wrapper/WrapperExecutor.class\u0095W÷\u007f\u0013ç\u0019ÿ\u009e-ùäãX2\u0006l\f\u0011Æ\u0080\u0090l\f\u0004\b+¤Ø\u0098âÖCµl\u0088!\u00ad9Kgû@Ö)§\u0013à\u0014\u009aÑÒt¤+m\u009a\u0090îtÐ\u0099\u0098\u0016l\u001a7¡\u0013Útï½ûgäÓöyÞ;¤\u00938(ýAïz\u009e÷ûìç=½òï\u0017_\u0006°\u0005ÿ\u0092ñ\u0088\u008cGCxLA\u0015Þ*ãm\n\u00828§@ÂÛùäq\u0019ï\bá\u009d2Þ¥à\fÞ\u00ad \u0016O(\u0098\u0087s2Þ£`!ÎÕ\u0012ç{yx\u001f\u000fïç\u008b\u001fàáI¦~0\u0084\u000fñü\u0014\u009f|\u0098WO\u0087ð\fÏçyx6\u0084\u008fðüQ&\u007f\u008cW\u001f\u000fá\u0013<\u007f\u0092\u0087O\u0085ð\u001cÏ\u009fæá32>\u001bÂçX\u0081\u000bÌþy\u0005wã\u000b¬â\u0017yõ%^}9\u0084¯°úÏ3Ã\u000b2¦y~\u009eÉOÈ¸¨`;¾Êä¯)Hã\u0012\u0083^V0\u0083Y\u0005Wðõ\u0010^\u0094Ð°¿;98ÐÝ14ØÝß724Ð3\u0092\u0018èOt\r\f\u000eK\b÷\u001c×Njí\u0019-;Þ\u009e´-#;¾[ÂüN3\u009b·µ¬}HË\u0014t\t\u008de\u0000\u001dû\u0092]\u001e\u0084rbbßàA\u000fqy\u00191ypßÈ\u0096mÛG\u0092C½\u0012\u0096\u001déN\u008c$\u0007û\u0007º*\u0011=\u0094\n8%g\u00999Ý²\r=/a©£zÁ62í\u0089â9©¿ ÄuÀÈ\u0090þ\u000b\u001cNÃlç=qÔ¤Ìì\u00981.aC\u008fi\u008d·\u008f[Z:£·\u009f²´\u001cÝk?ìÌ\u009d\u0082§`i¶aféRÝ\u0098i\u0091\u009cãzÊÞoX4\u009aÖ\u0094\u0084\u00adÑrðÛ!v\u009dÖS\u0005ºF`\u0081N3M\u009a-ì1²z_arT·\u0006µQÖ5Üc¦´Ì!Í2xï\u001e²Ý®\\ò)éá\u0002&*\f\u009d\u009f´µÔ\u0089^-çÞ«Ùcd\r{¯\u0084õ\u0015Zú»nÃ!\t\u0012]«÷$E×é\u0094\u009es=\u0010°\'\fr|Ë\u009d\u0099¸4gé9ÍÒ÷\u001byJ¬Ñ\u0002\u0083\fY\u0086\u0084EÑ\r\u008e\u0080¬n·\u000f\rts@òfÁJ\u0095BU¢(E\u0005ò2æÈDK×Ò\u0002Ò\u001c²2t!cjé\u0084\'-BF\u0096\u0012Y×&\u008bv\u0090ÑÝÙ\\Áv\u008ewËø\u0086\u008c\u0097d¼Lî\u001f×m¯z¤\u001b\u009d\u0094\u0005^B<úÿd\u0089¬\u000b\u000f\u0090)G£Go..?¤n.¶LÆ\u0097Öa\u009a6é§åz5¶K³lÝ\u0012q\nhÖ8Y[ç#\u0083\u00940\u001cH\tM·\u0013(aÉ¨\u000fþ-ÊÂW\u0015\n\u0090ÃvÐ\u009c$\u009bç\u0091ûÜ`Pm¬\u008bÞ¬Ü\u0006?}U·b§ú4FÙásïN\u0091Òú\u0098VÈÜè\\;ï\bé\u0088/TÈÒ\u001f,P¡§©(\u008eH\b\u009edH\u0019W)¯(±MËî5òyb-Ù«$E\u0016;µ¸¤¢"6²\b\tÍÿ»vÈ\no±J\u0088Vð;Û6w»±ÔîT\fâ\u009b$Ú¯º\u0099ö-\u001e\u0086T|\u001bß¡Æ]²y \u0090µ\u008dI½Xj\u0012Z]\u009d"%ðÈ\u0018)\u0013Y¿6¿>\u00926i\u009b5í\u0088~\u009aªg#\u0095M\t«\u007f\u0094;\u0095\u008aïâ{,í\u001a5\u009f;¬\u001e\u0015¯ÃëU\u001cÀkU\u001cD·\n\u008du=\u0082£*®ãû$$í)Õ\u000e-¯«ø\u0001^Q\u0091ÇI\u0015?dIe\u001c\tÍ\u009ePñ#æø1\u0013ë½Ää\u0084F/Q²0©â\'\u000eÆi\u0015?e6õ!#\u0097¤(è\u008e\u0084\u009f1õçe\u0004\u0007ø\u0017Lø%\u0013ê|º%y°Ó,dÒÂKÜ¢"§|\u001cj\u0099\u0093Â¡\u001bÙS¿Rq\u008cmý5\u0003ÿ\u0006¿Uñ;^ý\u001eG©Q¥Ë\u009ah\u0086\u0015&\u001f\u009f\u0085}#YÜ\u008eI¯§7w<}\u008fEüAÅ\u001fñ\'\u0015\u007fæL\u0018ÇQ\u0019\u007fQñWüMÆßUü\u0003ÿ\u0094°¯Ï\u008c\u0088D\u008f\u009c2ì\u0089È\t}Ê\u0089x>§§\u008c1COG\u008c¬¯)7r\u0083\u0092a\u0085W¡äTÖÖN{üRçÓ\u0093Ë|88a\u0099§\u009c÷«ÄÛïAXTY¬\u0012Öø¾oeÝ\u0082zfu\u0094Ç\u001a\u0091´y±¥º®¡çtR³ý{\u0085·»:\u0089íßvêý:\u001dÉZ\u0098¯|`\u0016GË_8æª«x\u00868ó¨\u008a£¾¢êò~Ì\u0095\u0010\u009c£7ó:§Ë+x\u008bµ@¤ü-I\nÝ:bä\u001cqJÞ»q(\u000e¸Kq6±Û·ßb¤\u0085\u0017j\t&\u0099\u009aÐù\u0005\u0098Ïï\b};dm§\u0003\u0016?\u0019JßpõEö¤\u0093\u009b)º@a\fÚ¦¨\u0083Å\u0095\u001fführ%\u0092\u0095Qß\u000f\u0003æ\b¦2&ÛÔxëg\u0093lL\u0011¿->lDÚÜé×ÁM6øuF¿g\u0096ôÊÛÂº\u0016ß\u008f\u008a\nC±\u009aþ!Ì£\u007fBµhÀ^ÜG»×Ð®\n\u009bh¿Ï³_Fû\u000eÏ~\u0005í;=ûU´ßïÙ7Ó¾Ë³_\u008b0·kZ\u0087¹c\u008b\u0099z8ÍóIv\u000fz\u0089³\u008fv\u009d¨¡\u0015Ð0\u0007ix\u000eUÃ±põ,\u0002s\b\u000eÏ¢f\u0016ò´\u0080ë§Ña\\\u0087\u0004\u008dªs\to\u0010Ðµ\u0018(\u0002\u008eC\u0016´ÖØ\fBÏbù\u001cj\u0087ÃJà%Ì\u001b®\u008e%¯@\u009dÅü«,,V.£ZÈX@3\u0010#\u008c8\u009aÐæ\u0091Õê\u009a\u0091\u0014¼R\u0013Mô`:B¥ûéB\u0080N¦c³X@À\u000b\txÑe,\u008eµ^F8\u0016¿\u008cº8is\u001eOÆ[¯`Iì\u0012QfQ?\u0083¥b\u0019^ÆÓ\f\u0096Ï¢a\u0006\u008dÎÙ\nç¬I\u009c\u00adtÎV9gw\u0091\u0087"3Xí\u001c6;\u0087k\u0004c\u008bs¶Ö9[\'ÎÖ_@c\u009fpÃ\u0006Ç\rqvCÛ,bW/\u0092þ\u0011<\u0085g\u0010u\u001dÐ\u0081E4n"kÖÐÿÅÍXBÿ\u0099\u001bè\u000fe\u0004Û(¦Û\u0089r\u000fÅ}\u0007îÇNLb\u0017\u001eÅnº¿\u0097\u0010öà<îÅ\u000b\u0014ÿ\u0084pa\u0080öKq\b\u0087\u0085K§éÆ0 VìHI¬8Cª\u0084K\u0097¢ê?\u0004RMÁ\u0093Q%Ó¿V\u009a£tÊ¯<\u008d\u001cZ\u008b0«hn!çÅ{È£\u00ad×9o(g.¡n\u0006mt²\u0091rg\u0006íÓñRHÃ"2\u009d\u0084¸\u001fü\tÑLò\u0013\u008eDÆrõ\nâ.<\u00807\u0092^¬M\bÒ«h\u0096Éî7Ñ.@§#Ä}¬¨É\u0003â\f"\u0004áð¦\u0019l¾\u000e%\u0016Þ4\u008b-\u0087çp÷°Xn\u009dÅ¶ÊÌê%\u0015úPG\n\u00942kµ«\u0082\u009bYu\u001e\u0099\n\u007fè¸2\u009f&"[²r\u000eÛ\u0087É\u0003÷ôÆ[g°\u0083~;/@éã¹M\u0004´\u0096dÕ\u0017å®¢ÔäT\u00ad¥P, Ia\u0092UOs#ÍMä\\Ö#"t[éf8¯80\u008c´\u0004£HyCTÏ!âøÈHs\u0088ô\u009a¢ºcô£/\u0007·\u000e·ÐÌÖ\u0085\u009cTÜUYÇÇ<\u001e\b¹\u001e\u00900\u0001Ã½ßîÞ\u000fòýÊËã\u009eËÁâåã8áú*C\u0006\u00059ö\u00ad\u008eôÝ»\u0002mñ\u0006Ê\u008c=\u0017\u008bHN@N\u0090\u008f3XL¹Ì\u0088[\u009d[Å\\\r\u0013mRH\t#\u000bSdL\u00189<Hw\u0015RÛ"\u0087\u0005\u008a\u000e\u0088\u0012\u009d>¾\\\u0003ö¸Ù\u001a\u008aÅ¥\u0000\u0015l¥\r9O\u0016\u0086\u008a\u0012C(\u0088.ÊH\']¤\u0003\u0084Tí µú!Ù\u009e Þ\u008cÄ«S´ª\u0012\u0098§]Ìçh\u0017\u0014µD\u0019L\u0085³yW !p\r5\r\u0081éÖk\b¶N¯<\u008fÚX\u009c\u0012zZ*%q3a\u00810\u0014LQwx\u0088|q\u0086,8\u008båx\u0098\u0092é\u0011¢?æñcKQ\u0097\u0096¢.-®.¼\u009a"\u0004öc#ÞLg\u0001\u0091d\nª_EXÆ\u0099`-q\u009d-z3AiÌ·\u009aD#»7è6²á\u0000×þ\u008d¶^á\u0097Ç=\u001en*êÒäê"á-\u0082ÿáÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Ôe\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000gradle-wrapper-classpath.properties+(ÊÏJM.)¶M/JLÉIÕMÎÉä**Í+ÉÌMµå\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000gradle-wrapper-parameter-names.properties\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000org/gradle/cli/\u0003\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ÕÜ?®<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.class\u0095T]o\u0012A\u0014=\u0003\u000b\u008bëÚ"¶µ~C?\u0094\u008fR*O¦\u0010\u0012Òh4!\u00ad\u0011ÒÄÇaY×m`\u0097\fC£\u007fÂß¢/4ÑÄ\u001fà\u008f2Þ\u001d\u0090P\u0096´ôaçÞ9{ï¹sæÞÝ?\u007f\u007fþ\u0006PFÙ@\u0002;:v\rD°c@ÇóÀ{\u0011xY\u001d9\u001dy\u001d\u0005\u0086xÕõ\\Yc\u0088fs§\fÚ\u0091ß±\u0019V\u001b®g\u001f\u000f{m[´x»KHªá[¼{Ê\u0085\u001bì\' &?»\u0003\u0086bÃ\u0017NÉ\u0011¼ÓµKV×-ÕÛ\u0003)¸%\u008fü^\u008f{\u009d\u0080ìÈ÷Îm!mQaØ¸Ìõµÿ\u009f¯|\u0013¢j«U©\u0011\u009bn\u008d\u0011\u0086Ãlã\u008c\u009fóR\u0097{Né\u001d\u0085\u0004¬\u0095\u0019ì¤}f[²\u0092\u000bC¤\u0085\u000b\u0087´¬-¢ k\u0092ôÚ\u0096Á=,È\u008d÷¹\u0018Ø\u0082ak^ÀÌÁß«\u0018\u008a^tÊê\fÖ\u0094Âõ\u001c¥-J\u001a\u0019\u008c×_,»/]ß\u001bèØc¸Õt\u001d\u008fË¡ +;X\u009a\u008d¨r\u008aîCµu\u0018VQ\u000bCW\u0088\tuÁhúCaÙoÜ \u008f\u0099«ú¶\u001fÔ1aà6Cúºë2QÄ¾\u0089\u0012\u000eLÜÃK\u0086Â\r&\u0084!9¯\u0089a{\tQá23Quá\f{¶\'§M¡\u0086Ð\b~r\u001dÕ\u0090Ýìõ3\u0010|i153\f¯\u0016\u000emn\u009eDevf¨èÎß\u0086J\u0085£\u0096\u009a~-C\u007f\u0085\u0004H\bý;"d©9´\u009a´«\u0093edcù\u000b°\u001fäDq\u0087Ö¸\u0002SX¡Õ\u001c\u0007`\u0015I²w/!)²\u008c:·Fy\u0001Ý7²\u001aÙÍ_\u0088|¼@ô8_\u001cAË\u0017\u000b#ÄöF\u0088\u007f\u009fVX!\u000bÊK`\u009dö\u001bªR~\u009c;©\u0014xëô\u0086)ï>=\u0011\u008aNâ\u0001\u001eRnp\u008e´âØ\u009c\u009cc\u001cÿh\u001aÿ\u0098â\u009f\u0090¯\u0011ò\u0014Ï\u0094ô4=c/\u0083-e·ÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000×\u0083µ³X\u0004\u0000\u0000ì\n\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.class\u00adV[W\u001bU\u0014þN2ÉÀ0å\u0012\tH¡\u0015°Ô\u0084¤ÄKKµIQJ©\u008d\u0086\u008b¦\u0082Ø\u001a;L\u00860\u0010fâÌ\u0004áOøîZ¾ûZ_¢t\u00adºúìÿñA\u0097·}N.\u0010\u0012iÊ2Y9çì}öÞç;ûvòëßO\u007f\u0001ð6¾Q0\u008c÷e| `\bó|¸£`\u0001w\u0015,â\u001e\'?ä«û\nÒøHÁÇÈô`\tË=\u0098Å\n\u001fV»ð\u0089\u0002\u001f>íB¶\u0007\u0083xÀ\u0089Ïø°&c\u009dë\u007f.cCÆ\u0017\fÁ\u0094i\u0099Þ\u001c\u0083?\u0012]c\u0090\u0016ì¼ÁÐ\u00971-c¹¼·i8\u000f´Í"qB\u0019[×\u008ak\u009acrºÆ\u0094¼mÓe¸\u0099±\u009dB¢àhù¢\u0091Ð\u008bfb~Óõ\u001cM÷V\u001d»d8\u009ei¸\u000böÞ\u009efå¹Ù\u0005ÛÚ\'¦á$\u0019\u0006\nF]èp¥ä\u0099¶Å0\u0018\u0089fv´}-QÔ¬B"ë9¦U Ñ\u0091\u0016Ñ»\u0086§\u0099E#Ï0ÖfÏÕ\u001d³f±[·\u00ad-³Pv\bòTä4Ø\u0013ÐV5Ç%\\Ü\u0011Á\u0092X3L¾X\u009e¤íÚQgIW\u0091\u0091´¬W]Àp§\u0005\u008d0\u0099?¡\u0095¬:£ì\u0099ÅÄ\u0092VJFOÑ\u0014¹\u0092MA`i\nÒ®q¸¦\u0015ËÆâAÉ1\\W@\nµó¦\\\u0005ì¶AÜ\u008a\u0080A)5"É\u0093ã4\u0082¡æä8,Õ\u0013äF³hª\u0015J+g\u008e\f^Èz\u009a¾K\u001aÂ\u008e\u008c\u0087\u0004añ@7ª e<¢ fÍ\u0082¥y"¨ß¾´\u001b;D\u0012=\'þû\u001d\u0003\u0012\u009a+\u009b;\u0086î%£\u00ad,\u0086ü\u007f\u0015W»\u0092J\u009d\u000b/G¬dí²£\u001b÷L\u001e¶Xg\u0005<Ãm©x\u0015#\fý§íªx\rã*&0.ãK\u0015o \'ã+\u0015\u008fA\u001a\u0093|g\u0013º\u008c<ß¡\u0000o©(`[\u0086©b\u0007»*\u008aØSaÁ¦¼¾\u00ad¢\u0084¯\u0019 Â\u0081«ÂC\u0099\u000fû\u0094%M\u0097U\u0011Å4¥Ü¹z\u0011Ýù%ÜLEu|t\u009a\u0018\u009ag·1qBuÞ)\u0094÷\fËk$1Ãø\u008bú\n5ÖÈÃÖxE;i1g\u0018¯÷Yu[së°¨ª¯D:2ÜKZMÍu6ò?Al©\u0010\u0086T\'¶[ô\u001a\'\\íL\u0092z\t½\u001f¢o\u0092\u001fB\u0091\u0093E\u009f1]^\u0084½Í\u001c\u0086.³\u0011õ¡&\u0085z6ð\u001eK®Z6\u000e<ñ¶ÒS+Y\u0082h~ß\u001au.\u009bVÞ8XÙb\b·»u\u009a÷ù2©¿\u001biÕî°\u0095t»e\u009eÔd\u008f£N§Û¾³áH;¾4A\u007f\u001a\u0086Á?2\u0018/y\u001a/\u0012\u0095 \u0099j\u0013\u0081é\u009fÀ~¤\u0085\u000f£4\u0006\u00053\u008c1ðº\u0015\u0002¸\u0084Ë\u0080$ñ¾ æ\u0089Ú<Ég\u0092y\u001dWjFK$í§ùj,ð\f¾\rÿt\u0005þì\u0086D\u0093\u0094\u00ad °\u0014¯ ¸\u0014\'R® kýøÔ\u0010$\u001aG\tè\u0018}/a\u008aNä\bÆ«Öª\bÄj\u008a~\u008cäú¨ýDH\u009bñæARüôßèô Í¹\u0018?·\u0082î\n\u0094#ô0,_;\u0082Êð\u001d\u0016iq\u0081á9|·¤\u0011)Ô[Aßl \u001cø\u001e\u0003q"û\u008f0àÇú\u000f\u0018%Ê\u001f\u000eT\u0010\u001a\u0091Â\u0001éq\u0005¯Ô¶þù9þ\u0084N\u0090\u0004êËäR\u00907¦È\u00133ä\u0085wÈ\u000fó\u0084o\u0083\u0090="\\ü\u0006×\tÓ\fbô\u008dÓj\u008aèkDóÛæ\u001a·ÊQ0Þ\u0014¾Îá-ú\u0013é#KuïsÎuâÜ\u0010Q\u0091þÄ\u0080\u008cÙ¿\u0090\u0090ác¿cø\u000fÚº)\u0000Q\u0082á=áÐ[ýótx\u0092V\u0017\u0005\u0000¿p¢2\u001d\u008b?Ç`\u0005á\'g\u0004[©\u0081:¶é«YMá¶\u0098çþ\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adÎyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000org/gradle/cli/CommandLineArgumentException.class\u0095\u0091ÍJ\u00031\u0014\u0085Oú3£µ¶Zm+êÂî´U\u0007ÜV\n"\nÂàÂ\u0096îÓi\u0098Ff\u0012ÉÌ¨¯åªàÂ\u0007ð¡Ä$-U´\bfq\u0093{rïwOÈûÇë\u001b\u008034K(`Ë\u0084m\u0017u\u0017\r\u0002ç\u009c\u000b\u009eö\bê\u0087þ=}¤^DEèõSÅEØ=\u001a\u0012\u0014.å\u0098\u0011T}.Øm\u0016\u008f\u0098\u001aÐQ¤\u0095\u009a/\u0003\u001a\r©â&\u009f\u008b\u0085tÂ\u0013\u0082\u0013_ªÐ\u000b\u0015\u001dGÌ\u000b"î]Ê8¦bl \u0017*Ìb&Ò«ç\u0080=¤\\\u008a.\u0081\u001b³$¡¡¥þrAÐ^âí\u009b2\u0098(ùdæ[ÃÅ\u0080f\u0089&Õ\u0097V\u0010\u0094ú2S\u0001»æÆoë/c§\u0006PF\u0011\u008e\t\u0015\u0082Î?^E°û5ÿ.\u0013)\u008fÙâ\u0012-äõ/\u0098\u0095\u00031\u0013ttuÖÓyNïN»3\u0005y±÷+:\u0096¬ÚÔ\u0095;XÕ§Æ¬Jëk\u0096â \u008cuÍ0¬Ê\u009cu£gäõî¶;ÇSä~ÂötÓ¾\u0085\u001dÌÊ\u00160w\u000e3§*6¬ÅMÛ]û\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000³ßâú\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000org/gradle/cli/CommandLineConverter.class\u008dQMKÃ@\u0010}ÓÖÆÔ¯ª\'Ï"4\nF<6¥ EQ\b($xß¦ë²%ÝÈvSúÛ<ø\u0003üQâ6\u0085\u0012L\n]XvæÍ¾÷\u0086\u0099\u009fß¯o\u0000÷8wÐupJp\u0092L-¸6\u0084~/\u009c²\u0005óS¦\u0084ÿb¸fã\u0094\u0007%ìu<å\u0089\t¼*Dè<.\u0013þid¦æ\u000eÎ\bn$\u0085b&×\u009cpW\'<(a\u0091ÑR\u0089`\u0018ÄqàÙKxî\u0085\u0099\u0016¾Ðl\u0092r?I¥ÿÆô\u009cOFÙlÆÔ$\u0094jçÎ®w\u0090Úøºv\u001a\u001fR\u0014m_U\u0088%J¡¡\u0003ï\u009dÐ\u001bÄýªñ°vJQ\u0096ë\u0084?ÉÔê_\u0094äFë%p}»b\u0011.·;o¾\u0012ºÿ-\b7Û\u0089\u000fZä3®ÌfSm\u0002¡\u0081Õi¶\bM´l¶g³\u0096ÅÛplÔÀ~Qqk*\u001d[9Àa\u0011¯\u0091#\u001c\u0017ïÉ\u001fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\nÕ\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineOption.class\u009dV[w\u0013U\u0018Ý\u0093¦\u009d4\u0099^\u0088´i¡\\ä"iB\u001bµ´ \u00adÜZ.Å^ÐÖ\u0016\u008a\bÓdL\u0007¦\u00990\u0099p\u0011ïwü\u0007¼ø¦¼ð .\u0081UYËå\u0093\u000f¾ù\u0017ü\u0019.\u0097¸Ïd:\u0099Ü¤Ë\u0087\u009có\u009ds¾³¿ÛþNæ÷\u007f~þ\u0005ÀËø&\u008cm8\'ã|\u0018\u0001\u009ckE\u001f\u0096Zq\u0001o\u000bé¢\u0018Þ\u0089à\u0010.Eð\n.\u008bA\u0095±\u001cA\u001a\u0019\u0019\u009a\u008cwÃh/ÝÊ\niEHz\bWÂ\u009c¯\u008a\u0085\u0011Âª8É\u0089Á\u0014C^Ü¾&\u0006KFA\u0086-A6ó¶næ\n\u0012:¦®¨×ÕTÑÖ\u008dÔ\u009cf\u008fJh\u009dÓ³9Õ.Z\u009a\u0084Ý\u0095§c¥¥¡æ²©9ÛÒsÙÑÃ¼¡¨V¶¸ªåìù[y^ÚäÓ\u001a7ÔB\u0081*\u009b«÷Æ\u0012âf$£\u0015Ò\u0096î8#!Z\u000b/!¬çÒÅeÕæJ\u0082´Dÿ²\u0096YÌ/êö\u008a\u0084¡jÿL+\u009bÊZjÆÐRiCO\u008d\u009b««j.3¥ç´YÇ\u0088ão8£å--\u00adÚZFBË\u0098\u009eÓíÃ\u0012bq\u009fùI[³ÔeC\u001bí_\u0090\u0010\u001c73\u009aH\u0015af\u008a«Ë\u009a5/Î\u0084ÃfZ5\u0016TK\u0017kw³ÅtÃ\tÚ+:3¼ëÙNUæÇ³-¡»Ò\u0000Óë\u001a©çk\u0083ê´ÍÙjúê´\u009aw®Ê(Ê¸.!¹a\u0004\u0091\u0081pV³g×)³)Þ_C\u009a½Õ{\r\u009c\u0089¬¨\u0085c.[$\fÇk¨Ò¿\u0091l\u001dª¹\'è´¡«{â\u001bRS|~2ävÆ?á§êæõx+ÉÚbi\u0085¢ÁÈzkN\u008f\u0017u#£Y¢ j>¯å2ÓZ¡ fYËT¼¡òR\u00ad\u0011Q\u008e\u0096\u0012\u0002ûxu\u001d¤\u009d\u000eWx8R\u008bº±\fE\u0019ë1Ã0oø\u0013Ð\u0014ïgëmñ\u008e¦\u0019¥\u009e74\u009f\u008a¢Ó\u0081r_q9éë\\\u0085WO\u0095\u001bw¸\u0096/\u001bjÝh¼\u008az"\u001d#ñÿ\u0081åÐzÎ,Zií¤.Zª»FkP *Ø\u008f\u001b$}ÙÂiµ°B+\n¶c\u0087\u008c\u009b\nna·\u0082]bèÇ\u000e\u0005ïá¶\u0082÷1£à\u0003|(¡³º\f2>Rð1>aÑÊ Sz\u0081´\u00895 \u0082\u0082½xAÁ$>U\u0090D\u009cé¼P~Ã.*8\u0085Ó\nö\u0095\u000eÊï%\u000f>Ã\u0084\u0082Ïñ\u0085¸û¥\u0082¯ðµ\u0082;ÂôÎg¥¨ÂñÙå+Z\u009aþEkß\u008cõM\'\ngÓ6-\u00870\u000bë\u0001:ú\u000b¦NV\u0004çÏ\u009f=!!¤{\u008aÝ\u0015LX\u0007`©e2zF»I«Á\u009c3Uö\\É%ÑN\u0015µ§e5CC]ñZ]Aá\u0081ºmÑ¸YC¶YÚb×\u0019Z.+ÈËØ&%ôÅÇÿëb\u000bÝ`¯ð)ð³sÜ4\fº"((¼á{±j^×ð<ÿ¸·ñë \u0005QÁ*°>\\\u0005¸\u001f\u0010ÄòÖ{ø#\u0013\u001c\u0099åæ\u001c\u0015\u009cóÎ\u0013ü%\u009dýNîíÇ\u0000×\u0083\\ý\u0081&\u00049\u009fI<\u0086\u0094x\u0082ÀùÇhz\u0088`âG4?DKyGN®!$azÿ\u001aZ%ÜÅV\na\t¿"2\u0093ø\tÁ\u00815(\u0001,Þ{úç\u0003¢\u0005\u0091â¸\u000b!\u008eÛ¹\u008a¡\u0003=èÆVú½\u0003£ôé$¥Ij¼H\u008d\u009dôa\u0014\u0011¼Dÿ\u009b\u0084/ü\u0016\u001a\u0002\u001ci;\u000eÐßaÊ\nçÒÎ\b¥\u0083\u0094»\u0010xÊ\u0090\u009adôÉ8$ó\u008b\b\u007f\u0011¬\u0014ð«T\u001aÅ\u0098\u001bf\u008a+q½Yøú\u0083£\u0090r²*6÷:^\u0094ð\u009b]Û%\u0090×¸w\u0018G\\\u009078\u00078Ë\u0089¤H\u008d\u0080ir`ÂÎv?/\'\u001c¨î\u0092\u009a\u0017\u0086ì\u0096ª\u001c\u0086ØÙã\u0015ç¨cæ\u0018Gaf\u0084;B\'\u0094\u0088FÖí\u0004|v\u0006évÊçrÈµ#áx=\u008c¶z\u0018CÄ8P\u0017c\u001c\u0013.Æ\u001d\u0016ÎÑ}\u0082vr c\u008a¹ëü\rJRÌ\u008f°i1!¤hô¹ÇØì\u0088]Ñn\u008aÉG\u0088\u0095S³\u0085\u0086À¯Ö\u0010«ÓÁ¢ô0§»\u0019ì \u0083.§jÈ5\u001f"GO\u0090\u001b¥ú\u0086 ý\u008d\u001e\u0099\u001fª\u0001ñ\u008e¹nÝæJ0¶·ï.b4Öó-ÂÉÎ\u009d\u008fÐ»\u0098\u001c\u0010n=ð\u008cw³"`<A\u0082F\b\u001b%H\u000f)$\f\'J ^\u008dz]ÃB\u009a$«\u0002\u008etÆ¡äA\u0087Ò\u0081h3Ï_Ç\u0094ëÈ\u0011?\u001d:kR<Mã3\rè :U\u0010r\u009a\u001a%°\u0013nÁ:\u0099Ç\u0016öÞw\u0090\u0083÷\u0010lºï\u0005Sâê\u009b¾¢uº\u0088\u0007\u001dÞ\u0006Ú\u008f\nÈY\u000frÂ\u0085ì\u0010\u0090Ñ¶ï\u001b .ø\u0010;*\u0011Û\u001cÄ¤Çªa\u0017QN\u0004\u001f"Z\u0013ñ\u0012ï\\ð¡É\u001e©öÕ\u0087èª\u0081¸D\u0088Ëu!Îzqù{9z¿ª\u00973uzYbçÖ»ÜU}y¥Îe\u0091òz¯\u0088\\ý\u008a\u0018\r_\u00919çq\u0098wA4\u009761\u0001ÂGu\u000b\u009fM!&Ö°\u0095b\u0099½íÎc\u0098\'s¯\u0091B\u0096\u008fJ1Ï·\u0098û§P~YÄNÂ{YÞ¢´àH\u008bÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000üí\u008a¯¥\u0000\u0000\u0000å\u0000\u0000\u0000(\u0000\u0000\u0000org/gradle/cli/CommandLineParser$1.class\u0085\u008cA\nÂ0\u0010Eÿhµµ\nvåº\u0088k\u0083^¡(\b\u008a\u0082\'\u0088íP[Ò\u0004\u0092êá\\x\u0000\u000f%¦¸tá\fó\u0087\u000fïÿ×ûñ\u0004°Æ8D\u0018bD\u0088ÏæfsÞV\u008a\t³Ì4\u008dÔÅ¾Ò|\u0092Ö±]Öò.\tÓ\u008dÎ\u0095q\u0095.\u000fÜ^M\u0011"&Ì\u008d-Eie¡Xäª\u0012?áÅ\u008a0ÙiÍ6SÒ9v\u0084¤ë\u0013JêR\u001c/5ç-!ýW\u0093¤ ôð\u009d¾_x\u0017`à\u007f\u0080¡×È_ì\u0019ê\u0080$ú\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099ÐÆ\u00adN\u0003\u0000\u0000å\t\u0000\u0000;\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classÅVëN\u0013Q\u0010þN[8e[ TA¼#V\u0084¶Ð\u000b" \u0088\u0016\u0094\u008b\u0014\nAIðß²¬u¡ì\u0092í"¾\u0082Ïá\u000b`¢A%1þ3ñQ|\u0006c\u009c³[ X`\u000b!ñÏ9sfæ|sÙ\u0099ÙóóÏ×o\u0000Ò\u0098\u0097Ð\u0080D\u001d-I\t\u008dHHH!\u001d@/îqôqÜ\u0017\u0092\u0001\t\u001c\u0083\u001c\u000f8\u0086%\u00040"AÂ#\u008eÇ\u001c\u0019\u0086ZëµV\u008c$\u0019Ú³\u0086\u0099OäMy¥ &\u0094\u0082\u0096\u00183Ö×e}%«éê\u009cl\u0016Us\u0088´\u00875]³F\u0018&:ÝÕÿÕ°Ù+ezC]\u008b\f¾1cEeh\u0014\u008cÙÍõeÕ|./\u0017\u0088\u0013Î\u001a\u008a\\X\u0094MM\u009cKL\u009fp\u0097ábæ\u0095¥\u009aã\u009aY´\u00166\u0097K\u0090\fÁ)]WÍ±\u0082\\,ª¤Õïêcä(\u001c\u008a3 \u001ch\u001e\u0091\u009aÊH\u0018ê\r}Á\u0092M+·ai\u0086Î1ÆÐäÐ\u008e)\u0012Z\u0084õ²3»*¿\u0091\u0013\u0005YÏ\'\u0016,SÓóC\u0095\u009c.wÏ+°É\u0007¯læEâ*ðèË\u0019¶>9U\u0016Z®Ä;éÛ;:"@²¢¬ÍÈ\u001bö§àxÂ°v.Uà\u001ekÊ®\u0014ÏÛ¤XRbI3Dª¹Ç -\u0018\u009b¦¢\u008ek¢|Z*tzD®\u0082\bãB\u0010!4q<\rb\u001c\u0013\u001c\u0093ALá\u0019C\u009b[j\u0018\u0006]\u001dy¡¯éÆ\u0096~D=´\u001e\'\nâ*®\tÇf¨\u0090]\rL\u001f\u0003ßr\u009c »Ê\u0002s\n\u0088Z«ü(Ü\u009a\u0015K\u008e¡ïL=VML\u008eÅÌ\u0096lª\u0087c:N\u0090>}ÓPí»WÑ\u0089Eà(Q\u009dÉ\u008a¢\u0016\u008b\u0091\u0081$Uio\u0015\u008dÑå´é¦¥\u0015\u0012ÔU¢Ã\u000e1¨\u009dóªÅÐQ>1rË«ªbíÝ-gqÌÑÜ:\u0014Ú»£fÍ9´cùÐ©¶y§«\u009a{Õ¢ý:Ãà9¹ÂOR/\u008dÀÿ\u0095ºøiPÑF¿üFz\u001c°PH\f4¢¼ð\u0088ù\u0006úmÒi\u0092Î^Ú\u0083ÑØ\'x¢±ø\u000e¼\u001fèìA3\u00ad\rBÆ&PÃ&\u0011`Sh!^\u000bÉH\u001f\u0097p\u0005°)\u009aLÄc¸NÖ\u001cÔ÷ðÃG{&ú\u0011\u009eÏðÅ¿ Æ\u0083ï¨\u009díþ\u0081ð.øR\u008c$þ(ÛAÝö.¤%¡·\u008bÀR,N¬`÷\u009e°~ÛvX¸\u0012\u0016\u0080l\u0006Ml\u0016Í,\u0087\b\u009b·Ý\u0089:\u0086öÝÉà\u0016ÚÉ\rAÝ&ÊCA\'\u0011Á\u001dÂé ®\u001fì7"\u001cµ!\u0081ÙYr8GR\u0081Ãí\f°\u0083\fÔ\n(6^f\u008aï\u009bâè"pfSQ;\u0007\u0082\u008a!nç¸ÛÆèÁeÚGÉl\u0003=ÆZ\u0089s\u0083ö\u009b>\tw\u0005DÈO7Rè\u0087x\u0085¥0Dò\u0000í\u000f!Þo)\u008cú<\u0098¦=ë\u0093þ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¥\u0019D£¢\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.class\u00ad\u0095mO\u0013A\u0010Çÿ{-½r-´¨ >W\u0004\u0081+p\u0080\u008a"ÆDð!$\u0015M\u0090Fxa²´g9½î\u0099í¡ø\u0011ü.¾\u0090D%ÑÄ\u000fà\u00872Î^ÏrÒ\u0092\u0003c\u009aìÎÌÎþffwnûó×·\u001f\u0000fqÛ\u0080\u008eQ\u0003i\u008cu\u00934®£h \u0089I\u0003S°tLë\u0098aÈT¼z\u009d\u008bjÉ\u00116ÃPÉ\u00935«&yÕµ\u00ad\u008aëXO¹lØÕ¥}\u009f\u0005\u0086Ô\u001dG8þ]\u0086\u0091±x÷ñ2CrÉ«\u0012<§\f+ÛõM[>ã\u009b.YN\u0094¼\nwË\\:J\u000f\u008dI\u007fËi0dï½ômùä\u008dïxB©ËBØrÉå\u008d\u0086Mªu0r$f\u0090\u0084\u001c\u008eî§¬óuþ~Ó^õ¹ô\u009bF\u0086þ±Ò+þ\u0096[.\u00175kÕ\u0097\u008e¨-\u008co0$¸¬©äÚ\u0016\u0019z<\u0011Aè\u0098eèkÊÍ¨´èS\r\u001b\u001dÈ\u001dbÅ\u0017ÑÆVçï\u0085ùg<±â\u0089?ÕdþÊ`±Smññ¢\u0091t\\cX>Â\u001dÇcg\u0082>Ðv¦Õ@]7|\u0094-\fÆª·-+öCGõÅ@\u009bÏ\u0094ª0\u008b\f²j¸\u009eE7\f\u001d7\u0018æcékâµðÞ\u0089\u000eW7xØ\u0092\u008a1§ãf\u0016·0Ï0y¬\u0006d\u00988ÎÙ3Ì\u001e¿5èó\u008d?U\u0086Ñ¶\u001b=ì¾\nq~\f\u001f:5ú\u007fh\u0098h\u001fþkºmqéóåÕê\u0083\u001d_ò2w·íC^\u00802\nô\\¦é\r¥G@õ\u0014I]ÐT\u009f\u0091¥\u0087´G¤i4gL¶\u0007Í,~Ab\u0097T\r½4ö"A;\u009f£\u008b\u00adÃ`\u001bÈ\u0091m é\u008e<N\u0002\u0081¤°\u008c~§Ð\u001fBçhV^Zâc\u008b\u0095"\u001bØ\u008b\bCk14²\u009c\u000e\u0018\u00838\u00172\u001eÓ\u000e\u008a\u008eÜw$×\u008bæg$T\u0086]\u009f\u000e\u0000+\u0001°Ðtm\u0001s!PIçIÒH¾\u0080K!z1¬ÙPÔâW¤Ì}ª¡VØ\u0016ÒÌ\u0089¤j´ÈF\u0093\u009cW\u0085_\u000ey÷ÉGÅO\u0099Å=°Ý\u0003\u0019®E2Lµ8)\f\u0005Ç¦¤+\u0018\u000e2\u001a\tv^¥\u009b\u0002Lº\'\u009dÆ>ò:CóÙ¤ú÷3q\u0091æ\u0082\u0002äÓô\u0007hb\u0002ÆoPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¤ÇÇà\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classÅVëRÛF\u0014þÖ\u0016¬#\u008bÄ¸\u0098\u0084¶¤\u000e5\u0001|ÁÜ\u0092`\u009b$\u0005\u009a[qpZ\'´&½ÉBq\u0015l9#ËM^¡\u008fÐ·HgÚ!)Ó¤ÿ:Ó·èß¾C;=+9`b\u0083L&3ý£Ý=ûé\u009co?\u009d=:\u007fþûë\u000b\u0000sx c\b\u008b\'è\u0091\u0091\u0011Á"GN\u0086\u0084%\u0019Y\\\u000eâ\n®r|$\u0016Ë\u001c+\u0002ö±\f\u0019×8®\u0007p\u0083ã¦\u008c[øDÆ\u0000Ö8ò2ÂXç(pÜaè·¿3\u001a±\u0019\u0086±|Ýª¤+\u0096ºUÕÓZÕH¯Ök5ÕÜÊ\u001b¦~Gµ\u001aº\u0095#ô\u0092a\u001aö\u0015\u0086\u001b\u0093Þð×\u0011\u008ey«\r\u0097\u009bÚ`\u0090Vë[:Ã)aXoÖÊºuW-WÉ\u0012Î×5µº¡Z\u0086X·\u008c\u0092 Ë\u0010YÑ\u001fÔ-ýºa5ìb³ÜòÉ Ü2MÝZ\u00adª\u008d\u0086N°EO\u0092±®\u008eè¤Am\u001fÚE\u009cÎ³0\fÔÍ¢\u00adZvá\u0091mÔM\u008eÏ\u0018\u0006Ý¹\u001b\u008b6mòµ9\u0099\u007f¨~¯¦«ªYI\u0017mË0+¹NË\u00947õ\u000eßÄÁ¯Z\u0015!]\u0087?úvu\u0007O"¹\u0013w\u0083\u0096\u0085\u0003Ët¯\u0081÷\u001c\u000f¶IUhÅ8*\u009b\\\u008c\u0010\u008cXkÛ·ÕGÎÇå(2l¿\u0095¼ò>Â¬\u0093{¾\'3â1+\u001es\f±^Þc\u0090\u008bõ¦¥QÎ\u0088\u0084\u001cîÀL\u000bí\u0015\u009cÁ\u0088\u0082a\u009cæ¸Ë\u0090:\u0096¦âå{\n6ð9Ç\u0017\nJØd\u0088zé©à>¾dÈxFºgn\u009bõÇf\u0097Ì<sØ\u0096\u0082s\u0018\u0013¬¾aH\u001c\u001e`Ùª4kºi_{¢é\u00ad<8×r\u0019måHªJ¸¨\u009b\u0080Ñ\u0089ñÆÄ4Ch?Y\u000bå\u0087ºfs|«@EYDÔ\u0018.y\u001eií\u0090\u0003\rwß\u0010~©X\\|³âÐ\u000b!7äòcÕÒ\u000f\u0012:lcîø·\u009d.\u0099wº\u001e\u00998.\u0088a\u00ad§\u008aÔë¥\u0092UMÓ\u001b\u008dØâ\f]®ù\u001eîó\u0094\u001b«i\u001bÕ4\u0015\u0003Q\u0018\u000e\u0018¨ªUt\u009bá|;M7S^½ÛnÚg\u0090\u0011\fÆ{a°ÉAz\u0006\u000f¨ûC7UÞBéi/Ø½j\u001az\u009d\t\u0095sJÍ\u009aJ²dºð¼\u007f´R{¥;Òå]\u0011ïï7(Ã\u001eÿ\tï\u001fÂÿ%nò8^\u0011¥î*BM\u0019\u000b\u0085Dy§\u0099\u001f>QíÁð.\u00adnÒÚO£\u0012Oü\u0002_<\u0091Ü\u0081ÿ\'Zûð\u001e=O\u008a=6\u008f>¶\u0080 »\u0080÷É6L{\u0084Ç(ù\u00863£jK6\u0086\u000fq¾åõ/\u0004ÐG£¾\u000b©\u0094H²\u001dô\u00adÇ\u007f\u0086ï\u0019ú\u0093ÏÁ}ø\u001d\u0081¬4"ý\u0081Y×|âG\u0084w!\u0097\u0012´\fÆ\t¯<ÝÅ@)|Rú\r§JþTñ\u0019B;\u0018|¹\u008bpI¼\u0091\u001a\u0091^!ßyê\u001cJÐ=\u000bNt3D5\u008bQ\u0096Ã\u0018[B\u0092]F\u008e]¥æqÅ¡¿à\u0012Û£¯c\u0002\u0093D[Ì¦hæC\u0010\u009b\u0088#I>GI\u009e\u0014¦©uM;\u0007õý\u0083\u001c\u0087Ä\u0011\u0018\n\u0081D\u009cm\u001d·@X\u0089FîèÇöõë\u0017\u008eÙ\u009c\u00138îBö\u0002sj\u0094O;\u00819æ\u001d\u0005Ål\u0001\u0017\u009c/tÑñq\t\u001fÐ¸Bj\u000eQ·|\u0096,1\u001aÇ%ÑMg\u0091 ¦yF¸\n\u0005 ºéU\u0088^9\u008bÛ\u0084\u008bÐø©äÃW4~-Éÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000´*«ZM\u0002\u0000\u0000ï\u0004\u0000\u0000F\u0000\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.class¥S]O\u0013A\u0014=wû±P·RË\u0087\u008a"\u0088UhA\u0016x1¦\u0084¨ML\u009aÔ\u008f¤\u0084÷¡\u001dêàv\u0097Ìn\u0089\u007fÅÿÀ\u008b/\u0098ø`|ö\u001f\u0019ñãÎî\u0006\u0083EkâCçÎÜ9÷Ü{Ng?\u007fÿð\u0011À&6\u000b°Q)`Ì,9Ü5Ë=\u001bK&½l£fcÅÆ*!¿¥|\u0015m\u00132ËÕ]B¶\u0011t%a¢¥|ù|Ðß\u0093zGìy\u009c)·\u0082\u008eðv\u0085Væ\u009c&³Ñ+\u0015\u0012æ\u001b"\u0094M?\u0094~¨"u$Û\u0091V~¯\u0011ô\u000f\u0085\u0016Q \tNÓ÷¥nx"\f%\u0017<i\u0005ºçö´èzÒíxÊel_ø]Óõ¥Ð¡Ô\u0095\u0011\u0094u\u0082Ý\u0089O<ÆÒrë@\u001c\t×\u0013~ÏM\u0090õáLµÉ5Áa¤\u0002\u007fÃè\u0019\u0002\u009c]o²²®Úß\'\u0010×\u0014Û\u0091è¼~&\u000eSÑçº½Ø;\u0090\u009d¨>\u009c©6mÜ\u008fÁ#¥nÔ\u008dóÖ\u009buBå_Ð\u0084ñ¶êù"\u001a\u0018ñ[\u007f\u009af\u0010)ÏýåØÖ°àm¦*´\u0083\u0081îÈ§ÊH\u009b\u0019j·f\u008a\u001c\u0014pÉÁ\u001a\\\u0007ëp\t¥ß©\u001cLbÊ\u0006ûúè\u007fÿÙsì\u0089 ÂÔE\u008a\b\u008b£Ý"L¦ïd\'höü@KÓ\u009f0}Á\u009b1/dü\fMX\u0018EÏnØü\u0085q\u0015\u007fsYXÆ\'>9|r9\u0012Ç\\í=¬w¼±Pä5o\u0092ô\u0005\u0097yï$\u0000L Ì\u0091\u008c\u0085i±ft\u0096cyeõ\u0004\u0099í¹·ÈÍ\u001d\u009b}ö\u0098³\u0099\u0098©l\u0010ô\u0015y:E\u0081¾Á¡\u001f1k-©LYÍn\u001a3q§2®òÎâ\u0019\u001c\\Ãuæ\u0099M&:åâÒcî\u007f#íÿ\u0080ï2\u001c\u008bµ\u0095OÈ\u00adòï\u0004ùã¿\u0088(&íJ`\u0007æR\u0092\u0087\u001c\u00adÔ\u0001ºØ\u0081\u0099\u0004p6k\u000e·0Ï÷\u0019,ÄøÛX\u008cã\u001d\\\u0089ç·Øî*w\u0099ÅM\u0003/\u008dý\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0006è2\t\u0004\u0007\u0000\u0000Á\u0011\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classÝXûw\u0014Õ\u001dÿÜd\u0093Ùl\u0006\b\u0081\u0004\u0013\u0014FMH²y\u0012ð\u0081bÚ\u0098\u0082\u00046\u000b6\u0018\u001añÁ°;n\u000663qf6\t¾ÛZmëûQj\u0000\u0081\u0016\u0094ji\u0005k\u0012R U\u008fµ\u00ad\u0087\u007f£çôôOèá¨ßïÌìn\u0092]ØÄ\u001fýåÎ÷~ï÷u¿Ï»ûÕ×\u007fý\u001b\u0080NL\u0087Ð\u0004µ\u008c\u0096ý!\u0084\u0011\u0093\u0010\u000f!\u0000\u008d1\u008fñ\u0092àe\u0088\u0017\u009d\u0097\u0003L\u007fPB2\u0088a\tF\b·Â\fAÆ\bC\u008f\u0007a\u0095Ã\u0086ÃD©\u0010\u001a0ÊÛ1\t\u0087BX\u0085\'\u0083x*\u0084\u0016<\u001dÂ3x\u0096O\u009e\u000ba7~Ê\u0084?\u000bâç\u008cy¾\u001c\u000fà\u0017¼¼ áE>þ%\u001fÿª\u001c¿Æó\u0012^bÖ\u0097%¼"áU\u0001Ù\u001cqtÓèw,ÝHHx\u009d0;gahÛk\u0018\u009aÕ\u0093Tm[³\u0005Ú#¦\u0095hOXj<©µÇ\u0092z{\u008f9<¬\u001añ\u0088nh»TËÖ¬ºÙüw\u000b\u0094z\u001a\u0004n¹\u000e«ÇCÔå±,2\u000f\u008b«">\u008b\u0091XJlGu4\to\u0010·gB?#\u0004Ú\nÛ:\u008b\u009eM\u001dU\u0093)¾eEä\u0080:ª¶§\u001c=Ù\u001eÑm\u0087ÎÊúõ\u0084¡:)\u008b\u0004×Í;Þìí\u0093ª\u0091h÷ïÝÅâ\u009c!Ý®ë¸þÍ=\u000b\u0098z³nèN\u0097À\u0097\u008d\u0085É\u0017\u0019\u0085Â\u009e/ìèÅ9³i@ ÐcÆÉ[Ë\u0098$\u009a\u001aÞ¯Y»ÕýIÂTFÌ\u0098\u009a\u001cP-\u009d÷>2ÀÞ\u0012¨Þa\u0098c\u0086gÕ\u009chn*l@~VòmÈ4º\u00adDjX3\u001c\u0081{\u001bsÃÕ´ØT\tª\u0019y\u0095¹â\u0004\u0096\u0010aì`\u009f:âßn)ÇBµ\u009c¨6î\u0090)\u0002\u001d\u008d\u008bÖ¹4¡9ÛT;{\u0093âÆ¦\u0007ÝË\u0011çHRc/\u0095¸)L\u0095`:C\u009aµÓ/=yÄ\rgz\u009b\u0093`9Ñö³BÂ\u009b\u0012Þ\u0092ð¶Àÿ¾\u000fYY\u0098z½\u009b¹Eã\u001d¼¬ç¥\u0093\u0097\r¼läå6.ÿ\u0005\u0088¡¸ô\u009b)+¦mÕ9þÕ94m\u009c52ºð\u0003\u0019\u009bq\u000fC¿\u0011X\u0091í,Ý\u0096¥\u001eâöÂG\u0087eÜ\u0089M2\u009aÑ.£\u0003ëe\u001a<\u001bdlÄ\u001d2ú\u0010\u0015h¾¶Mé\u0084Ù2\u001eÓü\fØà\u001f·&é\\ñ:´ÒPo7(qS³\u0015Ãt\u0014G=¨)ª¡¤\u0013½\u008dÚb6Ñwî? ÅÈ²ßâ\u001d6oBÆ\u0011\u001c\u0015ØÜm(Úð\u0088s(Ã¦\u008c©¶2b\u0099£z\\\u008b+\u008f\u0099\u0096\u0012»\u0086ê6\tÇd¼\u008bã2v""ã\u0004¢2N"*áw\u0002·\u0017ty\u009fnÛ\u0094U^æÐ\u0095ý¶Q\u0095\u0017Ï6ÿ\u009e¤FÍïb¨\u008cS8-á=\u0019ïã\u008c\u008c?à¨\u008c\u000fð¡\u008c?r$ºúRIG§zÌ\u0088¶\u00951ÍÒ\u0016,ü,þ$ãÏ|û\u008fpn\u008e×½Â\u0091q\u009e\u001dþ1þ"á\u0013\u0001¥P\u0019É\u0098Ä\u0094À\u001dß±\u007f\nt.°®ç0-Ï\u0083k]T\u0083\u0010hYLu\u000b¬[X[£\u0096\u009d\u00ad²^G³TÇ´hJ\u0017®j\u0081\u0086ÂmÐï!Ô\u009ci-¥X\u000f«Ô«7å\u0099:{#ó\u000b\u008a\u0006Q\u009eaR\u0095ob±ð¤f$\u009c!WW/Í\u0087¹¯\u0012B«ñø<î´\u001a\u009a\u001b\u00954Nº\u0093Is,3QhüJº½\u0085ë÷ºiåÝS`ï\u0002\u009c\u0091;\u008e\u0017êÀr5\u0016Ól»nýÆ\u000eêÆ=\u000bÖ\u0095\u0019éy<9ÿR9\u0019B\u000f=rZ:O\u001eÉãøÂS+g°_k¼Ò£ÇÖ\u009f`\u009d\u0014\u008a\u0001ÿíYÙØ\u0094ûú¬ÍÄ*Ý\\fÅ,¨gr¸z\u000es:·I\u00804¤Úüö \u0095\u0086ûYÙØ\u0094\u009b\u0016ìôx<ûÀ\u0090Ií}\u0096\u0099\u001aÙ£s\u009a-\u009f#½_c\u0086%s\u0010ÄbiÃæh¦Òê¯\u0017¶´¿\u0006 Ð¯\u009d0ý\u009a*E%\u008f8\u0082*yÊ¹_\u001atî\u0097f\u009dû¥9\b\u0081»\b.ÂÝ\u0015\u0015<<]Î"\u009e¥tòCÚ\u001dF1a\u0080\u0096pó$\u008aÂb\u001aÅá\u008b\b\fN£d\u0012¥á\u0096IHáÖI\u0004Ã5\u0081I\u0094\u0085k\b\u001b:ïJì¦u\r$@\u001cAH¼\u0083*q\u0014µâ\u0018Ö\u008awQ/\u008e£Y\u009cÀ½D³\u0011%,\u001f=Ø\u0002¸\u0010Û]äBly±\u000b±í\u0001\u0017bëKÈº\u00ad¸Ï·ñ$iaúhx\nåG°ú"äÁÊ%\u0081ËX:X\u001cþ\u0004Rÿ\u0005,\u009bFÅß\u009b§°<}\\\u0099{Lpió\fV\u0014a\u000f\tZy\u008e$\u0016»·¨e\u000f\u0088S\u0090Äi²þ}¬\u0013gÐ%>@¯øÐ½Aµ§=s\u0083(¶¡\u0097lÛNp\u0000Ek×\u0010¼\u0003\u0011ßÚ}\u0084\u0013ô\u00ad\'}Á)TM \u00865Ï Z`\u0002K.bÕ »ù\u0086ss\u008dXÊ\u008e\u0010\u001f\u0011Õ9(âcW±ì\tò\u0015owi\u0085BHzÈøÚ:éËDA_ÛÙLlJ\u0019O\u008a²\u0082\u0082¾ ÁÏ\u0006\u008f_¨ä[öû\u0015öí\u0004\u001af\u0099ê9²&¯#Ëx\u007f\u0001µ\u009eÖÕ\u0011\u008fíFz]Má&\u0017Ø\u00178\u009dvÁ\u009atPÖæ\u000fÊ\f]\u0018}-3¸\u0099ÕV\u0011p\u008bÀ§¸5ÚÜ:\u0085º3ßü×\u0013S?C\u0091ÉÒÝ\u0090¦k\u0088²ADÚxæ\u009bÿ\u0010\u0018Ê:µ\u0093n\u000eq\t+ÄeÊÇO)ª\u009fáQñ9ÆÄ\u0017ôTÿ\u0007&Ä\u00978&þ\u0085KâßøB|\u0085\u007f\u008a+®¿Âä\u0093·)\u000bwQ\u009c\u008bq\u0089<w¿\u009f©W|\u001fváUü\u0018ý~\u0016¬¦Ìº\u008a\u001d\u0012v_E\u0099\u0084\u0007þ\u008fÚ«\u0090]à¦\n&Þã\u0087Ë¢°H\u001c\u0090psKkM ¦d\u001aâü¼\u0090½å\u009a°Í£Ë$\u009d\u008c\u009fPù\n\u0017\u001aô\u000bHÆ\u0083¾Y2öú\u0005$ã!·\u0080\u0018z\u0018\u008f¸åþ¨«a\u001fÚ\\\u0097\u0094R\u0091\u008d£\u0015!ÜFßÛ\u0003ü\u0007Ê8~D\u0014\u0003¬¨"\u0088U´\u007f\u0002ü\u001fÍ8^\u000b\u0084¾\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$Ä¾¢¥\u0002\u0000\u0000ô\u0006\u0000\u0000<\u0000\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.class\u009d\u0095mOÓP\u0014Çÿw\u001bÝÖ\u0015\u0019*\u0088\u008fLDÙ\u0003²\r\u0091!¨\tÎ\u0087\u0018\'\u009a`0ÁW\u0017ÖÌ\u009aî\u0016o;¢ñ\u008doôÓøB\u0012\u0085Ä\u0017~\u0000?\u0094ñÜ¶Ì\u0001K\u0006Ë\u0092î\u009cÛs~ç±í\u009f¿¿~\u0003\u0098Å\u0092\u008e\u0004r:\u0092È\'I*(uZG\n7ÕÙ\u008c\u0092\u008aq\u0094ã\u0098eÐ\u009c-ÏrD\u001c·\u0018\u0086_øòK.]S®zÜ3\u0019\u008c§B\u0098²js×5]\u0086¹\u009a#\u001bÅ\u0086äuÛ,nÚV±ê4\u009b\\Ôk\u00960\u0003¿É#\u0090%\u008ar×\u0012\u0096w\u009f¡\u0092í\u0007\u0090[c\u0088U\u009d:å3¤\fWZÍ\rS¾â\u001b6\u009d\u009c®9\u009bÜ^ãÒRzx\u0018óÞZ\u0094îÈsËu-Ñ\b\u0090Ë²\u0011VµÐ;\u008b®\u009eTJºÉ?n\u0098¤I/¸GQ²µw|\u009b\u0017m.\u001aÅUO\u0092ÛRn\u009d!ÊeCåwä&Ã #\u000e Ö» º@ûë~Ê\u0011+\u008eØ\u000f\u0095:0ß\u0007Ýrï\u001dæ`\u0080´#:L\u001e\u0089:Õ\u009eÍ\u00adÅ1Çð¦¯\u0089÷ö)û[\u0011ùPR\u00972Ãäq\\\u0018ôU§%7ÍÇ\u0096Ú\u0092Ñ#63ª\u0019\u0006\u0086\u0090V\u0097Û\u0006t\u009c20\u008f1\u0003\u0015,\u0018¸\u0088K\u0006î`<\u008eE\u0086ùþ\u0096\u0088aú$ýe\u0098=y\u0003\u0019&z·\u0083aê\u0018Ã\t\u001a\u009d°Üý\u0005ÒýioÙ¦\nSÊ\u009ex[t¿\u0015\u00ad¦)<\u0086L/gdèí\u0095¤÷\u001a=Ij\u001a$i\u0088¨\tÑÉ0iOH\u008bÐ\u007f*Ïö\u0010É\u0017~"ºCj\u0084ÌAæQòÜÂ\u0000{\u000f\u009dI\u009c¡³ÑÀ\u001cgI\u0082/),£ß9\u008c\u0085ÐÅ\u0010ªå\u000b»\u0088}kó4º\u000f¶ÝÁÑÚ\u001c\rçqÁçÐ\u0096\u0084\u009cg\u0014\u009f2À`þ\u0007¢»\u0018(LïBû~\b÷ÉÇe\u0002Ã6n0Ä)I\')Bòe\u008c\u0087à{a\u0082I\u0005¦\u001cã\u0087¡\u009f;rL¶¡Év\u008e\u0019\\\rQ\u0015_\u000fQ\u0094ãëÿíÓ\u0095;û\u0082\u0004ûêã\u008cÀ0À¥AS¸\u0016B\u001e\u0092e4hØ\u001eØÎ¡d\u009a\u001d\u0015v6lÒo¼\u0092®ã\u0086_Ñ\u0094ï\u0099¥\u009a\u0081\tÄh8%\u00181õ\u0005+a\u0004êûUÂ\u0015Ò\'\u0014 \u009dø\u0007PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>ª\u0002\u0000\u0000Ä\u0006\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.class\u00adUÛnÓ@\u0010=\u009b¤qâ¸$\u00946\\Ê%¤)MÝKÚ@)½p)\u0015E\u0015¡ \u0005E*o\u001bÇ\u0004ÓÄ®Ö\u000e\u0085Oá\u000bxá\u0001$\n\u0088J|\u0000\u001f\u0085\u0098MÝ\u0092*A.\u0015/Þ\u009d\u0099³ç\u008cgfí\u009f¿¾ÿ\u0000PÄ½8\u0012È©Ð0*w×Tz\u008c©Èc\\\u0085\u008e\t\u0005\u0093*\u0014L+(¨\u0088cVAQÁu\u0086\u0084á4\u009bÜ®\u0095,ÛdÈ\u0096\u001cQ/Ô\u0005¯5Ì\u0082Ñ°\nO¹pÍÚê\u001fÌ\u0012CÔ{i¹¹\u0099\u001eè\u000e\\û \u0090èeË¶¼;\f\u000fóÁð`ùñ\nCdÕ©Q²IéØh5«¦xÆ«\rò\f\u0094\u001c\u00837*\\XÒö\u009d\u0011\u0099.CúÉ¶g9öÊ\u000e\u0017¾ZÙã\u001eÅµuÛ6Åj\u0083»®I¸\u0085À,s½\u0099è]SMþ¶j\u0092%¼}\fÃP¾ô\u008a¿æ\u0085\u0006·ë\u0085²\',»¾4þ\u009c!ÌE]&Ü\u0015¤\u00968ö\u0086c\u001f\u0010$\u008e${¿\u0017]pÆGÓì§\u008d±õ\u0098oû\u0015RËNK\u0018æ\u009a%\u008dt×éi©¨!\u0089\u0094\u0086Ó\u0098ÓÐ\u008fS\u001anbXÁ¼\u0086[XP°¨a\tË\fs\u0081\u0099¬¼ðL±f\t×+·ª~\u0098a°\u0097[ªÝf\u0098:\u001eç~½¨\u0081Z§)9höæOØS\u0086É\u007f©\u00ad\u0082»\fcÁs\u009e\u009bmÏqÌr\u000fº\u009c\t\u001a|ê\u001a¯Õ\u001e¼ñ\u0004¯ðFËüËdUº©ºÔ©áÜ0L×ÍÍÍÐ-\u001e=Æ½\u0094\u0013»õ_îïqk³Þ¥vr®l0.\u0092¡Ï¥F\u001fÒ\u0010\u0006å|\u0003©\u0094\u009cxò\u0084\u0011¡!\u001a\u0000Ã\u0019²J\u0084\bÓ\u009aÒ\'vÁtö\u0015!}r\u0017áOþYÐY\u008a³,T6\u0082$Ëa\u0088|i\u008aÑ\u0019ZÏ\u0003í\u009dÔ\b\u0011ç\u0005\fûÌ\u008bdKTT\u009fø\u0082È\u0087C¾(ÅÁò\u001d<ÑC\u009e(.â\u0012Å\u0019.#ãóì ¯\u008d*ê\u009f\u0011&ª>ZÙ7Dß!½\u0007eSZ2B\u0099ÇÞ#¹\u0087ø¦oª\u001fÛo+5UÉÀ¦\u0010cÓ\u001dºÅCÝ¢¯{\u0095ö\nB£\u008f\u0014*^\bÙvÒ#8G«Ni$èy6\u0012¢\u0098\u008e+\u0011ùÿÑ1E\u00888\u00ad3$r£]\u008bØoPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%àÌ»\u0002\u0000\u0000ª\u0006\u0000\u00007\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.class\u0095TmOÓP\u0014~îÖÑQ:\u001c¯\n¾\u0080\fÝ\n\u00832@\u0010\u008a\b.Ñ,YÀd\u0086Ä\u008fe4³¤kIÛ\u0011\u007f\u0086?\u0084/~\u0001#\u0089á³ÿÆ¨_\u008dç¶\rN6).]ÏË}Îsî=çô~ýõù\u000b\u0080E\u0094%d0#¡\u009f¿ú0+bN\u0082\u0000UÂ\u0002J"\u0016E,IHs;\u008d\'"V8|UÄS\u0011k"Ö\u0019z6LÛô7\u0019\u0092\u0005e\u008fA(;\u0007\u0006Ã\u00adªi\u001b;\u00adæ¾á¾Ñ÷-ò\fV\u009dºníé®ÉíÈ)øïL\u008f!»{ä\u009b\u008e]v\u009aGº«û\u008eË WlÛpË\u0096îy\u0006!\u0096ª\u008eÛP\u001b®~`\u0019jÝ2UÂ6uû\u0080§y\u00ad»\u009eáN_åÐ\u0018Äz`Q¢W\u0085k\bÂH-\u001e¡T\u0088Ó\tô\u0012ÃT|À%|\u0091ÎÚ4yÔ`õP?ÖUK·\u001bjÍwM»¡\u0085k\u0004É\u0017Ú\u0016w÷\u000f\u008dº¯uz\u0094\u008a\b-\u0000ÇÖ¤¤ñ\u009e$Þ/0Lß\u0004ÍÐ[3\u001b¶î·xÑªÿÚMË7-õO¥7â\u000b±IÔRÍi¹uã¥É;?Ú\u0091~\u009eSËÈb@Æ\u0006\u009e\u0089 \u0099Z½a×ÃB¶ÏÏh÷\u0005Î\u009f\u0013ñ\\Æ\u0016¶ið®ö\u0082a+6eY÷\u008c\u008aí\u0019¶gúæ±Ñ\u0099{"\u0006!c\f/\u0018&ãªÆqã\f¥ÿ\u001eý¿\u000e\u0016v\u008ea¸[ëh\u008aãÇ\u0082Z×0ü0\t}\u008b\u0003\u0005¥m\fj\u0086¯]{\u0096\u0090\u0085a¤=¿eÑ\u009eBº$Í>\u0095½Pí¶Þ}à4¥s2¯|=Ñ§ÕéQ*t±eèº£K\u008a.@\u0001\t>rd\r\u0092¥\u0092d$S3gH|$%\u0081!z÷p\'û\u0086aÒå\u0010\u0080\u0011Ü!Éx\u008b¢à\u000fD\u0096"¹2{\u008aä9\u0084·ì\f©Oè¹\u0080¸Sìp\u00ad\u000bçHs»wnL8\u0085tr\u0099\u00ad\u001fI"þ\u008e!ö\u0003yö3Èº\u001c2GY¹v\u0017÷\u0082\u009d¬à>i<2\u0087\u0007\u0098 Ø<\u001dl\u00924!»M»{\u0018ín\u0095V\u0088\u0017\u0099\u0099Ù\u000bô\u0015é\u007f\nùä\u009a#fÂdYþä"\u00925\u0092\u0089¨>¬{}FCÀåNS\u0098Æ#ZOâq\u0080Ï£\u0010H\u0005·INQÍ2(RÔ8éôË¦ÉSÄ<Ùi\u0092Ë\u0018ÿ\rPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000äfC\u0098§\u0001\u0000\u0000£\u0003\u0000\u00008\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.class\u0095\u0092ßJ\u001bA\u0014Æ¿³Y³º¦\u001aÿ4Õ¶Ö¨\u0001£\u0014×JoJ¤P\u0003¥\u0085 \u0085H.¼\u009b$Ã:²\u0099\u0095Ù\u0089ø\n}\u001c¯\u0004/ú\u0000}¨Ò3\u009b\u0080\u0088\u00854»\u0017ß\u0099³ßù\u001dÎ\u009cýýçá\u0017\u0080#ÔB\u0014°\u0011ÂÇF\u0080Í\u0000UBñXie?\u0013\nõ½\u000eÁo¦}IXl)-O\u0087\u0083®4ç¢\u009bpf¹\u0095öDÒ\u0011F¹ó8éÛK\u0095\u0011\u0096Î®\u00adJõ\u000fa2iÚVXþTú®µ4ÍDd\u0099dËÇVjâ(6¢\u009fÈ¨\u0097¨¨\u0099\u000e\u0006B÷]\u009fQ]í\u0019¤AXH5\u0087Æ\u009eÊ[ûÅÄ\u0001¶\bóOú\u001cÖ÷&£\u009fBÃT3k8\u0090Ú\u0012Nê\u00ad+q#¢Dè8j[£tÜ\u0098\u009a¸\u0010KûMd\u008fT¾Ì\u008b¼\u0011W^\'ÒÊ\u0000Û\u0084Ýúdð\u0087\u0086[\u0083w{H¨ý\u008f\u009b»´Ó¡éÉ¯Êm¤òÌsàÆ+a\u0006Å\u0000;\u0084£é÷@(?^ÑY÷JöxÂ÷Ó\\\u0011a{ò(\u0084ê$\u0093_åÿ×\u0087{\u008aðÜL \u0004|\u008aX\u0089ufÿ\u001eÞ\u001d\u0007\u001efs\u0013\'é\'æ8.\u008d\f\bñ\u0002ðygXÊu\u0019+¹®âe®\u0015\u0097/;çÚ\u0018þ\u0089Õ\u001bÃéßðÊÈ0\u0082çÑ:^çeorÿ[n\u000fÎ\u0014ø}\u0087y?Ä"k\u0099õ\u0095³\u0097gÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¢Æ÷E«\u0002\u0000\u0000¶\u0005\u0000\u00003\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.class\u0095TÿN\u0013A\u0010þözåÊq\u0094Z\u0004DQ\u0011\u008b´GËQÄ\u009f \u001akL\u008c\b&(\u0006ÿ[®\u0097rx½kî\u000e£\u008fâ\u0013ø/$\u0002\u0089&>\u0080ï¤qv[\u0010l\u0093B\u0093ÎîÌÎ|óÍÌîýúóý\'\u00809<éE?L\u009dÄ´\u008e4\u008aB-¥0£ã\u001a,\r³:4\u0014\u0085(\u000b1\u0097Âmá;¯á®\u0086{\f\t\u001eÖ\u0018²ËÛü#·<î×¬µ8týÚ\u0002COÐ\u0088ÝÀ§Í¢ë»ñ\u0012ÃT¾Ý¯ÝRXgP+AÕa\u0018Xv}ge§¾é\u0084oø¦ç\u0088L\u0081Í½u\u001eºBo\u0019ÕxË\u008d\u0018\u008cU\u0099°\tCê\u000bßwÂ\u008aÇ£È¡Sk9\bkV-äUÏ±lÏµ*A½ÎýªHñ\u009a\u0087\u0091\u0013æNÆS\u0001é\u009a\u0013?s£\u0086Ç?¯ð:å¹\u0098/t*´\u007f-æö\u0087W¼!éh¸Ï\u0090\u008a\u0083æ±\u0086\u0007\f/ÏTww~eÙ\u001båÓ¬\u0010e!æ\u0018rg\u0089cèã¶íDQ®<?Ká\u0095ü9»Ñ±p}-Ø\tmç¹+\u00860Ü\u00860#B\f\\@Æ@\u0016\u0083B<40\u0080\f1/\u0095\f,`\u0091aä\u007fÜ§;®WuB\u0003\u008f°dà:Æ\u0018\u00189_Á\u0098\u0086Ç\f¥sñfÈüÃ_ÝÜvìø\u0094éÈk¢{\u000fé®çEûõ(æa\u001c½sã-\u0086¡\u000e\u0093-¼§+Ï\u001b\rÇ¯\u0012ÝN\u000em¦VÍÔÒñnD0NÏ/MOW¡vR/i\u0097\u0015-¦5)m\u0083 \u008bJÚ\u0006i\tZ\u0007ÌC$Ìé}¨fq\u001flO\u0086\u000eÉ0\u0015`ôz\u0098\u0082^\u0096@\u009a©\u0018&ûx3\f#¸\fÈ\u009dHÃäN$RhOÓh¥\u0089¤\u000e,\u009aß f\u0093\u0007èù\u0082±\u001fÐ6\u000e\u0091\u0012j/Ù\u0019-\u0007Ð¿bôè ïÔÁ.Å\'$§\u001e\u0081Å4ÉÃhâ¶x\\¥¿\u0006eò\u00adF\u001f&&îE\u008b\u0080E«pL\u009a\u00070v\u008f«k"\u0019\'\u0090\u0092M¤\u008c¨üF+x\u0095òª\u0002Ù\u009c.\u001eBÙ;\u001d\u008eß2Ülº\u001c7DÃD«!\u001anÊ\u0086\u0088]\u000e\u0093HdR¸\u0085©6fTénGè#f\u0013\u0012ZA^Ê\u0002Få|\u0014\u001aõ\u001d\\\u0082N3¡_&õ\u0017PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq²\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.class\u009dTÏO\u0013A\u0014þfvÛ\u0085e\u000b\u0015¡*Z@¬ÐRd) \u0084\u0094\u0010H\u0013\u0092&ULjHô6\u0094MY\\vÉî\u0096ø¯ÀÉ\u009b\u0097^¼@¢\u0089Ñ«\u007f\u00931¾Ù®(\u0016\u00adñÐy?æ\u009b÷¾÷uf¿|{ÿ\u0011À"VtôcF\u0087.\u0017\ry\r³:TÌÉå\u0091\u0086y¹MÖÔ° ¡Ä\u0090\\·];Ü`Pò\u0085]\u0006µâí[\fC5Ûµ\u009e¶\u008eö,ÿ¹Øs(3\\ó\u001aÂÙ\u0015¾-ã8©\u0086\u0007vÀ\u0090Ù9\u000emÏ\u00ad\u0087¾í6+ÞÑ±ðEèù\fFÕu-¿â\u0088 °\b·Vóü¦ÙôÅ¾c\u0099\rÇ6\t{$Ü}Ùì\u0099ð\u0003ËÏ]_©Ì 5¢\u0088\u009aÎäk\u0087âD\u0098\u008ep\u009bf\u0007YîÎ\u0014ªtÆ\u008bª\u0095$û.Àåö"\u0089\u0010\u001cx~H8öòG@ÙT=\u0014\u008dWOÄq<í\u0095Æ;{\u0087V#,wg\nU\r\u008b\u0011¸ç°¥²\u0094\u009c¿^`Èý\u000b\u009a¡¿n7]\u0011¶¤\u000eë\u007fbÓ\nmÇü)Þz÷ì\u001bTJ¯{-¿amÛr´LW»yyÈ\u0080\u0081\u0094\u0081%,kxÌ°Ù\u0093cE\u0004VÕ\r,7°CûÄê¾\u0011\u0013=\u0010²ã¤\u0081Qd\u0018Ò¿ófXýÏ\u000bt¥XG,\u0086\u0091ëÔb\u0098êýOÐ%q,·\u0019\u001eDÏ\u0086nÚd¯3X w§\u0083a\u0080^©\n.\u0085¥h\u0090"\u0093,#\u009b\u0098½\u0000\u007fG\u000eÇ\u0010\u00adI\u0099ä\nÒä\u001b\u001d\u0000n`\u0084,\u0093òÄ\u0087?C¡<°U<\u0087¢¾\u0081¦¾\u0085ªlÌý\u001a\u00ad¨ÙSè£ê\u0019\u0012¼\u009d=\u0093î)\u0012jû\u0003Ô\u0017ì\u0002\u0089"¡\u0093m*¢D\u008dÇé³\u0001\u009eÀ O"Ë5Ló>ä¹\u008e\u0012\u001fÀ\u0012OE\u0084\u0096;McBÒ»\u0085Û\u0011É-Ü!\u008f\u0013¹%\u008cá.ÕÌ"\u0087{ä©ä\u0081N\'\u008dMö\u0015\u0006ë¬zz\u008bÆ\u0019\u008fÇY%¼B65[ü\u0004m\u008e~çèkÿE\u0093T\u0087BZÆ\u0093q\u00915²<\u0016\u0094]/h¦\u0003¸ä\u009fÀ}LÑ¾\u0082\u0007\u0011>\u0087\u0087\u0091\u009dÆM²c\u0094ïG\u0001ÃäMHxº\u008f¦) \u0088±ïPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000¸\u0004\u0000\u00002\u0000\u0000\u0000org/gradle/cli/CommandLineParser$ParserState.class\u0095SßoÒP\u0014þN)\u0014\u000bs\u0080ÛÔ9\u0015\u00117\u0018\u001bÕ½\u0019\u008c&\u0012MLÈf\u0082ÙÃÞ.Ð°.åÖÜvFÿ\'_|ÑÄ\u0007ÿ\u0000ÿ(ã¹-\u009bÝ A\u009a´çG¿ó\u009dï\u009cÛþþóó\u0017\u0080\u0003´mdQ³\u0091C-\u008fÇ6êxbaÇB\u0083\u0090{áI/zIÈ4\u009aÇ\u0004³\u001b\u008c\\ÂjÏ\u0093îáùdàª\u000fbàs¦Ò\u000b\u0086Â?\u0016ÊÓñ4iF§^H(¼\u0017*tU?\u0012\u0011\'\u008bï¤tU×\u0017aèòËv/Pcg¬ÄÈw\u009d¡ï9Ý`2\u0011r¤;$uõTy\u0087P\u009a\u0088/\u0003\u0097#\u0015\u001d}\u008c¼@\u0012Ö\u001b½3ñI8¾\u0090c§\u001f)O\u008e;Í\u0013BÞ\u000b/ \u0019¡ÆZå\f\u008e°\u0012È\u0014\u009b\u0085&¡\u009cøWt\u009fÌi2§íâqf¸YC!\u0090\u0087\u0081¼\u0010ûzÞ<Kï)\u0090)È\u001b9²°KØi,æyÖÑGm|~J¨ÿ\u000f\u009a`÷\u0083s5tßzúÔ7f0m=M\u0011\u0016ò\u0004«ñ*lî·[\u0016ZEì¡la\u009f°·Ìl<Ú¿í\u001c\rÎÜaD8X~í\u0084Úâá®4K\u008e\u0082g\u0098\u0088hxª¿Þê"\u0006³Ê¿V\u000eú²`è\u0015\u0080p\u0083#\u0087-±Íîþ\u0080ñ\u008d\u001d\u00036?s:I%\u0014Ø/&\u0000¶«\u0080ÉJP\u008e\u0089*l\u0013\u0092\u000eW\u0019\u009aºUÉ|\u0087ùõ\u001aÍZL³\u0091@\u0012\u009aØ»\u00855\u0010\u0013®ãNL|\u0017\u009b\u009c\'Ü»T×\u008ac¾¯+ÛJ)£\u0084²¤)ïO\u000b\u009f³5¦cÍ\u0014\u0097Rz²\u0097z²x\u0080\u0087qY5Æ?ÂM¶\u009bÈð\u009bm¬\u00986Wlã6Û-\r/åÿ\u0002PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pÍX\rÝ\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.class½UËR\u0013Q\u0010=w\u0092IÂ0@\b\u0010ñ\u0085\u0088(I\b\u0084\u0097\u000f\u0004±\u0090ÒÒ*\n\u00adBY°»$Sqt2CM&Ê/ø/.¤\u008aG\u0095\u000b?À\u0095\u001b_\u000b7nÜè/XvO¦B\u0084P!.ÜtßÛ·Ïé¾§o&ï\u007f¿}\u0007`\n·5Ä\u0090ÕÐ\u0086±6Z\u008d³É±\u0099à\u0083I\u008dR¦£¸\u001aÅ5\u0001µìIÏ\u0088â\u0086@û#é\u0096\rw\u0095\u0003\u0002ú\u0003Û6Ü%K\u0096ËFY`|Ùq\u008b¹¢+\u000b\u0096\u0091Ë[fnÉ)\u0095¤]X6m£\u008a\u001b®\u0083Ï\t\u0084¤[\u0014H,?\u0093/dÎ\u0092v1·ê¹¦]¤£öü\u0001V`è0³ÏS¨ã\'HdÞ´MoAÀH\u001delNÐZóé5\u0081ð\u0092S æº8e¥RÚ0ÜÇrÃ2øFN^ZkÒ5y\u001f\u0004ÃÞS\u0093Dê\u007fb?·\u009d\u0097öÃMÏtì¿ä<A\u000bÇ\u0081éú\u009dEÃ»/Ë\u008bn±R2l\u008fÔM¥×)ìØ\u0094áz+Æ\u0096·ÈrO¤Ò\u00adÎIsì\u0003Ú;\rÔm\u00991&k|DNÙ\u009b\u0096ÁOlVàÕ\u007f\u0098^óìI\u007fÂÊÖ\u0004\u009bI6Sl¦\u0005\u0086O\u0002¦k\u00ad:\u00157oÜ3yöÉ#9ã|G\u001d=èesSG\u0017â:º\u0091Ð¡¡SÇ\u0010\u0006¢\u0098Ó1\u008f[QÐ\u009b\u009eýç§!0Õ\u0014Û\u0000ÔÝ \u0096mEdúÕ6\u0017J`$uÒa\f6{\u0004\u0002\u001d²P¸»å¹rMZ\u0015Ú÷5z«\r¨\u008e\u0094Ä }\u0005ÛèK\u0019B\u0082\u0007B«\u0004\u008fÈ÷4%ò\u0011(<>P\u0015Ú\u0095h\u0017&ß\u0097\u0011ûP2£»\be²»\bgÆv¡nÓ\u0081\u0082$Ù$T@|\u0084*>A\u0013\u009fÑ%¾ W|Å):ËT\tÐ\u008f3\u0080¿â\u0082Â_qIÅ_q3!\u008a\u009eÅ¹ t\u0096<g)á×µ:\u0011\u008e\u0088o>¯^=\rx\u0005Îc @æ\u0002¤\u009aÙCäÍ!ð÷:°Z\u0003_ eªàYòÊqà\u001f>8YM¨ÝHÅEÿF\u0082\u009fw@³@9\\"\u009eÙ!µv\u0010ÚC\u0094\u009czÀ¨1\u008bø\u0089vñ«®¥x\u0095\u0095&Ò\u0083á\u0080k\u009d\u0014$}\u0011Ë\u008cfÇö!¶\u000fuõÁÇÏTsj]Åp9Ð9\u0086+\u0081Î1\u008cø:ó*\u00854ñ*4\u001ff\u001bE\u0007ù!\u008a´\u0013\u0093\u001eæ¿Ë\u0019\u009c¦./1Y\u009c\u009fÍ\f®\u0087µ?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009bÔ\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/CommandLineParser.class\u009dYi`\\Å\u0091þJ\u009a\u00997zz¶eÙ²=`lá\u0003ë\u00961¶°åS>\u0000\u0019K6\u0096±\u0091\u000fÌXz\u0092F\u001eÏ\u0088\u0099\u0011¶8B¸Â\u0011\u008e\u0010\u008e`\u0013\u0002\u0081`\u0087\u0004\u0082¹d\u000b\u0081ÙM¸Â\u0012Èî\u0012ØÍ²aÙ\u0083=\u0080\r!l\u0000ÇÇ~ýÞ\u009bÑÌè\u0019\u0089üPwOwUuUuÕ×ÕO¯\u001d{ö\u0010\u0080YòT\u001e:ñ±jþW5¿×±\u0016\u009fhø\u0083\u000e/>Ññ)þ¨sú3\rÿ§áOùø\r>×¡ã\u000b\u001dyøRÃa\u001d#ñç|\u001cÁÑ|ìÇ1Õ\u001c×\u0084\u0014W\u008bø%GÇ\u0018ÉÕÄ£c¼xýâS¿5Õø\u0015E\u009e\u008e]¢û%_Í\u0018ª\u0019¡fFúe\u0014u\u0091\u0002¿\u008cÖ¤PÇt|Â\u009de\u008c&cu\u0094à\u0013¿\u0014±\u0097qª\u0019¯8&¨& \u0004\u009c¤ä\u009e¬\u009a\u0089JO\u008bï\u0094|</\u0093Øà¨&\u0093uÔH±&§ê\u0098+S4\u0099ªÉ4\u001dóeº\u008eZ9MQÎÐ¤DÇbzAJuÔ©\u0095\u001a)Ó¤\\Çr%ðm\u0099ä\u0097\nzE*ÕJ\u0095_ªÕ.3Usº.³ä\f5\u009a\u00adÉ\u009c|¬\u0096\u001a¿\u009c©É\\5\u009c§¶¬õË|¥÷\u0002¿,T¿\u0017i²XG3\u0005Ë\u0012\u001cåHêx\u0004Ê¬f\u0019¯ÉR¿,Sv-×±UV¨ÑY~9[yç\u001c]êe¥.çÊ*¿4P\u0013\u009e\u00874ê²ZÖøå<µ¸V\u0093&\u0081Q\u001f\u0089\u0098±eá`<nÆ\u0005ãVw%BÑHS"\u0016\u008a´/\u008bîè\nÆ\u0082\u0089hL\u0093u\u0082ÉË\u0082q³>\u00127#ñP"t\u0089\u0099M$(°¹ÓùÎ\u0017L8?²=\u0012Ý\u0019±\u0017×\u0004cq3Ö\u0094\b&LMÖsÇsO°¶A0Úeú\u0002AQC(\u001eçÖöj]¬ÝZ¢-um\t3fÏÆ5i\u0016\u008cµfÎ\nÅâ\u0089¦îmÔkG0ÒJ\u0001KÍ¶hÌÌ\u009a×dcÊ\u0001u;\u008313cßM\u0082ü\u008c\u0089ÍÜ0Ý[\u00821«×¬«_Ý¸µ±®aÅÖ5uëÖ\u00adXÛ(\b¬ê\f^\u0012¬îN\u0084ÂÕ1³ÝÜU½&\u0098 V\u0091ù\u0082QQ[Ù¥=I\u0019£Ò¨\u001b\u0082]¤Ék\nµG\u0082\u0089î\u0018-\\\u0091¹ºÀþ\u0019\u000eFÚ«m\u0001óWEcíÕí±`kØ¬n\t\u0087ª\u001dÛV\u0085"¦\u00adìüE\u00949:\u0018\u000eGw6\u0084v\u0099\u00ad\u008e»\u0004Êú1Ö|ÆyqeÌ4\u0015\u001d1ë×òP<¸-lÒ\u0089¾\u0005¡H(±H\u0090[RÊsô,\u008b¶\u009aJ\u007fîÔØ½c\u009b\u0019[§\b\u0005\u0085«¢-Áðú`,¤~;\u0093\u009eDG\u0088\u0092§|\u0085º¶³©¬·K\u008d\u0004g\u0096l\u001aloi¶\u0004\u008b\u00ad5M\u000e%ä·\fü¤9.b\u0088I+vµ\u0098ÉÐÙ"\u0098[\u0092FUÏóR\u008a\u000fo;ÃRØñ¬`ö\u0090FN\u001b\u0014ç\u0094â3#\u00ad\u008cm\u001eL=\u0083 \u009a\u008c4åP\u0017õ%$Ðl¢ÓÉ\u001buöÎ\r*\tcÝLa\u0014te+ïr"n\u0006ê\u0016£\u0093uUC\u009b\u0097iØ¸Ì\u0080èéJ\u0006\u0085\u009bÇ]B\\\u0005ð\b\nkÙÎ\u0014°X5¹P°jØìÃ:ÄÉ\u0003)B\u0088p\u0002(^\u0017\u0019H\u0098i%\u0083\u0004¹\u0085¯n\tZÍük\u001bn\f»\u0089\u0019Ý\u0092\u009dÉ_\u009d>N¶§¢\u0082\n\u0017\u000e\u0012\u0011Ï\u0004\u009c&3A\u008632g\u0016\f\u0007R4ìÑd«\u008a\fZ\u00948?\u001elçy\u0006ÒO¤®«\u008b\u0001m\'\u0011áÂ\u0088f@çØh¬Õ\u008c%sÆ\u009eUÊuÅÌ6ë\b\u00923\u0005iÊ\u00ad\nÅ\u0095¾¹ÛÍ\u001e¢Ä%Áp77õ\u009a\u0091DLý^a÷E\u0099\u00909Í\u009aV\\Ñî\u0084\u008aEW\r\u0099p¼ vX8\u009d)â¬ä4iFf(Må¼aú\u0084}î\u008eà.ÁÔl?ºFò´,\u0083N@6ßÍ\f7üwå\u009e3ô½áÂ§ÉE\u009a\u00045ÙF¼î\u008c\u0086\u0018p\u000bJÒ\u0004-\u008b\u0086Ãf\u008b\u0015\u0000n1í\u0002R^¢¾:ít\u0004[½\u00ad\u0093B\u0014ÞY\u008bñÔ\u0099dïÁ3\u0089\u009b©RÃ·\u00ad»\u00adM\u001dÎ\u0084A\u001b-µVÔvmê\u0082Ï¼\u0081\u0007\u0004.(S\u009eYìn\u0091Z\u001c¦Q_;¥S\u0099©\u0007[ZÌx|Ú\u009c\u00993\u0005ÓK\u0086F\u0081R^Ñ9»f\u000epÎU\u009cg\f\u0087sPY\u0091\u00141O\u0089ð/ \u009b}\u009bëMÑîX\u000bk#\u0085Èã\u0006IªRr\fÜ\u008a[\fÜ\u0080\u001b\rÜ¬FßÁíD¨\u0081-Î\tÆ;¸\u008d&-\u0086´\u008aià{¸OP<\u0014ì\u000e\u0092Á´1¤MÚ¹\u0083t¨\u0086·\\Í\u0090×\u008dku§¸;5ÙnHXv\u0018\u0012\u0091¨!]r1\u0011%ûð\f\u0089\tÃ0§²Ò\u0090\u0084t\u000b*\u0087Ü1½ðT\u001b]BØ\u00ad¬ÜtáÂ-å\u0086ì\u0094¸!»¤Ç\u0090Kå2C.\u0097+\b\u001d%\u008bã¥\u000eÅÂª2C¾!W*¢o\u001ar\u0095\\Mx´ÖÕ²ZÅm¸\u0085U\u008c3W¹¥ª\u008cq\u009f\u0006\\ÉêlE,\u0016\u008d\u0019r\u008dRzüà´\b\u0085[UÆ\bíºV®3ä[r½!7(GÜ(W\u0018r\u0093|Û\u0090\u009båjCnÁí\u0086Ü*·\u0019ò\u001d%*ûÜ\u0006Å²!·ËwYX¹À¤\u008a\u008d\u00172Îu]Ì4y®\u0082Ó\u0087Y\u0016\r<\'\u0094kïPÍ\u009d\u0086Ü%w\'\u008dt°3²Ýlu\u0002\u008fY9LáÙ\u008f\u0018C¾\'÷d\u0098R\u0017\u008b\u0005{\u001423$*\u008a\r¼\u0083\u007f0d·\\/\u0080!{ä^C¾/÷hr\u009f\u00817å\u0007\u0086Ü\u009fÅ\u009e\u0002kC\u001ePáæ\u0099\u001e\u009f\u001eÉ\u0088:\u001b\u0001\rù¡\\lÈ\u0083ò\u0010÷\u0099n\u001dÑ\u008f\u0018EñâbÅ`ÈÃ*ÅÆ¹c\u009d&{\u0015ý>V\u0004i%\u0010±¬=\u0018f\tÙ½\u0083wbª¼eic\u009b^<cz|Fq(^\u001c\fÇÌ`kOq+ïÚ\u0088ÙZ¥´ø±ró#\u0086üD¥Bí²`$\u0012M\u0014\u0007[[\u008b£i¼AòF\u00923-6M<\u0011\u008c%\u008aw\u0086\u0012\u001dÅ3*gT\u0019ø\u0016®×ä§\u0086<*\u008fiò3\u0095\u000eQÁ¦aJ,\u008eFÂ=Å-ÑH"\u0018\u008aPÑ®\u008e`\u0084æÄB-Å-\u001d<±\u0016\u0086X\u009cñ©ö²º\u00ad3ª¾2`íÃ×äqCö+E&\u0096l^|ùæ®ËêÂ\u0094{Å¦Ô¨rë\u0096²RC\u009e\u0090\'éÔ!c\u0089%÷\u0092!\u0089\u0086|>Ï\u001bRÄ\u0089^ÒÃ\u0089w÷w¶`Ö×\u007f\u009d\f\u0007\u0084OðF\u009f3<,\u001dôd\u001fn>g?Ü\u0005\u0015_çy2\u001c°Ï|ô\u0097\u009f\u0098Þ%õ\n\u0007\u0080Áz¢Xç>"£Nd1ìV\u0093f\u0090Y\u001072³pLbÊ\u0000h1s}Á¸½6=£Jq\u008a®ÒÁÅ´Ï*£É9¡¤ôDuXà\u0004U ªëÇ»?\u009b¹²}\u0018eÊÐ\u000f³¡\u001f\u009b§[»\u0015\u000eÖ\u0082eN(åóq\u0019æ%ÏB=\u0097:\u0082ñFsWÂú®ÁzË\u0013±~\u008c-)u+Z\u000bv\u0004{¶©\u0097p,\u0091|\u0094\u0015\u0095¸\u0094\u0083\u001bÕ{þâî`8\u009eE\u0090<\t\u0012Ô\u000frÐ_n¾ÆÛ·¥C\u009dc^¼{[Ü\u0089Õ¢\u0092z×\u0012v\u0084\nç4\u00136º\u0098ð\u0097<[]¿k\u008ct6SN¶¾oÌ\u001cÆ;:ë\u0013\u0082\u0016\u008a´\u009a»Ô\u0083ÚC\u0093êÕqÖ»\u009b¦[àc¥¡`©ÛÑ|Ý½ó\u009dÛ(~®zvú\u0082V\u0086\u00127\\e\u009f \b£\u0018\u007f"\u009azü\u0096¸ª>²ÝL°\u009e\u0019P_·k¡°©pÊ\u00176#í\u0089\u000e+Lé\u0080üh¤1\u001aI\u001e`\u0081E\u00994c\u0085Ò/·]AËin±ç\u0016Ø¹¼\u0099\u0019<í±hw×\u0086\u0090Ú§0=ëÕ\u0097\u0002\u0015g3\u0086Nj\'"³@#yëYk>nV\u0017\u000e\u007f\u0005²0=t\u001a\u0090zi\u008fÎH_û»\u0085ò×r3Þ\u0012\u000b%?~u©\'þ\\\u0017\u0093\u0087é\u0004ßv³ÇBä\u0091\u0003\u008b\rAå\f¯\u008a7ºÝo}m°hüÜ~½ý\rÂÇ¡\u001d\u001döW\u0084\u0081\u0087sú\t\u000f\u0001Èé_\u001a&º%î@,yÛÂÝñ\u008eäÅ\u0091å<Þ\u0080Ã\fMçÙ<ïké\u009a\u0019³®àÇ\u0013Ö\u00ad²0nGRZÕ\u009eñA<\u0005[1ëQ; h\u0019K½&Â§\u0019i13|d³7ØLó]$7$å\u008dJ\u0093¦þÙAÈh5ã¡\u0098Ù\u009az=©\u0004ïæ\u0082ÖÂè´\u009e¿_\u0091Ó.\u009fóq*:±\u0016\u0080\u0017\'©ª\u0097£\u001cõF\u0086à&kümþñ¹l\u008doU}Á\u0004õ²ãï\u0011¤á\u001b\u009aíwùk\u0011r9ârÙ\u0001xÊúám>\u0000ß3ÈyÂâ¼\u0083\u00adÎ\u001e\u0098\u0003\u000fæâN\u008e\f\u009b\u001ewánöWñ¹}\u000f)\u0094¬\u0085ì\u0015m^YùAh½ðïO\tñYL+,\u0001ãl"G\u0080\u001aíÆ\u001e®ßË±\u0087ý÷ùÇ7<\u0015£ÐÜ7hb>Åxú\u0091×Ü\u000f½¹ìiäô!_p\u0000Æ\u0001\u008chèÇÈæ²\n9\u0080Q\u008då}(à\u000bÂ\u0013ðôa´`·¼®F\u0085\u0082¿Â\u0098ZoeÀÛ\u008b±»å±\u0080·°¨\u0017ãv£ \u001fã\u009b\u0015ë\u0084Æ}r\u001f§\u0003½8i7N"eÀKâ\u0093{1±Ö\u0017ðõâ\u0014\u0012\\N\u0082I\u0016AUÀ[°°\u0017\u0093k|6e\u0011)\u008a\u0015\u00ad\u0016Ð\u0002üå¹Èâ=\u0095Lg\u0093i\u008aÅtªEëñ:¤\u0014\u001bðúRt\u0093\u009fÄÔ=("õ4RïA~?¦ó(N{\u0081,$ªõ)³\u0003¾>ÌÈ¡»Æ)Y>gGK;¼åÈ®Õ,JÍ¡¼ª²\u001f%\u0014TZXÖ\u008brE\\Þ\u008b\nÕO¬õ\u0007ü½¨Ü\u008dÂ\u0080?i.UÁMjºªÑ[\u0093W\u0094§\\Vý æÒ*þRv\u0015×ê\u0099"uG¤\u009e\u0012YÕxm\u009eì;þâ>,¦.\u0092®®³¾\u000fÓ\u0087ÒK\u0011éÖ\u0091ÍlÜwlfe/N¯ØoE\u0088\u008a§\'QÁö<L`\u0012LE\u0013ê°\u000e+q>Ûõ\bb\u0003¶ã\u0002ô \u0019Wb#Ó`\u0013cm3\u001eÆ\u0016<\u008d\u000bñ×Ø\u008a_ã"¼KÊ÷°\r\u009f£\u0005ÇÑ*#`Êx´É)h\u0097btH):åLl\u0097&\u0084e\u0013vH\'¢Ò\u0085.¹\u0002\u0017ËM\u0088É^ÄåQþ~\u0006;å9ôÈË¸TÞÄ7äC\\)\u007fÀ5ò\u0019®\u0093?ãz9\u0086\u001bsr\u0098\u0096*ö\u001fÅhêåÃ\u000fp?Û»0\u0019\u000fà\u0087\u001c=\u008cQÖ\u009cFÍ\f{\u0095ºØt\u001aw\u009b\u0082\u0007ñ\u0010t\u0089c1~D\u008e<jµÍZõsß<gT\u008aW)é!r|èðúiÙ§ØË9\u001fêäYìãÈ«²)\u0099}\u001cíÆ\u008f\u0099q\u0013ä#<\u0082\u009f07§Êûø)5ÍÅcÉt·¨~ÆÑã\u009cY\u0080\u0082c(×\u0090§áj\rû\u008f`\u008e\u00861Å³g\u008c?\u0082\u0012\u008e\u008e¢\u009e\u00ad\u0086]G¨Ña,:Ìhü\u0012§æ\u001c\u0086\u008fÃ´,·\u0081ê\t\u008e\u009fÄS\u000e\u001cÍá\u008cB\n\u00adÌó\frËög¡Ð\u00adTþ¶4\u0014Ò\u001c3\u0084+®"d\u0090\u0088;(âN\u0017\u0011W16\u009e±E\u0088\u0097¶k\u009cÛ¬ðæ\u0000f5\u00947V\u001eªñäÖx\u008b¼E\u009e\u0007\u0099ÊEÞYµ¾\u008adN\u009e\u0091\u0083>ÌÎÁ\u0086k½\u008cûßUôa\u008e ±Ò\u0006!\u008c¯t0¨F!SE/ÎÜwü\u0083²\u0081X\u009eÂS\u0002ýá\'æMâ©Íd_Ã¸8\u008fç¼\u0081ç¾\u0091g¦ô\u009dMÍ\'¡Ð9Íóø×K\fô(=SXº\u0019\u0007-,õ3\u0013úð,-N\u009e¡=ÓÏ\u0019u\u0086Sá9ÎPôièÔð\u009c\u0086çÙ\nÝñ\u0005¦\u001dQ³û\u000fc"\u0099\u000eá\u0005Û%¹Ïp;Â°üª\u001fs\u009bË\u000f`\u001eq·\u0096x<¿\u0099ð¹à\u0000\u00166V¦\u0080¹\u000f\u008bè\u008b~,¦ï\u0096Ôz*-wÔ\u0012ü\u001c\u0087¼®F\u008eG|¶\u0098:%f)ÅX\u0010J¨X\u0096\u0014²\u009cBV\u0010\u00124[J^ Ï\u0091²^\u008d\u001cl×\u0015úT{\u001eÀ\u0094\u0080ß\r\u009cúp\u0016\u0085íÃä\u0081å¢ÁËÇ÷\u0006ü\u0085g\u001fÄ9Ü\u0085*Ô+±/#ß\u0092½\u0007ZáJNx\u0002y\u0001½\u000fçæ*ú\u0099\u008c\buÃ¬R6+í|*\u001a,í&©\u0091£\u009dVäUÀV}\u0010\r5^Æ\u0087bi\u001cÌÒ\u0095bY\u00ad¼Ð\u00875\u0016»µùÉ\u0015\u0085çy\u009eÇÚæ\\µÐ$hêÅ:\u001a4¯"iÏù4¥\u0088h¹¾p\u0083m\u00947\u0083¼ÙãH´\u0019\u008fßÌ8¼à\u0089T\f^ÊÈRè\u0094Çx\t0ÓK\u0019%³°\u001fk\u0098\u009fAæg\u0084éµ\u0093\u0019r7sä~ÆÝ!ÆÙo\u0019_ÿ\u008cçð\u0001\u009eÇÇ\u009c9Ì`9\u0086\u009f\u008b\u008e_\u0010K_\u0094\u0002¼$³ñ²,Á+²\f¯J;~);ñ\u009aÜ\u0086×å%¼!¯âMy\u009dxw§\u0095Ø#){9í%ÊqÇG\u0088ÒÏ2\u0007wR»\u009fã\u0017\u008cÞ\u000f0\r/r5\u008f{\u009d\u0082\u0097,º5¤ÙË\u001cðq\u001fÃBH\u008d»\\\u0088\u0097\u0089\u0083\u009a\nÖd^pôK¼ÆPÎ\u0093\u0017ñ7x\u009dY\u0010\u0090§ñ+òçb\u0096Ü\u008b7X:y¨ñóx\u0093Yçµ²Få\u009b\u00adÉ¯S\u009aü-1ÍÞáï8gËèOÉø{zSe×\r\u0018y\u001cµNv½¥a®\u0095`¿aZ\u0081x¼\u0002úà\u0005\r5Öøm\u008bè\b\u0016\u0012C\u000fãd"æQL´ðtLîq:É\u009bÅ\n\u001ceÍc%,3w\u0084\u0085Çä]}\u0018s\u0014Úêê\u0013²S\u009e}ÆÞÇ~e?\u009a\u00192\u001b\u001b<\u008bÊ_\u0081¯påª²>lJ¯\u009b0Ý©\u009bj½§ìA^\u0005Ãió\u0086\nu\u0017oQ£ÜEû\u008e¿Ãø¹p\u0000Ãª\u00148Ð~?Þâ\u009eoSÑw\b/¿å-ýOÄ³w\u0089g¿Ã\u0012Þ¶Kñ/´ÿý\u0014\u009eU°\u001aüGÒy\u0095^¤}×B±\u0095\u008c«\u0087,ÌZJ¾÷,;\u0096\u0090ó\u0096ô;É¢\u007f\u009f½òø\u0004x\u008eb´\u0086f9\u0002Ír\u0002\u009d¶öKêaß2ÿJ|ß\u008b\u007fsð=Ä³S\u009e8TÞPqhQn\u008d§ÈsÊ\u0083ØYQä\u0099Uëµ@Ýë\u0094O\u0081~lm.¼ÈI=oÓA\u0004\u000f`\u001b\u008b2\u0005/-ÉõÖìõ\'a*oµõ¢}\u008fCÓ\u0091Ms\u00ad\u0087wÅ\u008dý¨iVÕò\u0001\u0084\u001a*,ØK¿:&U¦@Äcéå©HbÏ{V5\u0094ky¿\u0086E=ð!Æâ#Þ&\u001f³Pÿ==÷\tk OÑ\u0086?âr®]\u008d?1Ë>g\u008e\u007fAäù\u0092y{8u\ncÑaÝ*^®\u008e°òHÝ*\u0087R·Ê!çV¹\u0095g©ò-y\u0087hÇà·.\u008e#¨f\u0080N>\u008c©_À{\u0014EV43$§\u0016øñïø\u000fçf®f¯\u000eN¹8÷Ñ¬·Á\u009c´;ÙËlçÎdþOü\u0097\u000bsNöÃÂ\u009dù¿]w\u0096aìÌÈû\u009fÔ\u0013i\u0089µ\u0002\u0004\n;{±\u009d\u0017\u0081g\u001f<¹Oajaø v<\u0005sð[©\u0080Gò¸%.ÇX"\u009cüÐ"ù\bQ\u000bkG\u0011Oa©XÇg\\\u0017\u009fp\u0017³\u008f±\u009fÏ>Î>Á¾\u009bâ.a¿\u0093\u009c»Ø÷xtòvâ2Î\u008fg\u007f9û+Ø\u007f\u0083ë#Ù_Éþ\u009bì¯òäð´;q\ré¯e\u007f\u001déV\u0013)^ñåý?PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008bå>É\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000org/gradle/cli/ParsedCommandLine.class\u0095Wiw\u001bg\u0015~FÛÈòÄ\u008bê%v\u0093TMc[\u0096å\u0018\u0092\u0000ñR·\u008e\u009b\u00908¶SâÆÆ)-L¬\u0089¬TÖ(£\u0091\u0013·\u0094.PhÙ¡liÙ7\u0003\t\u0090\u0014\u0092`rX¾Áá;ßøÆ\u009f \u009c\u009c\u0098ç}g$KÖ¸1GçÌÜ÷Î}\u009f÷Þç.3úÇ½?þ\u0019À\u0001ü.\u0082v\u0098*ò\u0011ø`Ö!\u0089\u008b*¬\b\u0082Î¢ .¶\u008ab\u0004u\u008ef¹\u001e\u0013¸T\u008f\u0093¸,.+*\u009eWñB\u0004M0#hÄ\'ëñ".©øT=^ÂËa¼¢âÕ\b·}:\u0082\u0016|FÅk\u0011tÂ\fã³âþ¹0^\u0017÷7\u0084ÅçÅÎ/Ôã\u008b¸$\u0096_\u0012\u0000_Vñ\u00950¾\u001aA\u0017¾V\u008f¯ãMaó\rqù¦¸¼©â[\n\u001aÍ¼\u009d1s\u0085#+3¶\u0095É¥©\u0099¼ /ë\u0003E;\u0093\u001d\u0098ÒóÃ\nêf2é\u009cn\u0017-CÁÉê§#Î2«çÒ\u0003\u000eÀð¤i¥\u0007Ò\u0096\u009eÊ\u001a\u0003\u000bÙÌÀ\u0093ºU0RãæÒ\u0092\u009eKMfrÆ)yâð(\u0091\u001bò\u0096Q0r¶£*T\u001f>cØ4y¤Zãq \u0004²\u008c%sÙH\u0095\u0081\u001a\u008cË¶¥\u008fYéâ\u0012ñ©hªÀ\u0099Ì\u0014\u0004ô¾Mª-°C#\u0099\\Æ\u001eUÐ\u001e¯08a\u001b\u0096~.k\f÷Î*\b\u008c\u009b)CxÏð¦\u008bKç\fë)ñLAtÒ\\Ð³³º\u0095\u0011kWYçpÎ#\u0084AÍ\u0099\n´¼äÌ\tFA|»\u0094ÒWÓÝ³wó\u001e/ë\u0080½\u0098)xØÖàÓV5KÔ¶x±  \u00ad:Ô\u0095|)ÜÃ\u001eö#÷wOP¿cÆÖ\u0017\u009ec\u009dI(\u0015ßVñ\u001d\u0005Ã^yØ\u0016¢ÈUØ6K¥Þ\u0012ïõ¤ÿbÑ´\u008d±\\jÂÌ\bú½Óîµ3Tp\u0091UG(\u0088\u008c\u0014í|ÑVÐQ³áH1\u0093M\u0019\u0096 7S8\u0096±\n´RÎ\u008a|{\u0085çY\u009b#Û¶õô·nQ/\u0094ª¬5^kÑKo\u009a\u0016u·\u0012O;=F\u0082¸m,·RÚÙ\u0011¯h¤q3\u009b5\u0016$ßbwcÖLO\u001aËF¶Ü\u0099mÞÆ\n\u0012\u009e\u000f¶\b¼ßûLïÐÏn"ª\u0014Ýöûª9mØG7M\u0094h©z*gJw\u008dr\u008b\u0000vè©\u0094D\u009cÕ³Ec\u000búY®Áeçy\u001díK\u0084?ëa{ÿòÿ?ÂÕ\u009cqZ:¯«f\u0002y Ó×È\u008cY´\u0016\u008cc\u0019Ñöm5ðû\u0085Ó\u001a\u000eã\n\tÝ é¸^Xd\u008bkèÇþ\u009a\u0007\u001cù\u001aÞ\u008f\u0003\u001a\u000eá\u0080\u0082\u00076\u009e\u008eY\u0096¾"\bÖð\u0001|PÃ[x[Ãwñ=\rßÇ\u000f\u0014Äîç1sµ=>4ü\u0010?Rñc¶ÂfÖUüDÃOñ3\u0005\u0007Ýñ8\u0014ë*$cÕ/\u001fGWý\u0086\u0012º*ÀSç.°\u00845\u009cÂ\u0093\u001a~\u008eU¾n¶\u0098\u0017\n|É\u0098\u0086_à\u0097\u001c\u0017=\u001a¦0\u00ada\fç4ü\nWU\\Ó0\u008f³\u001a~\u008dßp´WL\u0007öHZÏ\u0096¼:zyÁpyØéø\u0014ëé*ôÄr¦\u001dK\u0019ç\u0019}j¿È\u0015cü\u00ad\u0086ë¸ªá\u0006\u009eÑð\u000e®Ö\u0092[Ã\u001c»£v.\u0095\u00942}Ri\u009b\u008cÆ\u001f\u0097c9SV´UõPÉP\u008cIÎ\u009dir+÷°©\u00039¹¨\u001eã\u000e\u0091´\u008e°gËS§¹\nÓù´ØQ¥¨Z³\u001ey\u0088\u009cÛ\u0087ãµàµ\u001aO\u000fBçMkI\'Æ GÃ>ýÞ \u001bï\u0014=\u009f7r©\u008d\u0091W=Â¶~©\u0084\u0017Ì\u009c\u00adgDô\u00ad\u001e1\b\u0002[¼f(\u0003O\u000b:º½6y\u0085ÙP=ð¸\u009f³J8\u009eJ\u008de³\u0014\u009cÒÇÃü2mç\u0087s\u0000QÑëP0À\u0095\u000fïã\u009a-^^\u001fäúÐ¦5[¼¼þ\u0010êy?\u008cAÊC\u00802\u000e?TjÞHÜ\u0086\u0092¸\u0003ßümøo"@1H1t\u0013ê\u0086\u0018¦XG1r\u0013õ}kÐ\u0014L%×°CÁ\u0015\u009c¤Ð à¯h\u009c¾\u0083&Ú4\u000f\u0005úo!º\u0086\u0007\u0014\f\u0005;\u0082®]LHÒ°e(\u0094ø=\u0002\u001d¡\u008eÀ\u001aZý\u0098[]ÿ×êú;7d\u0090Ãò?\u0082Æk\'W\u00adü¾o£ÔÎÏñ\u009d\fùAþ\u0013Ø\u0085\u0019ì\u0086\u008d=x\u0015\u000fá5Äð:I\u001aá\u008eCü\u000fa£\u0001\u008fb\u0014!Z\u001dÀcx\u009c(\u0013D\u001dÃ\u0011\u0006Ìp1\u008e\'\u0000)\u001dÅ1ÒóaÊ\u001aï\u008eæ8¥\u0013\u0094÷!°NÎü*\u0092*&TþïÀ=t«hTÑÄÕ\u007fÐý_\u0012éP;É=\u009c\'¼\u0092X\u009cáÙ\u0002\u00ad/Ú\u0016ú\u0013Úçý\tF«ÞÆÎ\u0099ù\u0080\u0010ë¥\u0018\u0014bX\u0088\u007f@Çu\t#Bw¶vÉp\u001c§ú\\\u0087}bÈ9¹Ã»¼\u0087x?}\u0007\u009ddüÁ©À¨\u0093\u0095¡\u0080àTò}HH.ßÁÝo!\u0092\u008cîº\u0085ÝsÉè\u001eyë\bV¬ü£«ë\u007fOÞÂC×ËIØ/ë¥\u0017a$\u0010¡\u0017qÖa\u0092\u0015x\u0090A\u000f1\u0015c¬¾ã¤x\u0082\u009a)R_J@\u001c{ñ\u0011& (ü+\u0093}\u009a?Av\u0098ö3x\u008aþG¸û\ff\u0099\u0094\u008d\u0004\b«97\u0001\u00adðßCTE§Bºï"¦¢å]t¸\u008c\u007f\u0094F\u009c×.ã\'¨ññÞ\u009cè»\u0085Ø\u009c \u009bt<ìÃµ2¯\u0011i Êâ1éi\u009b³¡ì_3ã\u0019%\u009c\u0082§ß\u00036ì\r;AØ\u0093÷\u0081ý\u0018\u009eq\u0093÷6ï\u0001A-ÁöV4Rg©\u0091Z¦\u0013l G® \u0018¸¶ºþoÿµrNÚ$«gØ\u0010³dy\u008eE:\u008f\u001eú+\u008e\u008e\u0091ÉN:$\u000eôËÌ\u0095\u009cèÅ³øxU¡\u000bÍ\'\\\u009e5øïB%Ç»6\nZç3¾\u001b]\u001e^á\u009c\u0090\u0088¢kéô>\u001f\u009dl\u009aJþ\r;ï k>Ú\u001d\u0090eÞ\'*ù6zþ\u0092\u0014Eä\u0097\u000eGe¤)ö¤Aù<\u009d],;[í¢ÃS\u0003;\\ô¬Oº\u0016\u0086r\u0017=l8>Y \u008aÃß\u0080ä\u0013\b\u008a^ÚÜ9Ù\u008aÎ\tºðNL\u0006¯ç\u0091vczÂÍ\u00ad&@\u0018SÜ\u0087¹\u001b\u009bÒ\u009ag\u0007\\¬H«VvWc\u0018£ò\u008c\f.¸\u008897\u00ad{ªX\u009a\u0016Å\u0098\u0094ã°\u0097GôoøÛ )\u0010ãªÈ\u0091¶,ÏI8\båsöÈQ¦HI\f0\u001f\u00ad\u009b$Abïs\u008cÖ9û\u008a{ö`_ið\u0096«*^QUt¥\u007f\r\t\u001fÕ\r¢\u009a¹èó\u0089ñûÏ\u001bå\u008c9%ö<\'ì\u000btçE¾B^âKãårÖvs\u000e?ê\u0096Ø`ÙÑAé^EAEXP\tQP\n\u0096dÈ¹ÿ\u0001PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000yß\u0005tÚ\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000org/gradle/cli/ParsedCommandLineOption.class\u008dS]OÔ@\u0014=Ý¯îG\u0081eùP\u0004a\u0015\u0084eQª¨ø\u0001"\u0088hHV1Y\u0083Á·awR\u0006»í¦í\u0012á§ðlâ\u008b\u000f\u0098¨\u0004IÔg\u007f\u0094ñN[`Y$ñ¡Ó\u0099Û{Ï=çÜéï?ß\u007f\u0000\u0098Â\u00934²(ª\u0098H#\u0082b\n\u001d¸\u009e¦å\u0086\u008aÉ$ô4\u0012¸\u0099Á-L%q[¾ï¨¸+ßÓr¹§â¾\u008a\u0007\n\u0012[ÌlpWA¶´É¶\u0098Þð\u0084©\u0097\u0084ëÍ(H\u0095\u0085a1¯áp\u0005#-\u009fg\u0083³É,C/{\u008e°\u008c\u00999*IÌ\nKxs\n¢\u0085ñU\u0005±E»JÅ\u001d%añ\u0097\u008dÚ:w^³u\u0093"¹\u0092]aæ*s\u0084<\u0087Á\u0098·!\u0088I¡d;\u0086n8¬jr½b\ný\u0015s\\^]´k5fU%ÔJÝ\u0013¶Eí\u0092\u0006÷V¥\u0000\u0005Ý\u0085ñ³\u0094\u0014´\u0095=Vy÷\u0082ÕÃ\u001e©£\nj\u0094;*i\u0016=z&x\u008eÔ\f«V\u0017\u001c£Qã\u0096§ §p6K:\u0090dÇ)¹\u007fñKn07T@\u0096½U\u0090.Û\r§Â\u009f\tÉvà\u001cé\u0093\u0012IC\u000fz\u0015t\u009d°]p\u001c¶-)kèDNÃ(Æ\u0014\f\u009dt]6Mn0\u0093,ñøÒû\n÷±(#\u0000ÍWmîæ-ÛËo°-\u009egÖvÞ¿\u001c\u0093²Ñ°\u008a\u0087\u001af0« ?L\'æùZÃôDÝäA¦K©\u008f@ÓÏ¶*Õð\u0018ó\u001a\u0016$¡Ñÿ\u001bï)\u0094\u0095õM^!\u000fÛO\u008f\u0086î\u008c+v\u0002ï\u0096i¥áÊQ,7_\u0085 \u0094¬\u008eÒÀZ\u0006\u0015~\u0093¾«Â]ªÕ½m\\¡\u007f(K?\u0018\rLºHï.:EÐ\u008d8íÉrZ/Pd\u000eQÚ\u0001Ùâ>\u0094â!"kû\u0088~Eì³\u009f}\u0091Vù_\u0082*bTÓG;-ÈÇ%ôûø\u0003¸\u001cbí\u0084XÓÅo\u0088ï¢í\u0010\u0089µ\u009cº\u008fäÏâ\u0017Ä\u000e\u0090"¡\u001fÂpú(\u001c=@&\u0082_Ðö¨2êwì%\u008e ^*õè$üAêPÀPS÷é°û =1D:¥\u009a!ä\u0089©ä¡ÓIfÅ%þÞ±\u0090\u0084\u001f\u001cn\u0082\u0089\u00870\u00815W(v\u0095¾\u0007b\u009eRD\n×$ÈÄ\u0001Ú"xÓjÊ\u00182D¬Ï§ìç\u0086xr7\u0082k>\rº½!âó\u0090V.p£]Á.ÔØG²àÓ±ô\u0080ãD\u0013Ç\\\u0093Ô8"Ùy\tRð\u0089\u008cÿ\u0005PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vÆB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.class\u009d\u0092KOÂ@\u0014\u0085Ï\u0005\u0004D|?PÃ¢ìÀ\u0004\u009a\u0018uã#Q\u008c+¢$\u0018÷C;\u00961m\u0087\f\u0003\tÿJW&.ü\u0001þ(ã\u0014ª1ØDã,îé\u009c9ßôv¦oï/¯\u0000ö±[@\u0016\u001bylæ±\u0095G)\u0087í\u001cv\bÙ\u0013\u0011\n}FHWkw\u0084LSº\u009c°Ü\u0012!¿\u001e\u0006]®nY×7ÎZK:Ì¿cJDóØÌè\u009e\u0018\u0010\u008eZRy¶§\u0098ësÛñ\u0085ÝVò\u0081;ÚH\u009f+-ø )\u0083\u0080\u0085n´kS\u0086#cruLXõøgh|Ó×B\u0086\u0084\u008dj\u00adõÀFÌöYèÙ\u001d\u00adDè\u0099èÎ\u008fè%×LøÜ%\u0094\u0013Ö\u0006\u008e\u0012ñ\u008e\u0085\u008e\u001c*\u0087_\u0089¨å½?õÖ\u0088:("\u0087<\u0081Ú\u0084b\u007fJÕ\u008dö\t\u0017\u001d®\u00adØ\u008atòfë^*K÷¸Õ\u001d\nßµ¦\rXUÞð\u001aV½\u001d\u008c£Üi0\u001e1\u007fÈk\rÂÁ\u007f\u000e\u008dp8\u0083\u009dw\u0007Z±ß8T0gî?\u001a\u0019Pôa¦Î\u009b\u0099m\u0094\u008cÎí=\u0083\u009eÌC\n\u0005S³\u0013s\u001d\u000b¦\u0016§\u0001£\u008b\u0013|\tË1\\\u008fáôZêq\u0006-}CÓ_èJ\u0002\u009a\u009eEË\u0089èj\u0002\u009a\u0099E+\t¨ùw\'©õ\u000fPK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\nÏ8=|\u0001\u0000\u0000ü\u0002\u0000\u00009\u0000\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.class\u009d\u0092ËJÃ@\u0014\u0086ÏØ«mµ¶ÖjÕEÜ5B\u0013PÄ\u0085\u0017\u0090\u0016\u0017R/Pé~\u009a\u001eÓ\u0091$\u0013&ÓBÞJW\u0082\u000b\u001fÀ\u0087\u0012\'i\u0010©AÄY\u009c3óÏÿÍ\u009c¹¼\u007f¼¾\u0001À\u0001l\u0097 \u000f\u008d"l\u0014¡Y\u0084Í\u0002l\u0015 E \u007fÊ<&Ï\tdÚú\u0090@¶ËÇH Úg\u001eÞLÝ\u0011\u008a{:r\u0094Rïs\u008b:C*X4NÄ¬\u009c°\u0080ÀQ\u009f\u000bÛ´\u0005\u001d;hZ\u000e3\u0007a Ñ½\u0013ÜG!\u0019\u0006]îºÔ\u001bG\u008bv¹7S"\u008a\u0013\u00025\u001beb\no}É¸G ÑÖû\u008ftFM\u0087z¶9\u0090\u0082y¶²¶~X{()spL`7e.°\u0004KV,\røTXxÉ¢\u008aõ¿\u0094fD\u0005T \u0000E\u0002¤G \u001cÄPÇW\u0014\u0081ã\u0001Jm®h~²\u00adÆ\u001f49Aíjx\u00adµÑ°\r\u00adÓsÃhöÌ\rgÔ\u0099¢n\u00108üÇ5©Û] .F\u0081\u0014Ô\u0092¿s°\u00079õàQË\u0002\u0089Î¢â²\u001a\u0099*\u0013\u0095sû/@\u009eUg\tJ*æc±\u000ee\u0015+s\u0083Ê+1¾\nÕ\u0004î$p¦¾ô´\u00806¿¡\u0099/t-\u0005Í,¢;©h-\u0005Í.¢Z\nª>kìZÿ\u0004PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ýØ?¢\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000gradle-cli-classpath.properties+(ÊÏJM.)¶å**Í+ÉÌMµå\u0002\u0000PK\u0003\u0004\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000gradle-cli-parameter-names.properties\u0003\u0000PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000m±>=@\u0000\u0000\u0000?\u0000\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081)\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA\u009b\u0000\u0000\u0000org/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA¿\u0000\u0000\u0000org/gradle/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íAê\u0000\u0000\u0000org/gradle/wrapper/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ªÙfØ\u0003\u0005\u0000\u0000ê\t\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u001d\u0001\u0000\u0000org/gradle/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000hQþ}¢\u0000\u0000\u0000Ò\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081k\u0006\u0000\u0000org/gradle/wrapper/Download$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Çåî©\u001b\u0002\u0000\u0000L\u0004\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081N\u0007\u0000\u0000org/gradle/wrapper/Download$ProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u00005¶<\u009bÀ\u000e\u0000\u0000\u009c\u001d\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081»\t\u0000\u0000org/gradle/wrapper/Download.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000y\u0081L¢¡\u0000\u0000\u0000Ê\u0000\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081º\u0018\u0000\u0000org/gradle/wrapper/DownloadProgressListener.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000!9|\b¶\u0006\u0000\u0000\u0084\f\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ª\u0019\u0000\u0000org/gradle/wrapper/ExclusiveFileAccessManager.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0090ì\u0084,y\u0002\u0000\u0000\u0086\u0004\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081± \u0000\u0000org/gradle/wrapper/GradleUserHomeLookup.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099c67§\t\u0000\u0000\r\u0016\u0000\u0000*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081u#\u0000\u0000org/gradle/wrapper/GradleWrapperMain.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000úâ\u0018æª\u0000\u0000\u0000Û\u0000\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081d-\u0000\u0000org/gradle/wrapper/IDownload.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000p@áõc\u0007\u0000\u0000\t\u0010\u0000\u0000"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081N.\u0000\u0000org/gradle/wrapper/Install$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T¨,\u007f-\u0014\u0000\u0000t+\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ñ5\u0000\u0000org/gradle/wrapper/Install.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ð¿:öo\u0002\u0000\u00004\u0005\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\\J\u0000\u0000org/gradle/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000on\u0019\u0011¶\u0001\u0000\u0000`\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\bM\u0000\u0000org/gradle/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001dJØâ\u0016\u0007\u0000\u0000[\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0014O\u0000\u0000org/gradle/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0084\u007fÍëÂ\u0004\u0000\u0000|\t\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081nV\u0000\u0000org/gradle/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ª=©\u000f°\u0002\u0000\u0000?\u0007\u0000\u0000-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081~[\u0000\u0000org/gradle/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Gü¨\u000f\u0015\t\u0000\u0000\u001c\u0014\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081y^\u0000\u0000org/gradle/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Ôe\u008b\u000b\u001f\u0000\u0000\u0000\u001d\u0000\u0000\u0000#\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081Ôg\u0000\u0000gradle-wrapper-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u00814h\u0000\u0000gradle-wrapper-parameter-names.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000íA}h\u0000\u0000org/gradle/cli/PK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ÕÜ?®<\u0002\u0000\u0000S\u0005\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081¬h\u0000\u0000org/gradle/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000×\u0083µ³X\u0004\u0000\u0000ì\n\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u00817k\u0000\u0000org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000}\u00adÎyG\u0001\u0000\u0000K\u0002\u0000\u00001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081èo\u0000\u0000org/gradle/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000³ßâú\u0019\u0001\u0000\u0000g\u0002\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081~q\u0000\u0000org/gradle/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000Sf\nÕ\u0002\u0006\u0000\u0000g\u000e\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081Þr\u0000\u0000org/gradle/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000üí\u008a¯¥\u0000\u0000\u0000å\u0000\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081$y\u0000\u0000org/gradle/cli/CommandLineParser$1.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0099ÐÆ\u00adN\u0003\u0000\u0000å\t\u0000\u0000;\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u000fz\u0000\u0000org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¥\u0019D£¢\u0002\u0000\u0000&\u0007\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081¶}\u0000\u0000org/gradle/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¤ÇÇà\u0001\u0004\u0000\u0000\u009b\u000b\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081©\u0080\u0000\u0000org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000´*«ZM\u0002\u0000\u0000ï\u0004\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0004\u0085\u0000\u0000org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0006è2\t\u0004\u0007\u0000\u0000Á\u0011\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081µ\u0087\u0000\u0000org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000$Ä¾¢¥\u0002\u0000\u0000ô\u0006\u0000\u0000<\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0014\u008f\u0000\u0000org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000T\u0004K>ª\u0002\u0000\u0000Ä\u0006\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0013\u0092\u0000\u0000org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0098%àÌ»\u0002\u0000\u0000ª\u0006\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0018\u0095\u0000\u0000org/gradle/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000äfC\u0098§\u0001\u0000\u0000£\u0003\u0000\u00008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081(\u0098\u0000\u0000org/gradle/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000¢Æ÷E«\u0002\u0000\u0000¶\u0005\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081%\u009a\u0000\u0000org/gradle/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000gAq²\u0094\u0002\u0000\u0000x\u0005\u0000\u0000=\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081!\u009d\u0000\u0000org/gradle/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000`M~U\u0004\u0002\u0000\u0000¸\u0004\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0010 \u0000\u0000org/gradle/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000pÍX\rÝ\u0002\u0000\u0000k\u0007\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081d¢\u0000\u0000org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000dZ\u009bÔ\u0016\u0012\u0000\u0000l)\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u009e¥\u0000\u0000org/gradle/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u001a\u008bå>É\u0007\u0000\u0000\u0000\u0012\u0000\u0000&\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ø·\u0000\u0000org/gradle/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000yß\u0005tÚ\u0002\u0000\u0000E\u0005\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081\u0005À\u0000\u0000org/gradle/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\\vÆB|\u0001\u0000\u0000\u000b\u0003\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081)Ã\u0000\u0000org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\nÏ8=|\u0001\u0000\u0000ü\u0002\u0000\u00009\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ýÄ\u0000\u0000org/gradle/cli/SystemPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000ýØ?¢\u0015\u0000\u0000\u0000\u0013\u0000\u0000\u0000\u001f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081ÐÆ\u0000\u0000gradle-cli-classpath.propertiesPK\u0001\u0002\u0014\u0003\n\u0000\u0000\b\b\u0000\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000¤\u0081"Ç\u0000\u0000gradle-cli-parameter-names.propertiesPK\u0005\u0006\u0000\u0000\u0000\u00003\u00003\u0000Ã\u0011\u0000\u0000gÇ\u0000\u0000\u0000\u0000',
      f3b4dae340056399e69926fa62aba660b3e9404e:
        "#Mon Mar 23 21:48:17 CST 2020\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.5-all.zip\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStorePath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\n",
      e8895216fd3c0c3af4c4522334775f41b7deb42e:
        "connection.project.dir=\neclipse.preferences.version=1\n",
      "958fbe16bc8ffad9e705d43fcf0cf0cb5561425d":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="CompilerConfiguration">\n    <annotationProcessing>\n      <profile name="Gradle Imported" enabled="true">\n        <outputRelativeToContentRoot value="true" />\n        <processorPath useClasspath="false">\n          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.12/48e4e5d60309ebd833bc528dcf77668eab3cd72c/lombok-1.18.12.jar" />\n        </processorPath>\n        <module name="refactoring-crawler.main" />\n      </profile>\n    </annotationProcessing>\n  </component>\n</project>',
      a64b2758bd03a20260566a40b58c116679055c17:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="GradleMigrationSettings" migrationVersion="1" />\n  <component name="GradleSettings">\n    <option name="linkedExternalProjectsSettings">\n      <GradleProjectSettings>\n        <option name="distributionType" value="DEFAULT_WRAPPED" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="gradleHome" value="/usr/local/Cellar/gradle/5.5/libexec" />\n        <option name="gradleJvm" value="1.8" />\n        <option name="modules">\n          <set>\n            <option value="$PROJECT_DIR$" />\n          </set>\n        </option>\n        <option name="useQualifiedModuleNames" value="true" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>',
      "4fed64e0de33c78035aa4aa1eb052668eb85c6d4":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="RemoteRepositoriesConfiguration">\n    <remote-repository>\n      <option name="id" value="central" />\n      <option name="name" value="Maven Central repository" />\n      <option name="url" value="https://repo1.maven.org/maven2" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="jboss.community" />\n      <option name="name" value="JBoss Community repository" />\n      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="BintrayJCenter" />\n      <option name="name" value="BintrayJCenter" />\n      <option name="url" value="https://jcenter.bintray.com/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="MavenRepo" />\n      <option name="name" value="MavenRepo" />\n      <option name="url" value="https://repo.maven.apache.org/maven2/" />\n    </remote-repository>\n    <remote-repository>\n      <option name="id" value="maven" />\n      <option name="name" value="maven" />\n      <option name="url" value="https://mvnrepository.com/artifact/org.jgrapht/jgrapht" />\n    </remote-repository>\n  </component>\n</project>',
      b1662faf91f158c3fc95e7f294260c2ea0cdbc12:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ExternalStorageConfigurationManager" enabled="true" />\n  <component name="ProjectRootManager" version="2" project-jdk-name="1.8" project-jdk-type="JavaSDK" />\n</project>',
      e96534fb27b68192f27f985d3879e173ec77adb8:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="Palette2">\n    <group name="Swing">\n      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />\n      </item>\n      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">\n        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />\n        <initial-values>\n          <property name="text" value="Button" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="RadioButton" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="CheckBox" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />\n        <initial-values>\n          <property name="text" value="Label" />\n        </initial-values>\n      </item>\n      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">\n          <preferred-size width="150" height="-1" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">\n          <preferred-size width="150" height="50" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">\n          <preferred-size width="200" height="200" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />\n      </item>\n      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />\n      </item>\n      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">\n          <preferred-size width="-1" height="20" />\n        </default-constraints>\n      </item>\n      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">\n        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />\n      </item>\n      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">\n        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />\n      </item>\n    </group>\n  </component>\n</project>',
      "0f5826ff690d76f8961058a4fd1cf25f380882c3":
        '<?xml version="1.0" encoding="UTF-8"?>\n<project version="4">\n  <component name="ChangeListManager">\n    <list default="true" id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n    <option name="SHOW_DIALOG" value="false" />\n    <option name="HIGHLIGHT_CONFLICTS" value="true" />\n    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />\n    <option name="LAST_RESOLUTION" value="IGNORE" />\n  </component>\n  <component name="ExternalProjectsData">\n    <projectState path="$PROJECT_DIR$">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name="ExternalProjectsManager">\n    <system id="GRADLE">\n      <state>\n        <projects_view />\n      </state>\n    </system>\n  </component>\n  <component name="FileTemplateManagerImpl">\n    <option name="RECENT_TEMPLATES">\n      <list>\n        <option value="Interface" />\n        <option value="Class" />\n      </list>\n    </option>\n  </component>\n  <component name="ProjectId" id="1ZX2iP5KDQ49uV7GFoPy8hIg22p" />\n  <component name="ProjectViewState">\n    <option name="hideEmptyMiddlePackages" value="true" />\n    <option name="showExcludedFiles" value="true" />\n    <option name="showLibraryContents" value="true" />\n  </component>\n  <component name="PropertiesComponent">\n    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />\n    <property name="WebServerToolWindowFactoryState" value="false" />\n    <property name="aspect.path.notification.shown" value="true" />\n    <property name="last_opened_file_path" value="$PROJECT_DIR$" />\n    <property name="show.unlinked.gradle.project.popup" value="true" />\n  </component>\n  <component name="RunManager" selected="Application.RefactoringCrawler">\n    <configuration name="RefactoringCrawler" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">\n      <option name="MAIN_CLASS_NAME" value="refactoring.crawler.RefactoringCrawler" />\n      <module name="refactoring-crawler.main" />\n      <extension name="coverage">\n        <pattern>\n          <option name="PATTERN" value="refactoring.crawler.detection.*" />\n          <option name="ENABLED" value="true" />\n        </pattern>\n      </extension>\n      <method v="2">\n        <option name="Make" enabled="true" />\n      </method>\n    </configuration>\n    <configuration name="refactoring-crawler [dependencies]" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">\n      <ExternalSystemSettings>\n        <option name="executionName" />\n        <option name="externalProjectPath" value="$PROJECT_DIR$" />\n        <option name="externalSystemIdString" value="GRADLE" />\n        <option name="scriptParameters" />\n        <option name="taskDescriptions">\n          <list />\n        </option>\n        <option name="taskNames">\n          <list>\n            <option value="dependencies" />\n          </list>\n        </option>\n        <option name="vmOptions" />\n      </ExternalSystemSettings>\n      <GradleScriptDebugEnabled>true</GradleScriptDebugEnabled>\n      <method v="2" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue="Application.RefactoringCrawler" />\n        <item itemvalue="Gradle.refactoring-crawler [dependencies]" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name="SvnConfiguration">\n    <configuration />\n  </component>\n  <component name="TaskManager">\n    <task active="true" id="Default" summary="Default task">\n      <changelist id="24fd105e-2973-4f35-bddc-4762d669e749" name="Default Changelist" comment="" />\n      <created>1584971244282</created>\n      <option name="number" value="Default" />\n      <option name="presentableId" value="Default" />\n      <updated>1584971244282</updated>\n      <workItem from="1584971249949" duration="21487000" />\n      <workItem from="1585056855574" duration="4355000" />\n    </task>\n    <servers />\n  </component>\n  <component name="TypeScriptGeneratedFilesManager">\n    <option name="version" value="1" />\n  </component>\n  <component name="WindowStateProjectService">\n    <state x="320" y="115" key="#Auto_Import" timestamp="1585018149423">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="320" y="115" key="#Auto_Import/0.0.1440.900@0.0.1440.900" timestamp="1585018149423" />\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser" timestamp="1585064908569">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="533" y="173" key="#com.intellij.ide.util.MemberChooser/0.0.1440.900@0.0.1440.900" timestamp="1585064908569" />\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1584971325953">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="563" y="357" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1440.900@0.0.1440.900" timestamp="1584971325953" />\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1585016078944">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="277" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1440.900@0.0.1440.900" timestamp="1585016078944" />\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom" timestamp="1585056369795">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.bottom/0.0.1440.900@0.0.1440.900" timestamp="1585056369795" />\n    <state width="1398" height="240" key="GridCell.Tab.0.center" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.center/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="1398" height="240" key="GridCell.Tab.0.left" timestamp="1585056369793">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.left/0.0.1440.900@0.0.1440.900" timestamp="1585056369793" />\n    <state width="1398" height="240" key="GridCell.Tab.0.right" timestamp="1585056369794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="1398" height="240" key="GridCell.Tab.0.right/0.0.1440.900@0.0.1440.900" timestamp="1585056369794" />\n    <state width="500" height="445" key="SwitcherDM" timestamp="1585027804908">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state width="500" height="445" key="SwitcherDM/0.0.1440.900@0.0.1440.900" timestamp="1585027804908" />\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup" timestamp="1585064476794">\n      <screen x="0" y="0" width="1440" height="900" />\n    </state>\n    <state x="385" y="196" width="670" height="676" key="search.everywhere.popup/0.0.1440.900@0.0.1440.900" timestamp="1585064476794" />\n  </component>\n</project>',
      d45b35fe7e96659467ab36d569bede38ef6d8956:
        '# Java Gradle CircleCI 2.0 configuration file\n#\n# Check https://circleci.com/docs/2.0/language-java/ for more details\n#\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/openjdk:8-jdk\n\n      # Specify service dependencies here if necessary\n      # CircleCI maintains a library of pre-built images\n      # documented at https://circleci.com/docs/2.0/circleci-images/\n      # - image: circleci/postgres:9.4\n\n    working_directory: ~/repo\n\n    environment:\n      # Customize the JVM maximum heap limit\n      JVM_OPTS: -Xmx3200m\n      TERM: dumb\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - v1-dependencies-{{ checksum "build.gradle" }}\n            # fallback to using the latest cache if no exact match is found\n            - v1-dependencies-\n\n      - run: gradle dependencies\n\n      - save_cache:\n          paths:\n            - ~/.gradle\n          key: v1-dependencies-{{ checksum "build.gradle" }}\n\n      # run tests!\n      - run: gradle test',
      dfe0770424b2a19faf507a501ebfc23be8f54e7b:
        "# Auto detect text files and perform LF normalization\n* text=auto\n",
      ea419d85c301b292fbadf5b1f4da2c8350a1c0f1:
        ".gradle\n/build/\n/.idea/\n# Ignore Gradle GUI config\ngradle-app.setting\n\n# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)\n!gradle-wrapper.jar\n\n# Cache of project\n.gradletasknamecache\n\n# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898\n# gradle/wrapper/gradle-wrapper.properties\n",
      "669e8aabbeb973fc803553332427c4c3309bf0b6":
        '<?xml version="1.0" encoding="UTF-8"?>\n<projectDescription>\n\t<name>refactoring-crawler</name>\n\t<comment>Project refactoring-crawler created by Buildship.</comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.buildship.core.gradleprojectbuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.buildship.core.gradleprojectnature</nature>\n\t</natures>\n</projectDescription>\n',
      b34fbf6028059b5e0f654d1d1645aef6f2400c75:
        "# refactoring-crawler\nJava tool for detecting refactor\n",
      "6a7f3eb3c219c561b4ed3a7adeb10145aaa07750":
        "/*\n * This file was generated by the Gradle 'init' task.\n *\n * This generated file contains a sample Java Library project to get you started.\n * For more details take a look at the Java Libraries chapter in the Gradle\n * User Manual available at https://docs.gradle.org/5.5/userguide/java_library_plugin.html\n */\nplugins {\n    // Apply the java-library plugin to add support for Java Library\n    id 'java-library'\n    id 'com.github.sherter.google-java-format' version '0.8'\n    id 'jacoco'\n}\n\njacoco {\n    toolVersion = \"0.8.5\"\n    reportsDir = file(\"$buildDir/customJacocoReportDir\")\n}\n\njacocoTestReport {\n    reports {\n        xml.enabled false\n        csv.enabled false\n        html.destination file(\"${buildDir}/jacocoHtml\")\n    }\n}\n\njacocoTestCoverageVerification {\n    violationRules {\n        rule {\n            limit {\n                minimum = 0.5\n            }\n        }\n\n        rule {\n            enabled = false\n            element = 'CLASS'\n            includes = ['org.gradle.*']\n\n            limit {\n                counter = 'LINE'\n                value = 'TOTALCOUNT'\n                maximum = 0.3\n            }\n        }\n    }\n}\n\nrepositories {\n    // Use jcenter for resolving dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n    mavenCentral()\n}\n\ndependencies {\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\n    api 'org.apache.commons:commons-math3:3.6.1'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-core', version: '1.4.0'\n\n    implementation 'com.github.javaparser:javaparser-core:3.15.14'\n\n    compile group: 'org.jgrapht', name: 'jgrapht-io', version: '1.4.0'\n\n    compile group: 'com.github.javaparser', name: 'javaparser-symbol-solver-core', version: '3.15.14'\n\n    compileOnly 'org.projectlombok:lombok:1.18.12'\n    annotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    testCompileOnly 'org.projectlombok:lombok:1.18.12'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'\n\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\n    implementation 'com.google.guava:guava:27.1-jre'\n\n    // Use JUnit Jupiter API for testing.\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'\n\n    // Use JUnit Jupiter Engine for testing.\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'\n    implementation 'org.jetbrains:annotations:15.0'\n}\ntest {\n    // Use junit platform for unit tests\n    useJUnitPlatform()\n}\n",
      "8e25e6c19d5748190b8cc39e98c2b56e496a5717":
        '#!/usr/bin/env sh\n\n#\n# Copyright 2015 the original author or authors.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n##############################################################################\n##\n##  Gradle start up script for UN*X\n##\n##############################################################################\n\n# Attempt to set APP_HOME\n# Resolve links: $0 may be a link\nPRG="$0"\n# Need this for relative symlinks.\nwhile [ -h "$PRG" ] ; do\n    ls=`ls -ld "$PRG"`\n    link=`expr "$ls" : \'.*-> \\(.*\\)$\'`\n    if expr "$link" : \'/.*\' > /dev/null; then\n        PRG="$link"\n    else\n        PRG=`dirname "$PRG"`"/$link"\n    fi\ndone\nSAVED="`pwd`"\ncd "`dirname \\"$PRG\\"`/" >/dev/null\nAPP_HOME="`pwd -P`"\ncd "$SAVED" >/dev/null\n\nAPP_NAME="Gradle"\nAPP_BASE_NAME=`basename "$0"`\n\n# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nDEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'\n\n# Use the maximum available, or set MAX_FD != -1 to use that value.\nMAX_FD="maximum"\n\nwarn () {\n    echo "$*"\n}\n\ndie () {\n    echo\n    echo "$*"\n    echo\n    exit 1\n}\n\n# OS specific support (must be \'true\' or \'false\').\ncygwin=false\nmsys=false\ndarwin=false\nnonstop=false\ncase "`uname`" in\n  CYGWIN* )\n    cygwin=true\n    ;;\n  Darwin* )\n    darwin=true\n    ;;\n  MINGW* )\n    msys=true\n    ;;\n  NONSTOP* )\n    nonstop=true\n    ;;\nesac\n\nCLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n\n# Determine the Java command to use to start the JVM.\nif [ -n "$JAVA_HOME" ] ; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then\n        # IBM\'s JDK on AIX uses strange locations for the executables\n        JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n        JAVACMD="$JAVA_HOME/bin/java"\n    fi\n    if [ ! -x "$JAVACMD" ] ; then\n        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\n    fi\nelse\n    JAVACMD="java"\n    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\n\nPlease set the JAVA_HOME variable in your environment to match the\nlocation of your Java installation."\nfi\n\n# Increase the maximum file descriptors if we can.\nif [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then\n    MAX_FD_LIMIT=`ulimit -H -n`\n    if [ $? -eq 0 ] ; then\n        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then\n            MAX_FD="$MAX_FD_LIMIT"\n        fi\n        ulimit -n $MAX_FD\n        if [ $? -ne 0 ] ; then\n            warn "Could not set maximum file descriptor limit: $MAX_FD"\n        fi\n    else\n        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"\n    fi\nfi\n\n# For Darwin, add options to specify how the application appears in the dock\nif $darwin; then\n    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""\nfi\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin ; then\n    APP_HOME=`cygpath --path --mixed "$APP_HOME"`\n    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`\n    JAVACMD=`cygpath --unix "$JAVACMD"`\n\n    # We build the pattern for arguments to be converted via cygpath\n    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`\n    SEP=""\n    for dir in $ROOTDIRSRAW ; do\n        ROOTDIRS="$ROOTDIRS$SEP$dir"\n        SEP="|"\n    done\n    OURCYGPATTERN="(^($ROOTDIRS))"\n    # Add a user-defined pattern to the cygpath arguments\n    if [ "$GRADLE_CYGPATTERN" != "" ] ; then\n        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"\n    fi\n    # Now convert the arguments - kludge to limit ourselves to /bin/sh\n    i=0\n    for arg in "$@" ; do\n        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`\n        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option\n\n        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition\n            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`\n        else\n            eval `echo args$i`="\\"$arg\\""\n        fi\n        i=$((i+1))\n    done\n    case $i in\n        (0) set -- ;;\n        (1) set -- "$args0" ;;\n        (2) set -- "$args0" "$args1" ;;\n        (3) set -- "$args0" "$args1" "$args2" ;;\n        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;\n        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;\n        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;\n        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;\n        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;\n        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;\n    esac\nfi\n\n# Escape application args\nsave () {\n    for i do printf %s\\\\n "$i" | sed "s/\'/\'\\\\\\\\\'\'/g;1s/^/\'/;\\$s/\\$/\' \\\\\\\\/" ; done\n    echo " "\n}\nAPP_ARGS=$(save "$@")\n\n# Collect all arguments for the java command, following the shell quoting and substitution rules\neval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\\"-Dorg.gradle.appname=$APP_BASE_NAME\\"" -classpath "\\"$CLASSPATH\\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"\n\n# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong\nif [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then\n  cd "$(dirname "$0")"\nfi\n\nexec "$JAVACMD" "$@"\n',
      "9618d8d9607cd91a0efb866bcac4810064ba6fac":
        '@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the "License");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an "AS IS" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if "%DEBUG%" == "" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif "%OS%"=="Windows_NT" setlocal\n\nset DIRNAME=%~dp0\nif "%DIRNAME%" == "" set DIRNAME=.\nset APP_BASE_NAME=%~n0\nset APP_HOME=%DIRNAME%\n\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\nset DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\n\n@rem Find java.exe\nif defined JAVA_HOME goto findJavaFromJavaHome\n\nset JAVA_EXE=java.exe\n%JAVA_EXE% -version >NUL 2>&1\nif "%ERRORLEVEL%" == "0" goto init\n\necho.\necho ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:findJavaFromJavaHome\nset JAVA_HOME=%JAVA_HOME:"=%\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\n\nif exist "%JAVA_EXE%" goto init\n\necho.\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\necho.\necho Please set the JAVA_HOME variable in your environment to match the\necho location of your Java installation.\n\ngoto fail\n\n:init\n@rem Get command-line arguments, handling Windows variants\n\nif not "%OS%" == "Windows_NT" goto win9xME_args\n\n:win9xME_args\n@rem Slurp the command line arguments.\nset CMD_LINE_ARGS=\nset _SKIP=2\n\n:win9xME_args_slurp\nif "x%~1" == "x" goto execute\n\nset CMD_LINE_ARGS=%*\n\n:execute\n@rem Setup the command line\n\nset CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n\n@rem Execute Gradle\n"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n\n:end\n@rem End local scope for the variables with windows NT shell\nif "%ERRORLEVEL%"=="0" goto mainEnd\n\n:fail\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\nrem the _cmd.exe /c_ return code!\nif  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1\nexit /b 1\n\n:mainEnd\nif "%OS%"=="Windows_NT" endlocal\n\n:omega\n',
      "7b8bd669f6da73e4611a1c8a63e8a11c5f7e28cc":
        "/*\n * This file was generated by the Gradle 'init' task.\n *\n * The settings file is used to specify which projects to include in your build.\n *\n * Detailed information about configuring a multi-project build in Gradle can be found\n * in the user manual at https://docs.gradle.org/5.5/userguide/multi_project_builds.html\n */\n\nrootProject.name = 'refactoring-crawler'\n"
    },
    language: "Java",
    description: "Java tool for detecting refactor"
  },
  {
    name: "backend",
    language: "Java",
    description: "djakldfjklajsdlkfajsdlkfjaldsf",
    lastUpdateAt: new Date().getTime(),
    currentBranch: "master",
    ownerId: "PatrickLai7528",
    commits: [
      {
        sha: "d452a08ee6b7772f30b876395b09ce7a15f8a58c",
        message: "chore(*): update lai's mysql settings",
        stats: {
          total: 4,
          additions: 2,
          deletions: 2
        },
        author: null,
        committer: { id: "PatrickLai7528" },
        parents: [
          {
            sha: "1327329a38f6f97ee8caef9e6f99b28c5b721b29"
          }
        ],
        committedAt: 1584511342000,
        changedFiles: [
          {
            sha: "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6",
            filename: "src/main/resources/application.properties",
            status: "modified",
            additions: 2,
            deletions: 2,
            patch:
              "@@ -1,4 +1,4 @@\n-spring.datasource.url=jdbc:mysql://localhost:3306/myDb\n+spring.datasource.url=jdbc:mysql://localhost:3306/tle\n spring.datasource.username=root\n-spring.datasource.password=admin\n+spring.datasource.password=\n spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\\ No newline at end of file",
            rawContent:
              "spring.datasource.url=jdbc:mysql://localhost:3306/tle\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver"
          }
        ]
      },
      {
        sha: "1327329a38f6f97ee8caef9e6f99b28c5b721b29",
        message: "Initial commit",
        stats: {
          total: 753,
          additions: 753,
          deletions: 0
        },
        author: null,
        committer: { id: "PatrickLai7528" },
        parents: [],
        committedAt: 1584510539000,
        changedFiles: [
          {
            sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
            filename: ".gitattributes",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+# Auto detect text files and perform LF normalization\n+* text=auto",
            rawContent:
              "# Auto detect text files and perform LF normalization\n* text=auto\n"
          },
          {
            sha: "a2a3040aa86debfd8826d9c2b5c816314c17d9fe",
            filename: ".gitignore",
            status: "added",
            additions: 31,
            deletions: 0,
            patch:
              "@@ -0,0 +1,31 @@\n+HELP.md\n+target/\n+!.mvn/wrapper/maven-wrapper.jar\n+!**/src/main/**\n+!**/src/test/**\n+\n+### STS ###\n+.apt_generated\n+.classpath\n+.factorypath\n+.project\n+.settings\n+.springBeans\n+.sts4-cache\n+\n+### IntelliJ IDEA ###\n+.idea\n+*.iws\n+*.iml\n+*.ipr\n+\n+### NetBeans ###\n+/nbproject/private/\n+/nbbuild/\n+/dist/\n+/nbdist/\n+/.nb-gradle/\n+build/\n+\n+### VS Code ###\n+.vscode/",
            rawContent:
              "HELP.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**\n!**/src/test/**\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n\n### VS Code ###\n.vscode/\n"
          },
          {
            sha: "a45eb6ba269cd38f8965cef786729790945d9537",
            filename: ".mvn/wrapper/MavenWrapperDownloader.java",
            status: "added",
            additions: 118,
            deletions: 0,
            patch:
              '@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2007-present the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.channels.*;\n+import java.util.Properties;\n+\n+public class MavenWrapperDownloader {\n+\n+    private static final String WRAPPER_VERSION = "0.5.6";\n+    /**\n+     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n+     */\n+    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n+            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n+\n+    /**\n+     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n+     * use instead of the default one.\n+     */\n+    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n+            ".mvn/wrapper/maven-wrapper.properties";\n+\n+    /**\n+     * Path where the maven-wrapper.jar will be saved to.\n+     */\n+    private static final String MAVEN_WRAPPER_JAR_PATH =\n+            ".mvn/wrapper/maven-wrapper.jar";\n+\n+    /**\n+     * Name of the property which should be used to override the default download url for the wrapper.\n+     */\n+    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n+\n+    public static void main(String args[]) {\n+        System.out.println("- Downloader started");\n+        File baseDirectory = new File(args[0]);\n+        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n+\n+        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n+        // wrapperUrl parameter.\n+        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n+        String url = DEFAULT_DOWNLOAD_URL;\n+        if (mavenWrapperPropertyFile.exists()) {\n+            FileInputStream mavenWrapperPropertyFileInputStream = null;\n+            try {\n+                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n+                Properties mavenWrapperProperties = new Properties();\n+                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n+                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n+            } catch (IOException e) {\n+                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n+            } finally {\n+                try {\n+                    if (mavenWrapperPropertyFileInputStream != null) {\n+                        mavenWrapperPropertyFileInputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // Ignore ...\n+                }\n+            }\n+        }\n+        System.out.println("- Downloading from: " + url);\n+\n+        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n+        if (!outputFile.getParentFile().exists()) {\n+            if (!outputFile.getParentFile().mkdirs()) {\n+                System.out.println(\n+                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n+            }\n+        }\n+        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n+        try {\n+            downloadFileFromURL(url, outputFile);\n+            System.out.println("Done");\n+            System.exit(0);\n+        } catch (Throwable e) {\n+            System.out.println("- Error downloading");\n+            e.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n+        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n+            String username = System.getenv("MVNW_USERNAME");\n+            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n+            Authenticator.setDefault(new Authenticator() {\n+                @Override\n+                protected PasswordAuthentication getPasswordAuthentication() {\n+                    return new PasswordAuthentication(username, password);\n+                }\n+            });\n+        }\n+        URL website = new URL(urlString);\n+        ReadableByteChannel rbc;\n+        rbc = Channels.newChannel(website.openStream());\n+        FileOutputStream fos = new FileOutputStream(destination);\n+        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n+        fos.close();\n+        rbc.close();\n+    }\n+\n+}',
            rawContent:
              '/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = "0.5.6";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            ".mvn/wrapper/maven-wrapper.properties";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            ".mvn/wrapper/maven-wrapper.jar";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n\n    public static void main(String args[]) {\n        System.out.println("- Downloader started");\n        File baseDirectory = new File(args[0]);\n        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if (mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n            } finally {\n                try {\n                    if (mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println("- Downloading from: " + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n        if (!outputFile.getParentFile().exists()) {\n            if (!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n            }\n        }\n        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println("Done");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println("- Error downloading");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n            String username = System.getenv("MVNW_USERNAME");\n            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n'
          },
          {
            sha: "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054",
            filename: ".mvn/wrapper/maven-wrapper.jar",
            status: "added",
            additions: 0,
            deletions: 0,
            rawContent:
              "PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MF\u0095\u008fA\nÂ0\u0010E÷\u0081Ü!\u0017H¨\u0015Eº³®*\b\u0082Å\u00ad\u0084d\u008aCÛ$LcÅÛÛVT¨+wÃÿÃ{ü\u0083vXA\u0017å\u0019¨Cï2±P\tgE\u001b\u001ahÁE\u001d\u0087P\u0096\u0018\u001bÈD«{pòN:\u0004 \u009f§\u000f!Q+µælKæ\u008a=Ð·8\u0092ïq8Å»â,¿a\u0013eþ\u0018á®\"°\u009c\u009d\u0002\u0018¬Ðü¥vÖ\u0093,l&Ð«¨kMÈÙ\u008e@G°\u0013½\u009c2Q8£^R+÷¶\u001e×nTrI\u0097éÜ;_ÃÙ\u0013PK\u0007\bK¡Ý1¨\u0000\u0000\u0000+\u0001\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000META-INF/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000META-INF/maven/io.takari/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00005\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.properties+K-*ÎÌÏ³5Ð3Õ3ãJ/Ê/-ðL±ÍÌ×+IÌN,ÊäJ,*ÉLKL.\u0001\næ&\u0096¥æé\u0096\u0017%\u0016\u0014¤\u0016q\u0001\u0000PK\u0007\bL´@\u0005:\u0000\u0000\u00009\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/apache/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000org/apache/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000org/apache/maven/wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.class\u0095VÉv\u0013G\u0014½\u0085\u0086\u0016¢\u0099\u0004\u0006ä`#bÀ\u0092\u0007up\b\u0001\u008b\u0098Á\u0081 \"\u001bc\u0083A\u0098\f-©lµ\u0091º\u0095î\u0092±3'\u0090y^åd\u0099U¶a#û\u0084\u0013²Ï\u008fä/\u0092¼jµlI\u0096sN´èªzUuß»¯î«Ò\u009f\u007fÿö\u0014ÀIü `\u001bÃ°e/hzEÏ\u0017¹VÖ\u0097¸©=°õJ\u0085ÛÚ%Ë\u0012\u008e Á\u0084n\u00983B·\u0005·\u0015ø\u0019ö,êKºVÒÍ\u0005ízn\u0091ç\u0005Cð\u009ca\u001ab\u008cÁ\u0017OÌ2øÇ\u00ad\u0002\u000fÃ\u0087í*\u0002\b2ìÎ\u0018&\u009f¬\u0096sÜ¾©çJ\u009c!\u0092±òziV·\r9ö\u008c~Q4\u001c\u0006-ó¿\u0082J1\u0004\u001cÙe8\u0016\u009fËlD7#lÃ\\HÕ-\u0086¥]1J<%ã\u000b_^Îó\u008a0,ÓQ\u0010aØ·±g}&\f\u0086ý*ºp\u0080Â\u009f7ÌBF¯\u009a\u0014\u0090}M·\u0019zãm¨\u00adC\u0005\u0087\u0018\u000eº&\u0093\u000bíÖtf¼¤;NÆÒ\u000b2\u0089Ý\fjód\u0018\u0087Ñ« §aö`T\u001cA\u008cÈ\tëÖt\u009aò\u001e÷¼Ôw¥Sa<\u008bc\núZÑÒ*\u008eã\u0084·-³i[\u0086¶Å1  ÁÐµÁ»)>\u0015\u0083\u0018\"ò\u000b\\Ì¬8\u0082\u0097\u009bæ\u0018¢\r¸öm.nR\u0085&7o§ÍSºÍM\u0011ÆA\u009c\u00942\u0018aH4\u008e§\u0011Ê\u0016H\u0089Ù0Ná´\u0082\u0017ZÔv³hs½ âE\u009caØ\u0099¯Ú\u0012¿n¤p[âª[S\u0012fTE\nç\u0088¬ÃÅ¸e\n¾,Z\buÇ·\u008c\"\u0004\u0092ôI\u0012c2O\u0082.êU'Y)ñejòrÝ\u0003Ë.\u0015\u009cdÉ\u0013F²¡\u0010Iù\u0082\u008a\u008b¸D\u0089(\u0011\u0098\u008bÊp<¾Y\u009c\u009b\u0092\u0099\náeR¨+ûdÑ*s)\u008e+*^ÁU\u0012\"¥õbÎ±JUÁ§tQl§í\u0081\u0086q\r\u0019\u0005¯¶d¯~\u0096*&0É°\u0083\u00921e[TRb\u0085áL\u0087Àþ;TÏ\u0014Â\u0014ùhNFÞ2çC\u0098&Ij9ÃÔÊ#®Er¸)Ep\u008b¡¯\u00adt:8¢Äß¦Û L5® K´Ûr¤`\u008e\u008a¶C©\u0087q\u0007¯©x\u001doÔ%8ÁEÑ\"q\\è@pnSæ\u009b\tÚ|¾DW\u009bVG `\u001dy\u00059\u0086C[\u00adQQ\u0000ÝaAÃ\\²îSçl³ÏúEÙâÓ3%6\u009b\u0088ºn/\u0090`¶»*¸J\"`ØÕ\u009a5\u0086\u0090;éÞF\u0091|\u0007]G3[Ü?)\u0017Ø0=UîÝ\u0094\u0007W~\u0086ÙH^÷Öia8Ðz\u008f¯T\u001awùþvØs\u0003c¤\u0017rèÏÑ%.\u0015QU±\u0084\u0007²F\fGHV2\u009axb®\u0095©\\¹¢âm©\u007f\u0085ÎtR/ó\u0010Þ¥¸êµ8Ü$¿áäÀ½ä¢N\u0015ø>>TðAk\u0001¸ç®â#|LHe]P\u00ad\u0092Ç®NUyWÁ#ò°11]5\u0085QæëÏC\b\u009f2\u008c\u008f[ÕR!fZ\"V¢4\b\u001e\u0013E\u001e\u009b\u0090ç\u0012kÜ\n±k\u0017§c\u0086éY\u000bÄÔ6rU\t\u0011ë?îô'e¨\u009f«ø\u0002_\u0092væ-\u009bâjÓN\u0007½vÐÎz\u0005<Ä×²Ò¾Ù\u0082\u0099|\u009eç\ryBá\u0019«jçù\u0015w\u0010íô²&åv\u001c¥\u0097Ð\u0007ùóQ\u008fÞsú*4Ò¨eÔ\u0006\u0006V\u0011zL\u009dm\bÓ7è\u001a»±\u0083¾j}\u0001µ;©%\u0011c7\u00adÚC}?\u008döJ\u0018v\u0084vH8g`h\u0015û&\u009fà`Öÿ;¢Yßp\rÏÔptf\rý5\f¯â¹Qÿ\u001a\u009e\u008fúk8\u001bõG^ªáüh 2>TÃå5¤oG®?ÁáìPäÆ*f<S4\u0010\u0099%¨;Y_ä.Ùî\u008d\u0006£AF\u0006_Ö7Hã7o?v9É G)4\u0090Ð\u0082è¡ðzq\u0088\u009eÞ^ê÷!F¯áQzFú0\u0086c¸\u0081\u0013È£\u001f%zëLjm\f¸D¯Ö)xDeo\u001es.y\u0007\u000b(\u0012é Ê0¨ç#¤),â>¥à\u0014Î\u0013R\u0099\u0012\u0094'¯&,ZUñÒV\u009f{\u008bæ¶É?!^Î\u007f¤o\u0090Ú´$;\u0018±]²\";\u001axzÚï\u001bû\u0005Ñh gd\u0082r²\u001cy§\u0086÷~B`è×G>ÖÓåÿù\u009f¿\u009eàa6òI#\u0001køl\u0015_ý±~n\u0007È\u00150L¤\u0093HÐá\u000eRÿ\u0014F\\z1W\u0000éuzi\u0097\u0014£µ»ð\u00adK\u008fá;\u0017éû\u007f\u0001PK\u0007\bÒØüÆB\u0005\u0000\u0000`\n\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00002\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.class\u0095SmO\u0013A\u0010~\u0096Ö\u001e\u009c\u0087Ôj\u008bø\u0006JÅ¶`\u008f\u001a¿aÐ¦ÅÄ¤\u0005B\u0015bø`\u0096viÏ\\w\u009b½-\u0084\u007f¥\u001f\u0014£\u0089?À\u001fe\u009c½T\u0083@\"\\rs³sÏ<Ïdföç¯o?\u0000TðÔÁ\u0018Ã\u0092Ò]\u009f\u000fx»'ü>?\u0010Ò?Ô|0\u0010Ú¯\u008b}>\fM]\u001dÊPñ\u008eÐù\u008a\u0083$Cî\u0003?à¾\u0014Æ¯\u000eMOH\u0013´¹Q\u009a!ezA\u0094_&ÎÆÅIW(ïy \u0003³Êà\u0017.\u0093XÜfHÖTGL\u0080áª\u0087+H¹H`Ò\u0083\u0083k\f\u0089\u0082\u0005L5\u0002)Ö\u0087ý=¡ßð½P0d\u001aªÍÃm®\u0003{\u001e\u0005\u0093¶t\u0086ò%ôó\u0015*}¦+Ì&\u008f¢C¥;'º\u0011(É0_(6þ¶ê|Ð\u008a\u0083\u001cÃì\u007fPã¸Å0ÙÜ^ßyÿ¶µ¶µ^m®¹¸\u008d»\u000eî0¤ãä\u0090Ë®ß:\u008a\u008cè{¸\u0087ûÔ\u0010[\u0099VTº9bX(4Nà\u008c\u000edw¥x64\u008e¹?J\u009bÕVkgc«îâ!ò\u000eæÿU\u008aá\u001e\u001ea\u0081\u0094\u008cªõ¸®jÍI)Y(îÖ\\dQ°s(2L\u009f#½[³³q[j¨ÛâU`'\u0090;Óà²M£\t®Év¨\"Jk\nÓS\u001d\u0007e\u0086ÒÅçäaÙ®Ãt[Éý ;Ôâô\u009c¼×R\n]\u000b©÷\"Â\u001c-S\u0082î\u0007K§íF\u00917F¯\u0083q\u008aO\u0090÷\u008cÎ6â\u0096\u0016?\u00939\u0086÷)ÆL\u0091M\u0011\u0006XE\u009a¬\u0017û.®#Cß$nàæ\u0088á\u0005\u009dì¿ìwdße¦¿b&3Kæ\u000b\u001e\u001cãñÇSd/O\u0090eGd\t\u0094bÔ\"\u0096bê'ðé:[1\u0016ãèù\rPK\u0007\b5ìC¢\u0012\u0002\u0000\u0000å\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000S\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.class\u00ad\u0094]o\u0012A\u0014\u0086ß\u0003´K·Ø\"*X¿Zûå.*«^\u0099`L\b\u008d\u0089\tÚÆ*\u0089éÕ\u0014FX³Ì\u0090Ù¡È\u008f2©7¶ÑÄ\u001fà\u008f2Î\u0000*µ$íE7Ù93sÎ¼ç\u00999³ûó×·\u001f\u0000\u001eã\u0089\u0083\u0004á\u0095T\u00ad\u0080uY£Í\u0083\u000e;à\"è+Öír\u0015lñ\u000f¬\u0017é-Ù\u0017\u0091dM®Öw\u0007±æ\u009d\u001d%\u008d[\u0087<6½O\u0083JO·¹Ða\u0083i©\u001c¤\bù\u008fì\u0080\u0005\u0082ëà\u0084\u008f0û,\u0014¡~NHz~\u009d\u0090ªÊ&w\u0091Ä\\\u00063\u0098%,ÖBÁ_÷:û\\½eû\u0011'äj²Á¢:S¡\u001d\u008f'Sº\u001dÆ\u0084íÚ\u0085¢\u0097\tK-®wX\u001c÷¥jNøB)\bk\u009e_û»¯éAe\u0007\u0097\tËgD¥q\u0085°ÐÖº[êZ\u0088w1W.®¡à OÈ\u000eWGL´\u0082\u0011r\u0006×±D\u0098·h#ú\u0001aÓ«MÄi\u0015\u008aVÙ?=\u0095ÆMs\u0084ÿRý\u0001Jã6\u00016é²\u0095_!<\u009d\"x®\u0014.V±î`í$ùÐ\u0097Á\u00066\r¹\u0096Õ6S\u0015¥\u0098!Oyþ^ÕE\u0016\u009e\u00ad¹O(LÉ¼Wµ×ã\u008dwÁ\u0005öë.\bs\u0004wWöT\u0083¿\bímÊ\u009fÒ*Y Bæ¥\u0010\\U#sh<vð\u0088P<?\u000faõl\"¬\u0018\u009e$ì\u0093DÂ~\u0003fì\u0098Q`¬©\u0010f\u008aGH\u007f1\u009d\u0084©\u0016\u0086nà3æM\u009b\u0019\u0005\u0018{ÉØ\u0014\u0016°8^\\1³ÖWø\u008eìû\\î\u0018Ws7r·\u008eqç+î\u001eáÞá\u007fr\u0087\u0013r\u0085\u0091\\Ö\n\u0017Çr\u001bÆ&Æ,÷§³$\u0086ï\u0083aû\u0010%Ø»e7\u0010\u0098¿\u008cû\u001bPK\u0007\bË\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00000\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.class\u0095X\u0007`\u001bÕ\u0019þ\u009e-ùÎâ0\u008e\u009c8QB\u0089\b\tñ\u0090\u00ad\u009a\u0091\u0010\u009b@ãÄ\u0001\u0083í\u0004Évª\u0004HÏòÙ>\u0090uæt²ã\u000eº \u0085\u0086ÒB\u0007e\u0094RZF[Ú\u0092\u0016d\u0093°ÚÒÐM÷Þ{ï½è÷\u009edY¶\u0015\n\tÑ½ñ¿\u007f~ÿÿÞÏ§þ{øQ\u0000mâ\u0005\u001a*\u0004\u009a\u001cw4jN\u0098É1+:nNZéè\u0094kNLXnt\u00875bfSÞ\u000eg*\u009drÌaËÕà\u0013¨½Ì\u009c4£)3=\u001aÝ5t\u0099\u0095ô4T\t\u009crl.Åã\u00025»c»Î\u008buÅãû·\u009f?Ðw¡\u0080è\u00168~»\u0093ÎxfÚ\u001b4SY«\u0012Ú;Ã\u0002Çu\u000eìÜÙ\u0015Û\u001fïÞÛU\tl¬\u00158\u0081üRvÒôl'Ýg\u008e[\u0002Á\u009ey]â\u009ek§G;¸XB6h¹\u0019~\u0004ªÎ¶Ó¶w\u008eÀÆ\u0086¥g\u0096®4\u000e\nø¶;ÃV\u0000\u0095Xn \u0016+\u0004*\u001b\u001a\u0007«!°ÒÀñ¨\u0091£\u0090\u0081\u0013P\u0013àh\u008d\u0081\u0013%Í\u0089I'=b\u008ff]k·ë\u001c\u0098Þ\u0096õÆ¬´WÐF\u0012\u009ed`\u00ad$\\Y$\\HC3{ì´Õ\u0097\u001d\u001f²Ü~s(¥Ìt\u0092fjÐtm9/,ú¼1;#\u0010éyöáëÐ±\u00811\u0018ó¼\u0089Ö\t©Þ@Ær\u0003Ø\u0088F\r\r\u000b\u0002\u001b\u009fÎxÖ¸\u0081&43\u0014£\u0096GkÈÒ\u009b\u00168µ\u008c\u0003\u001b\u0097.ih\u0011è}öº\u00adÏ\u008b,È±\u00adÌbÿ9Ô4\u0082¨\u008cÅó\u0005b\rÏÁîgÁ\u009b\u0011\u000fà4\u009c¡át\u0081zeMÚò¢\u000bh\f\u009c\u0089M\u0002\u0081\u008cå\u0015D0î\u0005o,!&C\u001dg\u0011Ü½\u0083}{ö\u000fÄ»b}Ûz»t´Ï-íÞ\u0016\u008fïÙ\u0015Û¡álFñ9\u0018Ó\u0016@\u0007Î\u0091~8W ú\\ü `\u00ad\u000f\u0017æ\u0002kK\u0094\u001f\u0088u\u0017òÀv¢;í\u0094¥\u0088\u0003]\u0007\u0092Ö\u0084ÄeFÃ\u000e\u0081ºù8\u0017w\u0002Ø\u0089ó5\u009c'`\u0094\u009e7Ð\u008d\u000b\u0098xÖ\u0001;ãeTöì\u0095¤=\u0006zÑG/HT\u0099.\u001d&©\u0089¾\u0086Æ\u0085ò%ñn\u0003\u0017).ã\u0097\u000fÛnF&PÜ@?¶\u0091~Î\u008eî´g¹i3% \u0099ÃÃ®\u0095¡°\u009a\u0085\u0086\u0011ÃÃVÆ³Ó\u0085\u0014«Y,i/.Ö°oÎ\u0082Â1\u0003\u0097àR\u0001¿ç\fÄzJ\u0014Ìo÷\u0010â/bÂÏqêÌ\u008e\u008cX®5¼+ëMd=f\u0081e\u008ek\u0018\u0012XU*«t7\u0000\u0013Ã2\u008e´~YÃbç\u0007°\u001f£rw\u008cuf~·\u0094\u0081¢º\f)\r\u0097/T\u009d>\u001e\u0087´\u0093\u0080O³º¦Y¥\u0095á«\u0017Ù0¿×!};aà\n°L×Ó\u0091\u009dfÆN.®M\u008de\u0011³\u0094\u0099TLÀ3\u0090Å$ë\u0017«W2\u009b2=K\u0016\u009cm£ä(°¼¡LÕÐq\u0080 \u0093T-\u008a,\u0080\u0017ã¥\u001a^R\u009a\u0093\u000b$\u0019x\u0019\u0096Q\u0002s2f]\u0091e\u0090ç*\u0095<úr\u0003¯À+é\u0007b\u00ad;]ô\u001b«o\tØJ6:ü\u0090\u007fx\u0001é¸\u009a\u0097Sk\u0000¯Åµ\u001a®a®\u001c3Íz\u009cÑQ\u008bÅáu8Èªl§G\u001c\u0081\u0015å\u008a$}òz¼AÃõ4¾\\8\r¼\u00117\u0010oS®í\u0011\u0012ZÃ¾ÎînyêMx\u008b\u00867ÏeßB\u0095\r¼\u00157Q.ÇÌh?Ï4vë¸Y\u0000òÜ\u00ad\u0006n\u0093·\u008d?\u0099r2\u0096\u0094\u007f+3ÑÉÒÿõå!EV¼\u0099\u0018êUÇ\u008a\u00ad@\u0085Íý\u0015e\u001dHîY7µ(\u0001{¸\\\u0093\u009d\u000b½ºå\u0099ÒC*aÈm_'\u008dMgÇcÊ\u0084\u0013x3\u008dÊ,Þîdef3\f\u0017hx\u007f©õ»Jj\u008fÀ\u0007\rÜ\u008fCL¡\u0005(ëVqX·\b¯e!÷aúGÞ\u0089\u0019Y\u0007\u001e4\u0090\u0093\u0098\u00ad&dâ\fö8½6\u008bÃ\u001a\u001eZxAªÃ\u0006\u008eàaYã®È\u009a©Ì¢°ç\u001fG\u001d\u008d{u<*pÕ\u009em±¾î¾óÂ\u0003\u0019\u001e\f\u009fßß¿;¬R,¼0ÇÂÎ¤å\u0086ÍtØNg¬$\u009f\u0007ádÑõaÏ\tÏU½0\u000f\u0085{%\u0010ÃÃ,°®=\u0094\u0095$\u00adáÝ)ËÌ¨S\u0019\u009b5?\u009c-Ê\u008b+8?nà#\n©S¦\u009bÖñ1Vb©\u0081ãÚ/V\nhø8óc±¥\u009dY;En:\u009e¤¹y½\u0003x\u0002\u009f\u0094\u0005ê \u008cÂ§\r|F>\u0016\u008c!JßtFW:©^OOàs\u0006\u009eÂçyJfK\u009a\u0001nyV\u000f\u0088\u0082À\u000eÉâ\u008b\u0006¾$c¢{N~\u00935\"YRÕôl!àòµö5\u0003_Ç7¸È\u0000nO\u0099ò6¨[PjÔ\"ù~\u000bßÑðm\u0002nÑ\u0096\u0081ïâ{ù\u009a¡æ=\u0085·kh)\u0097\u009e¹gÕ\u000f\nàhe\u0010R\u00ad\u009dÊ\u0005\u0001ü\b?ÑðcÂ¢ì1\u0003?ÅÏ\b4\u0019Í\u0082¢\u001bþ\u008fkòªëø\u0005\u001d@õòNv¥)¿2ðkü&\u000fÛ^\u008bá¤£_P\u0086Û¾%ÜJù»ÖH\u008aN\u008dæ9PÐï\n×W©]ë\u000bbuü\u0081^²Ô¤¿\u0010\u0018\r÷\u0006ðgüUÃ_æ.¾2\u008c\rü\r\u007f'\"ìô¤s9KÁ\u00962i³¯L&-]ÒñO&ï@ÿÎ\u0096³d\u009aþÛÀ\u007fðß|ì;§=\u008b.\u00ad/çÒ}\u009d:Ë\nÂrç@ë\u0081ñTë\u0090\u009d\u001enÝaz¦7=a±Ø1\tY{tÁþhÙ\u0004\u000fyyÛ;ù\u0084p§5Á6hõ<Û\u0018\u000b\u0095=n\u0015«\u0092.Ø\u0010]<÷î\u0092é·4Q3á)Û\u001b{\u0086:`gÂiÇ\u000bg²\u0013\u0013\u000eu\u0019\u000esmÚÉºá\u000b\u0006{[\u0003¢RèÌ=QÍþí\u0099;\u009aþ1×\u0099\u0092-\u0083zÐUÍub+\u008f\u0081e\u0002y\u001eYsHZ}l\u008c0ãó\u0010\u0098£ÕòSwawV\u0088\u0017\u0001#×ÎÜåv\u0099nÊ\u0096T+J¨\u008a\u001edzn\u0014Ë\r±B\u0096\u0094**d¥'\u0019`±Ò\u0010«D\u0088B&å%²kdQ;R\u0006(\u0005\u0087°\u008c\böhO\u0089\u0013ùdkØþLõf¯8É\u0010ke½\u0091\u008dÏü]Â\u008bÍ.Ô\u009a´ê>õ\tºmÊq\u0087u±\u009eÄ*O\u0018æa\u0087¸9µð ã\u0082ê@uÑP¨4\u00ad\u0093ãó\u008bM4ÅÉ´J~º\u00880«9)n¶æ7M79¦\u000bö<k6d¢\u001b2á\u0086\r\u0099\u000eõ_cÉP:ç4C\u009c.Î ¿F\u001cwÜô\u0016åU\u0099\u0002plwQ\u0013\u0096ëb÷\u001c\u0090\u0004\u0083Ê´\u0082¡Å\u00adeó[óÍ¶\u0093É÷çÕN¦tq\u001b-!³8Q\u009c´ò¯þú%MJ«dHïu³¾»\n\u00992\u008d×ýÿ\u0016\u000e'3¥+ùÏ\u000f\u001fVC\u0083Îq5\u009fs\u0015|\n\u00adÆq%s\u0003AÙÂs\u001c\u0094\r<¿²\u009b¯Å2þ\u00069³ISÉïÊ¦\u0019Ô55?\u0088ú¦È\u0083XÅÙjþ{Þ!Å$ÌßÕ¨âo\u0094\u0002\u009fO\u0016mdu\u001a\u0019\u009c\u008ez\u009cAu@\u001aÅ\u0006ëp\u008azY®Tb\u0085\u001aIÁ\u0015ü{\"V\u0014ÄîTê\u0003Ë\u0083ëgqêQÔ\u001cA$!fÐ:\u008b¶y\u00995\u008açf\u009as\u0016êÐ®ä\u0018ùs\u00059\u0015ò\u007f1\u0014x\u000e\u0016x®\u000fnV<O\nnQßz%ãI)£#A£¶\u0096\u0091±\u0015«p\u000e9î(\u0091±¾ \u0083×\u000b¶\u0091º\u0093c\u001fgÛ\u00954\u008bç\u0094Å\u0091\u001cºn\u0086ï\u0010¿\u0017æ°kOSsd\u0006±y\u0001õ\u0090Oíó\u0018¥óiÈ\u0005ô}\u000f×z\u008fá´\u0001\u009a\u0091wÚ\u001e¼P9\u00ad\u007f©pñSò<\u009e+\u0087E\u009fh÷7ç\u0090h¯:\u0082ý\u0089#0\u0013\u0094\u009e\u009cÁH_¨*\u0007»Ý×Ô\u001còÍÀ¡Ý\u0099v-ä\u000bN\u0085´\u001c¦C¾\u001c®l÷/ÛXû°Þ®Wo\u000eÜ\u0083H}`EõÕææ@}`9^5^ýæÛQ\u001b¼j\u0016¯Qsks %¤W®¨Îáº\u0090?¤çpcbSuÅ\u001dO\u007fæ\u001e¬m7\u0082o#aÈ\u007f\u0014zÈ\u009fÃ--G¡µäðö\u0090ñØ1v\u000e)ô¾\u0086\u007fçüt%C\tìæ,Æ\u009d~¢x\u0000kè\u008duôD#}\u0011E\u00820Ø\u008bs±\u008fð¹\u0084=÷¥ôä~R¾\u0088¿ì/1\u0084\u0014\u007f³\\\u007f5Fp\rFÙ\u0004\u008cáFbü&\\\u008e[¹û\u000e¤q'×ïáú}\\?Äõ\u0007¹þ\u0010\u001c\u0015\u008fëU\u0086\u001c.Æãp1\u001e\u0087\u008bñ\u0098ÅíäSI\u009aaÜ\u0081w2*w2ëò£\u0087H\u009b\u001fùÉ÷N¼\u008bßãp\u0000ïÆ]L\u009f(u½\u009b\u00124ê¿\u0095:ÜK<ôÐ¶÷ð[\u008d\u0097óT~ÔM¨¿\u0017ï#×\nÙ¤\u0096Dÿ>\u0005½\u009bTÞ31\u009a\u009agð\u0081¾\u0096'\u0089¾à\u0087\u0088\u0082\u0007r\u0098¹\u0005zð\u0091Y<\u0016\t~ô\b\u009eH\u0004\u008fÎà\u0013M-3øT\u000e\u009fÍá\u000b\u008cý<4O¢* \u0080*d(Ì£ª\u0093\u0004Þ\u0014ót\u001a\u009bØTJ\u00974åE\u0015]²¹è\u0092Íø2M\u00adàé6|EåQ\u0085|\u0018ç³QDÉ[V\u008c\u0083M9|5\u0087oöF\u0082ßÏá\u0087Á\u009fW>\u0082oåðË¾Hð·rþ{\u001fç\u0089Êà\u001fã\\l÷µ\bîWæð§v\u007fÈ\u0017òs³2QÙ\u001cüG\u000eÿ\"Á\u009f\u001eÇìý{\"Á§y²N\u0088Ò£}-¢\u001cqß\u0011Q\u0099¨\u0013þ\u0096\u0019¡=F\u0005u\"ì\"fQ\u008cÝô\u0095üæ\u001dÑDóAÄèlmWá Zq\u001d¶\u0010=\u0017\u0011\u00111öªc¸\u0081Ô72FoRN\u0089\u0091\u0092¦\u0015\u009drP9\u0080÷$^-\u0002â8r]\u0085-Â\u0010ÇÓ)\u00ad8EÔpä#ÇUâ\u0004QËè\u008d¡^\u00adU\u0092£!\u0096\u0089 r\u001e{»B)»\u0096séö6\u00962Q×ËB&êú\"G±\u0096é³F\u008652+ê\u0019ØÚö\u009cXÝ\u0092\u008fìýÍ9ñ¼û\u0017\u0095\u009d\u009b\u0019\u0083[XÏneÅ¼\r\u0011Bw>¦mEõÛDXÅ´\u008ao\u0090\u0093U\u00ad6°A¬+Ä4KTäÕú3yJÃÇ\u009a\u001e`Ó\\'Na]í\u00ad\u0013\u001bøé«\u0013\u001bùi÷Õ\u0089Fùõ×\u0089fù\u00adª\u0013-ò«Õ\u0089h\u00ad®\u0002ÄÃõñ\u0084¯9\u009eð\u0087üñDU¨*\u009eÐBZ<¡Gâ\u0089Úª\u0016þ°PÅgEÛ¼5ë\u0094Ü;)ÿÝÔí.Þ\u0006w³8ÜCýï%âÞÃ{è½%\u0081\u0019+XæGR\u009c©\u0002càb±IYV\u0087\u0001±YY¶\u0006½â,\u008e|¤í\u0012[8ò\u0093×VÑÎQ\u00159\u009e):T²V\u0088³¥\u001eb«8G]£\u0015è@þO\u0004B\u009c\u008bÀÿ\u0000PK\u0007\bC5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000org/apache/maven/wrapper/Downloader.classE\u008eÁ\u000eÁ@\u0010\u0086ÿ¡\u0094\u0092\u0090x\u0000\u0007\u0017.6Î½\"\u0091H$\u0084ûj'´©ÝfUëÙ\u001c<\u0080\u0087\u0012[\u0084I&3\u007fþo&ÿãy»\u0003\u0098 í¢B\u0018hs\u00102\u0095Á\u0091ÅIæ¬Dad\u009a²\u0011S]¨DË\u0090\u008d\u000b\u0087Ð\u008de.E\"ÕA¬ö1\u0007\u0019¡\u0011~\u0011B\u007f¸|û\u008a3±]/ü\u008f\u008a´\u0098G\tû£\u001dÁ\u009b]\u0003N³H«³\u008b&¡÷ÿ÷s,µÑ\u0017\u0013pyEèü#\u008cKºN TQ\u0016ÙD5Ô\u00adv\u00adrìlØöì^Aë\u0005PK\u0007\b\u0084q÷\u0012°\u0000\u0000\u0000ã\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/apache/maven/wrapper/Installer.class\u009dXy`\u001cåuÿ=i¥Y\u00adÆ\u0097\u008cl\u008bÃ,\u0006ù\u0090u`\u001bd\u0090\u008dñ!\u0019D$YX\u0096ÄÚ`3Ö\u008eäÅ»;Ë\u001e\u0096d®\u0080m\u0012\bá\bIÁ\u0086p;Î\u0001\u0004Ó°²\u0011`Z\u0002iSÚ4éEÚ4mi\u009aÞ-½ï¸¿7{hW\u0092\u0013Ã\u001fZ}3ßûÞý~ï}óÝ\u009f½þ\u0016\u0080\u0015rÌ@\u0089`\u0091\u0013\u001fj²bÖÀ\u001e»)bí³£MÃq+\u0016³ãMíÑDÒ\n\u0087í¸\u0001\u008f`ö-Ö>«)lE\u0087\u009a¶ì¾Å\u001eH\njZÛ6oèíØ¶«µ½gÛÖö\u008d½ÛÚ·tíêÞ°íZAUÇ\u0004}O2\u001e\u008a\u000e\u00ad\u0011ÌØä(Ïh²Ï\n§l/*ø*'-\u0018J$\u0013\u0002oÐ\u0019\u008e\u0086\u001d+(¨í8£j\u00adY\";®\\cVrÏ\u0086DÂ\u008eì¦²\u0082¥g>×]HÉ£åkCÑPr\u009d ûç\u001c*\u0010v¶\u009c\u0097õ\t<\u009b\u009c íC)ªLÌÄ\\AéÒe}\u0015\u0010T\u009bð¡RWóM\u0098\u0098!\u0098Õ\u0011\u008aÚ]©Èn;¾Í\"\u0003u\u009f3`\u0085û¬xH\u009f³/=É=!ºè\u00923k\u0091\u000f\u0019mó\rÄm+i·Ò¯\u0082«\u007f\u008e}ý\u0099ÿ\u008cÍ`h(\u0015·\u0092!'ºfY&~!§is(l+»¶\u0091\u0001;¦{\t\u0003~ÁÜ\u0089øæw¼X$0;ûºúwmmëÞÒ»µÃ\u0087K°Ø@mQþô\u008c&\u0092vÄÄ\u0012,e\b\u0086ì¤\u001dÝ'X¼tjÊ,\u009búÊ\u0087:Ô\u001bX^ÌÑÝ3Ñ\u0080F\u0081\u0011J´EbÉQ×ãÛ\r\\J\u009d\\Ò¨\u009dlêÝÚn`%]?ùðÆT(Ì\u0010+ûËL\\\u008ef2Ú§iºep\u0092n\u0099ô\u009f^·\u0015¸B£}%£<\u009d9}^Ð\u0095Ò¤\u0084W\u0099X\u0087«é\u0000õ~\u0094ùÞpV\u000eÈê¹Æ\u008b\r\u0082uS\u0082\u009ayhÈ<¬jln\\UôªÁ}Õ°;\u0014mÜ\u001f\u008a©\u001a\u009bL´¢\u008d\u0085\u0097t2\u0002\u0004ç,\u009dÖ¶&\\á\u0005K{y+#6\u0090´\u0083þÂHû\u0019ÄPÜ\u0089FìhÒ¿/\u009b¸~\u001f®C\u0087\u0081O\t.<cþu8CCvÜD§ºÍ\u0013\u008a\u000e:>lÁõ\u0006ºé\u0093\u008f\u0095µ&¶¢\u0087åÄ\u0094Ò´\u008f\u0087v§ô5S%gQ6\u0005è½^ÁÂ\\eÓ>\u007f§r÷Ó1V|Ô?\u0018w\"~õN¿\u0006é\u0086I±9c\u0002äb£úo7±C³qv(±!<l\u008d&rÂtó&\u0013;usfn³7J\u001b÷úp3v\u001b°\u0098pg\u00074jð\u0080`ïÇ¯î³ã\u007f\u0089\u000bC\u0085¾¤m6\u0086\f°(®ø¤<LìA\u0088\u0088Â0m\u000fÅ\u0014_\n\"\u0094C\u001c\u001fö\"b \u009c+Þì{\u0013Qu\\¹=¢ýB\u0089b&nUv3È®Û\u008a3ý\u0094Nw\u0012&\u0092\u009aÚ\u0006wº¬\b\u001b\u000ea¦¬1fÅ\u0093º=¢\u0095J\u0094¸xi±äéêVéo3q»+;h\u0087Y\u0001^ÜIÝ\nS¨\u0012\u009fÆ=\u0006î&Ë³h&Ú\u0005\u000e°.\u0096\u0016gf±.\u0019É\u0087LÜ\u008bÏ°Fi\u001díØæ\bæLRzÙv\rÌ}&îW_TMª\u0080Ö\u0010\u0081Mð\u0080\u0089ÏãAò\ts\u008fïØLü\u0093ùd\u001ey*ÜÔAª5\u0095xXñö\u0011&kñ\u008en<jâ\u008bø\u0012\u0019\u0086\u00926SËa÷\u009d·´\u0090E{ö=Ù<\u0086Ã\u0006\u001e§nSwM\u001cÁ\u0013¬ý¨=\u0092\u009c\f?ÙbóâËì9\u00adêyuu0\u0014ç[\u0087¥ªþyÚÄ3\u001ah-ü\r»\u0013N8\u0095´5\u0007ÕæçL<¯¾«ÈD\u008dV«*GM|Åí\u0015{¬D\u0017¥zñU&do\u0094 \u0018Sþ^|\u009dúø\u0093\u008e_y¼hâ%¼ÌÜI)ÁDÌ\u008a3f\"f\u0006^\u0011\u009c;aÃÖT4\u0019\u008aØ\u0005}òUÁ®\fâ\u0004\u000bÂä_R\u009bXâ\u000f:vÂ\u001fu\u0092þ\u0001'\u009a´BQ¿\u0015\u001dÍ\u001b\u001c²\u0013\u008dþ¶\u0091X\u0006\u0080©ß`(\u001aôÛ#Ö@2<ê_1á\u0098Fídß2ñ\u001aÒLÙA'\u001e±èÛ+§é1;Î²·}\u0013WhÌO\u009ax\u001dãl®t¶¶¹öi¢¥N{ÓÄ[8%X\u0090°\u0093m#ö@*©\u001d¡Û\u008eGB\u0089\u0084\u008e\u0011Ó$q\u009f\nø\u0015\u0013¿\u008awèþDh¿í6ñv/Þ\u0015Üx&\u0087eý\u0094 ;\u001c\u007fä\u0093y\u008bø1P\b\u0091\u0082¦\u008f\u0089©L¿BÕzã\u0084®\u0099Åµ-¨\u008cì\u008b\u000eoµcNfÛ*ê\f\u009c\f¶\u0013R¬\u0082\u008e@\u001f\u0085'Ã§ å\u0093Ã7ù»\fóÀ;sÊ \u0097\u009bÀm*äKFbyR#\u0098\u0081\r\u0086&è\u0082ÇìÉ`Áh\u0005u\u007f^ñø:\u001aË\u008d°þI'Ö\u0016K_G\u000e\u0015=¡¡¨\u0095LÅI~é/@§)Ç\rüqn4u\u00896ÄãÖ¨Rúð#T)Vü©\u0089?Ã\u0087\u0014£\u0018¨§Ü<\\¶cj÷ù\u0089\u0089¿P\u008c¨\f%Zsy¢ùù\u0097&þ\n\u007fMS\u00ad`pÒ\u009c\u0097+\u001f\u0086Ñ3èv!Áß\u0099ø{eS\u0011Jô3û\u009cá\u0084\u0017ÿHgrÔhb6\u0018ø'ÖÈ\u0004\u008bî¸3`'\u0012ÙQÂ\u008b\u007f!ì\fì\u00898A/þ\u008d2W_~¹êö\u001f&þS\u0011o6\u008bp\u0093\u0015u¢!ú;\u0003y\u001fá¿µ±ý\u008fBñ\u008eé{ÙGø?\u0013?Ãi²æ}!î\u0096qa\u0015guXã\u0013\u0091RCxK\u009c3eÓ\u0014\u008f\u0016©1l\u0085\u0092\u009b\u009d¸WÊ\u0019Ý\u001e;ÉêÊÕº?6Qì~\"P\u008bß\u0010/ÕÊyzcjpÐ\u008eÛÁ\u00ad¶öCC|¼RæöÚ£±T\u0092*ÛV$³\u00adº\u0098¦Ì\u0090\u0099ÌYZ]@Ài¾`z(Ø \u0001\u00152\u009bÞ\u00909ôñÒiIè\u000f1d®\u0012\u009dÃÔ\u0099 Ê\u0088U4\u0097yE9µÙÅÒ¤ªT\u008d*¯Ô0Øµ\u0089Ú(\u001få<\u0002®\u009c/Xû±p¶\u0098í\u001aUh¡)\u0017ºc9\u0095\fêõP\u0085mòÉ\"¹Ä\u0090\u008bsú¨-[òmÅ\u0094Z=¢sU'#d\rñÐ\u0012¥ç5ká\u0084ìö(\u0085ÄS1BâDG\u0092:AÝ&'\u0015\u000eº\u00ad'ñ\u000b\u0002É¹^êMipGöa+N\u0006M\u0082\u0015ÝaÛJØì`~½ª*\u0016§x\u001d\u001dõ\u0087\u0006ý£NÊ?Ì«¿¢p\u008a4.liY¸\u008bk\u009d\bËÝt×\u009b\u009c\b\u000f²´LªéÄ³¦\bJb»ÙU§¦inê&|²7Ï\u009d&\u008fyV/Î\u000b:¦Ï<ý\u0010\u0090H\u0006\u009d\u0094\u0016Â´\u0011¡\u0091aÆ\u0080\u0012ì<I±ï×ä±í\u008c>^ã\u0095õ,\u0018'Ñ¨C\u001coÆ²Ñ\u0094Mz\u0007®ÔÑ5îÐËÉÑ\ni\u0093k\fÙ\u009c»ßf°NáÔ6åZi§-½=ùï+\u0005»z3\u0096O\u0099Ò!\u009dä\u0098t:\u009ca¶(\u0086câúZH=M\u008b÷Ê\u0016-è\fH)·ëMÙ*=z£\u008e\u0006í\u0011½\bO{«¥NåN¢Ë5j¯ô\u0099Ò/7¸\u001eKd\u0090e\u001a\u0014bb\u000fìaØ8Ð2dÓ\u0012\bçX5×H¤\u00064\u008a\u0086ì\"·\t;8\u00895e[\u0093Ov\u008a¥ wJW\u0003¦\u00045N\u0006¯\u0002:\u0001\u0010U\u008afÒ¶h*bg\u009bv¥\fIÈ\u0090=E\u009c\u000b\bL¹E'ÓJ\u009dLÛÂ¶^n\r\tç0¬P\u008f6\n\u001bõ\tÛ\u0086þèÍDb¦Üê^\u0018\"{µ_ªn\tE0z¥©0\"\u0085\u001cÖL\u000fd\u0086ðêrþäôÝ\u0092JæI\f\u0019Éõ\u0091l\u0013+ÜõÉ°X>IÉm\nt·«Kòr\néÜö r§)wÉ§9Ñ\f8±Ñ\"¤m\u009c\u001eEÏÄLý{\u008f)\u0007Ô\r³8kw:q;ëG×\u001f\u0087L¹W¿\u008d\u0095\r\u0084\u001dÍÔRw¾ö\u0004mM\u009dùg\b\u001aC»?7\u0093Ì\u009fêÇì\u001cS¦á\u001fÍWýTOûä!yÄ\u0090\u0087yã\u0098N{S¾ \u008f\u0092Íp\u009c\u0097\u001b\u008a\\ºcc{»v\u008b/Éc\u0086üR!\u0004G\u000b\u000e=.\u0087i\u0080¢6ÏòÌ²v=qH\u0085\u001dR\u001c\u008a\u0016\u0001H\u0081\u000bi¼\u008b@ó¦÷%Óh·\u001bv2Ù±\u0091Äa-\u001d_\u008f\u0093\u008a\u000fØÙQ.ÿù¯QY\u0010@Û£Qb@Øâ@¨cÎ\u0094q\u0010\u0017q@)\u0005øW\u00832\u0094óÉàS\t¼¨Ò\u008f\u0094\\Wé'Jþ÷ro&fñw6\u009f\u0002¤Ñs³êÆ0§nùk8§®þ5Ì;î\u001e^à\u001eóð·\u0091¿M¨À¥<º\u0082\"\u0000\u007fæ\u0018ÎÅy\u0080»R1â®TP\t×çã\u0002þ_Èw\u001e>]¨\u0002K\u0017P1ª!?¨ºè\u0004.îjx\u000fë\u001bÒXv\u0004W\u008e£)0\u008e\u0015\u0081\u0086\u0013X5\u0086ÕU-i¬\u00adZÏ\u009f46\u008eas§îU]Ã\u009d\u0086Ì»\u0013h?\u0006ïò4º2[Û¸U\u009fF_f\u008bï\u0003Í\u001eþÞØ\\V÷-ÌãjWKyMy\u001aÁ\u0016£´Ù[í9\u0082Ê\u001a#\u008d[\u008eà\u0086qì\rèÚQFº\u0088guHåÄ\u000f·TÔT¤±¿ß\u0015uG\u0091(²?§¾¦â$î¢÷+ôøÁ~O³We}¶¥¢®¦b\f\u009fkñU{\u008f ªºì\bfÔøNâ!Áa\u001cÕÕ\u0017x\r0\u008f¡¡Æ<\t&ãÛØÛRé\ny\u0092Bj*Óx*on]Må\u0018\u009eíWÊ\u0017\u0004GN\u007fÏ¥;¦tF\u0086®êküQE\u000b\u000f\u0019úâ\u001b9=òÒ\u0017\u008cã\u009b\u0081ªã\u009e7Q\u001a(\u00adï9\u0081_\u001eÃØ©º\u001a_éI\u009c(QEÆð\u0086R¿Í:x:KþíIä\u0005Ô¯¸é§9ó .æïåLÃfÌÁjý\u0098\u008aV\\\u0089kÐ\u0082\u000e¬Å.\\\u0005\u001bë8þ®G\n\u001bq;6á.R<\u00806\u001cÇf\u008c\u0091ò»¸\u0016¿\u008fvü\u0018×qÎïä¤ÞÅq·\u009bÃêõr>¶Ê*ôH\u000b×\u00adè\u0095=è\u0093\u0018úe\u00047È=\bÈcØ!_ÁMr\u001c;å=Üìæë\u0083Ì\\f]._¹z\u000fßaV®À<ü\u001a~\u009dyÚA\u0004Ë¬Êå}Ê/§5¶Dð\u001bx\u009fù»W\u0086ð\u009b\\\u0095!%7á·ð=îß.}øm|\u009f\u0019}\u0097ôà\u0007ÜõRÿKñ;|WA\u008dÿ\u0006¿ë®>Â\u0087ø=Zã£æ\u000bñ\u0007|W\u0089\u000f¨\u0084Iù\u0099½\u001f²zJô\u009b\u000e\u007fÿÐ\u00ad½?rËóU®´\u0090×\u008fãG\u00811ü¸\u0093i|Ëa¬ä¿?\t´\u0094¿Õ\\VÚì9\u0086ójÊ«=+»X\u0018\u007f~\u0018\u0095õ\r'ñÓ\u0012ô\u001fôHµ§ºìÙÓ?©\u009f\u0088ÍB\u0097_\u0090\u009aÚ¬ÔAÔb\bõØ\u0083Ë¸^\u0087°ë«:·æ×çk{½k\u0007[=ã¨v\u0094ðÔ,Z÷}òÌÙ\u0091Ùû!÷JôsA\u0006^ä\u0003z©\u0082\u0014\u001f\u0010^þö0<ÇµÒ\u0096Wý\u0003\u000bªSºÆñQ üMÔ\u0005J«þ¹'à©ú×\u009e@\u0019Ëêß{Æð_-\u009e\u001aO\u001aÿÛRVS\u0096f®ã\u0002Íõ¹R\u0096©¼§\n à¦q1\u0002ãR\u0011PÊÊ1\u00995&U-åãR\u001d\u0018\u0093ù-Æ1T×\u0018seA&qk¼=i9·\u009fµ)\u0017\u0004Z¼ß9ýS\u0096\u008eø»\u008ea\u009e+Q.â²2³\\¬èäÏÈ]V,W\u0096Ï\u0095Fþ\u001e§µÕx\u0006ÏË\"÷ÿË²$\u008b\u009b;1\u009f¿1zûVú&\u0081¹H\u0092b\u001fVa\u0098U0Â¬\u001f%øîÇ\u008d¸\u008d\u0014·su'î`\u0015<ÄÿGp7y\u001dÀQ\u001cÄË8\u0084Wp/\u0088%x\u001d÷Ñç÷3\u0083\u001epã´\u009f\u009e§oóqú@.uã4\u0017ïÊ\n®T·wd¥\u009bÉ«\u0010\u0091Ur\u0019#Û\u0082A¹\\\u009a\u0099É·¢IVË\u0015Üß\u008fÅr%ëÉ \u000eU²\u0086o¼x\f\u0015ÙÕQVÄZ¹\u008ag_qWë¸*ÑËp¶\u0089ÜèF\u001d8\u007f®\\}B6¼*\u00adi¹®\u0083.êJKwÉ\u000b(ó¼Xúâ¤\u008eò\u0010»ÀÃ|~\u0084Ú?êZ3/Ã#kÍ\fÌ\u0092mn#+Ñï~YIÔ\u0084z\u0003«\u0097»©Þ¸<-½\u009d¥ë\u008eaa\u009d\u009bYõ\u0017¬dj\u0011$\u009b=\nðe¥/\u001e,\u0095\u000bêßzöô\u0087<±\u007fB\u0089E4\u000b4ÑÀãtâaÂÔ\u0011¾{\u0002Kð$\u0096ñy%\u009es\u0095º,#.ïâÕnù²#Óa\u0001ÙNn39ÿï\u0090\u001béâE0\b\rï»Íî%\u0006.ßú\u0098\u001cZ\f\u0095,òr¾90.;\u0003ËÇäæL\u009aífÆ\u0005\u001bN\n§ò·eo&á#\u00871_\rª×\u0087(MJ\u008bÓ\u007f\fW\u0015¿\u0083£¯ëj<ú&>.)\u0096Áp \u0088fLFÇd\u007fZî \u0080»µg\u001cV\u0091\u0007'úûJ7\u0087¾FÕ¾A%_bî¼Lµ_Áb\"ÙjâO\u000b^#ò¦\u0099½/17Nà\u001e\u009ct\u001d³.cJÞ1\u0007ä3®ctõY7÷f#Áùý>:Æ\u0087Q¹_>GW,$R? \u009f§SE\u0007ÓÉ.¢ã=®Ãkçxð\u0086WK±¾¡´\u009a\u001a?¸¼!-_dG\u007fòôG\fú\u0091ú´<1aD\u0006ÔÞ J§\b7o3\u009a§\u0098HïpHù6.Á»\u0005\n×æ\u0015®\u0095'åË®Âµò\u0094<\u00ad°\u008f\u000bå\u0019y\u0096\nWÀ+Ï1¦\u001e\u009e4³«\u0012y^åÉ\u000br\u0094ÿõ\u0083\u0090\u008d\u009bÙfäÿ\u0001PK\u0007\bå¡[\u0007Ü\u000f\u0000\u0000\u0088\u001f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000org/apache/maven/wrapper/Logger.class\u0085SmOÓP\u0018=w\u001bkWÊÀáP¦2\u0010Äm*õ%ñ\u000bÄ\u0018\t&&\u0005\u008c3%á\u008b¹«×RÒµó¶\u001dñ§ø3Ä\u0004\u008d\u001fü\u0001þ(ãs»\u0086\u0017\u0087±I{oÏs\u009eÓó\u009c¶¿~ÿø\tà\u0011\u009eh(04#éY|ÀÝ\u0003aõùP\u0084Ö\u0091ä\u0083\u0081\u0090\u0096\u001dy\u009e\u0090\u001aJ\f3\u0087|È\u00ad\u0080\u0087\u009eµÛ;\u0014nÂ 9[o^ìv·\u0018Ø>\u0083¾á\u0006~è'Ï\u0018\u008a\u00ad¶ÃPÚ\u008cÞ\u000b\u001d\u0093´KdJ»)\u0006sÛÙÙ{\u0097÷\u0019\u0098Æ\u0015\r3\u0017Ä»\u009fâDôMÔ0ËPöD\"Â!ÃjË>GI¤\u001fzëíqÈ@\u001d×4Ì]TÌj&®c\u009epñ1åAüÊ\u000b#)6y,\u0018ê\u0097iïWÀpÃÄ\u0004Ê\fÓ¶\u001f\u008a\u009d´ß\u0013ò-ï\u0005ÔS³#\u0097\u0007\u000e\u0097¾ºÏÁòF6¿\u0081\"\u0016M,@W\u0093\u001fø1Ã\u0092ý\u009f\u0088×\u0089ê\u0087\u001f¢\u007f¸q*\u0014Õª\u0089»hQºQJá×G4?²^\u0013'!¦à}\n \u0083û\u001aî1Ì^R6ñ\u0000+ôÞ\u0006\n\nB\u0092êÇ\u009e\u001afì\u0089dç\u0088Kb\u0018Ý(\u0095®xé«\u0001'Gf×\u0014\u001dK\u0014P\u0091¾\"\u0086\u0086J\u0089v%èÐèd¨ÐÝ\u001a\nPGµfÔÌï¨\u009eàêW4¾\u0010RÀMº\u0096\u0089\u0007ÌáV\u0086(\u009d\u0085Ó^\u008bVU\u009dè|Cóï\u0096zÖb\u008e\bdã6\u00ad\u0015,c%o~NlU«\u001e£ñ\u0019Æ1îtNÐ>S©f¶çI\u00ad\u0081)BÎÔªdÚÊÔ\u001e\u009eª=ÍÕô1\u001d#³Ý¤\u0091\u0017Ïiè¹\u0006£ßK1\u001fÿ\u0001PK\u0007\b\u0084'+ãü\u0001\u0000\u0000m\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000/\u0000\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.class\u0095X\u0007|\u001bW\u0019ÿ¿Ø±då²ä:\u00893\u001a%Í°e[ÊhÒ4I\u0087l+Äñ¬íØuÒÖ\\ä³\u00adTºSN§\u008c\u000e\n¥@Ye¯2\n¥P6i\u000b²¨iSV\u000beïQöÞ#@\u0081\u0002\u0085ÿ»\u0093µ,\u001bóû%º{ï¾÷Íÿ÷½ïóãO?ø0\u0080íb\u008f\u000b\u000b\u0004\u001a\fs<¨&ÔÈ\u0084\u0016\u008c«'5=xÊT\u0013\tÍ\fvÉÕ\u0090³èR£º\u000b\u0095\u0002Ë\u008e«'Õ`LÕÇ\u0083=Ç\u008ek\u0011K`e[ø@èpçÀHWh0Ü=r¸?Ü7r°§+,àíÌS÷[fT\u001fß'°¶\u0084l¤·¯§7Ü70<Ò\u0011\u001e\u0016XÜjèIKÕ\u00adA5\u0096ÒÜð\b,µõ\n¤\u0092\u009a\u0019\u00980â\u001aE\u0096ò\bw\u000fÊãn,&ù\f=\u0094®Áî¡\u0091Áp_KO\u007fØ\u008d%\u0094bïH\u0092îP\u0017·\u0096Moõ\u0086úû\u0087zúÚÜðN\u009fë\u000b÷ö\u001cîëtã\u0002\u0081EÜ\u0091\u008cúÛ{ºÝX%°pg`w`§\u0080[~è\r\r\u001ctc\u008dÀå3\u009cê,\u009a\u009d\u0085}¦h«ÙÞj>\u0016Õ\u00037D\u0013d·?\u0012\u008bêQër\u0081\u008aú\u0086A\u0081ÊVcTsÁGÛK}Ú\u0092\u008aÆF5Ó\u008d\u008d\u0002Õ9'y°\t[\\Ø\\\u0014²þ3IK\u008b+Ø\u008azÚ2®Y½¦ÁèZg\u0004¶ÔÏ\fVÃÌ-\u000führ¡±\u0098\u00adýMA3\u0002\u0002®\u00932p=c%,\u001d´\u0094g¹\u001eÛ\u0014lÇ\u000e\u0081ªýY«kË©3èÆÅtE0\u0010ß!\u000fíVp\töð\u0090\u0084¨>*Ð</\u001b²þ²åîU°\u000fûéoËp>\n\\P_FÇj0¨\n\u0016¢\u008aøê\u008cêZw*~L3\u0007Ôc1MâÜ\u0088¨±AÕ\u008cÊµ½éA\u0005Z¤Që¨°5\u0011M\n4vÎ;Õ\u0098&\u0095q>\u0005VÔ\u001f-ç\b\u0001OøtDKXQf\u008b\u000bí\u00025yªÜ\u0017\u000fµîPÐ\u0089.Òge\u001dRMÆnÚÆ¨\u0011<\u0010\u008diû$e\u008f\u0082^\\%°<K\u0099ÅFT£î\u0017Ö\u0017Ó\u00979Þ¯`@\u001ew\u0099\u0086aµEM¹7¨`HºwI\u0096å f&©\u0097\u001bLôÚ\u0001õzzÌgÛîË\u001aïóà(®uá\u001a\u0081õ³z«Ó\u0018\u001f×L\u0005×IÄTFõ1C\u0082ý\u0099\nT\u001cc\u001eçam«¾jÚÖ\u0094\u0015\u008d\u0005ó_l¥G\u0015h T×%T3©9é\u0091'9`\u001añ\u00909N&\u009bÊ\u0086¡\u0080o\u0097\u009a Ã\t\u001cw!J\f\u0095\u0013¨àzÄ\u0088ÖDÊ\nÅøâ\u00ad/9ß0(UÒ\u0015\u0018`\t¨QGGK\u0015bpJ\u00031XMÛé\u008c$X\u008a+\u008c\u0014\u007fks$½ÔÓ¢¶\u009a\u001a§v'qÚ\u0085S\u0002õ³z6\u001b\u0085ði-\u0092²\fr=\u0083\u001bèÁ1Ã\u001c*Å\u0084\u0094.Ð[¢N\u0081\u0093BvRÊ\\ £æ+q\u009f\u000b7\tl\u009c\u0095¼]Þ\r±\u0098fºð,\u0001ÿ¬tmÚ\u0098\u009a\u008aYmÆ)=f¨vu|¶Ì©\u0093ú)\u000fnÆ\u00ad23\u009f+°µLÁ(\u0097n.<\u008fålVi½ª5\u0011J&µ8\u008dµqÿ\u0002\u0005·Ë¤[lÓ\u001dfM>h\u0097äÛð\")9áÁ\u008dx\u0089|{©íÂÙÍÈé¿ov¢\"é¶²/c)\u009c\u0095¼\u0085é\u0099´¸\u0090\u0085¦ßRMKê|\u0007Z$@^©àUx5\u0093X³\u0003Â\bGË!\u007fver\u0001\u009a\u0083¦\u009c\u0006vM«Tíd«)#\u00915¤\u0018iÜH\u0094\u0080qYrFº¬(\u009fú,â§\u008a\u0081G0Í\u001f¤¼gû£ãºj¥L\u008a=4\u008fÚ°\u007f>8»\u009cè\u007f«@hV=Ø\u0013\u0004KKB«\u0011\u008f«ú¨¼\u0093Ø9\u009dÔ\u009cpÞ\u0085\u0016\u0017Þ.\u0010\u0098\u0093WÁÙ^Yÿxðn\u0089\u0083»ðN\u0005÷â]´3bècÑqÛÎ\u009ds\u0000µ,7» Ý\u008d÷(x/Þ'\u000bZ,f\u009c:¬_¯\u0013Õ=ÎÕ%°£~\u008eêP\u009e\u00addú\u0001\u0005\u001fÄYö_vá\u0016\b\u0097\u000fÂ\u009c\u009cmv£\u0005ü÷IÓïWð\u0000>Ä\u0014\u00888î\u0014hû\u001f\u0086ÏäÓ0³ñq!ÍzP\u0004\nÇ½NÈ\u0004Zç\u00162\u009f¸\u0013\u0098Ë#¥î\u0012Øöÿ:Ø\u0085\u008f²ù-L77\u001ef~9}x>í<\u0098Â#²\u008c}Là¢Ùo\u0082\\\u0019õà\u0013ø\u0094\u000b\u009f¤J³jTjçAª\u0016\u0093·ý£x\u008c\u0018âå>óR\\_¾;)¸\u0098§ð\u0019\u0005\u008fÛ%Y¶\u0007ª©é\u0096$\u0095_>§àó²I©Î}\u0091»_Tð%¹ëân·\u001a§\u0007¾Â»û\u009aÀqÕÜäÆ×Ø>\u00179Â\u008fo(ø&¾E¿\u0099Z\"¦F´\u0003Q3Iðì\u0099ß\u0015S®-\u009eÂ\u00ad\u001e<\u0081ï¹ð]\u0016¬<AkLM²\u009bø>~à8\u0084®°\b1æS\u009bát\u008d\u001b§{\u009e$+\u0096\u0019µÎ\u0004KiÈþGø\u0089\u000b?fo77¥\u0082\u009fâg\u008eßä\fÒo¤Ì\b\u0013ní\f\u0011ù¯dþ\u000büÊ\u0085_²w\u0098\u008dFÁ¯ñ\u001bg\b\u0091Ý³\u0094WÐ\u0097ê\u009a\u0015äÌEF¿Ã\u001f\\øý4\u001c³û\nþ\u0088?1ù-ãp_û\u008ccí\u0004ð\u009f\u0005Vç=Ö\u0097Ò\u00adh\\+h\u008cÏã¯\u0012¸OÊþ°À÷\u0003\u0013¦qÊéY\u0088Ö¿ã)\u0017þQ,»]Á?§ÑÒOøJdü\u009bW×\u0098\u008d&?þ£\b\bA¨h'Rj,Y2ÉLOAGÜ¢\u0082\u0013E«ªë\u0086å\u001bÕ\u0098¼qæ\u009f/\"C\u009bà\u0085îcÏåËæ\u0084\u008f=»o\u008c½¨/B÷\u001dS\u0093\u009aoëæäÖ\u0000Å\u0089\u0085\u008a¨\u0012.\u008a#}\\%Þ.-\u0083·£e4(\u0007¸óØF£\u0085G\u0011\u008b¦¡/\u009b\u000b\u0089Äm.Á±yM¡#úÏè\u0096z:çS\u000eQ±\\ \u0097\u0014Ç\u0083.!dÖuÎq|\u009f[p¾Þ\u001dì\n\u000f\u0084\u009aÛ»\u000fdËBÔ\bXö\u009cà¬\u009b§ËDÂ\u0088\u0017åß\u0013b\u0085\"V\u008aUNFôiI\u001bd¡¤Óü\n4Ì>\u001a²j´ëlÊ³}²[¬&vº\r\u009f-Ð\u0097\u0017Â\u0090¤ôÑ\u0080ìòyGN\u0088u\u008a¸P¬gèe\u0087\u0096ÇQ\t;\u000e\u00adb\u0083\u009c\u008a\u009dÑG\u009eÞâ\u0016\u009bh*Ed7}º=Mú\u0092\t-\u0012\u001d\u008bj£¾¨î;&ÇT\u009f©E´hÂâÓ±(à\u0011[D½Kl\u009d\u009eø\u008aÅ)¢AN\u009c\u000b#1#©¹\u0005ÇôM\u00adF\u008a|\u008aa6\r¬¬|Út^43\u001f\u0004çwÿÜ\u0005«0C\u0098yæ\fO×\u0096uÃô_q\nËvm\u0001Û<\u000e8Ë\u0089\u008b\u0015±Kþ\u0089¢\u008a±Ôô\u0093\u009c^\u009d¢áôyµ¥ãr@òÁ\u00066Þ\u0015\u0000ªQ'\u0007u¾ÕÁÅ'\u0081É÷\u0005öþ¢\u0082µÂõ\u0092\u0082õR®\u0097\u0015¬\u0097sí-X×p}AÁº\u0096ë\u0015\u0005ë\u0095\\×\u0015¬WÃÃ·µXÇ\u009d\u000b¹s\u0085\u00ad\u001d°f\në\u0087½\u001b2¸(\u0083\u0086I\u0004½;ÓØ\u0095Æ¥\u000fà²ûì\u0083Wð×Ã'à#\u0093f\\iï\u0082l¶ç\u0098\u0005ù\u0014|.ôO\"\u0094?Veo®·\u008f(\u000e\u0001ZÑf{%\u008c\u0003¤z\u0006ß+ùå Íæ)jèâ3\u0096Á¡ÎÆ\fº»øÓ×\u009dÁá½\u0095¶\u009aWSÁºJGÁ\f\u008ed0²waÝB\u007f\u0006\u00914Æ\u009b3\u00887Ý\u008f\u0013\u0019¤öVÕUù§pãð\u0014n\u001eöÞRW9\u0089çLá¶á\f\u009e?\u0089\u0017NâÅS¸cx\u0012/Oã\u0015ym\u0003\u008c\u0007°\u008dúl§~;\u0018\u008d\u008béå]Ø\u008aKÐ\u0084=|Û\u008bK±\u001f-¸\u008c³óå¶U\u0007\u001d}ñ\u001a¼Ö¶d\u0002\u009dx\u001dí©F\u0004¯çÛ\u0002r¹\u000e\u0003|« ¯a\fÑ'\u0095äv%Þ\u0080;é\u008d\u0016Öè7âMÜõÈÑ\u009fôo¶õy\u008bí\u008f\u0014OÉ(m\u009dÂ]T÷m\u009dS¸\u009bÏ{º\u001a\u009bÒx\u0007ÿ¿{¨±É\u009fÆûÓ¸ï\u0011|ølÎ\u0094\u0015d\r\u0084èÎ\u0016\u0082¨\u0095àhcìÂ¶Ê>\u0087eVe7Ã3\u0089\fU^FÈ|\u0004\u000f\u0092\u0083G\u008eüÙÈ\u001e%'\u0019¸\u0006úz\nSÒ\u0083Þ\u0087&q.\u0083\u008fÓåÙM\u007fÁVÞ\u009fKlAí\u0014~\bõè(@A\u0083í\u0011\t«\u0001\\\u0095\u0015´+\u000b¡E´çÓÎ¿¼=\u000e\u0090º\u000bX,²\u001d-YôæX\u0084²t+m\u009dÒø,ÿ\u007fÁûeïWÓøú$¾]Ê®¯\u0080ÝÊ\u001c»NteÙÝÃØJ \u001fò\u008a4¾\u0093Æ\u000fÓøy\u001a¿í¸\u0017\u008b\u0019\u0088óÃ\u008d\u0093øË9\u008aø\u009b÷_i<}'êäf\u008dXPù\u0010*\u0086+üý\u0019Q9)Üç\u001ceDõ¤PÎÚ²\u0096Â+\u0016g5YmW\u0086«¹7L|\u001ca~^C_]Kt\u008dä\u0082µ\u0014\u0015b©XÆÕZ\u0004²o5¨\u0016Ë\u0085×Îî!bÒÑøIbK\u0006þ\u0088WÔ\u0088\u009a´¨íð?\u0086%\u008eZu\u008e.\u0013Ã\u0093bMg#\u0015ZÛX#|i±±«)Gs\u0091¤iÚ[É¯\u009bë*ÏvËgó¹\u000eç£ß?)\u009aÎQ\u001f\u001f5?`×\u008eVúê ß»ì§c\u0091\u0004\u001c0Ê\fÐ°\u0098\u0088^Å\u009cðá863g\u009a\u0099)Û\u0011§¾\u0006iOð¼ÁÓ\tV\u0081\u0013Ä\u0087I.I\u0006Ù²-÷Ó\u0096j´\u0089 Øfû¡YlgÆ\bò¨\u0013\u001bèµ\u0005¤Tè\u0083\u001dvÔnÏEÍ \u0086ÒËÛ½Õ¬i\u001dþG¡Ø\u0011\u0090î÷*\u0019±s¸£pK¾Ü\u008fËìà ((gø{\u0003äßFjp\u0013+ÝÍØ\u0082[r\u0090©B#\u0085J:!vË\u0093â\u0092ÿ\u0002PK\u0007\b\u0011ps½]\u000b\u0000\u0000Ë\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000>\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.class\u008dR]O\u0013Q\u0010=³-»PWX¶õ\u0003?A\bi\u0017tåÍ(1!\u0010\u008dI£&\u009a>ø`rÛ^ÚÛlw\u009b»[ü[\u009aØ\u0098øà\u000fàG\u0011æ^\u001ab\u0081\u0087¾ìÌ\u0099\u00993gîÉ\u009e\u009eýý\u0007`\u000f\u009b\u001e\u001cÂ«L÷b1\u0012\u009d¾\u008c\u0087âD¦ñ\u000f-F#©ãÏ¢è\u001fä¹\u001c¶\u0013©·\u009aYG$G*/´j\u008f\u000b\u0095¥\u001eÊ\u0084` ND\u009c\u0088´\u0017\u007fj\u000fd§ x]\u001eú¦F\u0084å¦íª,~§\u0012ùfÚ:R\u009aà\u0016}\u0095o½$Ô\u009bóé3ÛÝW©*Þ\u0012ÞÏM\u009a=`\u00165Z\u0084òaÖ\u0095KàS},b©\u0082\u0012\u0002\u001f\u0015¬\u0012JõFËtª><¸&»ãc\u0001.a¥©Rùq<lKýU°\f!´æ´\u0084V\u0006O\u008beóDÂë9o½n0?9ìÉâÿ\u0092õ.¨7®\u001a[á9¶Ü \u0006_²±îÈ\u000b\u0010Î\u0088¼0<\u0082ÿ!M¥>L\u0004×s\u000f\u001b\u0084íù\u008e$¬^;\u0013\u001bìM\u0089ÿ¨\u0012Bc\u0010g¡±\f\b\u0002cªíðU¸Å_\u009fÑw8(s¬E;\u0013Ü\u008eþ`%Ú\u009d \u008c\u009eOPûÅu\u0007wí\u000e3Óe¾Ä2\u008eQE\u000f÷¸²nµj¸\u008f5ÀfFË±\u0099Q7Z\u000fðpª\u0015s$\u008e\u000bÑo\u0084?/\u0097»¶8´\u000bý\u008b\u0081éBÂ£\u001bÉµ«äâ\u0006²\u0083Çöû\u0004O9V,}\u001dÏ@çPK\u0007\b\u001coÏI»\u0001\u0000\u0000t\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler.class\u009dVù\u007f\u0013÷\u0011}kK\u0096,\u0016\u0002\n\u0098Ú`*ÎÊ\u0092-\u0085&´\u0004\u0003\u0089/°RËv}\u0081q\u001b²\u0096\u0016yAÞUvW\u0006·i\u009b\u001e$mÒûNKzß§Ó&\u0092\u001b7¡÷\u000fý£Ú¾YÉ\u0092mD>¦?HûÝÝùÎ¼yóföûïÿ¼ù6\u0080\u0093øW\u0000M\nNXv.©\u0015´Ì\u0082\u009e\\Ô\u0096t3yÓÖ\n\u0005ÝN\u008ekîB\u009fãè\u008bóyÝ\u000eÀ§`÷umIKæ53\u0097\u001c\u009b¿®g\\\u0005mé¾\u0099¡Ñ«Ó\u0093C\u0013W\u0087ÇÒCW'§&R£\u0017\u0015\u0084GêÆ\u0093®m\u0098¹^\u0005;\u0007,Óq5Ó\u009dÑòE=\u0088V\u0005\u000fmq `×øÄØSC\u0003SUWA¨\n\u0002Õgtá\u0081\u009cvt{ØZÔi]\u0089cXÉ\u000bF^g\u008c\u0096³\u0086i¸ç\u00154G»f\u0014ø\u0006¬¬\u001eB3\u001eVñ\u0010v3à\u0088aê£ÅÅyÝ\u009eÒ\u0098\u009a@µ2Z~F³\r¹¯>ô¹\u000b\u0086£ :²=~\u0018xOt3\u0094®\u0099V(èP±\u0013»\u00186§»\u0083\u0086C&æ\u008b®a\u0099\nn¼\u0083ïK\u0095+éºfä\u008a¶&;z»¶\u0089å\u0098\u0097ÏÆ`½!\u001cB$\u0080w+èy \u0098*\u000eà0\u000b\u001fíªäfênrz\"E\u007f\n\u008eª8\u0086ã\nvT3\u001bÕ¤\u001eG¢\u009b-»îÕ\u0081l~\u008f\u008a(ºH\u008b\u00ad/ZKúÐ-W7\u001d\u008f\u0096\u0013Ñ{wÜÇI\\E7z\u0088À¶,B°+\b¦\u001b8x`¦ïñ\u0010@R\u0081º±ÀÂéI\u0015ïÅ£\n\u001eÞRÝ~Í!\u0092½Ñû\u0000?¥â}x¿\u0082\u0010·\u0089)±×\u0099k\u0090øº¤\u0002x\\Áþ\u00adVýE#\u009fÕmÁÓ«âl#<¢\u008f\u0010ÎãÉ\u0000\u009eØÔÇ\u0015\u000f*úÐÏ.[\u0092¶\u001c»¶¥\b\u0095^o\\\u0084Ó\u0018\u0094¾bÛîk\u0004\u007f&\bÎ\u0002%)\u0086)\u0015Oá\u0003lP!ÜÌR\u008aÛªt5;/VZÅ¨¤\u0017t\u00adÊË\u0010\u0012\u0018\u0017\u0000\u001f¤\u001e·ô_#8ÂÑ¤\u008a)q\"ä_1\nÂ¿<\u009eQqiÃca,\u0080Y\u0005§ÿß¦\u000bá2æ\u0004Û\u0087\u0014\\Üö\u001ci\u0094C}¢pþe6*UAò\u0001¥Mòæ\u0099q¥U\u0082ÙZß\u0006dééÐ[\u0091\u0081\u0010²H\u0007 ¯Ë¾ÚÑ¢_\nfAºW¸JgO\rkÎB\u0010×\u0015ø\u008f;Éã\u008e\b-¯b\u0011\u0084×rÍ²\u00175~(\u001eoPì¹m\u0089\u008c\u0088\u008av¾\u0012ãY\u008eõôà©\u0010\u001c\u0014\u0003 Û\u0003\u009e¹£g\u008a¶á.'Óºãh9öSNw\\\u0015K¸Y\u0099O)ï³\u0093a.'ï/ºÆ^z%\u009de\u0015\u001fÁGI\u00984ì²«óËà\u008bvÍõ\u000b\u0090\u008f©ø8>ÁT\u008b\u0085¬æ2\u0084?:×ß5\u0013À'9\u0001<Ç$`!ÙoäR¦«ç¤Q\u001d|ZÅgÄaKÖ\u000b\u0012ÂóxA´ò\"\u001fES²_\u001e}Nôþ\u0092ôVªáHú<¿/õÇ\u0013EÓ5\u00169K3zAj\u001dÄ\u0017\u0015\u001c\u001c°\u008aùlÄ´ÜÈ\u0002)\u008c\u0018f¡èF\u001cÏC\"\u0084\u0097ñe\tû\u0015\u0005±Fc³þdjÁ¶nÊ§±WRû\u001aGLý]-\"ÁW<Ëwz#\u0089\n:ß\u0091c\u00926_¡µi\u008e\u0083H!\u008bûF\u001a\u0004è\râ\u000e_'¤&ßSñ}ü\u0080õÍk\u000e\u000b\u009cÕoÉäj8\u0086Rbÿ#\u0015?ÆO\u0014´:Åùu\u0094mÑT#fY]Óë\n¥À_J:á\u0097*~%ã!@\u0005¬OÓß\u0088Ç\u0097ª\u001d3mçk§\u0091õ\u008f\u001fý\u0014ª¶¯©ø\u0003þH\u0082ôg\u008bZÞÙ\u0002t]ýW\u0082x\u0083*+òx\u0093È\u001aTJ\u0019\u007f\n`uóÈ^v\\}QÅ\u009bÒ\u0081\"îqÛb\u009b»Ë2\f\u0007\u0083x\u008bAd¨\u009d\u0089\u0004q\u0097\u0016\u0011Ã\u0089\u0014Í\u001b¦uÓ\u0094z\u000f\u0012Ô¼÷y\nMZE;£Ëhá!hÓ\u0018JH86~Ê49@H°#µÙsÏ\u008cÃaN\u0083f\u001e'\u009bÑ\u000e?Zx\u0017à]\u0013\u0082¼\u000fm¸ßÁ\u001fÏA\\\u0007ù\u008c\u00071þïáÝ£¼*¼úce\u0084_óL÷ò?Ä+èÜ\u0087#ØÇ\u0095Z1B\u001böó*\u000eÞUup\u0081\u0096b\u001b\u0012\u0007±ø\u001bh¯{ÙåA;F/ÇÑ\u008a\u0013\u009e§¶\u008auÕ\u0093¬\u0004\u0096\u00808\u0080\u0083U\u009fÿ%p\u0081};\u0016/¡³\u008c#éXw\u0019'Fc=ñ2bg|kHÌÊ«GÊxl\r§g¹<³\u008ase\f\u0084/\u00940Üîã_\t#e\u008c\u009dñ¯ÛNÔm§·Úz«îú¦\u00965\\\u009e\u008dµûÛ[Ê¸²RK§\u0083°À\u0013O+zH@\u0082\t$1\u0080Gp\u008b\u0087yIm¸\u0002º\u0096Úm|\u0018O3¥V<\u0087«ÜÛÄ]Kx\u0086«fZ\u0098ôÔBj\u0006Ð\u000f\u008d\u0014øég'æ¹\u0012K\u009e«ªd\\ç\u001b\u001f¯\u0087bDØYB¦\u008ck£aÃÿ\u0016\u009ag\u009bã\u0093³¾\u009eÉUÜXÙRºS\u0090#\u008e \u008aUv×P\u001dò\u0010(ÞJð5Ñ2\fËCÕ$\u009f\u0095jÜ;Ü';\u0013áÂ*ì4y»5ÚÝSÂskx~ÖG,\u009f*ãöîH\t\u009f]I¯áåÙð\u0017X£/Ýõ<\u001f¦l¾º\u0089µ^þ\u009f¥\nÏQyçùö\t\u001cÅ\u0093\u001e¾Ç\u0098\u001f£Ôð%ðu\u000f_\u000båð\r|ÓÓî~|\u000bß&¾£\\¿\u0082ïx\u0092\u008bÖ\u0090>Í7\"´½ñðwKxõÜÁ;ðÇWâÍ\u0007Køa\u009d\u0097°\u0097Í\u0010kt\u0081^.\u0092ë\u0094\u0017?RÙ[\u008b¿\u0017?\u00adöÍNü\f?÷bñ\u009c]\u008deÓZüt\u0090\u008f_¤»E9¯\u009eïdÀî\u0095îNß3%üº\u001e±ÍË,ÍÿQr<ÆÌÇ\u0089bbCU:jQ;ð[ü\u008e1ü|û{O\u0001*\u0095 ñ¥*<¬Vãß¦\u0085Ô·/\u001e\u000e\u0096°ò\n\u0082±×Ñ¾\u0012\u000fïðîv\u008bÜÃ¯¯¢TÆÚ\u008a\u0094E4\u001fþ3å\u001e\u0017¡¿½.ò¿ÜÝ\u0002s\u00862½Ä\u0090\u0097\th\u0096\tÏmèÖ¾\u001aÌ>üÕ#§\t\u007fóöÿ\u001dÿð$§p\u009f\u0082\u007fBù\u001fPK\u0007\b\u0087|+\u009f?\u0007\u0000\u0000Þ\u000e\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00006\u0000\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.class\u009dUY[\u0013W\u0018~\u008f\u0004\u0006Â¸¡¨AEÔ¢\u0010\bQ\u0011µ\u0004iÕb¥\r\u008b\u0086¢P»\fá\u0098\f&3ãd\"ÐÍî«íUoôÂËò<½¢½\b¥<O½ï\u008fjû\u009e$\u0090\u0004b·¹8gÎ·\u009dï{¿åüþÇ¯¿\u00018\u008dï4l\u00138e»\u0089°á\u0018ñ¤\f§\u008dûÒ\nÏ»\u0086ãH7\u001c[Ìx2=îÚ<x¦Ì\\3¬Ù\u0094t5ø\u0004vÍ\u0019÷\u008dpÊ°\u0012á±\u00999\u0019÷\u0004ê\u0006LËô\u0006\u0005j::'\u0005|WìYéG\r\u001atÔ¢N`gÔ´äh6=#Ý\tc&%\u0005\u009a¢vÜHM\u001a®©ÎE¢ÏK\u009a\u0019\u00813ÑÿêWD`OBz\u009b¹\u0002G:¢yoM;|ÕLÉHgá\u0098õÌTxÄp¨×\u00103\u0013\u0096áe]Þ?ô÷Ò\u0003ÑRä1Ï5\u00adDd+e0¢a\u008fÀî\u0092æ5#\u0093¤¶\u001fMhðc\u001f\u000ehØ/ \u0097ß¤#\u0080\u0016ÂhfÔ)\u000fã´\u0086C\u0002{KfJaùq\u0010\r\u001a\u008e\bì/72l9Y\u008f^H#íG+\u008e*ì\u008fÑ\u0093ÍAM*ýçt´ã\u0004!OÙÆ¬À\u0081\u0092P\u0099\u0099¼l+:ttª,ÖÆSvFjè\u0012h)Å}#kyfZ\u000e-Ä¥ã\u0099¶¥!´îX\u0019.\u0097³fjVºõ\b\u000b\u001c\u001fr]Ûm\u009bOJ«M]Ov\u009b³\u0011]Û\u001dzyÑ\u008fn\u009cV\u0011\u009c\u0011hîØ\n³ò¬\u001bguôá\u001c\u0081SÕa1\u008eP¹h¡:×³¸Õ\u0099\u00882qAÇóè\u0017¨÷ì\u0002\u0093 wlU¡l\u0010\u0003Ê¡\u008b\u0002Á*\u000e\u0095Q&\u0092®=¯*\u009a^Öã\u0005vLf£0o÷tô\u0004;ý¸\u0084+\u001a.¯\u0003\u0095O°+\u0013r!<nx\u009et-\u001d/aH@\u008bÛi'_\u0012¡j D\u009f¡\u001dQ)~YÇ5\f\u0013\u009c»r1&=U\tå\n$E\u001añ*F4D\u0005¶W0t\u008cb\u008c\u0098\u00984fx¶+°¯Bw¸H§\u0081ë\u0088i¸Á\u0086ÞÊÕ1\u0081×Xb\u0096\\ð6£ZÌ\u008d\u001a\u0012\u0017\u0014\u001a·tLa\u009a\u0001§\r\u008fmÏ\u001b{Ë\u0003¾\u00924Ü\u0098¼\u0097\u0095V\\V\t{¤ Ds·ñ¦\u00867ªàZ\u0014Ññ\u0096ê4ß\u001dÓ\u009aUÒ\u0086\u008e\u0019ÄYÛ\t×Î:ªÖ\u0086«&_\"¡áNÅð+ðt$a\u0012ä\u0094´\u0012^2ßºÃ\ný»:RHó\u009cPÐ\u009fø\u0087º,\u0092\u001aaã\u009e\u0006§\"\u001f\u009c\u001d:\\p\u009aÕ°3\u0005.T±õ/\u00ad_GVÇ}\u0005\u0080\u009642£Ì\u008b\u0086\u0005ÎÎ\u008dÞ\u001fÛhc\u0081\u001d¥\u009e,L¥\u001d\u0095\u0083D ±(±H\u0017Õ\u0090ß<[ýNÙ(ÞWÆ.Í²\u0088ª2«0n\u0004\u0002\u00157\u0094O\"\u0001A\u000f\u009a£U<%Os\nu¿a¡JKð\"ÃMdÓÒòÔó³\u0005\u009djºëuEèÙD\u0095jÅÒP\u0081U<e\u008bÎúsÖ÷¿\u009e\u000fÂ\u0016³³n\\\u0016@?ô\u008c'¯G©â(è\u001aÔ·\u008d\u007f|k¹j<\u0085¹\u000bîµÁ\u0015Ôÿ\u0094gû¹Öå\u0089\u00adhäª\u0017\u0004¸oçÞ\u0080\u001dØI©]yÙÝÊ\u0088xBn=Ï?¯¡ij\u0005{£Á\u001c\u009a\u001f£¶ky\r\u0007I8<²\u0086Ö)ÞÐ6Ú\u001dÊáø\u0012ô~\u001f\u007fN\u0006|OÕ¶\u0084Ã£k\bN\u00ad¡{ª©g\u0005§¨ß\u009bÃùÐ\n\"O\u009b\u0006\u007fÁ\u008b£Ý9\\]Å+\u0002ýµK¸\u0014¨]Å8ÿ}¡\u0080/\u0087É\u001cnö×\u0005êrxý\u0011Ú\u0003u$½Ý¯\u0005´\u001cf\u009f ¹+ u+©9\n®ÂªÁM¥ÍÔ>þs\u00adk\u00991\u001cãÀ\u000eÒû\u0000Î£\u001fó\u0084I!0\u0089f®G\u0019×1Æ{\u009c\u0091¶Sâ$O\u009d\\\u0083|\u0010ºp\u008ak/÷ó\b!\u0082\u001eN±Ó\u0098Æ\u0019Ü#õ=\u009cÅ§|t\u001eâ\u001c¾§Ä\u000f¤/SJ!z\u009b(\u0012-,â\u001dîõø\u0011ïR\u009eu\u0085Gx\u001f\u001fä}jÆ\u0003|H_\"¤~\u0084\u008fù7\u008d[ø\u00846kh¿\u000f\u009fásø¨\u0015ä8ü\u0082ùz\u0088\u0016|\u0089¯\u0098\u008f¯\u008b9+Øý&\u009fà\u0087ùl}û\u0017PK\u0007\b{\u0002`-è\u0004\u0000\u0000×\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.class\u0095\u0094ßS\u001bU\u0014Ç¿\u0017B\u0012Ò\u0085\u0084\u0004ª\u0088µÒjÙÄ\u0086-B´Z\u008a\rI*mC\u0012I\u0003Êè0\u0017XÃÖ°\u009bÙÝÀTÿ%\u001ftFÆ\u008e\u000fý\u0003ü£\u001cÏÝÝ@²Ü<ô!{~\u009fûÙ{Îæßÿþy\u000b`\u0005Í\u0018Æ\u0018ò\u0096ÝÖx\u0097\u001f\u009dèÚ)?ÓMíÜæÝ®nk{¾,YæÏF»gs×°Ì\u0018\"\f©Wü\u008ck\u001dn¶µúá+ýÈe\u0098)V÷\u008a?4\u000fZµF±ôâ RÛeHW¯ò\u009a®m\u0098íG\fSÔÎq¹éîòNO\u008fc\u0092aa»¸[©\u001dìí\u0014\u001b\u008dÊÎÁP'\u0086L`\u0097ë{µj½X\u0016½ãP\u0018nIËúi\f\nï\u009có×NË¤wû\u0085\u0081í3Lû®²unv,~L9Ç\u0086Cd\u0087=ñn\u0014÷\u0089MÝÕZ;Ï\u008865\u0018ßä\u008e\u001er5¸{Â\u0010ûÕèúA¡ù¾èºa\u001aî\u0006Ã¸\u009a¥»\u0088\u0094¬c=\u0081q| à&ÞKàC|\u0014Ã\u00ad¡»l¾v\\ýTÁm|LõmÝÕÍ3\u0086{êõkÌ^w%p\u0007\u009fÄp\u0097Fq\u0015Û´¬\u008eÎM\u0005\u009fâ\u001e½l\u0097Û\u008e\u001eø\u0018æd\u008d÷'Á *\u0098Â´Ðr\n\u0092\u0098\u008eã>CÒ¿îV\u0093îz«¾]\u0011áe\u0005iDãx@sío\u008d¸\u001eG\u0004?W\u0090AThk\nf}í\u000b\u0005s\u0088R³ªaêµÞé¡n¿ä\u0087\u001d],\u008buÄ;»Ü6\u0084\u001d8#î\u0089á0hÕwÚQ17Ã)\u0086FMs \r\u0098qt7\u001c\u0089¨ûbDÓý\u009aþÆ$/s/=4\u0094òÐÆ¤ÔìðÎ\u0088·,+HaÆo0\u009c>£\u000eg\u008bs3¡¦þ&Íª\u0092!S²#K\u0096\u008eRÒÚ_Íp\u000fß\u009b Üýþ\u001e'\u009cAÃ\u008f\u0004iÎ Ñ´zö\u0091þÔ\u0010Ã\u009a\u0097ÍbYpa\u0091.e\u009cþs&1\u008f\tDÉ\u008a\u00915\u00868Ù\u0089\u0001û\u0006ýhó<=\u0019HºIOÒ¢y2\u0013ÈÙ@Îy2I=è»¢çûdýF~F²\u0090û\u001bó¹tü\r\u0016Þ`ñ\u0002K¹ô\u008d¾\u009eÍ¥?»@>\u0097Ö.°âé«\u009e^øÓkû%=ï\u0010 è \ba¦°@ßìmò-BÅ],Ó7µF±\u0087\u0094¡ø\u0087á+|M\u0092á\u0011Ö\u0003\u0010\u008d¤\u0088MäþBö÷ËÆQÏ©\u000e\u0014O\\\u0016?ÆFP¼AÙc\";·@¸WX\tÏ{\u009fjò^\u0087\u009b~VÐAhâîÄÁßHA\u0096Â \u000f¤ Oä Ka\u00905ª)\u008c\u0000\u0099\n@\u008aØ\u0094\u0080\u0094þ\b\u0081<\u0094\u0082Tðô\u001a\b\u008d«\u0014\u0006Y§\u009aÇ#@Ä\u0016\u0089\u0083¿Å\u0096\u0004$\u001f\u0006y\"\u0005y\u0086ç2\u0090|\u0018¤L5\u0095\u0011 iï\u0004\u0086\u0017R\u0090\u00950È\u0096\u0014¤*\u0007Y\t\u0083T©f{\u0004H&\u0000Ù\u0096\u0082¬\u0086A\u001aR\u0090\u009a\u001cd5\fò\u0092jZ#@f\u0003\u0090º\u0014¤\u0010\u0006ù^\nÒ\u0090\u0083\u0014Â ?RÍO#@æ\u0002\u0090ï¼\u009a\u009dÿ\u0001PK\u0007\bº\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.\u0000\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.class\u0095W\t{\u0013×\u0015=\u0003r$\u008ba\u00136`\u0096Ta\t²¼¨¤$e§Þ\u00007ÆV,cb\b¥cil\u000f\u00915êh\u00841´IÚ¤m\u0092\u0096î[Ò&mhZº×´`Ñ¸\t]I\u009bî{\u007fM¿\u009e÷f$\u008dÄ\u0000áó÷iÞ{s×sÏ½óüÖÿ^{\u0003Àvü7\u0088E\nb¦5\u0099ÐòZzJOLkgô\\bÆÒòyÝJ\u001cs\u009e}gõtÑ6\u00ad \u0002\nV\u009cÖÎh\u0089¬\u0096\u009bL\f\u008d\u009fÖÓ¶\u0082\u0096ÞþÔÈp\u007f÷Ñ\u0091þ¡ÁSG\u0087\u0007N%\u0087\u0087\u0092}Ã#c\n\"\u0003Uù\u0094m\u0019¹É=\n\u0096ö\u0098¹\u0082\u00adåìQ-[ÔChT°<c\u0014øz¼h\u001bfî¨\u0095U°®ÆjwWª¯b6\u0004\u0095\u0081x5ºµ\u0082®`Íñþä©ÔÈÐp_½ür\u0005ê9#\u009fb\u0016º#[k>Ù5rØ#\u001e©3\u009fÔì©\u001aóuòÍ\u001eó\u008el8o\u0099\u0084Î6ô\u0082\u0082Õ\u000e\b4\u0095M$+ç\u0004bYUê \u0091eTË\u001cIÃL\u0088½\u0080jF³rDm¨hç\u008bvÅ\u0094Ä³\u008bÅÉe´q)xOÚÌM\u0018\u0093\n\u0012\u0003wªg\u008f\u0094,Z\u009aH\u008dª«&L\u008ba\u0089bö\u001a\u0016\u007fMkVA2V\u001b\u008b¿ãÖ;z+³\u0087\u008e\u0002=fF\u000fb\u0013Ñò\u009a\u000ea\u008b\u0082ûk\u0095å®ÃÝuVa\nã>Ü¯b\u001bbLy¯\u00913ìý\n6ß:T\u0097s\u00ad£AÄ\u00154ùÕ!\u008cV´\u000b\u0093\u001d\n\u0016ÇZGÃ \u0088bÿN\u0005û|-×\u0017ò\u0016Ð\u008c\u0092Ö\u0003FN\u001f,N\u008fëÖ\u00888\u0014\ra¦µì¨f\u0019bï\u001e\n¶¸ð+XËr¸Ø%kè!r\u007fHÅ»±\u0093¹ëgÉÏ\u0082\u008cøx\u0010»Ièj\u0010ÃÅ\u009cmLë}gÓz^Ô8\u0084½\nÚ]\u009bÑ*\u0098Ñ\tZ\u008dnÛZØ\u0016Í\u0098ÜæL;*ív\u0086±\u001fï\tâ@M¿;XªèB7\u0003`\u0094Ó\u001a\u0019¹+v3Ü'\u0006ê§\u0004\u0089r\u0093T\u0018»Ð+\u0080îSÐìcE\u0094b1Ú\u00838¬ ã®H\u001dÆ!´7²\u008e\u000f«Ø\u0080\u008dbuDÅj¬\u0011«!\u0015kÑ\"V\u008f¨X\u0087õ¢Þ)\u0015#8ÊþË\u009aZ&éiÝmo\u008b\u0000\u000ei\u008e©x\u0014\u009cy«ó\u0096\u009e×,½·f¤\u0019Ä2æ¢\u0090ÓíÄÑáþ=\"Î\u0013*\u001eÃIR¥ Û^\r\u0005+cµÒÂË!\u009cRñ~hìÚÉZyg¬5Å|\u0081V\u0090V\u0091\u0001\u0005\u0096PÍ\u008d\u009cM¾Ó\u0007v\u009fBø\u0099<\u0004RaJÔnUáæHÄûÓ*\u001e÷\u008bTLHñ~ZEÎO¿ü>¯â\u0003B?LýãF¾l¶ Â\u0016jáBÍñ\u0019\u00153\u001eé²\u0091Y\u0015ç<Òâ8\u0084\u000f²\u001dzÌb6#)/j\u001e\u009dñé\u000eË\u009c\u0096ÝÑ)\u0098ú\u0084`ê\u0093\nâ·\u0087ldÊ2gÜþ\u000fâÃÌ®ú®Ò\u0090\u001c\u0085ö\u0094AzÅïf|*,_ó\u0080\u008f9¾\u000bW6\u0085 \u009eU°ÞË\u009cÔlÎÖÎV$\u0004\u001d\u009eWñ\tÁÕ¥\u0096®e$ø&¿ºa\\À§\u0083øTy@»ú*>#\u0090m$²)\u0006:-'ÑçT|\u001e_ \u0005A(²=g;\u009f°\nÉË-#\u008c~IÅ\u0097\u0085\u0089æ\u008a\u0089T^O\u001b\u0013F\u009aª¶0÷\u0082\u008a\u0017E@\r¶I\u008f\u009c/\u0005³h¥«\u009fÄjË´âeÁå¯ó\u009bá74üéÿ²\u0088¢W¬¾©âU¡ÜÌ&5-û\u0088Q(P¨Ü\u0012A|»\\2Æß?T\u0001-\u0088ïð\u0006àM¬?Ç/2]èÚt\u0018\u0097ð=Á\u008fïW»¶\u009c¾èÚVüPÅ\u008fðcÖ]\u0090\u008d3¾*ä1#e/ã§AüÄ\u001bDU@Å\u0015ñ\u0095jHgMÑì!#ç\u009cWxQg\u008fS¥®÷DKüLEI@½\u0082ïjÆ¦\u0082í±;\u007fÐë¯\u000fA]R\u0094ñ\u0018±\u0013>½qK{ýâ\u0012\u0098ÍêÖmdºMÓfôZþ\u0088&\u0092%Y(.`º\u008e_\u0006ñ\u000b\u0005\u009bîl^Å¯ðk¶H\u009a\u0098Ør*+8\u0010»Ë<o\"õoñf\u00107n÷eò\u008b]Åïð{V° ¶\n¶ø\"VÇ\u001f²F³&9-Vù\b\u0013\u007fÃI\u0094ÖÞ\u000eÖüF\u008cû\u0004vÛ\u008b£o\u00158\u0010¤Ôas\u009aµWÝÁ9;¨ÉmF\u009fÐ\u008aYç\u0086Ï|Ï87ý\u007f)è\u001a4£r\u0017\u009d1ì©èãú¬s\u0003)8\u0003AÏD\u008d\u009cï4.ßU:YÊ\u0094\u001c\u000eÎÀiª\u009b\u0094\u009d\u0002#N\u0014Þ\u008dø_N#ZÐ\u0080{¸\u000br·\b!îÃ\u009eý\u0012î\u0097zöË¸_áÙ¯ä~\u0095gß\u0084\u0088¸Hp\u001d\u0011×\bùä%B>yÕàS¥Ï{ñ\u000ejD¹\u001b¤î\">×-@\u0019[À}cñÈæ\u0012¶. u¬\u0084¶¶\u0012:ç¤Ýíü\u0015^Äÿe\u000fðwµ£\u0085wI\u001fb%¼\u0010sì¨Ø6\u0018\u0093\u0090ê\u0088ÏãÁ\u0017±v\u0001»Æ\"{\u0002¯cñØâxê\u001aö\u0095Ðs]ø\u008dûº[&\u0001z\u0090F\u001ebè;=n;ÜÔÄÊq\u000bq\u001fvÜ*;¨ÑÀ\u0093\u008bñ\u0012\u000eÒô!\u009aî¿\u008a÷ÆÛ¯b Þv\u0015\u0083ñ\u008e«H¶1¨\u0017ðd[û5\fÇ¯ðu\t£ó8.\u0097\u0091%â1\u008f÷\u00950>\u008f\tçl¥sfÈ³¬s¶Ì93å\u0099å\u009c59gEyvö\u00126ì\u000eÈÌÏ;\u0099·\u0089Ì[\u0002%|èúeF¼\u0015\u001fÅ³xÊÍy?\u0096ów\u000f\u0002èäj/Ë¹\u008f\u0099îgÁ\u000eP²\u000bqt\u0013\u0091\u001eô£\u0017'ÑÇ\u000bÈAê\u001fÂó8\u008cWð°Äh\u0087\u0093=>\u0082§%F\u0017%Z\u008a\\\tj,\u0092+\u0081Ûbê\u00adÁ3´\u0010à)/\u0087üý\u0018ß\u0006(ýqYÂ\u008c|\u0003l!:Ï\r\u0010²O¾\u0089\u0016I\u0093+\u0018\u009cÇgyòEÒe\u001e_\u0099k«V.B-A\u00ad\u0006\f\u0091n\u008f`\u0013R\u009eêmq#k Q¾\u008a¯Ñ×\"ñ±¿É÷\u0098\\\u0003\u009bék \u0012\u009aÇK7°r\u0001\u0017HÑP\tß(á\u00959¹ºxL©wý(Ý\u008e1ÅÇØg'¥kÕ1åº\u000e\u008bë´Çá·¤Ãó\u0004Dho\\À¥1&üÝ#míóøÁ%\u0084\u0007ù\u009cë¸.~/K\u0092¯ä_Ùå½²õ4\u009e¦ÉÙ\fCÐ\u0099é\u0004Q×ÉÛIé>*¹¼±ÂÛ\u008d²\u0012ÂR\u0013®b\u009e\u0096\u0014ñÑs\u001bç\u0001>E¸!\u0087I×ê[0çI)ä¦¤à5,¸ú\tW¿Aè×+\u0017=Ê\r\u0015å\u009fãu\u000f\u001eOI3Y\u0006-¨\u0014iwâxcw £\u00ad%0\u008fß\\®kÒY\"z\u008e\u0090\u009c÷\u00100R!`\u0004oá\u000fÒ_\u0004\u007fÄ\u009f$\t\"ø3þBÝ0\u0013ø+A\u00114ã¥ÉM`\u000fß\b©`¼Ma\u001bÕ§ð\u0084\u0087MÁ\u008a\u009b þ&ß\u000bCºkh\u0086;QÒõ\u0082C$ëK\u0083\u001d7ÐÐ1×Îßö¹8\u0007ÎÅªñuT\u0007Í5ÒàR¶Årâ±\u008adlÆsÒaÜ1Uq¸Þu(V\u007f\u0097s´\u0091yý\u0083+\u0011ý«\u0095l\u0092î\u001cÜ ÇÀ?\u001bÜ10\u0016\u0010MT\u009e\u0083u)^ð¤¸¡âq\u0083ëQÁ¿¥ü\u007fþ\u000fPK\u0007\bøÇ£9\u0091\b\u0000\u0000,\u0013\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000org/apache/maven/wrapper/cli/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.class\u009dUëN\u001aA\u0018=#\u008bèJ½\u0015\u0011më¥WXÁÕZÛ*ÔÔØ\u009a\u0098Pk\"!é¿\u000eë\u0014×ÀB\u0096EëKôYì\u001fLÚ¤\u000fÐ\u0087júÍ.E\u0094-¢?v.ß|sÎùÎ\fÃï??~\u0001XÆF\b}\fk\u0015»¨ó*7\u000e\u0085^æÇÂÒOl^\u00ad\n[7J¦¾Y¨967\u009c\u00adJ¹Ì\u00ad\u0083¬i\u0089\u00ad\u008au,lGØ!(\f£Gü\u0098ë%n\u0015õ\u008f\u0085#a8!ô3,w\u0005õ\u0003cèÏ\u0098\u0096él0\u0004â\u0089<\u0083²U9\u0010*\u0002\u0018\n#\u0084\u0001\u0086\u0011\u0099¿[/\u0017\u0084\u009dã\u0085\u0092`\u0018ÏV\f^ÊsÛ\u0094ófPq\u000eÍ\u001aC:{ëºÒ\fÑËÈ§Õ\u007fèoo\u000f\u009bÉåÒ\u001b\u0084\u001d2¼\bC<\u009e½po\u0087R$G:\u0091½j)mRß\u007f5DÕ1+V-\u0084èu§ÖF¿i\u0017ëea9\u00adý\f\u0083ûfÑâNÝ¦zR~\u00122m±}Ç6\u00ad\"\tO\u0090ü\u0010¦\u0019\u0016{¥ÞãvMØ*¦0¤\u0082áA\u00183\u0098%zªÿ\u008bYtéWâÝýì@K'ò\u0012p>\u008c\u0087xÄ\u0010¬Ê(Ãö\u007f\u009cì\nî\"\u001e´Q¤¥Ì'a\u008cã)Ã»k¤uîö=8\u0085ÛEº\u008e\u0011?}tç]ýtù\u0097nê\u0003Ý\u009e^O\u008eaõæµÐiK7\u0016ÃÐ±Ä0d\u0089\u0093\u001d«æpË »#q\u009fZeúsiÞ\nCþÆ\u0084\u009dx¾v^ãS'.ÃºïÝè\u0095¯g\u0097É0i\u001a\u009d©CG.\u001cù<ù\u0000\u0006Ü\u009c`ÜËU÷+uÛ\u0010Û¦|[æ»½\u001e\u008b\u0012\u008bás&·Þ\t»Ñ\u0019êù>]y\u009f\u0094y:Æ\u0000}Aú\u008f\bROo/µ\u00834Û¤\u009eÉ¨v\u000eõ;\r\u0002\bSÛï\u0006Çq\u0087Ú°\u0097\u0080a\u008cP?z)2F=\u0099\u0082»´/Bc\u0085f\u0013\u0098¤Q\u001fb.Á)\u00ad\u0004¨\u009fü\u0089©Oç¸÷AK6p_K.40×Àã³\u0016å°\u009b\u0016!e\u0013D\u001bu©ç¼\u00adMj9z\u00868Q\fÐ<\u0001\u008dH¤\u009c(õ^ÖX+kÁ\u00ad\u008b~ô>Â\u0092®°=Z\u0091ûTmAk ÕÀòÙ\u0095ò§]\r\u001eºÚÒ \u0012ú\u000bZ¿0Bm3bÕ\u0087ï¥Ë÷\u008dV\u0014êcM#vµ\u00944\"%\u008dH^b÷\u009c\u0098¡*gIÁ\u009c«Bóö¶TÄ\u009aNÈÑ+¼&\u0096\u0001R$=\t¸Ê<çb-ObMO¼ü5ô)\u008a|\u0004(âi\\§/í\u008e2ÍÈ\u009b¿PK\u0007\bðdQvý\u0002\u0000\u0000T\b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.class\u00adVk[\u001bE\u0014~\u0087lØ$lÛ\u0010\u0081\u008a\"\u0085Zjn\u0090\u0016è\u008dP\u0014\u0081ÚÔp±Ô -j\u0097e\tK\u0093ÝuwÃÅÛ\u000fñé÷~Õ/é\u0083>öég\u007f\u0083¿E=³\t\u0081d£@,y\u0098\u0099\u009d9çÌû\u009e9gÎüñ×¯¯\u0000\\Ç\u008f\"Ú\u0018f\f+\u009f\u0092MYÙRSEyGÕS»\u0096l\u009aª\u0095R\nZjzÝv,Yq\u0096,\u0083¦\u001cMµg\u008cbQÖ7²\u009a®Î\u0018ú\u000eMª\u0096\b\u0081áÎ©\f5Sgh\u009fÔtÍ\u0099bðEc9\u0006aÆØPCð!(Á\u008fv\u0086\u000b\\~¡T\\W\u00adGòzAe\u0088d\rE.ädKãßÕIÁÙÒl\u0086¹ì\u001bà\u0094fèÌ«\u0087Bû\u008b¦£\u0019:CW4\u0096Ý\u0096wäTAÖó©eÇÒô<\u0089özDgUGÖ\nê\u0006C_\u00935[±´ªÅ bè\u009bZ¾d\u0011\u0081±è\u007fC?\u0006tI¶lB\u0019Ë\u0089èf\b7b\n\u0081á¢\u0084ó¸ÀG½\u0012Â|ô.Þ\u0013ÑÇ0r¶]$ôã\u0012\u009d\u0092Q\u0085<\u0017}âuBìÔÐ+NH\u00870\u0088÷E\\>\u0003\u009c\u008a¦\u0084+\u0018b\u0090¶d{ÚÊ\u0097\u008aªîÐ©\u008fF[@Àð\u0081\u0084Nî\u009aAÄ$Ä\u0091`8OvëNh6ú\u0006Ø\u0092ûL×\u0099\f×ÎzÈgQ©m×¡«»\u0019Ývd]¡Èê<\u008cÛ\u0092£\u0015Ró²I\u0012Áe-¯Ë\u008e\u001by·\u001a×'½\u009c½3Si\u0011ãdüHó¾lo\u0091v\bc\b2\u0088J%\u009d\u0018\u0096N\u0088l\u0097éÆ1\u001eé\u0006¸^ø¡¹=EuÙÚ\"&Nº\u0080\u008e\u0099>\f\u009a\u009a>Ãóÿ\tï\u0094ÞjÍÇ!ÜÅ\u0087\"¦NJ\u0014\u000fH\u009e·\u001f1<8{üzLÕ2æcÌ\u008a\u0098a\u0018oE_Â\u001cîQàÑ\u008d\u0098\u0093\u000b%\u0095Ò6R\u0017xYÍvÒ\u001d¸\u008f\u0007\"2\u0094\u008aõ+\u0012>E\u0096! Ñý,;\u0006¥RO\u009dv¦:O\u0016\u0016°$b\u0091Ì{W%|\u0086\u0087T,tuÏi¼Ð\u0017×·UÅI\u0007ð\u0088\u0081Ý\r¡\u000b9\t+ø\u0082BYÓ7Ô½ÅM\u0086îfîÌ\u0004ð\u0098\u0001\u001dXÃW\"¾d8WwÒ\u0012¾ÆS*of\u0089¶¼\u001dõîè\u009di\u0002\u008bãY\u0097 \u0080ªJÐ.ñ:F\u009bs/d2MÊ\u0012\u0017ßäây\u000eº\u0099\u0004÷\u0093&a\u001bÏ\u0088 ]{\u000b®K¨\b\u0013\u0017±rÛÛ'^>ÞÜ Ü4kÅ\u0095WïÆÔ\u008d<S÷Ý\u0000\u0098Û3-Õ¶Ý\u001c\u008c4+¬>Ó \u000b\u008cb¡§¾âï\u009b\u0087UÿFKIÅ\u0090k1çO<$\u0086=\t7q\u008b\u008f¾\u0095\u0090Â5rÈ²Q²\u0014õ\u009eÆ\u0011'N÷\u0004\u0019á¶\u0019¬Ó=g\u009aY\u0098lÉ5Sia\u0090 ûÀÿ\u00824¢7\u0018µ\"}¥¨§0\u0087?þ\u0012\u0081_hÐ\u0086\u0010µíîd\u000f\u0085? U\u0004¨?\u0007\b\u0002\u007f\u0082¸}¸Úwò\u009ed\"x«jÔ$i¾ÙÕ\u0084ÿwt\u00adúâeô,¯\nÔ½½\\Æ;óÉ2\u0006æ\u0093ôyµ\u008cèÊÑ®\u0011\bÔöã\".¡\u000f\u0003\u0018¢\"Î\u0011\fT¬U\u0010¸£$\u0086ù{\u0088vîÇ\bi\u000büP¨¿îÚ\u001auQ\u008cÒ\u0088#\u000fü\u0086±Õ\u0097¸ñs\u0003»+ÇØ\u0005ª¶\u0019?fÚí6\u008d\u0005úºSµ\u0098v-þé:\u000eXKpFeL\u00961}\u0080O\u0018&\u0084\u0017\u0098ê\u0015\u000e0Ïð\u001a]\u000bÃ\u0011âùùM\u007f·ÿ9ÂÉáÈê\u0001\u009eø°ò\u0002½Éa_·¿\fy¸Û/<-C\u00ad,pÕ-\u0086\u009fþ~\u0095ä(}.ÊË\u0084\n\u0088\u0012û\u0018µqb\u009c lILÐh\u0089f\u001e\u0013cÎ`\u009cP\u0011¦\u009awÖP@Ñeµ\u0006\u001d\u0006¡\u001f I\u0013ß\u0090Ý(ý,Ø¤áÔ¸s©\u0012ÚÂÓÄ}\u0087¤\u008f¸sÎqÒâÞ\u000fÅ\u0013É×X+c·Ñ\u008fÌEÑ\u0006\u0084gé\u0014\u001eVc`¨\u0016Xeìÿ«\ný\u007fç¶ßW\u001dýÃ?PK\u0007\bjç F®\u0004\u0000\u0000Î\f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.class\u009d\u0090AOÂ0\u0014ÇÿEØt¢ \nF\u0012\u008dÜ\u0004\u008c\u008bG\u0083!1D\u0013\u0093Å\u0083\u0010îe4£fë\u0096n\u0003¿\u0096'\u0012\u000f~\u0000?\u0094±\u001d\u0004\u008d\u0012\u000föÐ¾÷úïïý_ß?^ß\u0000\\âÐD\u008eà*\u0094\u009eM#êN\u0098\u001dÐ)\u0013öLÒ(bÒv}n÷Â  bìpÁn¤\u0097\u0006L$·Ï.\u008b\u0012\u001e\n\u0013y\u0082ú\u0013\u009dRÛ§Â³\u001fS\u0091ð\u0080\u00adî\t\u008ck.xÒ%¨\u009e9_º~\"¹ð:Í!A¾\u0017\u008e\u0099\u0085\rl\u0015Q\u0080APÒ\u009d\u001eÒ`Ää\u0080\u008e|FPqB\u0097úC*¹Î\u0097Å|2á1AÇù·ù\u000e\u0081\u0019°8¦^Öã\u0097;\u0082Ö\u001aÏß*\u0083\u0089\fgÚ\u008d\u001aDOPÑ\u0013\u0094\t\n.McÅ¬®Õ\u0012Xý0\u0095.»ãz\u008eÆ_\u0016/4\u0000\r\u0010E×+§\"õIj7UÖUyN\u009dF«=ÇæKvo©ÝÊªGJYÇ¶\u008aj\u000b\u0015\u008aØÉ(\u0006vQR\fÍ*/Y÷ª\u0083îa¶Úçsìý\u0084\u001d«G'\u0019ìt![ÁÌ%LGû8È,V³×µOPK\u0007\bûm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.class\u0095R]OÂ0\u0014½\u009dÀ\u0004¿ð;þ\u0003ö \u0095\u0010\u0013e\u0084Ä &&K4\u0081ð^Æu\u0096lÝRÆô·ùà\u000fðG\u0019K1H¤Ñ±\u0087¦½g÷\u009csÛóñùö\u000e\u0000u8¶Á\"P\u008fe@YÂüg¤\u0011ËPÐ\u0017É\u0092\u0004%õCN;q\u001411ô¸ÀN,2\u0094)J\u001b\n\u0004ª#\u00961\u001a2\u0011Ð\u0087Á\bý\u0094\u0080íÏþ P«y?ð½ja\u0083\u0010]ÇûÝã\u0012¨Ü¾ú\u0098¤<\u0016c\u001bÊ\u0004®òÚ¹\u0096Á$B\u0091Îû\t\u0094»<\u0010,\u009dH$pj²ÐZ¨uSÉEà¶]§×S>\u009aFËË\u008e\u008dC\u009cç\u0016SZ3½\u009b\u009a÷ç¤\u008fL\u008eq¸0¯Yùbu\u001a-ß_¹/çU\\®L<¿\u0092²ÊÏ\u0013\u000fôó5þ¡Y Ð\u008cÒuú*LÝx\"}¼ã¡¢81e÷ljY\u0005´Õk.»o/\u0097J\u0004\b¬Áô+ªÔ\u0017¡\u0004\u0016ØêTPõu¨¨\u009d\u0005\u001b\u001aÙ4 [\u001aÙ6 ;\u001a©\u001a\u0090]\u0085ìÁ¾Þ\u001fèõð\u001b9ú\u0002PK\u0007\b=8\u009f\u0094L\u0001\u0000\u0000»\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.class\u009dU[W\u0013W\u0014þ\u000e\u0017'\u0084IÀT¹X«XDC\"Ä»V@« \u0095\u0012À\u0016\u0004A¡\u000eÉi\u0018LfÒÉÄKûKÚ\u0087¾Y_|h»\n.ëZ]}ò¡kõgôo´ýÎdÈ\u009dµjWÖÌ\u0099sÎÞßÞßÞß9ùãï_\u007f\u0003p\u0006ßhh\u0011\u0018µ\u009dLÂÈ\u001b©M\u0099È\u0019\u008f¥\u0095xâ\u0018ù¼t\u0012©¬\u0099\u0098´s9ÃJ'MKÎç]Ó¶4´\tto\u0019\u008f\u008dDÖ°2\u0089ù\u008d-\u0099r\u00054ÛÛ.\bt%½Ý¢kf\u0013\u000bÒ\u001d\u0013èX03\u0096á\u0016\u001d)0X»;\u009e¬@-¸\u008eieÆ®ÒC7\u009cL1'-wñY\u009eNû«¬&³F¡@\u0093\u0003õkã1åÙ\u0099\u0096\u0085\u0094czÉ\bD\u001aá\u0005\u0082\u0085âFªÄ\u008b\u0016i\u0099wdÊPöË\u0086cÑ\u0084\u0016¦\u0095*npMMÄªÀ¾qÓ2Ý«\u0002½Ñ*ÄiW:ÆFV\u008e\r/\tÄ\u009bí4¥§¬Û&í´\f¢\u0015½:\"è\u0013h\u008d\u000e/i8D®\u0095úÜ6\n\u009b¬Q\u0010ýèí\u0080À\u0007:Ú±¯\u0003GqLÃ\u0080@¸\u0002¾d\u009bi\u001d\u001f\"HèÅ\u0095;7\u0095ùq\u001d\u001d\bvâ\u0004¢\u001aN\u0092jc~:\u0086\u0011\u0013\b\u0098jîÚ\u008e@Ot¸ªCÓþúX'NaTÃÈ.JÍ®\u008e\u0004N3°%\u009fR\t\u0007v\u0011ªô1¦ál\u008dlJÅèÄy\\ÔpA T£\n\u001d\u0097p\u009951ÒìÐÁh#ÜðªJè\u008a\u008e1\u008cS{\u009bFaÎ\u008bÍ*®*\u0005R®sÅÜ\u0086t\u0016\u0015K¥\u0003;ed\u0097\fÇTs\u007f±ÍÝ4©×ÓÉw;\u0001uÚ+\u008b\u0080*±}ÙõÔ\u0086£\u0086ý\u0090ÿY#Ô`Fºó»gj\u007fMWJ§j¨~m\u000f NVçº\u007f\u009c\u0004ÎÒë\u009dùêU\u0010\u0005\rÉ]éy\u0091\u0093f\u0081¸!¦»Pu®jUà§£TyGG\u0018!\u008a!gä\u000b\u008bvµÏT´Ñå\u007fd«\u0095\u0001ÃLjªr\u001fhàÉë\u00ad\u000fq£hfÓÒ\tâné\u0094\u00adèÐ\u0011RÓû:\u001e`\u008d}Uñ\u0014ÞHÓ\u0004÷\u0000ôØ~¡£«\u0004fèØ@\u008a`YieÜMO«ÓjCª(_\n\u001c\u008eNî\u008d\u0015\u0000=Â÷w/+\u0099\u001e\u0018\u0019\b`\u008b·Ó\u009a\n\u0093ÕÑ\u008dý\u0001P{úýÊåµ¦ðó:¾Â\u001c\u000f¹k\u00970\u0099\u0083#\u000bÅ,»Ö¿g@FcÓ§j.SVóz6k?©hAàPyq\u0096\u0088f>+«6\u0083\u0095|y\u008e½f4¹l\u0017ì¢\u0093\u0092·Lu@z\u001a\u001a:ª2Ä1\u0092lå¿Ö>Þ\u0096¼\u00039Ó8kA\u0080\u000f/¹ò¼\u0093\u000f»ç}\u0087ý±Ë\u001fY!\u008e!ÚFð\u001eç%\u008f\u00038Èñ\u0005ÑÛ8^\u008b½BOì\rúW^áým\u001c\u008eý\u008c#Û\u0018\u008c¿Æ\u0090ÀÜ\u000bô\u008d¼F\\àw\u009c\u0099\u008dý\u0082Ã§^ã\\\u000b\u0096¹ø\u0091Àwÿüõ\u0013!Z1Á÷\u0011\u000f~\u0090 ½L \u001f=8\u008e\u0018\u0086p\u0081ãU\u009cä\u0003\fx\u0094®ñ÷1à}µã:Ó\u008b\u0091Æ\r&Ú\u0082I®ê\\)íMñKà&n\u0095\u0093ÿÄK>á\u00ad\u0003í*¥\u001f½\u008d\t¯Vj1æ\u0085*\u0081´û¡\u0004nc\u009aoå|\u0091Öj/\u0010\u008b\u009c!ÓXÅ?È\u0011\u0018%N¢\n#PÆø´\u0019ÆL3\u008csÄ8ß\u0014c\u0016s>F5\u0089ùz\u0012\u0097\u009b\u0092ø\f\u009fûÎ×h\u00ad\u0002i±ø6æ\u001bâ\u008fÓiÂ\u0083è)\u0099\u0095K®aÁS\u0084Àb9\u0093?}0ù\u0006w)\u0083å$3º÷\u0016z\\\u008d;X]æ¸þ\u0016Ñø\u000e\u001e~\u008f`¼{`\u0007éåx$£ö\u0094Ñº÷\u00111}ÛGß¢¯Þ6ç\u0099ìÀ®¤z\u0085\u0082\u0005û\u001f`ï»Øù>vú({}\u0082]\u001ea©Ï³à\u0013\u0098¡\nfù\u009e#÷y¬°\u0006\u000fI¡BMúÔ\u0002X\u0083\u0083\u0082GÍm^§{\ruZf\u009dîíQ'Ý¯S\u0091Õ,\u0081]ö»\u001e&ÇA\u009e\u0093çho{Ùú²®u\u000fªZ\u0017.·îq\u0019å\u0092\u008f\u0012R(\u0091\u0099\u001f\u009a\u0082<¬\u0002\t\u0095A\u009e4çµÞÀ+M^r\u000f^]>¯î²\u009a/ø\u0019i±¶m<j\u00003\t¶U\u0095\u008fVÎçiS1¯×\u008bÙj*æg\u009eÕ×ÿ\u0002PK\u0007\b6W°K\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classÍV[O\u0013Q\u0010þ¦-,,ËU¹x¿U.-°à]\u008aH-÷«I\u0095\u0084ÇÃ²\u0096Åv·Ù.ðKü\u000f>b¢A%1¾\u0099ð£\u008csÚ\u0002Å\u0016a\u0011\u0013\u001fÚ9gæÌì|3sfÎÞÏ¯ß\u0000\fbFA\u0080\u0090pÜ\u0094.²ÂX3õ\u008cØ4m}Ë\u0015Ù¬éêFÚÒ\u0013N&#ìÕ9Ë6_\n7gºáø\u001bÏt',7ç%7V\u008ab\u0005!Â¸OC\u008bYÏrìø\u0096p\u008b\u009c¤'<\u0093Pí\u00adY¹ð\u0000a`Î\u009fÅ\u0018ë\u000e[¶å\u008d\u0010\u008cn¿Ê\u007f>\u009f?´Z¢\u0015ëY\"\u0084\u0012ÎªY\u000bB\u009d\u0086*T«\b¢^\u0083\u0082\u001aB£<´°\u0091Y1ÝWb%Í¸Zæ\u001cC¤\u0097\u0084kÉ}\u0091\u0019\u0092`9v>½\u00ad\u0098\u0005Æ_g\u001c\u009e<1\u0080å\u0098\bõ\u008eÍip½Br\bkÝsëbSèia§ô¤çZv*VÎéñë~Á|IÚc*ÚqIA\u0007¡ß\u009f-\r\u0097q\u0085P#\fÃÌåÂ\u0083\u0084¸ïÜ÷\u0014 mxVZ\u009f\u0017ÙX\u001d®á\u0086\u0082ë\u001c\u008f#\u0002\r7q\u008b\u0010L\u0099\u001e¡³44\u008b+ë¦áí\u001b*e)¸ã\u0003S!0\nî\u0012&}ÆôµýÖv¶ì²ÐÊúìÒÐ\u0082\u000b*Âè\u0091õ\u0019!ìUJ¬Ïrñ\u009bõÒ|ûÕ=\u000e\u001dßC\u0005½þ»ÏlEk\nú\t±3\u0015s!\u0086*ú0 CÌu¸zª»s¶«³\u007fñ\u0096TDq_~ð\u0001Qò\u009c\u009bÞ\t\u001f?µrAë¿.¯Êå\u0090oòAá¦d÷.Ë\u001c\u008f\u001b§Ø&\u009b\u008dßÑú\u0019_Åø\u0010Þÿó©u.sFV\u001d·F\u0082\u009at6\\Ã\u009c°ä(k+Óî\u0097!#hÓ¶mº\u0089´ÈåL\u009eu\u0017+ÙdõÊ)`Aå\u0087\u0082\u0082\u0004aôoç\u000e§®\u0002O+\u00ads\u0005\u0093\u0084¡³×\"Oå#»\u008eãZ\u0019\u000f\u0017®6~\u009aQS\u0093|Nð*\u0088\u0080|N0¿\u0096wS¼\u0097r-\u0012ý\u00045\u0012íÝ\u0081ö\u0081÷\u00014ð\u007f\u0083\u0094Q\u0002U4\u0086:\u001aG#óÚXÆçÑ\u0084f ¿â1À<Î\u0002Z\u008bVß±ý\u0010Óxä#ÔÏhëý\u0082«\u0001|Çí\u0085¾\u001fhÙEx9Ê\u0092Î\bí {{\u0017Ñeyn\u0017}ËÑ^fé}ûÂ{Û\u0007®´H\u00834\u008df\u009aA+Í\"Lóyw\"\u0085\u000f\u001d¸\u0013ÇC<b7äê1¯\u0002Ì\u001fÀ\u0013<E°\t\f|¨èb\u0017C\u0093\u009aJ\u001esì\u0010sµTfÌ\u008dy\u008eü\rçÿ\u009fa\u0084é\u0010\u009b ~W<gN\u0094é(Ó Óx(\u0080\u0017LÇB²]·c\u001c*&\u0098N\u0085ä\u0084lÇ4Ô_PK\u0007\bæ¿Ëk-\u0003\u0000\u0000%\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.class¥\u0095mO\u0013A\u0010Çÿs-\u00ad\\\u000b\u0005\u0015\u0004\u001f\u0011\u0011i+\u001c\u0088úB|&JL*\u0092\u0000Mä\u008dYÚµ\u009c¶{Íõ\u0000ýN¾\u0090D%ÑÄ\u000fÀ\u00872ÎÞ\u009d¥Ø\u0002¹4\u0097ÜîÎÎüvfvv÷àÏÏß\u0000æp/\t\u0083°à¸\u0015KÔEiKZ5±#\u0095µë\u008az]ºV©j[\u008bN\u00ad&T¹`+¹\"Ü\u0086t'\u009e½÷¤û¦îÙ\u008ej$\u0011'<\u0088\b\b\u009aUOx\u0092\u0090*\u001dÎ\u0013f\u000b'²|Ër\u000bq\u0081\u0090xh+Û{L\u0098\u009f\u008aj\u009c-\u0012â\u008bNY\u009a\u0088!\u0095F\u0012iÂ\u0093S0'ÆÃÈ^\u0010úÓèA\u0082\u0090ÑZËÛµMé®\u0089Í*\u0007x¶à\u0094Dµ(\\[\u008fCaÜÛ²\u001b\u0084GQ\u0017nÝ\tÎÄ@M|Þ\u0094ì\u0087ë\u0005BÂÐTá\u0083Ø\u0011VU¨\u008aµê¹¶ª,d7\b1áV´3m\u0093\u0084>G\u001dAlu@t\u0080Fõ=À·¦.\u0089\u008b\u0084¥\u0088\u0098uõQ9»ª\u008dfb\u0014\u0097õ\u008e^!\u001ct\u008a b©tS\u0013Qm\u008f\u008bÉ¯×\u0084\u0013îKÊQË\u008eú·K+\u009d6º\u001b§M\u008cc\"\u0089\u001b\u0084\u0099h©Jã&&¹\u008cD¹üâ\u0093ç\u008a¢¨nËc*\u0091ã©G>µ]\u009d\u0092lÑäó\u0099Õ\u0095q\u0086`®:ÛnI¾´õ)\u001cn3\u009dÑ\u001e\u0013Ò¯\u0094\u0092îbU4\u001a\u0092o¼\u0099ÓRÒÆaÄÑKs\u008eð´ÛóB\u0018ì K\u001d\u0019\u008d\u001cWJ\u0018ã,Äø\u0011àK@_UÜë\u0081¡\u0093Â\u0092^\u001e-ñÈà6\u0095£}\u0098¹üwôíñÐ@\u0086ÿýÚ\u0094ÖÐCë0©\u0088\u0001\u0096\r\u0007ê\u0018d ü\u009eÆ\u0012\u007fçp>\u0084ÞçVk\u0019±/M\u0096Ö\u0001m´0\u008c&ÃÀ\u0010Ë4ã\u0002FBÆk¶Ð\u008eg~aôm>÷\r}ÚÃK_ÿ\u0003¾ó\u0081c\u0081j\u0013\u0098\t\u0081ºwÕ_\u008epÍÏ\u0085F?\u000fc655ÿ\u0003×s\u0087TSÏP\u0099\u008bF¶¸j6Éf@æ©$n\u0085¼IÖÑë'rù}Líýçá\u009aÏ\t\u0002Îùÿ<ns;\u008e8ÏOÃbæ,·wâúu\u009aÆ|\\ßiÓ¸\u000bó/PK\u0007\b\u001b\u001b['\u0093\u0002\u0000\u0000Á\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classÍVíS\u0013g\u0010ÿmrpx9%ÒB¥E\u001b-\n$\u0084#\u008a/\u0010¥b\u0004k\u008d@\u001b¥\u008döe\u008eãi8\u009bÜ1\u0097\u008bô_é\u009fÐov¦\u001dl\u0099V¿uÆ/ý\u008f:Ý'9$\u0098S9´3ý\u0090ì=ûv»¿Ý{v\u009fýóû\u009f\u0000røVE\u008cpÝõ*\u0086¹aZëÂ¨\u0099\u000f\u0085clzæÆ\u0086ð\f«j\u001b\u0005·V3\u009dµ¢í\u0088eÓ«\u000boø\u009aøÎõÄ\u0082íÕýRc5\u0090«P\bó\u0011=-mø¶ëÌm\u009a^À)ù¦/\bÝþº]\u001f\u009e$L\u0016£yÌ³íeÛ±ýY\u00825\u001aÕøÕúM¥µ6«üØ\nA)¸kâ\u0010\b\t\u001d]èÖ\u0010Ça\u001d*z\b½Ri±Q[\u0015Þ\u001dsµÊyõ\u0015]Ë¬®\u0098\u009e-Ï\u0001S\u0091É\u0012\u0016\"F\u001b^\u0006\u0006 aíª¾\u0016ÁÎ¤\b\u0087]\u0087ëàù\u00adê\u0010ÖG\u008b\u000fÌ\u0087¦Q5\u009d\u008aQò=Û©ä;9cQão¹o«{^Å{\u0084ü\u0081Ü´\u0082Ð0\u0080A\u0089þû\u0084µ}E}° wR^Ñ0\u0084\u0013*\u008e\u0013&¢9Òñ!R\u0084\u001eÓ²D½>\u009c#ÌEn×±V:\rß®\u001a·Í\u008d|\u0002§0¬â#®à\u001e\u0081\u008eÓ8C\u0088W\u0084O8Ó\u000eËÒê\u0003aù;\u008eÚY*F#äÔBE\u0082\u0091Ö\u0091Áønbg\tç¢'vOÅ\u0004áFÄÚÜu¾wÜM§£¯ä×9©£\u000fïhÈâ¬ì\u008fs\u0084gaý\u0011ñ[\u0089Ú=íÍ\u001eÕöeÙq\u0017ª8O\u0098Þ¯¿9¯Ò¨\tÇ\u009fÿÁ\u0012Mg=¸H8\u0019øO\u0005·G¶Êª)·©\u0090\u001a9]\u001f\u0099P1MH¾Ø)\u001aò¸¢âò\u001eQ\u000bN\u001d³ø\u0098/d¾¦j&·Þt\bâ÷_Ý\u008d\u0081\u0096\u0086)ÌÉº]#ô\u0087x\u0091\u0010\\\u008f>~n\u0085\u0002ª¡\u0080\u0005ù²\u001bD¥·<C^s¡ìÛ¸eõ¿î×pp\u009b33nz\u00159\f;êÈÍâ\u0006CGwÛ\u0080!\\y#\\\tG\u00ad\u0017Á\u008b²\\\u0004p\u0013~úÏw\u008a·³\u0005ÈÉÄc\u0080 \u0095Ü\u0086g±\\n\u001a\u0003\u001dæ\u0013²\u0004\föMÇ\u0011^¡jÖë\u0082W\u0091þP§l\u001f^S\u0016\u0084/r*¾$\\}Óµ\u0080\u008b\u0017ÂÓÛ\u000b¬â+ÂÌÁ\u009b\u009b\u0097¦=§c/»l\u0091bXã¼;S2)×=~\u008a#&×=æ\u001fâÓ'|\u0096r=\u009dù\u0015Z:3¾\u0005ýg>Çp\u0084ÿ\u008fH\u0019\u0019è¢I$(\u0087^æ\r°\u008cõ\u0091ÄQ ùÄ\u0083\u008ay\u0084wÑ\u001fxý\u009býw1\u0015Û\u0018(gÆi\u000bÇ\u0016Ó¿@{\u008c\u000fÆ\u007fÃÉ\u0018\u009ebdF\u0019TþB®Å\u001eû\u0011}ÛÈ\u00963|4Ò¬\u009f{´\u008d©rß\u0005å\u000f\\*Ç³¥Ç\u0098ÙÂÕ'Û(\u0094¥EvPÙÑ\u009c\u007fô<Ü\u0013\u009c\u0018è<\u0087z\u0081W\u009c\u008b8E\u0097x¶O#Oy,Ól3ü©V`ÏÃ\u0017\fÁM\u000e[>}ÊO1$p\u000f·PäÔ\u008f³ì6\u0016¡$Á\u009e\u0097\u0082äFX¢0U\u009bh-ï¢Õ-Ý0Z½M\u008eü}Öüÿ\u001c%¦3ì\u0082xã¸Ã\u009c\u0002Ó»LãLW\u0094\u0018¾`ZVä68Ä/×p\u009fé×\u008a\u009cþCø\u0006Ú¿PK\u0007\bì\u0014úßÝ\u0003\u0000\u0000\u0000\r\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000T\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.class\u00adS[O\u0013A\u0014þf·t¥l¥¶\u0080\u008aVPQz\u0083\u0015_K\u009a\u0098&&M\u001a$)éûP\u00862d;ÛÌnëoñ?ôÅ\u0017L|0>û\u009f¼\u009cÙÝ@ \u0018cÂÃì¹Ì9ß9ß9³?~}ý\u0006`\u000f;\u000e,\u0086\u0083@\u000f=>æ\u00833á\u008døT(ï£æã±ÐÞÀ\u0097^;\u0018\u008d¸:éJ%\u000e¹\u000e\u0085ÞjóPtT(T(#9\u0015½HK5¤°1×<\n´\u0083\fCá\u009cO¹çs5ô>\u001c\u009f\u008bAä Ë°\u0012{'\u0091ô½«x\u0086ì¾T2j1Ø\u0095j\u009f!Ó\u000eND\u000e6\u0096\\8¸Ç°l\u008a\u001fLFÇB\u001fñc_0\u0014»Á\u0080û}®¥±Sg&:\u0093!Ãa÷nù4\u0019\u009cAlQ\u008díJ÷\u008aY\u0012Ù\u009c÷T;9\u0094°ê`åÚ$\u0092[\u0017kxÈPJ1\u008f\u0082ÎP\u0005Z\u0098.\u0018VoÁOÐ\u001e»X7y\u008b\u0097yÔW0\u008ed öÌ@æÒ.¯ßÒhNäé)\u0003ëÜ`\u0090ì¦9ï15\u0019^¸(à\u0001C¯r×3\u00adö\rþ\u0012C®\u0017Lô@¼\u0097f\u0083ks@»¦3\"Ý\u0093CÅ£\u0089YÁþßú¿ñ®öçGÒ¢¡¸\u001d¥\u0084nû<\fEè Î°û\u007fÜ\u00186þÁ\u000eo\u0088\u009bMg\u0081þ²\f,ó\u008aÉZ$Ë#ÉH.Ô¾ ÷\u0099\u0014\u000b.}³ÆÉ~\"Oº\u009b\u0004à>\u0096I2³\u00814ù\u0094¢3$\u008bõÆ\u0005\u008a\u00adò',\u0094gF\u007f4»D*\u009a\bö\u001bY\u000bÈÑÏíZv\u008cZK2ST£=ÁÓ¸R\u0011eÒ,êÁÅ3lÀ.¼£\u009a\u009biÍ\u001d\"b\u0093Ì×êßQjÐ¹ÀóÙõÆéäc\u000få\u0011×\u0097iê+\u0092VÊuëv®æÚ¦@£½Æv,+¨\u0092ÌÅ\u0083ª¡\u0081õ?PK\u0007\bà¤ûG*\u0002\u0000\u0000¯\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classíXéw\u0014U\u0016ÿ½¤C5Í\u0003c#Ñ\u0080K©\u0001\u0092ÎÒ \u0088b0C\u0004Äh\b`\u0098d\u00823h¥»L\n;UmUu\u0002¸\u008eÛ,*nq!âÎÈè8c`L\u0087\u0018qß\u008e\u009eã\u0007?û\u001føÅ¿@½·ªº³ts°\u0013?z8t½õwïýÝå½\u0097¯\u007fzï\u0003\u0000kñ¹\u00822\u0081\u00ad\u0096Ý\u0017×ÒZ¢_\u008f\u000fh\u0083º\u0019\u001f²µtZ·ã\u0089\u0094\u0011ßl\r\fhf²Ý0õ\u009d\u009aíèvÍ\u008d¦5dîH»\u0086eú#\u009d®æê\nB\u0002\u009bJ\u0084*@\u0011\u0090\u00967ÖéÚ\u0086Ù'pMû\u009c ýíÍ\u0002\u000b|8\u00815¿\u001aÈG ½\u008b\u0012S\u0083g\u0004ðÄ'§Á\u0010@\u0085ãÛ´±T#¦1Â6\fj©\u008cî\bT¶ïÓ\u0006µxÆ5RñvÃqina§ÑgjnÆ&15³¦7úý\u0094föÅ\u0003BZ\u0018Îí7\u009c\u009a5¥PâëÃ{7\u001a¦á¶\b!kKÝ</G\u0096ê¼R}5\u001f\u0007Õu\t\u00846[I}!\u0004Î\u00958\u001bÑ\bÊQ-±\u0014Ë)½Jeª0+H\u0084\u0082ó\u0005\u0096Nù·Õ¶µ\u0003ìä\bVàB\u0016u\u0091@ym]\u0017+q±Äb,áÖ¥\u0012\u0015XÀ\u00ad\u0095\u0012\nÂÜZ-±\u0010\u0011nÕI,\u0082\u00148\u008b\u0085wd\u0006zu{·Ö\u009b¢P\u008a¶[\t-Õ¥Ù\u0006÷\u0083Á\u0010\u0007\u008eÀ¶Rí)^0(\u009a\"\u0096Ùj÷e\u0006tÓ\u0015ØY[\u0018®uóñK\u0084,\\+q\u0019.\u0017XÒ§»×kÎ\u00944¢j\u008f\u0082+\u00046üZ\t¹½[÷'tÏ\u00960®\u0014¸<XÑ\u0098¢%ª_lÔÕ+\u009dÕjÒÒ\u001dÕ´\\ÕÕn×UÍTµ\u0000 IÁ\u0006Êå)cwôîÓ\u0013äÈf\\£`ã\u008c)\u009f\u0007\u0089\u0016ü\u0081\u0092ï6Ë\u001eÐHù\rE¨º¹}6 ±W°*\u0082uhåh¹V`Y1Â»X\u008d-\u0012[q\u001d\tLéf\u009fÛï±Õ\u0016ÆõTÉZMU\u001fH»\u0007òÖ¨C\u009a£¦mkÐHêI\u00954T\u0013§a¤i\u0011n@»\u0082\u001bÉ\u001d3\u000b\u0095Ävt\u0090\u0014-\u0099\u009c¥VÎ\u0092=ìÌ\u009d\u0012»p\u0093\u00176Äz:¥smm©\u009dW\u0090\b\u0084µ|PD\u000b\t!]¹\bi¶Û¡ïw)\u0006\"èF\u008f\u0082?\t4\u0095V\u0093$öp$F)\u0012[S)k(\u001f\u008c\u000eóòg\u0089¿ð´b8[\u0099_\u0005·\bl)Ñ°í\u0086ã\u0090Ò¾<\u0082÷L\u008c`/4vy¯À#¿A-*\u0015¡¨R\u0014ha\u0090³×wXs\u0089¤\bnC¿\u0002º\u001f4ÏãT\u00910°\u008f\u0003 \u0091Ð\u001d§f\u00adÀ®9ò\u0093/WE\u0012.\u0005SÁÀ\u0099Â¥àH\u0092°\u0090¦ó\u009drbGp\u00859X$aK=\u0018Ï\u0090,\u0005j\u0004Û8Dm\t\u0087«BÈ1\u000eRTe0¤`P`Ý\\\u0000%öã\u0000YGÉÐ\u0015\\n¢µu³¯7\u009ckwJÜÅ\u0089±<\u009f7Û3)× ìÏçO\u0018÷P\u001dÈ\rçãÉQ\u0087t[/¡6Ý'ñWÜO\u0001a¸º\u00ad¹\u0096-P5C©¶`\u009cèx\u0010\u000f+x\u0088´.\u009c\u0095ø\u001bþN4\u0099T0\u0004Î©\u00ad+¬gÌÞ?%\u001eá2¼\u0088<\u009c3\u0085q\u001f\u00938äU\u0082~Íá\u009aÃ$<!ñ$\u009e¢ÚH$lÑÓ¶\u009eÐXõnÍ6½[òL!ùÐ\u001bÆ³\n\u009e)¡RùA-ñ\u001c\u009e\u009fÊ\u000bÒe[É·½@\u001fÃ\u008aï$eÜn\u009b9mV0BW¤Ù\u009a^\u009b1RIÝ\u000eã\b±¶»_W#8\u008cVþyYâ\u0015¼J\u0007\u0011\u008b2©^4\u0016;\u001c\nL\u000f\u0000\u009bÃx]à¼\u009c\u009f\rGM\u0006ÜQ44zRþÅ\u0002Þ\u0098\u0085{ÚlÎáòÎ\u007fK¼É.\t»\u0096?\u0019Á\u007fð_\u0005oç®i3M\u0097ø\u001f;[IóPÊd§\u008eJ\u001cg\u0084ÅäÔÎLo\u0010\u009a\u0011ü\u001fc\nÞ\u0015¸zîÇ\u009aD\u0016q\n-Ëì°Ì\\ù\u0090i/\u0017sÝõs«\u0004ôªñ\u009e#Btþþ\u0004\u0098ë\u0099x\u009a\u001b1ß¾\u0004ÞçÃú\u001cºætZ\u0019;¡_gðÝ»ª\u0000¤\u0089£\u008c¼Úf\u009aº½9¥9\u000eWÑªâÐT:\u008a\u009eÃ\u0002g\u0017{\u0083O'\u009eÂhÚ$TÒ°\u001cÀ\u0002DùiA\u00ad(?,¼/=+¼/=*¼/=BhõYÔ.Cee%¿\u008c¼\u009del Í,£Þ³\u0084Æ(\r±ú1TÅÄ8Î\u008bMbEÏ8.\u0018\u0083\u001ak\u0018Ã%±Æ1ÔÄªCcX\u0015«®\u0018Cíq\u000f1F¿\u0017\u0092l\u0088\u0011DÄóX&^ ÷Ö\u0011z\b½\u0088\u0095â%Ô\u008b\u0097QOkÖ\u0091\u009e\u0084Oÿ\u001a\u0001¯UáéÀ-Ö¼Ük±î!¯ÅÚW\u0090vM\u0088çuT¼õ\u001d±,Ö\u008c`Å$ÖõD×\u0087Náª\u009eòØ»¸¤ó$®\u001eÇ¦\u000fë³Ø\u009c\u009bÞV8Mmµ~\u0002meè& \u001d£y+\u00963\u0003âu(â(iÿ\u0006V\u0089ch\u0011o¢M¼åYPåKÏ[Ð\u0081Nì&Ý\u0004þ\u0088\u009b\u0002\u001d»I{Aß\u0095$¥&\u008b®Ã¨fy\u0013¸YPµZ<\u0089½=Lî\u00ad£3E/aóÅ;¨\u0012£PÅ\tO\u009cô\u0081\u0002q\u0082_P\u0081\u0090Ë<¡@8\u0010òv\u001eg\u0001\u008f\u0013þÔþp~ÿ®\u009c\u0092b/\u0011É$ÿÈD\u001eÆêi\u001aú¬%\u008a²¶\u008aû'¡ûRoo÷·Ý!@\u0084»^ãÖÐÑ\u009cå\u0007s\u001e¸»¸\u0007&p¯@Ç1D\u001b'ð\u0080ÀGhÞ^ß\u0090Å?¨û¨ÀÈÏ?ø0\u008f\u007f\u00818µªNâéI\u001cî\u0089¾0\u008e\u0017\u0019*\u008b\u0097¢¯eq4XE\u00ad,\u008eeñ\u0096ß\u007fç\u000bD©U\u001bô²81ÊÝ)¾×SR@¼\u008f¥â\u0014\u0005èGäæ\u008fé¦ÿ\t\u0086Äg8$>ÇÓô=\"¾¤3é+|'¾Æ÷â\u001bü ¾õxU½Pý1àµ\u0005'0\u008e\u0093Äì!\n×\t\n\u0088²JPb½\u0017øª\u0081|¢°7bõ\r\u008dÕ¡ê\u008aqL\u001e\u009få¯\u0011\u000f·Ìû\u007fÊûý\u0000\u001fÒ7æ%À0\u0091SF¯\u0087a|\fþ\u008bÆ0>\tñÍ{\u0018\u009f\u0082\u008f©a|\u0016\u008aü\u0002PK\u0007\bF{)6N\u0007\u0000\u0000M\u0014\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.class\u00ad\u0095[O\u0013A\u0014ÇÿÓ\u0096\u0096.[.\n¨(\u008a\nØ\u000b²â5\u0001E\u0011Á\u0018+\u0090`jâÛ´LÊ\u009aÝÙfv\u0081\u0098ø¢¯~\u0015\u001f$QH|ð\u0003ø¡\u008cgv\u0097Z /MIÓ\u009d9\u0093s~óßsiÿüýõ\u001bÀ\u001c\u001ef\u0090`xá©ºÅ\u001b¼¶-,\u0097ï\nií)Þh\beÕ\u001cÛZö\\\u0097Ë\u00ad²-Å\u0006W¾P\u0093olß·e}½\u0011Ø\u009e\\RõÍ\u0080\u0007\"\u0083\u0014Ã|\u0087¤h\tã\u0019Ò^\bdx^î\u0010\u0013)i\u0081-\u0010í±-í`\u0091a%ß=®PaH-{[Â@\u0012}&20\u0019\u009ev\f>\u008eÌ\u0082¡ßD\u000fÒ\f\u0003ÚkmÇ\u00ad\nõ\u0096W\u001dÊÆ¹²WãN\u0085+[Ûña*Ø¶}\u0086ÕN/n[1JÒ Ë?V\u0005Y*X\u008f\u0093?\u0092/\u007fà»Ür¸¬[\u009b\u0081¢°\u0085Â{\u0083´\u008e\u009a¸\u0080a\u0086^Û?rNrU×ROE0ä<y\u008c»Ý\u0086Ûæ¦îke`\u001c×2¸Êð¬[\u0096\u0089\t\\g0<IÎ\rGè.]Ìw¬ñ¸º$n\u009a\u0018Ãe\u0086>O®yò(A\u001bí\u0012ßÝUã¸e\"\u008f©ð\u0015¨ì;®\u0090\u0001U=|\u009f£È\u0015¹E\u0085Ìë\u0016ÿz\u0006£r6\u00adY¨è\u008e»\u00ad'\u00ad\u0097Ôoz;ª&Vm=\u0003£§\u0018³:o\fæ+)\u0085Zv¸ï\u000b?\u0083»\f³\u009di¡æo«\u0086aèÔ{RõZ,ê\u0013Ê!ý¤Ò0è\u0081¦]\u001a\t-\u009eN²d½$+Ak_\u0091\u001dÂ(\u0096~\"·Of\u0002\u0003ôì×¡ÌA\u000fsa0\u0089A:\u001b\u008dÜ1D@\u0084;\u008deô9\u008fá\u0018:\u001fCÓÅÒ\u0001F¾5yÚ\u000fLµpÒMN\u001a\u0017q)äP\u000bÆ\u009c×t¿\u0016\u009f+þ@î\u0000WJ3\u0007¸ñý\u0004n/ÄMD\u008eM\\.Æé]\u000fí\u0012´\u009fÄT\f~\u0012\u000bÌj0i\u009c>\týÔ¢1Û\u0084f\u009b\u001a\u000b(Æ¨G¡\u001d£Hã»ÿé3t8ûL\u008dò%Ä\u0099\u0091c\u0084£\u0083\fJ1d\u009a<\u0093QÂ\u000e1³\u007fB\u008c\u0013F'Âïlø´p\u0087Ö1\u008aaôgy\u000fz¢æp?¥\u0087x\u000e\u000fRÆ?PK\u0007\b\n\u0081ªï\u009a\u0002\u0000\u0000I\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classµU]O\u0013A\u0014=ÓÖ\u0016\u0096\u0095\u0016\u0004Ä/@¬BKe¡øIQC\u001a0&\r\u0092Ô4\u0081·év,KÚÝfv\u000búSü\u0005úà\u0083&¢F\u0012\u007f\u0080?Êx§,µI«ÍúñÒÙ;÷\u009esï\u009c¹wúíû\u0097¯\u0000\u0096ñ \u0086\u0010Ã\u0086#«\u0006opsO\u0018u~ lãPòFCHÃ¬YFÞ©×¹])X¶ØæÒ\u00152ù´áY\u008e½~È¥¿Sô¸'b\u00880¬\u0006¤êÀ3\f\u0099?ý\fK\u0085ßrµ\u0090\u0095\u000eÆ\u001cCÔÛ³ÜäR_lW\u001d\n»fÙ\u0096÷\u0090Á\u009c\u000f\n\u000eZhªÄ\u0010É;\u00151\b\u0086³:b\u0018Ð\u0010F\\Ç \u0012\f\u008f\u0082\u0016Ð©\"\u0091+ÖQ\u001dg\u0010e\u0088«¨\u00adf½,ä3^®\u0091¬£\u0005Çäµ\u0012\u0097\u0096²ýÍ\u0088\u0012\u008eáqÐÄ½;\u0081ÔLÔùË² Kz'1\fãó\u0085}~À\u008d\u001a·«FÑ\u0093\u0096]Í¥v5*ö¢\u008eK\u0098d\u0018°ÜÓà0\u0097UUk\u0017\u0082ºÄ±·\u001cû4p»\u0017ëßè§á*®Å0Ë°\u0018ìZu$q\u009dî\u0093W*\u001b/<ÉK¼Ö\u0014¿8vIÃ\u001cR1Ì÷ËÒU«\u008e4\u0016H*n\u009aÂmõúJà~MíÆp\u0093!\u001fP¥õç\u009e\u0090\u009b\u0096t½b³ì»5d`¨¾¥BÞü÷Á\tz¯½*&ñcÈ2äþ\u0084ë¤ë\\\u008d\u009eÎ[êÔ·\u0019\u001a}Ný\u008fNágn½\u001dZÑiJSlZjt'º\u0000\u008bªß\u0018ô'¶-d¾Æ]WÐl\u008fõ\u0012\u0083¢:Ù\u0089\u00ad÷DÓÔuX\u0091\u0019\u001aÚ0ý\u0081\u00840¦\u009e\u0019 \u0091P\u008f\u0018í\u0084\u0011!YÔP\u000f\u0091U \b\u0015\u0097H/\u001cAO³O\u0018Ng\u008e0ò¾\u0085=G¿ÃÊÏ¦ ±iÄÙ\fñ\u0001\u0013ä#\fÆé\u000b\u00ad/\u0095#D\u009cç1é3¯\u0092\u00ad¢¢é\u0085\u008f¸ð¶Í\u0017%?X²\u0083'Úæ\u0089â2®\u0090\u009fa\nÓ>Ï>q«¨lú\u0003F\u0088j\u0086Vý3n¼ÂÄ12;ÊR\u001eª|ñ5âÇXÞñÍ\u0095wí\u009c\u009ab`)\f°tGÞl;oÖÏ\u001bÂ\u009d\u0016æ.îÑ:KJeè\u0015¸O;Ë´®¶T\u009bC.¢4\u009bÃZDû\u0001PK\u0007\b»Ð=\u0086ª\u0002\u0000\u0000§\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000E\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.class¥T[O\u0013Q\u0010þ¦-¬\u0094r- à\u0005\u0015j[.]\u008a\u0088J\u0091\u008bU\u0093\u009a\u0006LjHôíPNÊ\u0092v·ÙÝâßð\u0087ðâ\u000b\u0018I\fÏþ\u001f£¾\u0018çl7 -\nÅ\u0087³3gvfÎÌw¾9_\u007f}þ\u0002 \u008dg\u001a\u0002\u0084\u0015Ë.é¢*\u008a;R¯\u0088=iêïmQ\u00adJ[/\u0096\r=kU*ÂÜÎ\u001b¦|-lGÚ\u0013\u001bU×°L¶W\u0085-\\ËÖ\u0010\"ôî\u008a=¡\u0097\u0085YÒ7¶veÑÕÐN\u0018ð¬5×(ë§þ\u0084ö%Ã4ÜeB0\u0091Ü$\u0084²Ö¶\f#\u0088Î\b4\\#ô¨ÓÖk\u0095-i¿\u0011[eIèÏ[EQÞ\u0014¶¡ö¾1äî\u0018\u000ea-ÿ\u009f\rd\bZÑÛqÒbâÒéêy2\u00adú'saD1¨a\u0080\u0090j-6\u0082!\\'\u0084KÒ\u00ad\u001b¸ý¾D2\u007f\nsAº\u0019\r#\u0084\u0017W\u0002¥àÚ\u0086Y:\u0085&\u008caÜP·r\u0093ðêòÈü3g&¹\u0019ÆmÜÑ0F\u0018ü\u0093!å2\u0013Gu\u0015Á]ÜczT\f\u0093°\u009aÈ\u009fç\u0094É\u009fG®\u008c\u000fÆ\u001fLd<&Î\u0010´^\u0090\u0086û\u0084õ\u0016;Ê\nGæLG\u009a\u008eá\u001a{²\u0019®\u0018\u0012\n®$¡Ð2\\\u0017$÷p\u008ba*\u0082^L\u0013â\u0089|cK\u0099fK2Çä¶¼{H\u0013f[åêIð\u001c\u008f\u001bßFZ\u008dbÓ!õ\u007fs\r5ùè7[Ô\u0000\u0010\u001eª>ú\bÏ¯H«\u0006`\b\u009d<\u0018\u0005«f\u0017åKC=\u000fCM\u0091)U\n¡£`\u0094LáÖÔ¸¿û[Á\r¼Zj\u0015¹eF%\u00923MigËÂq¤£a¹\u0085y¯\u0017L\u0018»\u0080\u0014LìF8¸óó\u0007\u000f³\u008cR\u0090W\u001b¿þ!\u0004ÔcË»\u000eÞé,\u0089eÛä!Â\u001fY\t Âßve¤oèb=Rw@7zX\u0092º<?ø\u0003'S)\u0017¦\u000eÐ\u007f\u0084á·t\u0088ÑO¸u\u008cñõé&Óbè\b1µ\u008fÏ\u008c\u0084\u000e0¹\u007frZ7\u0017\u0007ú\u008e(ý@\u009c~z§Î×3û§*m\u0006)¯\u0092\u0005.:Å\u0091Q\u008csci\u008e\u008d³Ï\u001ck¡Þ5®î\u0081_Ý\fÿá¼è\u009a\u009c:Ft\u009a×\u0001æ÷Ï¶È«Ë³p\u001c£²à\u0087ÆX\u0006|T\u001e\u009d\u008f\u008aú\u001dÄcO{\u0082EOf°Är\u0094í1<Å\nkÄr\u0095å0Ë5\u008cþ\u0006PK\u0007\bK\u0002\u0096\u0017Í\u0002\u0000\u0000\u0081\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000F\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.class¥RMoÓ@\u0010}ã¸Ië\u00864M¡|Ó\u001e@Jz¨Å\u0095V\u0015\u0010\u0081@\u008aÚJA9pÛ¸#w+{m\u00ad7\u0085?À\u000fê\t\u0089\u0003?\u0080\u001fU1ëF*\u0088^JVÚ}óF³ow\u009eæ×å\u008f\u009f\u0000^b»\u0085\u0080ðº°i¬J\u0095\u009cr\u009c«s6ñ\u0017«Ê\u0092m\u009cd:\u001e\u0016y®ÌÉH\u001b>V¶bûü¨tº0Wdì\u0094ã\u0016BB÷L\u009d«8S&\u008d\u008f¦g\u009c8Bs_\u001bí\u000e\b\u008dþ`B\b\u0087Å\tGh`¥\u008d%4\tk^ôp\u0096OÙ~RÓ\u008c\t½Q\u0091¨l¢¬ö|\u009e\fÝ©®\boG\u008bþs\u008fÐ)\u008c\u0084Ö\u001dòW÷Æ¦\u0084\u0083þà¶º\u007f+F\u0085\u0011¡YÎF:>î\u008f®m\u0018;«Mº· ~'e÷AU×o\u0088\u0099\u009fëgåf\u0099±\u0013\u0087Þõ\u0017÷f0\u0089@X\u0011åq1³\t¿×ÞûÍ\u007f®îú\u0006\tí\u008fÆ°\u001dfªª¸já1a÷v_ ¬ß0HÏ\b¯þß.Âê\u001f,Ü\u0096\u0086\u001að«\u0089À\u008f\u009cð\u0096°X\u0090\u0004\u0097v¾cùB\u0082\u0000Q]$Iú\u0086U\u0089ÛW\u0005\u0082wà§»\u0083µ\u001a»X¯±\u0087\u008d\u001aïú|×WÞ\u009b\u008b¿\u0010\fæâ\u009b7\u008b\u0007õ¾_\u009f\u000fðP°'\u0011á\u0011\u009e\u0084\u0011\u009e\nn\u0085ÑoPK\u0007\b\n \u0095Ò\u0094\u0001\u0000\u0000¥\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.class¥S]O\u0013Q\u0010=SZ¶¬k©\u0005\nø\u0089\nÒ.´+~àGÕ\u00071&&\u00044\u0098\u001a|ò²½)K¶»Íî\u0082ñ§ø\u000b|\u0095DJ¢\u0089?À¿dDçnW\u0004\u008a\u0089\u0086\u0087Þ\u009d{fÎÌ\u0099¹Óo{\u009f¿\u0002\u0098CMC\u008aPó\u0083¦%ÚÂ^\u0097VKlIÏz\u001b\u0088v[\u0006\u0096í:Ö\u0082ßj\t¯±èxò¹\bB\u0019L.·#Ç÷V¢Àñ\u009a\u001aÒ\u0084ü\u0086Ø\u0012\u0096+¼¦µ¼¶!í\u0088Ð'\u0082&¡°øÇÓ\u008d¯\u0011úý\u0098ÏÆ\u0003Çs¢G\u0084éRo\\/R®\u0013Ò\u000b~Cêè\u0083a \u008bÓ\\§T®\u000f\u00800h \u0083~e\u009d1 ¡\u009f\u0011¥xi³µ&\u0083\u0097bÍ\u0095J\u008do\u000b·.\u0002GÝ\u00130\u001d\u00ad;!ááâ\t\u0086ÀMå\u009a2zâ\u0084mW¼[\u0012-Î;\\*÷¶\u0090Å8!U©è8\u0087\u000b\u001aÎ\u001f\u001a]7ÆÀE\\\"èa$\u0082(|åDë\u0084\u0091cæS~\u00adá2aô¨ãñ¦ã6d c\u0002WÕ\u008c&ÿB¯«\u0088k\u0006¦Qâ\u0097P\u009dz\rBå¸Ð\u001e(©QS)L\u00033\u0018%d#¿ëÌ¢B n\u0091`\u0019(*_ã\u009fÞ÷D/ ú!ÜP\u001d\u000f°\u0018aÛ2\f'ç\b/J'Ë{Ü\u0006ë+þf`Ë§\u008eZ bO\u0086ª¢\u0010\u008cg\u009e'\u0083\u0005W\u0084¡\f5Ü#TÿO\t§8¨\u0085\u0087ÍûÎÿÛ\u0014\njÙÙ*¨Uço\u00861n\u009cý:ßVù¦â\u0006Í]\u009c2gv\u00903gw\u0090ßN¨\u008a\u0096æó\u0007\u009f{Lú\u0089\u001c\u0001C\u008cLti\u0018Æ\b\u0010[ª\fÅ\u0096*\u0094b\u009b\u001f4)ó\u0086£\u0095oÞü\u0084\\a¬\u0083³ï1þ\u0005\u0013«\u0085±]\\a0ßÁT\u0007å\u000f(Æèì!ôã¾\u009a¸\u0002õÅ\n\u008cnÆD\u0001©ÕJªYüU¾\u008cÙAõ(9{\u0080\u009cé\u0092óà\u0089\\OÈÓ,Uµ¬\u00993¬bnû0\u009d'1\u0014#Ègq\u0013·\u0012ÒÔ~E\u0016}¤\"¾ÿ¦ðïv|Îã\u000e\u007fõ\u0098t\u0017÷¡ÿ\u0002PK\u0007\b\u0016¤\u0018Óv\u0002\u0000\u0000f\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.class\u00adTMO\u0013A\u0018~fºeeY(ß\"ZPAh)v\u0005\u008c\u0097\u0012\u0012Ò¨©iÀ¤\u0086DoC\u0099´K¶³Íî\u0016\u007f\u000b\u009c¼y°\u0017/\u0090hb<û£\u008cïl+\b\u0085\u0090&f3;ï×¼ó<ÏÌî¯ßß~\u0000XÃº\tÎðÒ\u000fj\u008eh\u008aj]:\rq$\u0095ó1\u0010Í¦\f\u009cªç:E¿Ñ\u0010ê ì*ùV\u0004¡\f\u0016w\u009b\u0091ë«J\u0014¸ªFÙ¦\bDä\u0007&\f\u0086ÑCq$\u001cO¨\u009a³»\u007f(«\u0091\u0089\u0001\u0086É8Ú\u008a\\Ï¹¨g\u0018Øt\u0095\u001bm1$2Ù=\u0006£è\u001fH\u000b\t\fÙ0q\u0087!¥÷Üi5öeðNì{\u0092a¼ìW\u0085·'\u0002WûÝ \u0011ÕÝ\u0090áuù¿Ð(0\u0098ÕØ£ÖË\u0099ò\u0005¡Ne¡7\u0092-Y\u0098À\u0094\u0089ÉK\u0002t²6¦q\u0097¸zRÕ¢zÌµdâ\u001eÃN\u009fp\u008b\"\u0094%\u0015J\u0015º\u0091{$¯â¶0\u0083ûZ¸\u0007\f\u0095L¿ZÜÒ¼\u0090ÝÓýçl\u008cb\u008c\u0004òcéÖô\u0081ô¨q\u009e^'ÖaÝ\u000f\"ªc\u001fþ:ëWTí\\\u0093BoD«Ê0Çð¦o67\u009c¬&Á0Ä`UüVP\u0095¯\\}}¦{Öç5\u0016\u0086Á\u008a[S\"jé\u008b°y\u0013â+\u0097z³W\u008f-RÄ.)%\u0083¢'ÂP\u0086&\u001c\u0086|\u007f\u0094\u0018æo9\"\"r=m<#Ò\t\u001aIúä\rpým\u00917H\u009eC3£9¹r\u0006ë+\u0019\u001c6½\u0007t\u0090\u009b\u0018&Ûî\u0014`\u0004)\u009a\u0099>ÿîâ/ÔT·ÜÎ\u009dbÜø\u0004Óø\f#±µú¯÷ÂH\u001fÃ\u009a2N\u0090äíô\u00896\u008f\u00914Úß1ó\u009e\u009da6GÕéöùÆs\u0084\r|\u0010#ÜB\u009a\u000fa\u0089ÛÈð\u0011¬ñ\u00146øX\fèygÓ. mÍãa\fr\u001b\u008fÈâ\u0094ÙÀc,\u0010¼4\u0016éY\u00801ºMÀ\u009ft\u0081?¥L\u0082æá\u0095ÜOL¬Ò8ÅRû2{\u001aÃq\u0084Ö\u0011¨åîRÝ\u0082w\u0005Ë\\/\u0098N'\u0090\u008d\u00ad\u0015äây\u0095ö\u0004ÆÉ\u009aA\u009eÎc\u0096êóôû\u009dý\u0003PK\u0007\b7¤çy\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000@\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.class¥\u0093ÍnÓ@\u0014\u0085ÏMÜ:uS\u0092\u0006\u001aÊ\u007f¡\u007fI#b±%\u0015 E !Em¥TY°\u009b8£Ä\u0095=\u008eÆn\u0011ïÄ\u0086\rH,x\u0000\u001e\nqÇ\u000e\u00904Ù\u0094X\u009a¹sí{?\u009f3\u009aùùëû\u000f\u0000/pd#Gx\u0019é¡+ÆÂ\u001bI7\u0014WR¹\u001fµ\u0018\u008f¥v½ÀwÛQ\u0018\n5èøJ\u009e\t\u001dK½\u0097\u0085n\"\u0012iÃ\"\u0094/Ä\u0095p\u0003¡\u0086îiÿBz\taõØW~ò\u008a\u0090¯Õ{\u0004«\u001d\r¤\u0083<Ö\u008aXÁ*¡dp'\u0097a_êsÑ\u000f$¡Ò\u0089<\u0011ô\u0084öM>yi%#?&\u001cwþ_a\u008bõ\u0085âS_r¦\u0093ÓqâG\u008a°Uëü\u0013ÝM´¯\u0086\u00adú\u0007BÁ\u008f³\u0092\u0002*,þy³áà\u000eª6¶flf\u001dEÜE\u0089`\u0087\"aa¬3/ôÐ8\u0099C\u00136\"5#`´@À\u0002I75\u009eágí¯Gê$R\u007f~|¶Èù\u0092û\u001b©©\u0092·j@x][\u0006Yï9 ¬\u0011\u009cnt©=ùÎ7\u0087¡:×Ô4N\bÅ÷JIÝ\u000eD\u001cËØÆ>áÍ²Ûfã\u0090Ð¼\u0019\u0085°9ÇáÝ\u009fÊ¬\u001d¶\u0095\u0087yøâ\u0099\u009bÀ¹Í\u0099Ë\u00918®\u001c}Cá\u000b/rpx6\u009fAE¬óº\u0098\u0015pÜ\u0080¹t·PJAe\u008e\u0019¤Å]9\u0083nT6¿âöçk\u0098r\u008a©f%\u0019&]mã\u001e\u0088\u0081÷ñ \u0005?Ä#~OxüW]#Íy\\W¶=¥\u008c2dÙh|2iÜç\u0098\u009bØÚYl+\u0097\u008e§éü\f»\u001c+¼ÚÃ\u0001j\u00969\u0004\u0007¨[ÎoPK\u0007\bûtS\u0083ì\u0001\u0000\u0000°\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000M\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classÅU[O\u0013Q\u0010þ¦WX\u0016(H+â\r\u0015µ]\n\u000bÞ/\u0084H\b*\tA\u0012´\u000f¾\u001dÚ\u0093²Úî6Û-ðêÿñA\u0012.\u0089\u000fþ\u0000þ\u0001^\u001e|ñÅ\u0017ý\u0003Æ9Û\rT\n\u009a\u008a\u0089\u000fÝ\u0099sÎÌ73ßÌ9Ýùñö\u001d\u0080qÜ\u0089#Dxä¸ESTD~Y\u009ae±\"msÕ\u0015\u0095\u008atÍ|É2§\u009drYØ\u00859Ë\u0096\u000bÂ\u00adJwè\u0099ýÒvVí'\u0015ÏrìúÞ¢'<\u0019G\u0084ð E°&\u0014B´Z\u0097\u0013s-b5 Ü'\u0084\u0085[$ôÎ½\u0010+Â,\t»h.z®e\u0017ù¨#¿ïK\u0018û}\u001c\u001fµÐ\u0010\u008d\u0001b\u0013\u0096my\u0093\u0084WéfüVá\u008eSf&G\u0088L;\u0005©!\u008cn\u001d\u001dH\u0010fÒ\u00adB6u\u0081\u0081ÛÁìé\u0088£Mi}:Ú¡)-¥#\u008a\u0018¡[ùÏ×ÊKÒ}*\u0096JRqíäE)'\\K\u00ad\u0083Í\u0088·lU\t³\u00ad¦tÔ\u00941û]Eé=\u0016Õ)·X+KÛãV§3ÏyÛ±ÙÂõæå\u009a7¥z?\u0099Î\u001c\u0087[\u008d\u008b\u001dÔq\u0001ç\b\u009ac³q¥$Õ`òb?öÂ!\u0013p¬°\u00846\u0011 k¸\u0082t\u001cW\t£\u00adÍ\u0094\u008e\f\fB§(\u0014fÖ<WäD©Æ\u0089'\u000fË\u0095'hç?Oñ?\u009b\u008dLN5mDÝ\u0003\u009dû´èÔÜ¼|h©9L5Á\u008cª\u009a\tú¬mKwº$ªUY\u008dãÚ\u009fÈnÂ!ô\u001cò\u0016Þ$Üû{Jø\u008dúeÕ\u007fTÉ\u0018ä\u0082Ãü\u009a\u0087Ñ«î%k½êÎú\u0092o,Ë\u0018B\u008a\u000f¶ëäU\u0099W\u0011\u0096I\u0083¶Ñe\fo¢ÇÈnâ\u00841²\u0089ä:\u001f\u0084p\u0092¿)\u0006\u0003í\"Jï¡Ñ\u0007tÓGôÑ'ôó\u0099Q\u0007À)\f\u0000¾¦\u0002\u0092¯©\u0090!_SÉ\u0084y÷4Î\u0004¡³,\u0095U(òz/NLíÐg\u001fW¯\u009f\u0006¸\u0084³8\u0017x\u009a\u0081gÔØÂù7\u0007\u009c¿48G÷\u009c/âRà|\u0097eè(ç¯¾sªn°WQ\u0014C~E¤n\u007f\u00003É6*DÂØ`¶6Ð³\u0085Ë,\u0092û\u0088~åô\r\u001dô½!¥D\u001d5\u0001nÂp\u0080\u0095f\u0006\u0099_´\u0019ÃÙ\u0091md×\u000fdµëû\u0087üß¨ÿ51Ær\u0080\u0019\ró\u001f÷õ\u0088\u0086\u001b,oEÔ¼\u008fã6´\u009fPK\u0007\bO<êÑÇ\u0002\u0000\u0000Õ\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.class¥Z\u000b|TÕ\u0099ÿ\u007fÉdîÌä\n!\u0098È H\u0004\"!ä¡(¨I\u0000C\u0000\u008d\u0090\u0080\u008dB\u0003\u0082Ü$7ÉÀd&ÎL\u0080ø~ Ò*P\u00ad\u0015\u0082ÖÊ¶6µZ\u0015\u0095\u0084\u0098\n\u0096Z+îv·»Ýn]ÝG©înÕ\u00ad}¸îÚÕ\u0085ý\u009f;w^É \føû\u0099sï9ßû|ßÿ|ç\u000eo\u001e{ù \u0080\u008bd¯\u0086,AE0ÔQit\u001b\u00ad\u009dfe\u0097±É\fTn\u000e\u0019ÝÝf¨²Õï«¬\u000bvu\u0019\u0081¶e¾\u0080¹Â\b\u0085Í\u0090\u0006\u0087 o\u0083±É¨ô\u001b\u0081\u008eÊå-\u001bÌÖ\u0088`l°;â\u000b\u0006Â\u000b{\u009b\"!_ \u00833Ë,ª\u009e\u0088Ï_Ù`tW\u000bÜM¾\u008e\u0080\u0011é\t\u0099\u0082¦ÔÕ\u009ae\t\u0091Q\u0001ÕËNÕ°å\u0096æêùÔ0Îðû\u0083\u009b\u001b|[Ì¶èlX «\u0005ã\u00adùë\u0002\u001b\u0003ÁÍ\u0081øJ~\u009bÙ\u001d2[\rõº\u0082:#fHP\u0010µÄ\u0017¬´¦V\u0085|\u009c¦èñÓ\u008d0ý·X\u0017ùÂF\u008bßl\u0013¸jhLÀ\u0017\u0099/È.\u0099¹Rà¨\u000b¶\u0099\u001e\u008cG\u0081\u0086³\u0019\u0084\u0084[u~\nÐQ\u0088s\u0004\u0085mfØ\u00172Ûjc\"\u009b\"\u008cKØ\u0012²Ú\r\u0081WÇ\u0018xT\u0010é`cOW\u008b\u0019ºV©¤ÑË\u0082\u00ad\u0086\u007f¥\u0011ò©w{ÒYc\u0019¡á<ÁÄ\u0098ýË{\"Ý=\u0011FÓ4º¢n¸Q\u0084©\u001aÎOÙÁ¦ÞpÄìÒ1\rÓ©?Ø\u0013\u0019\u0015\u0083¨\u0088j\u000f&ã\u0002\u001d\u00930\u0083ö\u0095,K§¦zæJ\u000f\u00ad\u009f©¨J\u0019³\u0004\u0095\u001dG+D\u0091N\u001f]½ð\u009478\u009ayÔ\u009f\u008d\n%9OÃ\u0085ÜëD\u0002]e\u0084;\u0099D\u001eT¢BEïb\u001d9pj\u0098C\u0013Òì¦\u0007\u0097`¦¢»L\u0087\u008e³\u0018\u008d\u0091f\nrº\u0095RÁâ\u00925£Ssæ\u0017\u009bnÙÛ\u0096ä\u0000åy\u0016oi5£\u0089§\u0081Ùrù©:_\u001bêèé2\u0003\u00918¿\u0007W`¡\u0086ÚØ&Z\u0011¨\r\u0085\u008c^fW\u001d\u00161\u001b\u008cð2_\u0098ûX\u009cb|´Ti|\u0082M\u0091U«\u001d[¢£\nWr,Ib¨g(T~\u009d\u008e¿¹\u00ad\u0089WîB\u009a \nV§S\u0096\u0006\tægn\u0080\u0086e'\u0083¶QL\u001a\u001aGeU\u0093\u0019ÉÅ\n|IÃ5\u0082³R KG\u0013®e°7\u0019þ\u001e\u0093ù<¡$9²uA¿\u009fÑVÀäA\u0003Vª¼]\u0095¨\u009b\u00914ªn\u0096¢YQ\u0011®ÎI¿\u000b+5\\/X\u0094YÙL_h¶\u0007Cæ\u0012_(\u001ciêi±×=X\u0083uJÛ\r\u0082§J2\u00adÄLw#CùéM¦ÿ¹0Ðª¡\u0085(8:>:ÚÀTs©\u00026\"AByaÊ\u008eÔÛóÕ¹è\u0080OCgLJÊª\u008e\rØH\u008c\n\u0098[X@gÇ$$\u0017\u0090\u0086®T\u0000µ²Ô\u0083 nÔÐ-¨ÊÐÛè N\u0000ú\u0010\u0002S)¯Ëèm19\u0013\u008aD\u000f+BrI\u001a\u0018ZíB\u008f «¼Ü\u0003?6ëØ\u0082^&¤yc\u008fá\u000f\u008f`\u0089\u0015ÿj\r7\u000bª34±¶\u009dá±ÏM\u000fnÂ\u00ad*un\u0013t\u009f$uÎ<\u0015\u009253\u0003\\¸C \u0095\u0097¯Y7oí,åõ]:îV!Óº\u008c\be\u0086ÕÜ=:îÅ}ì7Â=-a»\u001b)(©\u009f9:\u0082jÓ¾¢ã«¸\u009fÕm\u009dÂ\u0089\u0088w¦\u0089xÆGÁh\u0087¢â\u0093ö\u009cFlÇN\r;\u0004W\u009c©,\u001d_Ã\u0083\u00821¶+\u008dLb\u009e\u001f\u0082ù%\u0019Û\u0099l¡\u000b_ç\tfG}^E©\nò7t<\u0082]\f¼/ÐfnYÞÎ\u009aa\u0088ëÕR\u009f\u008aÿ\u001eU\u007fõé\u0083¾\u001d\u008féø&\u001e§Ð` vÀ\tV¤Ëñ3³û\t\u0002\u0082e6\u00advá/Tî¬YW¾¶¢TÃw\bÙ\tuñNlq(\u0014d\u0087ðmT(àï×ñ=UT<Î\u0002\u0011Ã\u0017\b/5{5|\u009f\u0010=ÒÒ\u0085=>\u007f\u009b\u0019rá\u0019¶\u009c,È§ð¬*\u0092çNPº+\u0015Å>\u001d/àEu`Ó¡\u0000ÛÉò´\u00118\u0081ªj%b¿\u008e\u0001\fÒËH0Öx§\u0082VRÐ\u0087t¼¬ºÏ1\u001df\u0084\u0087[,ðjé\u0087:^Q\u0099Ãý`H»ýfÄT;yHÇ«ø\u0011\rô\u009b\u0081\u008eH§Õ\u009fÖ«ÎéÇ:ráQåó\u0013\u001d¯«\u009dÌ\r\u0006\u001a\u0083vo\u00ad\u0010ö\r\u001dG\u00942\u00adÓ\b«<T´\u007f©ã¯\u0090G|³´Ä6n±òüìt'\u001e\u008fãî\u0091\brÒÆ1m÷e\u0089±\u0092BPs&)Å\u0010\u0018ª¢òÓ54zÔÚ\u0018\u0082,<slPp\u001eh³jXêù\u0012´EkÑ\u0087\u008b8í#ÐEßh\u0007\u008b.õ~ÐÛ\u001d»#\u009cr³%\u0098\u0092¸Fñüµ;¹pm q©\u009a\u009d1 T«´9ªÃ\u00ad®5\u009enÕ\u008d_\u00176:ÌDO\u0014\u00adC«\u0012âýÎ¿Å:xë\u0090^\u0012\f\u0011æ\u00ad\u000eþ=ü\u0087*¯w5¼\u009fÒ´]\u001b2M6m\u001a>\u0014,8\u00adð«ü7¬^À\u0083\u000fð;¥å#v]\u00996I£¤Y5ÿ[üA\tüã¨N0\u0089*\u0017\u001fã\u0013\rÿ\u0095ÒpÒ'\u001dÿ\u008dÿQ`ÑÖVë÷\u007fA/É3þÏ1\u0084²ÛüÀF³-~KúTaÛÇª\u0093ú¿\fîÿQ\u007f4\u001cç¥è´B\u0011M°äð\u001e\u0013a4$Kpõi\u0086w¤L+È\u009f\u008bC\u0097\u001cq2Ï\u0088tñ\u009c\u001d\u0097Ò\u000e2 Õ\u009a¸RòËºE©;\u0091G4ÆHrå,Mt\u0002fê\u008dI\u00971êLÈæF¸\u0084p\u0096UVÄ;\u0094äë2^xçwl\búX¢5'Ø\u009eSAøjåD¡.ç(hWp½È\f·\u0086|\u0096'.ñ\n\u0088¾+ä\\]&Éd\u001aÒ\u00ad.í\u0097¥i÷NxûK\u009eR¢¦èR¤\u0002æÜhö22\u001e\u0099*Ó5\u0099\u0016sÝ\"o0\"\u009dº\u0014Ë\u0005ÔØelá\u001dY\u009dïõ\u008a½D\u0097\u0099\u008aÝÅã$¤\u0004h2+%²Ì»é\u008bÕZ®\u0094J¹.\u0015ªÉvÑ±\u0095êöä\u0012Þç\u001dÅáâ\u0080Z\u009e\u00adËÅjÙÉe\u001e·¬u\u0099£Ë\\¹\u0094Sí\u0016\u0002$\u0082\u009b\u001c³\u0093ÜuãàQí\u0092Ë¹iÅê\u0090\u0096j\u001eÁR#\u0098\u0094®?\u008c\u001d´.á\u008d]\u000b\u0017\u0015)\u0013\u0095=WèR«\u000e²\u009cv\u007fO¸S\u0081nZ\u0004#2·Ç´Æ¿ª\u008c0Fuk!*Iúb5vD\u009aR\u008f\u009f\u0089\u009fÑ7\u0013û£\u0018\u000fÖ\u0014éQ¿\u0094\u008eî\u0090Ùn\u0001|l&oäw\u0001\u009egÁ$&î:\u0093\u0083¶X\u0017^\u008eÖ^§º\u0015ßf2×¦zqê§nÒ÷¼9'ÿJ\u0098ö\u0000\u009b6RwZªé#<>\u0001Yu:\u0007OÙ\u0094\u0005éa ¦tþ©!\u0081&_f~\u008dÎÌöv\u001e\u0083²JÁÔ\u001aB¹\\Ï\u00adN§\u00884²N%9oúe§Ø^*ÙÖç¶ýJÃ~Ö]¤3\u009a$\u0085é1MÝµL\u001b\u0082IÝbI`\u007f}\"ÙªrÔí\u009e£%9µ\u009f²\u008b\u0097'Ü\tCwz\u001fæF'\u0099&¼ËOMj\u008c¨¤Ãð\u008fúèæ\u0092 Û¢(SÑ\u008câð\u008c\"_¸Èð\u0087L£\u00ad·¨\u008d\u0095\u00140Û*Ø1Ë\u008d\n©èúå\u0019\u0001T\nô\u008b\u001fÏ*Q=ºlRW[OXÝåÂ«|\u0091N\u0097\u0010v«ê\u008c@ \u0018)âñS\u0014L²È E\u0081ØLk\u0094Æb-ÚLÖ¢\u0019å3háçh\u008ew\u008f\u0094í2Z[Ípx:ñ÷â\u008c?\u0003Í\\\u009d\u0010ÀN´6s\u0001£~\"\u0088\u0089\u009b\u009dx¼XpåéJ\u001eõ\u0015ßÓ\u0014ì\tµ\u009aK|ª#.\u001cÅW¡¸\u0088{õ\u0081\u0080\u0019²>Ø+ÔÍ±*^\u0093û\u0004u§óùbÄ\u0087,\u0016júi=ùc\u0007\u00815íg0M\u001e\u00104fhF\u009d\u00116ë\u0003a3\u0010öE|\u009bÌ\u0091]\u0013Sû$\u0014\u009aìÌ¼í[\u009aøµ%éNÃ¸§_Ðä¡Ì¿n6øÂaZ\u001a\u0015Æ²µU\u0014¤\u009d×ä\u001b§Û¼Ön6Bfª\u0017'ZÈ\u001bÙù³õLãì\u009eÌ?Ã-O9\u008eõÔ×Âô\u001d1oæ)j¿ÅrÊPmÊïf)®N8Ñ\u0012Îçm/\u001b@\u000e²Ôo1|Óø\u0096\u0005\u0017ÿç\u0015ÐzÎµÆ|õ\u001b\f\u00907AýâÅ÷1¤\u0019\u008b<r\u008cS?SrTÿ\u008dË\u0097\u0001äï\u0081æè\u0087#ûELØg\u0089\u0098È¿N\u008b¤\nçZ3àÛ¤8û<8¬Õ±¥Ã\u0098Üü\u0002¦\f¢x\u0010%\tf\u008fÅ²\u0088Z\u0017[\u0002ô(9f¡Ì\u0016Uj\u008bº\u009e¢\u0014í¤ÒA\u0094S\\eó .Ú\u008fÙ|¼¤yÖ æîÇ¥\t¹ù¤\u0006®äßjJ»\u008a²ë-ù\u0085Q\u0019¶|õ¤ãrj¸\u0093\u000eTs\u00ad\u0086sÊäy¶ùY\u0016½»tÖ\u0001,\u0018ÀâçGxÝ\u0094$Ô\u001d\u0017ê¦Âz®\u008búQ\u0087Û\u0090\u0010\u001aÝ\u0084«\u0095ðì\u009dÜ\u0098\\úøÙ0\u00966\u000f£¡¹ô%Ì\u001eÂrÁ ®\u001bÄ\u0097\u001b\u0086±¦¹´L\u0006±¶qÖ\u0010ÖSZN¿¼êÍ\u0019B»àUø«\u001cå^Ç\u0000\u0002}ò\u001d¯#?2\u0080M}È\u001bÆMÍ\u008aç\u0096Æ~y\u0098Ó·\u000fàÎ>L$¥×\u00913\u0080\u00ad\u0003ØVåô:\u0007ð\u0000\tÂ$xÈ\"¨ð:òæ\ràá¹Î(e\u0001)v+ZÍ«y\u001d\u0005NÇz\u008b÷Q2Í'Ó·,¦ó-Z%v·-ÖëpÆé\n_À\u0084=( õ^RïAî0¾Í={ò\u0010YHTåTþz\u009dCøn\u0016úP¨d9m\u008d\u0096uø¥-»J³(5\u009bòæòa<Õ\u009cÿô ~ (\u009f\u001fÀKjÜVåòº\u0006p \u000fù^WÌWÚ\u0081\u001djz¸1g®»\u009fR\u001c\u0005î\u0002·òfw\u0095'I\u0090Ç\u0016ä\u0089\u000b\u001anÜê\u0096\u0002·\u008aðÁ½ÇßìÇ\u0012Zq8ÙP\u009b¬\u001fe_h\u0091¢ðX;õZ£Ú¼\u009f\nö\u001c«)\u001fÀ\u009be*\u009d²\u00adt:\u0088Jþ]\u0087\t¸\u0001Ó°\u009e\u0089c \u000e-h@+V¡Mý¶\u0082\u0010Ú±\u0005\u001d¸\u0007\u009dØ\u0001\u001f\u001eÇ\u0006ü\u0000\u001bñ2ü8\u0082.ü\u0012\u0001¼\u0085 þ\u0080n|\u008a\u001bÅ\u0089\u0090ä±\u0083)DD¼è\u0091©Ø,\u0017b\u008bÔóö|\rn\u0092µ¸YÖã\u0016iÇ\u00adìyn\u0093^Ü.\u000fá\u000eÙÍ÷'q·|\u000f[å9Ü+C¸O\u000ea\u009b\u001cÆýò\u000e\u001e\u0090£xPÞÃCò!sò\u0013<\"\u007fÆ.«\f\u009eQi-\u009fÅÊ\u0080OWágLû\tò.þ\u001a\u007fÃÄ\u009f&oáçø[ú\\%ûðwø\u0005Ë\"ÄRú{Úî¤OSð\u000fø\u0015\u009f\u001egÍª9\u008d~éöê§x\u009fÞý\u0002Nú\u0014åÐèÑ!ü#ç4út\u00835ç¢µnûé\u001d\u009bÎ%>\u0096àÛ\u0094ì¦\u008fSð\u000e9<ø§\u0018ÚXvþ³U®ÿ\u0082\u007fµÑf\u000e\u00adU\u0005®\u0095:öã×¥\u0089º\u008f\u0002Ö£¬ÝÇ\u0092\u0000K\u008b\u0003Vnz\u0011\u0087G\u0089x\u0082\"ö¦\u0015ñ\u001b¼\u001b\u0015\u0091=\u008b\u001e(\u008882\u008c÷\u0014Æý;1á·Ä\u008a\u000f\u009aYáÿ9\u0088ß7\u0096ÇAc\b\u007fÊÂªa|Ê\u001aû_BÃ\u0010>#b8ûñ\u0013Uc\u0016b|^\u0095\u0013å?F~\u00053¿·Ê;g@²mnÑ\u009a\u0007ÅÍ¼Õ¢ì\u009e~4x=qÀq{Ý¬\u0006Ç\u0013\u0098âu%RÞ\u001dMù!ñPD?&Ùk\u0091QkJ\u0092ÊþãÏy]ãeì\u0001\u0019G\u0089Ô^Påñz^G®ª¾\u0083{Àµ\t\u009cqxÝd\u0090\u0089ÙdtÚ\u008c\u0097fÏÍñ:\u0086ä<å¯2PëÇ¹ÊXÛ@gA\u008eªÍ\u0083\u0007ä|\u0012j6×QÅ2#\u0089¥+Æ\"¥\nµ\u0086¤Ìb·´O*\u001b/\u0095\u008eW\u0090Ý\u009c\u00adVØX7\rÈ%ôë²2åÖx¹\u008c~\u0015Ðêªñ2/ê]N\nu³Ã\u0096hñÅ\u008dØY6 \u000böÅ\u000bþ.\u0014ñï÷\u0099¬OÃËÒ\u0099ÉR\u009e\u008dgyn<\u0087Õx\u009ee¾\u008feü\u0002¶áE<\u0088\u0097H¹\u009f\u0014\u0003x\u009ds?gÉ¿\u008da\u001cÅ\u000fñ\u0011^ÁÇ4þ8\u009e\u00157\u000e\u008b\u008e\u001fËL¼&s8.Àër=µûñ\u0086Ü\u0085#r\u000fÞ\u0094\u00979÷\u001a~&o°$UòíàÑË\u0004\u008b\u0017í\u0011\u0016éB¦\u009f[^\u0095:YÄTõÊó²X\u0096ÐîÙ²K®dJ:hå\u0000Þ\u0092«\u0098Â«ñ¤ÔsU£µ;åjYÊöa\u001bæË2\u0016\u0099\u009bV\u0016K\u0083õt\u0014çI£*<Zø\u008a\u0014³\u0018sh§n\u0015£\u0093V®\u0093å²\u0082²UY^B¹Q\u00ad×Ä´Ê\u0097¨5ª«)®ëZ\u0096v\u0094ó:rzÔç?Úk\u009d±²ÒªÁ_ñÝÉqé°¬bf778æÏú)4&Ø²Ò!õ/\u0093x¤bª}¤V9&ï\u0081»lÖ\u0080¬]UF¼\u0096õê){~\f´\u008f¿Í-4\u0012\u0098]¡j\u0093hæ\"\u0092y\u00884c\u00885ùÄ¨\u000b\u0088I¥týB:SEd©áÜ\u0012ÂÂ¹¶k4GZ¤Õj\u0015\u0096J\u001b\u0003ÀÛ\u0016êÄ$\u0012gQR\u00adt@Ýþ/@¡t\u0012»\u001c\t¬²87p¼\u0093áß\u0018E\t\u0019O\u0097\u0095\u0093}³\u009a«r\u000eÎudÏWU\u009b3yv\u0083\u0002\u00872ûØô\u000e\u008b\u009fÙ\u001b\u0088¦vYÓ\u0001é\u001e\u0094ð¡²ü§\u0007$\u0012_Þ<byk¶L.pì=þâ0>oVMÐ ô6\u0094Y\u0080¡j\u0089ÝàD\u0016\u0097]~\u008dJ_y\u0099]³\u000e;j¿)K@_4dïÓì\u000fp\u001e>d8~Ç®è#öQï³Áû#\u000f¶?Ñµ\u008f±\u009dã.|\u0092\u0014²¾xwÕ'7YÝÕ8,´\u000e\u0084,r]dec\u0016y£\u0019\u0095\u009dç\u0092\u009bå\u0016\u001b\u0089\u008b-pg3Lû~ýÌ\u0088\u0016n^¬q%Ë\u00adr[\u001a\u0096Ù#»¾ê$\u0096ÛÓj9<RË\u0082$\u0096;äÎ4,\u0097\u008eÔR\u001bï¨³X½êïÝ²\u0095c\bc¤\u0014+ä\u001e§[î\u0085È6ÒÜÄñ+PÿªDä«¤¼\u009fãvL\u0094\u001d\u001c¿Æ÷\u00079~\u009d\u0015ò0ÇG\u001cY\u008c¾È.êÚÎq·Ã#}\u001c\u001f%ÿ1\u008e\u008fq>Èñ\u009b\u009c\u007f\u009cã\u0013ðü?PK\u0007\b5Øûü²\u0010\u0000\u0000´(\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.class\u00adVi{\u0013×\u0015~¯\u0016ËÈ\u0083Á\u008e1(\tF`À²\u0090-¶\u0090`\u001b·¶\u0083\u0083©\u0017\u008a©]\u0013Òd\u0090\u0006y\u0088¬\u0011£\u0091\u0083³µMÛìk\u0097,t_é\u0007>$ÏS \u0094§Ë·>Oû\u001f\u009aoù\u0019iß{g$KÖ8\t4_4w9÷Ü÷¼ç=G÷_\u009fþåo\u0000\u000eà\u008f\u0011\u0004\u0004ú-;\u0097Ö\u008bzfÑH/éËF!ý\u0094\u00ad\u0017\u008b\u0086\u009dÎäÍô)Ý.\u0019Ù1kiI/d'Í\u0082\u0011AH`óE}YOçõB.=sþ¢\u0091q\u00046YEÇ´\n¥Ñ\u0095YÇ6\u000b9®L*«²cæÓSzqP`Ã¬\u0099+èNÙ6\u0004\u0016êw\u0087&W]º\u000e\u0006'ï\fØ\u008cº\u007fp\u0098÷´\u0016m£d\u0014\u001cw©T\u000feÖphÒ]¿âs½rd\\vl}ÄÎ\u0095\u0097è\u008e\u008e6×\u001c\u009b4KÒÓî5Kë¸j\u001a2\u000b¦3,°5Qc0á\u0018¶~>o\föÎ\tLøí\f}6\r~\u0004H_¡1+kD\u0011D\u0087\u0086MØ\"\u0010LôÎE°U m\u0015î\t½´Hî£èDÇ\u0006\bÜ«!\u008c¦\bîo°\"EQÜçZíÐ°\u0001Ñ\bv\nÜ³j5bÛú\u008a\u008c?\u008a¸k·[\u0083\u0086\u008d-Ø\u008bD\u0004=\u0002í\u008dÁièER Ù\u0094sÇ²\u0005:\u0013½5|Nxë\u0083-H¡?\u0082¾\u008a\u0097º]\riìgÈ\u0005fK £â¡F\u009e\u0083\u0011\u001cü<¥70\u0019Áa\u0081Ãw#Â(\u000e¡#Ê\n{PÃC8*\u0010Í\u0019«bl«\u000bQÊ±\u0005\u0083\u0092£!\u0081\u008du\u001b\u0011\f×Õ\u009a+§\u0016|\u0015£\u0011\u008cÔY3\u008d\u001aÆð0\u0013],\u0093\u0085\u0087\u0012\u008d$4®ø0%\u0099\u001e×ð\bN\bD\u0016õÒ´\"\u0095ê9+Ë\u0088!N\u0097\u0097Î\u001bö\u0019\u0099>fcÒÊèù9Ý6åÜ[\f9\u008b&ãÜ\u007f\u0087\u0005Ì\"\u0089X\u0015\u0092:ü\u008a\u0084Uä\u001a|®óÆ²\u0010Ð\u008aêÆ\u0019ÏÃ\u0091»ë/ìb.\u0006&CÆßPìÔp=)+Å\n1ã_N}³`\u001c«Òeëåîah\u0006³µÃ#s ¾§\u0094\u008a×w2¹\u0016e\u008d\u009eÓð\u0018¾En.\u0095-Ç\u0018)dOZ&¹Iø÷¨Æ\u008b¢8\u0086'4è8ÏÜ\\°ì%\u009db9\u009ah4|ô³ÅWånÈ¿\u0007ú´T\u009fã\u0011\u0090ä\u00adk\u0097GËf>kØQdÑÑ\u008cE\u0081@*.'\u00175<\u0089<qK¶\u000bY\u0081>\u001fÜ\u008d·xîÈ1\u0089\u0012=Ò\u0013Ko\u001eß¤|KÊ¢$uZvT\u001dÆÖ=Os³4nÚ%Z\t¦«©äeô\u000b3@)²@+zÞâ\u0087þ¬Lò3\u001afð¬ÀIßøîª\ndÇz^Ã·ñ\u001d\u008a1c\u0015\u001cÝ\u0094U»Å§ëÈÆ¡\u0011çHa¥\u00025\u0096¨i\u0080cV>O;éU\u009aöùïùKàl\u000b~ ;ç\u008b¬\u0003¿S2ú\u00975\\Æ\n\u009bWÞÊM\u001aËF¾Ú\u0088;ýQ\b$¿8\u0004Ù\u008cßÐð&Þb\u0093d\u0097\u0017ØëÇ\u0081ß?Ò;\u0002»j2Íkrz¾R¡Ç/g\f\u0085³\u0019?\u0012Øæb\u008e÷ì)õÄ\u000b\u0096\u0013Ï\u001a\u0017\u0098\u008cl\u007f\u0014oã'ò\u001fþÝu\u0004À§@\u001ba\u001d_ó\u008ei¯û\u000fò^2{\u001b\u0016×\u0091ÝF=\u009bU\u001eçô|ÙhÁÏð\u008b\b~ÎçRýi\r¿\u0094ú\bÒZ ¼,m)YÎ*:xÚ\u0007ñ\u009d¶ÃÿCÀ¿Óð{¼ \u001b@6;\u0092g'\u0088ÎZe;c\u008c\u009b²Yw6\u001cí\u0097`±\u0093\u009a\nòý\u001cD»|-q\u0016á,\u0080fÎù.ªÎ[8çû§:oå.\u0098©Í\u001c»+m´\u0080\u0090\u008f49\u007f>y\u0013÷$o£sá&¶]G\u008cÃû8Ü~\u001d]\u001cÆ9Üu\u001dÝûna\u008fÀôU\u009cè»\u0085}\u0002ÿÀ\u0081©Û8ÄÝ\u0007\u0006B©\u001b8r\u000b\u0003\u0002\u0003MW±=ÖäY\u001c\u001b\b'ÿ\u0084X,\u001c\u000bÝÂW\u0082\u0098\u0097;Ç\u0005®ü÷ã>opý#\u0015Ñ\u0004\u007fû\u0089\u001c\u008c2Ä÷Þ&lÇ½Ø\u0081=Ø\u0085£èÆ(vã\u001cg\u0017ùu¸ö\u001c\u00128IëÃd\u0082\u0011àk\u0098\u0004Ôh\nÓ\u008cü(Y\u009eÁ)Æ:\u008a\u0083ø:NÓë921\u008b3<ñ\rZj´ríç8\u0012²\u008fò\u0097¼Ðo\u0093Ú\u008b·/\u0084ÿ\u008aàB0É ºnâÑÙ\u0085\u0090\u001cvËá\u009fñø\u0087\u008aK\u0089ÜµO)D®ß¸\u0087( ÿåª¼g\u0094ÿÿpÔÄïéÛÈ\u0092¾\u000bS¡a\u0097Ü\u0081ðU\u001c\u0088\u0085«ä\u0085¶_A4Õ\u009e»\u0001s>Õ¾¤>±PÍ,8,\u00ad\u0015\u008fÿf\n¬\u000f×p¹\u009fÚ8@e\u001c$«\u0087ÈÞab<ÂÑ\u0083\u0018àóp\u0084,\u008dqo\u008a\\\u00adryºÊåi\\R\\6s×F\u0089¨£8AöË¼c's°L.C5\\Jû§\u0014\u0097l{\u001e\u0097\u0013<\u0015à·-¹ï\u0006\u009e\u009e\u0097D2Öç\u0002¸V%/ª\f\u008e\u0093\u0092q\u0005£Ó=P\u0085ÑÆD\u009eQn¿\u008b\u0017ªT~O¹\u007f\u0085£\u0010¿½tú}¥Î\u00ad\u0015u\u001e\u009bJ\u0092\u0092\u0097>@8t\u00ad\"¶O\u0082×ª\fuªhO¡\u0083ê¸\u009fØ»8îa4'Uöd\u009dõV!ôò¢W\t \u0083`%\u0098@MÔrï5\u0005\u008f\u007fu^Ô%\u0082T\u001e¤ú\tíõ\u0000\u0001\u001d\u009aJý\u0013Ûnãí\u0085ö\u001f\u0086\u0094®öI\u0015ÝÄ\u008fÿ\u009eZ\u0095R»\u008açqJõ\t\u008euBÊ¬\u0003Ée¥\u0095Å\"å\u001dàø=¼_åç\u0003\u0005$\u00ad\u0080\u0001²\f»×ê5W£×pÕñ\u0015¼ëEñ°\u0097;M\u001ef\u0014?\r`þ£5i{\u0092:Ë×¤M«úÑð+\u0005\u0010ø5~ãy,xéêªãeZªÂí ¿å\u0015}«8[UÐ\u0016¿Eæè\u0092º'éz¨ÞÓ¥jZ¨\u0091[ñ\u00adìt\u0092\u0092 Wÿ |]ý\u001fPK\u0007\b\u0088!ç@ë\u0006\u0000\u0000z\u0010\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000:\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.class\u009dS]O\u0013A\u0014=Ó\u0096n)K\u0081\u0002U¾¤\bB[´+\u008aõ£\u0015EÄ\u0084¤\u0011\u0093\u009a\u001ax\u001bÚI»d»m¶[\u0014ÿ\u0089>\u009bøâ\u0083&*A\u0012õÙ\u001fe¼³»´\u0085\u0086\u0017_vvîÜ{î¹gÎüùûã'\u0080\u0015¬+ð1¬Ö\u00ad\u008aÆ\u001b¼T\u0015Z\u008d\u001f\bS{mñFCXZÉÐµ\u0017Üj\u008aòF½Vãf9¯\u009bb»aëuSA\u0080ax\u009f\u001fpÍàfEÛÞÛ\u0017%\u009b!xÀ\u008d\u0096hÒYÞ9lÙº¡åõ¦\u009deè/è\u0015\u0093Û-K0,\u009c;Îå;X\u0005ÛÒÍJv\u008dJ\u00829ÝÔí5\u0006\u007f\"Yd\blÔË\"\f?\u0006Uô#¬`\u0088a´\u0003´nYüP¢\u0085\u0011Á`?\u0018¢*ú\u0010d\u0018\u0092Ì\u009f·j{ÂzÉ÷\f\"\u0010Í×KÜ(rK\u0097{/\u0018°«:qÏäÿG\u0012¢\u001bª\b»(\u0005`\u0018K${G\n\u0013¥I\u0015S\u0098¦Ü*oz¹4Ü®\u0082+\f³\u009d\u008a-Ã\u0010\u0015n\u0014ln\u008bÍ7%á´\b!NIn»x¹.\u009aq³nÇ«Ä0ÎÍÃ¸£}:\u008c\u0019\\\u0095úÌ3\u008c'zI$\u008b\u0003¸\u0086%\u0005\u008b\f\u0091³· \"\u0081$ÉÐÔßº´¶BXf\u0098ò:\u0012ãx\u00adeØzÃ\u0010n³fZbÝP\u0091\u0086F\u00054¾ì¹Õ=ºë\u008c¬\u0082\u00953\u0086qÉ\u0090)N%#Ý£§\u009au»f±'x\u0081W\u0006x¹¼nUZ5aÚ\u0092Õ]\u0015÷p\u009fXQü\u009c\u0012\u001e§ä.]\u0003÷J¤%zp%ÎC\u0015kòÂ\u0014½¹YkØ\u0087\fáB½e\u0095Ä3]zfú\u0002;¤%\u0018æèÆýôØ\b]:\u0091V\u0085v>\u0084hÇ¤\u0087é;@\u0091'\u0094Åh\u001dN\u001dAM\u009d ²s\u0084áo\u0018ùâd\u008fÒ7âà\u008c#\u0080\u0018\u0086h\u001d£\u009dêÖÐ.æô¸\u0084Ë\u001e^ÃÃË¤¾câ=\u0006O0³\u0013\u009d=ÂÜ¯ÔW\u008c\u001cc\u0081nù\u0083\u0017N\u009d\u0086ýÇ¸îÃoÜüÜî\u001a#\u009eÀ\u0004±\u009eÄ\b¦q\u0085Ì\u0095ÀlW÷L»û-Ü¦*w¾U\u0087\u0085FQ\u0099Ó'Ñ; A'8ß\u0005Ò×\u0006¹Cqw\u0084§\u0094í\u0093\u0019²xù\u0018\u0019\u001f^uä\b;gK\u0094\u0099ppbn®\u0087#ÿ\u001e ë´§×æ!æ<:QW\u0083\u001cÃ;(þ\u008f\b\u0004>\u009dã¶ÜÅ-ÚæöÈÉzü\u000fPK\u0007\bà=!C×\u0002\u0000\u0000@\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000H\u0000\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.class¥\u0091MO\"A\u0010\u0086ß\u0012\u0004DüB]uãa¼\u0081\tL<û\u0091(fOd%Áxo\u0086rh33=i\u001a\fÿJO&\u001eü\u0001þ(cÏ\u0080Æ°\u0093]\u0093íC½Õ\u0095÷©Nu½¾=¿\u00008ÂÏ\"\u0016\b\u0017Jû®\u0088\u00857`7\u0014c\u008eÜ{-â\u0098µë\u0005ÒíhuÇ\u009e±b+Fò°¥ÂPDý¶\u008c¸¥¢±-².\"OhýµÏyoh´øW#BáDFÒ\u009c\u0011rµú\r!ßR}.#\u0087¥\n\u0016Q ¬%þß£°ÇúZô\u0002&TÛÊ\u0013Á\u008dÐ2¹Ï\u008ay3\u0090CÂeûÿ\u0087;&løüa\u009a\\ÅFª\u0088°U«·ïÄX¸\u0081\u0088|·k´\u008cüã\u00126\bÔ!ìýA\\²\u00112à~\t[\u0084J<}¹a5&ìg¸\u0087\u009e\u0096iZÂ\u008e]R\u0097\u008d3\u0083\u0012M\u00adÎ\u00adÒ\u008e\u0019°Ó\u001bÉ ïL\t§ÆM¿é4:á$ñ\u009d\u0086\u0093±\bF\\o\u0012Ê]5Ò\u001eÿ\u0092É\u000f\u001d~køf2\"\u000e`÷\u0081äämf÷`cÑÞ\\«duñð\t¥G\u009b, lc!-nbÙÆÊÔ`u%ÅW±6\u0083\u001b38W]\u007f\u0098Cw¾ ¹O´\u009a\u0081nÎ£û\u0099èv\u0006úc\u001e=È@\t»©kï\u001dPK\u0007\bïBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000G\u0000\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.class¥\u0091ËN\u001b1\u0014\u0086ÿCB\u0012\u0002-\u0090r§\u008bé.©\u0094\u008cºbÁEB\u0089X p\u0091ReïLN'®fÆ#\u008f\u0013\u0094·*+$\u0016<@\u001f\ná\u0019\u0002Bé\b!Õ\u008bsóÿ\u001dûØ\u007f\u001fï\u001f\u0000üÀ^\u0019\u000b\u0084S¥}WÄÂ\u001b±\u001b\u008a\tGî\u008d\u0016qÌÚõ\u0002éö¦\u0089áðZ+[0\u0092\u0093¶\nC\u0011\r»2â¶\u008a&¶Èº\u008c\"¡ýn\u009bÓAb´ðÌû\u008d\b¥#\u0019IsB(Ô\u001b}B±\u00ad\u0086\\E\u0001K+XD\u0089°\u009aê/Çá\u0080õO1\b\u0098Pë*O\u0004}¡e\u009aÏ\u008aE3\u0092\u0089½S÷¿g;$¬ûürïéUl¤\u008a\b\u001bõF÷·\u0098\b7\u0010\u0091ïö\u008c\u0096\u0091\u007fXÁ:\u0081:\u0084Ý\u007f\u0088\u000e\u001b!\u0003\u001eV°AXN²\u0083\u009b±\u0095\u0010¾æ\u0088\u0013OË,¬`\u009bpÐcã<3N<S:ê\u0097cFì\u009c÷/\u009c:·ü\u0096Óì\u0084Ót÷8\u009cND0æF\u008bPí©±öøL¦\u008fÒøÈ¼\u00adt*|\u0083ý\u0001¤«h#ûòÖ\u0096mæZOÖ/~¿CåÖ\u0006\u000b¨Z[Ê\u008a5,[»ò,°þS\u0086\u007fÆê\fnÎàBmíÏ\u001cºõ\u0006-¼¢µ\u001côË<º\u009f\u008bnæ [ó¨\u0093\u0083\u0012v2Õî\u0013PK\u0007\b¯vê²\u0089\u0001\u0000\u0000&\u0003\u0000\u0000PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000K¡Ý1¨\u0000\u0000\u0000+\u0001\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000#\u0001\u0000\u0000META-INF/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000b\u0001\u0000\u0000META-INF/maven/io.takari/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000«\u0001\u0000\u0000META-INF/maven/io.takari/maven-wrapper/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000L´@\u0005:\u0000\u0000\u00009\u0000\u0000\u00005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0002\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.propertiesPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u009f\u0002\u0000\u0000org/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000Ó\u0002\u0000\u0000org/apache/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000e\u0003\u0000\u0000org/apache/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000O\u0003\u0000\u0000org/apache/maven/wrapper/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ÒØüÆB\u0005\u0000\u0000`\n\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0098\u0003\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005ìC¢\u0012\u0002\u0000\u0000å\u0003\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001;\t\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000Ë\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000S\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u00ad\u000b\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000C5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u00017\u000e\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084q÷\u0012°\u0000\u0000\u0000ã\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0005\u001b\u0000\u0000org/apache/maven/wrapper/Downloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000å¡[\u0007Ü\u000f\u0000\u0000\u0088\u001f\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\f\u001c\u0000\u0000org/apache/maven/wrapper/Installer.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084'+ãü\u0001\u0000\u0000m\u0003\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001>,\u0000\u0000org/apache/maven/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0011ps½]\u000b\u0000\u0000Ë\u0018\u0000\u0000/\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u008d.\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001coÏI»\u0001\u0000\u0000t\u0003\u0000\u0000>\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001G:\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0087|+\u009f?\u0007\u0000\u0000Þ\u000e\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001n<\u0000\u0000org/apache/maven/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000{\u0002`-è\u0004\u0000\u0000×\t\u0000\u00006\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0007D\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000º\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001SI\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000øÇ£9\u0091\b\u0000\u0000,\u0013\u0000\u0000.\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001LM\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009V\u0000\u0000org/apache/maven/wrapper/cli/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ðdQvý\u0002\u0000\u0000T\b\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0086V\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000jç F®\u0004\u0000\u0000Î\f\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001ðY\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ûm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0015_\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=8\u009f\u0094L\u0001\u0000\u0000»\u0003\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ö`\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00006W°K\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0087b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000æ¿Ëk-\u0003\u0000\u0000%\u000b\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001úg\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b\u001b['\u0093\u0002\u0000\u0000Á\u0007\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u009ek\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ì\u0014úßÝ\u0003\u0000\u0000\u0000\r\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001 n\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000à¤ûG*\u0002\u0000\u0000¯\u0004\u0000\u0000T\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001õr\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000F{)6N\u0007\u0000\u0000M\u0014\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001¡u\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0081ªï\u009a\u0002\u0000\u0000I\u0007\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001h}\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000»Ð=\u0086ª\u0002\u0000\u0000§\u0007\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001z\u0080\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000K\u0002\u0096\u0017Í\u0002\u0000\u0000\u0081\u0007\u0000\u0000E\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u009d\u0083\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n \u0095Ò\u0094\u0001\u0000\u0000¥\u0003\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ý\u0086\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0016¤\u0018Óv\u0002\u0000\u0000f\u0005\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001å\u0088\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00007¤çy\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ê\u008b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ûtS\u0083ì\u0001\u0000\u0000°\u0004\u0000\u0000@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Â\u008e\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000O<êÑÇ\u0002\u0000\u0000Õ\u0007\u0000\u0000M\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u001c\u0091\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005Øûü²\u0010\u0000\u0000´(\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001^\u0094\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0088!ç@ë\u0006\u0000\u0000z\u0010\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001r¥\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000à=!C×\u0002\u0000\u0000@\u0005\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001¿¬\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ïBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000H\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001þ¯\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000¯vê²\u0089\u0001\u0000\u0000&\u0003\u0000\u0000G\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001ü±\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.classPK\u0005\u0006\u0000\u0000\u0000\u0000/\u0000/\u0000\u0006\u0012\u0000\u0000ú³\u0000\u0000\u0000\u0000"
          },
          {
            sha: "642d572ce90e5085986bdd9c9204b9404f028084",
            filename: ".mvn/wrapper/maven-wrapper.properties",
            status: "added",
            additions: 2,
            deletions: 0,
            patch:
              "@@ -0,0 +1,2 @@\n+distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\n+wrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar",
            rawContent:
              "distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n"
          },
          {
            sha: "3c8a5537314954d53ec2fb774b34fe5d5a5f253a",
            filename: "mvnw",
            status: "added",
            additions: 322,
            deletions: 0,
            patch:
              '@@ -0,0 +1,322 @@\n+#!/bin/sh\n+# ----------------------------------------------------------------------------\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# "License"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#    https://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# ----------------------------------------------------------------------------\n+\n+# ----------------------------------------------------------------------------\n+# Maven Start Up Batch script\n+#\n+# Required ENV vars:\n+# ------------------\n+#   JAVA_HOME - location of a JDK home dir\n+#\n+# Optional ENV vars\n+# -----------------\n+#   M2_HOME - location of maven2\'s installed home dir\n+#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n+#     e.g. to debug Maven itself, use\n+#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n+#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n+# ----------------------------------------------------------------------------\n+\n+if [ -z "$MAVEN_SKIP_RC" ]; then\n+\n+  if [ -f /etc/mavenrc ]; then\n+    . /etc/mavenrc\n+  fi\n+\n+  if [ -f "$HOME/.mavenrc" ]; then\n+    . "$HOME/.mavenrc"\n+  fi\n+\n+fi\n+\n+# OS specific support.  $var _must_ be set to either true or false.\n+cygwin=false\n+darwin=false\n+mingw=false\n+case "$(uname)" in\n+CYGWIN*) cygwin=true ;;\n+MINGW*) mingw=true ;;\n+Darwin*)\n+  darwin=true\n+  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n+  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n+  if [ -z "$JAVA_HOME" ]; then\n+    if [ -x "/usr/libexec/java_home" ]; then\n+      export JAVA_HOME="$(/usr/libexec/java_home)"\n+    else\n+      export JAVA_HOME="/Library/Java/Home"\n+    fi\n+  fi\n+  ;;\n+esac\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  if [ -r /etc/gentoo-release ]; then\n+    JAVA_HOME=$(java-config --jre-home)\n+  fi\n+fi\n+\n+if [ -z "$M2_HOME" ]; then\n+  ## resolve links - $0 may be a link to maven\'s home\n+  PRG="$0"\n+\n+  # need this for relative symlinks\n+  while [ -h "$PRG" ]; do\n+    ls=$(ls -ld "$PRG")\n+    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n+    if expr "$link" : \'/.*\' >/dev/null; then\n+      PRG="$link"\n+    else\n+      PRG="$(dirname "$PRG")/$link"\n+    fi\n+  done\n+\n+  saveddir=$(pwd)\n+\n+  M2_HOME=$(dirname "$PRG")/..\n+\n+  # make it fully qualified\n+  M2_HOME=$(cd "$M2_HOME" && pwd)\n+\n+  cd "$saveddir"\n+  # echo Using m2 at $M2_HOME\n+fi\n+\n+# For Cygwin, ensure paths are in UNIX format before anything is touched\n+if $cygwin; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME=$(cygpath --unix "$M2_HOME")\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n+  [ -n "$CLASSPATH" ] &&\n+    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\n+fi\n+\n+# For Mingw, ensure paths are in UNIX format before anything is touched\n+if $mingw; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME="$( (\n+      cd "$M2_HOME"\n+      pwd\n+    ))"\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME="$( (\n+      cd "$JAVA_HOME"\n+      pwd\n+    ))"\n+fi\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  javaExecutable="$(which javac)"\n+  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n+    # readlink(1) is not available as standard on Solaris 10.\n+    readLink=$(which readlink)\n+    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n+      if $darwin; then\n+        javaHome="$(dirname \\"$javaExecutable\\")"\n+        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n+      else\n+        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n+      fi\n+      javaHome="$(dirname \\"$javaExecutable\\")"\n+      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n+      JAVA_HOME="$javaHome"\n+      export JAVA_HOME\n+    fi\n+  fi\n+fi\n+\n+if [ -z "$JAVACMD" ]; then\n+  if [ -n "$JAVA_HOME" ]; then\n+    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n+      # IBM\'s JDK on AIX uses strange locations for the executables\n+      JAVACMD="$JAVA_HOME/jre/sh/java"\n+    else\n+      JAVACMD="$JAVA_HOME/bin/java"\n+    fi\n+  else\n+    JAVACMD="$(which java)"\n+  fi\n+fi\n+\n+if [ ! -x "$JAVACMD" ]; then\n+  echo "Error: JAVA_HOME is not defined correctly." >&2\n+  echo "  We cannot execute $JAVACMD" >&2\n+  exit 1\n+fi\n+\n+if [ -z "$JAVA_HOME" ]; then\n+  echo "Warning: JAVA_HOME environment variable is not set."\n+fi\n+\n+CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n+\n+# traverses directory structure from process work directory to filesystem root\n+# first directory with .mvn subdirectory is considered project base directory\n+find_maven_basedir() {\n+\n+  if [ -z "$1" ]; then\n+    echo "Path not specified to find_maven_basedir"\n+    return 1\n+  fi\n+\n+  basedir="$1"\n+  wdir="$1"\n+  while [ "$wdir" != \'/\' ]; do\n+    if [ -d "$wdir"/.mvn ]; then\n+      basedir=$wdir\n+      break\n+    fi\n+    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n+    if [ -d "${wdir}" ]; then\n+      wdir=$(\n+        cd "$wdir/.."\n+        pwd\n+      )\n+    fi\n+    # end of workaround\n+  done\n+  echo "${basedir}"\n+}\n+\n+# concatenates all lines of a file\n+concat_lines() {\n+  if [ -f "$1" ]; then\n+    echo "$(tr -s \'\\n\' \' \' <"$1")"\n+  fi\n+}\n+\n+BASE_DIR=$(find_maven_basedir "$(pwd)")\n+if [ -z "$BASE_DIR" ]; then\n+  exit 1\n+fi\n+\n+##########################################################################################\n+# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n+# This allows using the maven wrapper in projects that prohibit checking in binary data.\n+##########################################################################################\n+if [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Found .mvn/wrapper/maven-wrapper.jar"\n+  fi\n+else\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n+  fi\n+  if [ -n "$MVNW_REPOURL" ]; then\n+    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+  else\n+    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+  fi\n+  while IFS="=" read key value; do\n+    case "$key" in wrapperUrl)\n+      jarUrl="$value"\n+      break\n+      ;;\n+    esac\n+  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n+  if [ "$MVNW_VERBOSE" = true ]; then\n+    echo "Downloading from: $jarUrl"\n+  fi\n+  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n+  if $cygwin; then\n+    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n+  fi\n+\n+  if command -v wget >/dev/null; then\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Found wget ... using wget"\n+    fi\n+    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n+      wget "$jarUrl" -O "$wrapperJarPath"\n+    else\n+      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n+    fi\n+  elif command -v curl >/dev/null; then\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Found curl ... using curl"\n+    fi\n+    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n+      curl -o "$wrapperJarPath" "$jarUrl" -f\n+    else\n+      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n+    fi\n+\n+  else\n+    if [ "$MVNW_VERBOSE" = true ]; then\n+      echo "Falling back to using Java to download"\n+    fi\n+    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n+    # For Cygwin, switch paths to Windows format before running javac\n+    if $cygwin; then\n+      javaClass=$(cygpath --path --windows "$javaClass")\n+    fi\n+    if [ -e "$javaClass" ]; then\n+      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n+        if [ "$MVNW_VERBOSE" = true ]; then\n+          echo " - Compiling MavenWrapperDownloader.java ..."\n+        fi\n+        # Compiling the Java class\n+        ("$JAVA_HOME/bin/javac" "$javaClass")\n+      fi\n+      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n+        # Running the downloader\n+        if [ "$MVNW_VERBOSE" = true ]; then\n+          echo " - Running MavenWrapperDownloader.java ..."\n+        fi\n+        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n+      fi\n+    fi\n+  fi\n+fi\n+##########################################################################################\n+# End of extension\n+##########################################################################################\n+\n+export MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\n+if [ "$MVNW_VERBOSE" = true ]; then\n+  echo $MAVEN_PROJECTBASEDIR\n+fi\n+MAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n+\n+# For Cygwin, switch paths to Windows format before running java\n+if $cygwin; then\n+  [ -n "$M2_HOME" ] &&\n+    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n+  [ -n "$JAVA_HOME" ] &&\n+    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n+  [ -n "$CLASSPATH" ] &&\n+    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n+  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n+    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\n+fi\n+\n+# Provide a "standardized" way to retrieve the CLI args that will\n+# work with both Windows and non-Windows executions.\n+MAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\n+export MAVEN_CMD_LINE_ARGS\n+\n+WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n+\n+exec "$JAVACMD" \\\n+  $MAVEN_OPTS \\\n+  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n+  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n+  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"',
            rawContent:
              '#!/bin/sh\n# ----------------------------------------------------------------------------\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# "License"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#    https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# Maven Start Up Batch script\n#\n# Required ENV vars:\n# ------------------\n#   JAVA_HOME - location of a JDK home dir\n#\n# Optional ENV vars\n# -----------------\n#   M2_HOME - location of maven2\'s installed home dir\n#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n#     e.g. to debug Maven itself, use\n#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n# ----------------------------------------------------------------------------\n\nif [ -z "$MAVEN_SKIP_RC" ]; then\n\n  if [ -f /etc/mavenrc ]; then\n    . /etc/mavenrc\n  fi\n\n  if [ -f "$HOME/.mavenrc" ]; then\n    . "$HOME/.mavenrc"\n  fi\n\nfi\n\n# OS specific support.  $var _must_ be set to either true or false.\ncygwin=false\ndarwin=false\nmingw=false\ncase "$(uname)" in\nCYGWIN*) cygwin=true ;;\nMINGW*) mingw=true ;;\nDarwin*)\n  darwin=true\n  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n  if [ -z "$JAVA_HOME" ]; then\n    if [ -x "/usr/libexec/java_home" ]; then\n      export JAVA_HOME="$(/usr/libexec/java_home)"\n    else\n      export JAVA_HOME="/Library/Java/Home"\n    fi\n  fi\n  ;;\nesac\n\nif [ -z "$JAVA_HOME" ]; then\n  if [ -r /etc/gentoo-release ]; then\n    JAVA_HOME=$(java-config --jre-home)\n  fi\nfi\n\nif [ -z "$M2_HOME" ]; then\n  ## resolve links - $0 may be a link to maven\'s home\n  PRG="$0"\n\n  # need this for relative symlinks\n  while [ -h "$PRG" ]; do\n    ls=$(ls -ld "$PRG")\n    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n    if expr "$link" : \'/.*\' >/dev/null; then\n      PRG="$link"\n    else\n      PRG="$(dirname "$PRG")/$link"\n    fi\n  done\n\n  saveddir=$(pwd)\n\n  M2_HOME=$(dirname "$PRG")/..\n\n  # make it fully qualified\n  M2_HOME=$(cd "$M2_HOME" && pwd)\n\n  cd "$saveddir"\n  # echo Using m2 at $M2_HOME\nfi\n\n# For Cygwin, ensure paths are in UNIX format before anything is touched\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --unix "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\nfi\n\n# For Mingw, ensure paths are in UNIX format before anything is touched\nif $mingw; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME="$( (\n      cd "$M2_HOME"\n      pwd\n    ))"\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME="$( (\n      cd "$JAVA_HOME"\n      pwd\n    ))"\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  javaExecutable="$(which javac)"\n  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n    # readlink(1) is not available as standard on Solaris 10.\n    readLink=$(which readlink)\n    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n      if $darwin; then\n        javaHome="$(dirname \\"$javaExecutable\\")"\n        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n      else\n        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n      fi\n      javaHome="$(dirname \\"$javaExecutable\\")"\n      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n      JAVA_HOME="$javaHome"\n      export JAVA_HOME\n    fi\n  fi\nfi\n\nif [ -z "$JAVACMD" ]; then\n  if [ -n "$JAVA_HOME" ]; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n      # IBM\'s JDK on AIX uses strange locations for the executables\n      JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n      JAVACMD="$JAVA_HOME/bin/java"\n    fi\n  else\n    JAVACMD="$(which java)"\n  fi\nfi\n\nif [ ! -x "$JAVACMD" ]; then\n  echo "Error: JAVA_HOME is not defined correctly." >&2\n  echo "  We cannot execute $JAVACMD" >&2\n  exit 1\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  echo "Warning: JAVA_HOME environment variable is not set."\nfi\n\nCLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n\n# traverses directory structure from process work directory to filesystem root\n# first directory with .mvn subdirectory is considered project base directory\nfind_maven_basedir() {\n\n  if [ -z "$1" ]; then\n    echo "Path not specified to find_maven_basedir"\n    return 1\n  fi\n\n  basedir="$1"\n  wdir="$1"\n  while [ "$wdir" != \'/\' ]; do\n    if [ -d "$wdir"/.mvn ]; then\n      basedir=$wdir\n      break\n    fi\n    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n    if [ -d "${wdir}" ]; then\n      wdir=$(\n        cd "$wdir/.."\n        pwd\n      )\n    fi\n    # end of workaround\n  done\n  echo "${basedir}"\n}\n\n# concatenates all lines of a file\nconcat_lines() {\n  if [ -f "$1" ]; then\n    echo "$(tr -s \'\\n\' \' \' <"$1")"\n  fi\n}\n\nBASE_DIR=$(find_maven_basedir "$(pwd)")\nif [ -z "$BASE_DIR" ]; then\n  exit 1\nfi\n\n##########################################################################################\n# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n# This allows using the maven wrapper in projects that prohibit checking in binary data.\n##########################################################################################\nif [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Found .mvn/wrapper/maven-wrapper.jar"\n  fi\nelse\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n  fi\n  if [ -n "$MVNW_REPOURL" ]; then\n    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  else\n    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  fi\n  while IFS="=" read key value; do\n    case "$key" in wrapperUrl)\n      jarUrl="$value"\n      break\n      ;;\n    esac\n  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Downloading from: $jarUrl"\n  fi\n  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n  if $cygwin; then\n    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n  fi\n\n  if command -v wget >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found wget ... using wget"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      wget "$jarUrl" -O "$wrapperJarPath"\n    else\n      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n    fi\n  elif command -v curl >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found curl ... using curl"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      curl -o "$wrapperJarPath" "$jarUrl" -f\n    else\n      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n    fi\n\n  else\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Falling back to using Java to download"\n    fi\n    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n    # For Cygwin, switch paths to Windows format before running javac\n    if $cygwin; then\n      javaClass=$(cygpath --path --windows "$javaClass")\n    fi\n    if [ -e "$javaClass" ]; then\n      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Compiling MavenWrapperDownloader.java ..."\n        fi\n        # Compiling the Java class\n        ("$JAVA_HOME/bin/javac" "$javaClass")\n      fi\n      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        # Running the downloader\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Running MavenWrapperDownloader.java ..."\n        fi\n        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n      fi\n    fi\n  fi\nfi\n##########################################################################################\n# End of extension\n##########################################################################################\n\nexport MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\nif [ "$MVNW_VERBOSE" = true ]; then\n  echo $MAVEN_PROJECTBASEDIR\nfi\nMAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\nfi\n\n# Provide a "standardized" way to retrieve the CLI args that will\n# work with both Windows and non-Windows executions.\nMAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\nexport MAVEN_CMD_LINE_ARGS\n\nWRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nexec "$JAVACMD" \\\n  $MAVEN_OPTS \\\n  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"\n'
          },
          {
            sha: "c8d43372c986d97911cdc21bd87e0cbe3d83bdda",
            filename: "mvnw.cmd",
            status: "added",
            additions: 182,
            deletions: 0,
            patch:
              '@@ -0,0 +1,182 @@\n+@REM ----------------------------------------------------------------------------\n+@REM Licensed to the Apache Software Foundation (ASF) under one\n+@REM or more contributor license agreements.  See the NOTICE file\n+@REM distributed with this work for additional information\n+@REM regarding copyright ownership.  The ASF licenses this file\n+@REM to you under the Apache License, Version 2.0 (the\n+@REM "License"); you may not use this file except in compliance\n+@REM with the License.  You may obtain a copy of the License at\n+@REM\n+@REM    https://www.apache.org/licenses/LICENSE-2.0\n+@REM\n+@REM Unless required by applicable law or agreed to in writing,\n+@REM software distributed under the License is distributed on an\n+@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+@REM KIND, either express or implied.  See the License for the\n+@REM specific language governing permissions and limitations\n+@REM under the License.\n+@REM ----------------------------------------------------------------------------\n+\n+@REM ----------------------------------------------------------------------------\n+@REM Maven Start Up Batch script\n+@REM\n+@REM Required ENV vars:\n+@REM JAVA_HOME - location of a JDK home dir\n+@REM\n+@REM Optional ENV vars\n+@REM M2_HOME - location of maven2\'s installed home dir\n+@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n+@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n+@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n+@REM     e.g. to debug Maven itself, use\n+@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n+@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n+@REM ----------------------------------------------------------------------------\n+\n+@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n+@echo off\n+@REM set title of command window\n+title %0\n+@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n+@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n+\n+@REM set %HOME% to equivalent of $HOME\n+if "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n+\n+@REM Execute a user defined script before this one\n+if not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n+@REM check for pre script, once with legacy .bat ending and once with .cmd ending\n+if exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\n+if exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n+:skipRcPre\n+\n+@setlocal\n+\n+set ERROR_CODE=0\n+\n+@REM To isolate internal variables from possible post scripts, we use another setlocal\n+@setlocal\n+\n+@REM ==== START VALIDATION ====\n+if not "%JAVA_HOME%" == "" goto OkJHome\n+\n+echo.\n+echo Error: JAVA_HOME not found in your environment. >&2\n+echo Please set the JAVA_HOME variable in your environment to match the >&2\n+echo location of your Java installation. >&2\n+echo.\n+goto error\n+\n+:OkJHome\n+if exist "%JAVA_HOME%\\bin\\java.exe" goto init\n+\n+echo.\n+echo Error: JAVA_HOME is set to an invalid directory. >&2\n+echo JAVA_HOME = "%JAVA_HOME%" >&2\n+echo Please set the JAVA_HOME variable in your environment to match the >&2\n+echo location of your Java installation. >&2\n+echo.\n+goto error\n+\n+@REM ==== END VALIDATION ====\n+\n+:init\n+\n+@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n+@REM Fallback to current working directory if not found.\n+\n+set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\n+IF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n+\n+set EXEC_DIR=%CD%\n+set WDIR=%EXEC_DIR%\n+:findBaseDir\n+IF EXIST "%WDIR%"\\.mvn goto baseDirFound\n+cd ..\n+IF "%WDIR%"=="%CD%" goto baseDirNotFound\n+set WDIR=%CD%\n+goto findBaseDir\n+\n+:baseDirFound\n+set MAVEN_PROJECTBASEDIR=%WDIR%\n+cd "%EXEC_DIR%"\n+goto endDetectBaseDir\n+\n+:baseDirNotFound\n+set MAVEN_PROJECTBASEDIR=%EXEC_DIR%\n+cd "%EXEC_DIR%"\n+\n+:endDetectBaseDir\n+\n+IF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n+\n+@setlocal EnableExtensions EnableDelayedExpansion\n+for /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n+@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n+\n+:endReadAdditionalConfig\n+\n+SET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\n+set WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\n+set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n+\n+set DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+\n+FOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n+    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n+)\n+\n+@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n+@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\n+if exist %WRAPPER_JAR% (\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Found %WRAPPER_JAR%\n+    )\n+) else (\n+    if not "%MVNW_REPOURL%" == "" (\n+        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n+    )\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n+        echo Downloading from: %DOWNLOAD_URL%\n+    )\n+\n+    powershell -Command "&{"^\n+\t\t"$webclient = new-object System.Net.WebClient;"^\n+\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n+\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n+\t\t"}"^\n+\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n+\t\t"}"\n+    if "%MVNW_VERBOSE%" == "true" (\n+        echo Finished downloading %WRAPPER_JAR%\n+    )\n+)\n+@REM End of extension\n+\n+@REM Provide a "standardized" way to retrieve the CLI args that will\n+@REM work with both Windows and non-Windows executions.\n+set MAVEN_CMD_LINE_ARGS=%*\n+\n+%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\n+if ERRORLEVEL 1 goto error\n+goto end\n+\n+:error\n+set ERROR_CODE=1\n+\n+:end\n+@endlocal & set ERROR_CODE=%ERROR_CODE%\n+\n+if not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n+@REM check for post script, once with legacy .bat ending and once with .cmd ending\n+if exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\n+if exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n+:skipRcPost\n+\n+@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\n+if "%MAVEN_BATCH_PAUSE%" == "on" pause\n+\n+if "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n+\n+exit /B %ERROR_CODE%',
            rawContent:
              '@REM ----------------------------------------------------------------------------\n@REM Licensed to the Apache Software Foundation (ASF) under one\n@REM or more contributor license agreements.  See the NOTICE file\n@REM distributed with this work for additional information\n@REM regarding copyright ownership.  The ASF licenses this file\n@REM to you under the Apache License, Version 2.0 (the\n@REM "License"); you may not use this file except in compliance\n@REM with the License.  You may obtain a copy of the License at\n@REM\n@REM    https://www.apache.org/licenses/LICENSE-2.0\n@REM\n@REM Unless required by applicable law or agreed to in writing,\n@REM software distributed under the License is distributed on an\n@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@REM KIND, either express or implied.  See the License for the\n@REM specific language governing permissions and limitations\n@REM under the License.\n@REM ----------------------------------------------------------------------------\n\n@REM ----------------------------------------------------------------------------\n@REM Maven Start Up Batch script\n@REM\n@REM Required ENV vars:\n@REM JAVA_HOME - location of a JDK home dir\n@REM\n@REM Optional ENV vars\n@REM M2_HOME - location of maven2\'s installed home dir\n@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n@REM     e.g. to debug Maven itself, use\n@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n@REM ----------------------------------------------------------------------------\n\n@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n@echo off\n@REM set title of command window\ntitle %0\n@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n\n@REM set %HOME% to equivalent of $HOME\nif "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n\n@REM Execute a user defined script before this one\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n@REM check for pre script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\nif exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n:skipRcPre\n\n@setlocal\n\nset ERROR_CODE=0\n\n@REM To isolate internal variables from possible post scripts, we use another setlocal\n@setlocal\n\n@REM ==== START VALIDATION ====\nif not "%JAVA_HOME%" == "" goto OkJHome\n\necho.\necho Error: JAVA_HOME not found in your environment. >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n:OkJHome\nif exist "%JAVA_HOME%\\bin\\java.exe" goto init\n\necho.\necho Error: JAVA_HOME is set to an invalid directory. >&2\necho JAVA_HOME = "%JAVA_HOME%" >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n@REM ==== END VALIDATION ====\n\n:init\n\n@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n@REM Fallback to current working directory if not found.\n\nset MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\nIF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n\nset EXEC_DIR=%CD%\nset WDIR=%EXEC_DIR%\n:findBaseDir\nIF EXIST "%WDIR%"\\.mvn goto baseDirFound\ncd ..\nIF "%WDIR%"=="%CD%" goto baseDirNotFound\nset WDIR=%CD%\ngoto findBaseDir\n\n:baseDirFound\nset MAVEN_PROJECTBASEDIR=%WDIR%\ncd "%EXEC_DIR%"\ngoto endDetectBaseDir\n\n:baseDirNotFound\nset MAVEN_PROJECTBASEDIR=%EXEC_DIR%\ncd "%EXEC_DIR%"\n\n:endDetectBaseDir\n\nIF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n\n@setlocal EnableExtensions EnableDelayedExpansion\nfor /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n\n:endReadAdditionalConfig\n\nSET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\nset WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\nset WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nset DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n\nFOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n)\n\n@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\nif exist %WRAPPER_JAR% (\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Found %WRAPPER_JAR%\n    )\n) else (\n    if not "%MVNW_REPOURL%" == "" (\n        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n    )\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n        echo Downloading from: %DOWNLOAD_URL%\n    )\n\n    powershell -Command "&{"^\n\t\t"$webclient = new-object System.Net.WebClient;"^\n\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n\t\t"}"^\n\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n\t\t"}"\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Finished downloading %WRAPPER_JAR%\n    )\n)\n@REM End of extension\n\n@REM Provide a "standardized" way to retrieve the CLI args that will\n@REM work with both Windows and non-Windows executions.\nset MAVEN_CMD_LINE_ARGS=%*\n\n%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\nif ERRORLEVEL 1 goto error\ngoto end\n\n:error\nset ERROR_CODE=1\n\n:end\n@endlocal & set ERROR_CODE=%ERROR_CODE%\n\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n@REM check for post script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\nif exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n:skipRcPost\n\n@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\nif "%MAVEN_BATCH_PAUSE%" == "on" pause\n\nif "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n\nexit /B %ERROR_CODE%\n'
          },
          {
            sha: "e168b2799d20267ac52cf4acbd15701d9ce1aab4",
            filename: "pom.xml",
            status: "added",
            additions: 66,
            deletions: 0,
            patch:
              '@@ -0,0 +1,66 @@\n+<?xml version="1.0" encoding="UTF-8"?>\n+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.springframework.boot</groupId>\n+        <artifactId>spring-boot-starter-parent</artifactId>\n+        <version>2.2.5.RELEASE</version>\n+        <relativePath/> <!-- lookup parent from repository -->\n+    </parent>\n+    <groupId>com.example</groupId>\n+    <artifactId>demo</artifactId>\n+    <version>0.0.1-SNAPSHOT</version>\n+    <name>demo</name>\n+    <description>Demo project for Spring Boot</description>\n+\n+    <properties>\n+        <java.version>1.8</java.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-data-jpa</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-web</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-web-services</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>mysql</groupId>\n+            <artifactId>mysql-connector-java</artifactId>\n+            <scope>runtime</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-test</artifactId>\n+            <scope>test</scope>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.junit.vintage</groupId>\n+                    <artifactId>junit-vintage-engine</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.springframework.boot</groupId>\n+                <artifactId>spring-boot-maven-plugin</artifactId>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+</project>',
            rawContent:
              '<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.5.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web-services</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n'
          },
          {
            sha: "094d95b93ffb2708ff7037793fd189908b1ea6fb",
            filename: "src/main/java/com/example/demo/DemoApplication.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package com.example.demo;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class DemoApplication {\n+\n+    public static void main(String[] args) {\n+        SpringApplication.run(DemoApplication.class, args);\n+    }\n+\n+}",
            rawContent:
              "package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n"
          },
          {
            sha: "724cb23604d06cf9a508f444b8f9080b1dc2d00a",
            filename: "src/main/resources/application.properties",
            status: "added",
            additions: 4,
            deletions: 0,
            patch:
              "@@ -0,0 +1,4 @@\n+spring.datasource.url=jdbc:mysql://localhost:3306/myDb\n+spring.datasource.username=root\n+spring.datasource.password=admin\n+spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\\ No newline at end of file",
            rawContent:
              "spring.datasource.url=jdbc:mysql://localhost:3306/myDb\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver"
          },
          {
            sha: "eaa99696e2ab439159031a591b363c39f4c240c1",
            filename:
              "src/test/java/com/example/demo/DemoApplicationTests.java",
            status: "added",
            additions: 13,
            deletions: 0,
            patch:
              "@@ -0,0 +1,13 @@\n+package com.example.demo;\n+\n+import org.junit.jupiter.api.Test;\n+import org.springframework.boot.test.context.SpringBootTest;\n+\n+@SpringBootTest\n+class DemoApplicationTests {\n+\n+    @Test\n+    void contextLoads() {\n+    }\n+\n+}",
            rawContent:
              "package com.example.demo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Test\n    void contextLoads() {\n    }\n\n}\n"
          }
        ]
      }
    ],
    trees: [
      {
        subTrees: [
          {
            subTrees: [
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "DemoApplicationTests.java",
                                sha: "eaa99696e2ab439159031a591b363c39f4c240c1",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "demo",
                            sha: "93e4bded8452e203035bd6b8abc7a82bb32a8d75"
                          }
                        ],
                        type: "FOLDER",
                        path: "example",
                        sha: "862eb54f328d7aecdd398b471e91052cd52deef9"
                      }
                    ],
                    type: "FOLDER",
                    path: "com",
                    sha: "3e68f2d1b3d549d5e6c7b2fcc48b068543a7e21e"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "11a164cc86eddd688bd55248d66b1e440c8aba00"
              }
            ],
            type: "FOLDER",
            path: "test",
            sha: "5b8f16582645727e0f73f9bfc69c64ba885c0ebe"
          },
          {
            subTrees: [
              {
                subTrees: [
                  {
                    type: "FILE",
                    path: "application.properties",
                    sha: "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6",
                    subTrees: []
                  }
                ],
                type: "FOLDER",
                path: "resources",
                sha: "a0da322879762d8496c522beed090a912db02eae"
              },
              {
                subTrees: [
                  {
                    subTrees: [
                      {
                        subTrees: [
                          {
                            subTrees: [
                              {
                                type: "FILE",
                                path: "DemoApplication.java",
                                sha: "094d95b93ffb2708ff7037793fd189908b1ea6fb",
                                subTrees: []
                              }
                            ],
                            type: "FOLDER",
                            path: "demo",
                            sha: "5ac8d98532041c8c09ade371d71cc4dcf8d44c2a"
                          }
                        ],
                        type: "FOLDER",
                        path: "example",
                        sha: "c226961e386ea808b1f2a6e73f9ba2f81969eb57"
                      }
                    ],
                    type: "FOLDER",
                    path: "com",
                    sha: "f6071f0916b97cc4a745867541c5c0b07f96194f"
                  }
                ],
                type: "FOLDER",
                path: "java",
                sha: "bb9bf49398954eed70064e2e8bdd62574de6c442"
              }
            ],
            type: "FOLDER",
            path: "main",
            sha: "2526e45f3340ba78d441ebbbef2bc404110984ae"
          }
        ],
        type: "FOLDER",
        path: "src",
        sha: "f497f93edb6dc2f63380ab334fe152f283ca01a4"
      },
      {
        subTrees: [
          {
            subTrees: [
              {
                type: "FILE",
                path: "MavenWrapperDownloader.java",
                sha: "a45eb6ba269cd38f8965cef786729790945d9537",
                subTrees: []
              },
              {
                type: "FILE",
                path: "maven-wrapper.jar",
                sha: "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054",
                subTrees: []
              },
              {
                type: "FILE",
                path: "maven-wrapper.properties",
                sha: "642d572ce90e5085986bdd9c9204b9404f028084",
                subTrees: []
              }
            ],
            type: "FOLDER",
            path: "wrapper",
            sha: "6bef16b891b042bd96e7515ad6e3b1029795e3dd"
          }
        ],
        type: "FOLDER",
        path: ".mvn",
        sha: "88bf4cf610648943581817557053739d932c2ca6"
      },
      {
        type: "FILE",
        path: ".gitattributes",
        sha: "dfe0770424b2a19faf507a501ebfc23be8f54e7b",
        subTrees: []
      },
      {
        type: "FILE",
        path: ".gitignore",
        sha: "a2a3040aa86debfd8826d9c2b5c816314c17d9fe",
        subTrees: []
      },
      {
        type: "FILE",
        path: "mvnw",
        sha: "3c8a5537314954d53ec2fb774b34fe5d5a5f253a",
        subTrees: []
      },
      {
        type: "FILE",
        path: "mvnw.cmd",
        sha: "c8d43372c986d97911cdc21bd87e0cbe3d83bdda",
        subTrees: []
      },
      {
        type: "FILE",
        path: "pom.xml",
        sha: "e168b2799d20267ac52cf4acbd15701d9ce1aab4",
        subTrees: []
      }
    ],
    branches: [
      {
        name: "dev-yxw",
        commitHeadSha: "8a7fa401df16de95b4540aa6c61648d75fa4e99c"
      },
      {
        name: "master",
        commitHeadSha: "d452a08ee6b7772f30b876395b09ce7a15f8a58c"
      }
    ],
    shaFileContentMap: {
      eaa99696e2ab439159031a591b363c39f4c240c1:
        "package com.example.demo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Test\n    void contextLoads() {\n    }\n\n}\n",
      "1e4ec5a4e8d9437085d6f28ae0b1851a889689e6":
        "spring.datasource.url=jdbc:mysql://localhost:3306/tle\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver",
      "094d95b93ffb2708ff7037793fd189908b1ea6fb":
        "package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n",
      a45eb6ba269cd38f8965cef786729790945d9537:
        '/*\n * Copyright 2007-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.net.*;\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.util.Properties;\n\npublic class MavenWrapperDownloader {\n\n    private static final String WRAPPER_VERSION = "0.5.6";\n    /**\n     * Default URL to download the maven-wrapper.jar from, if no \'downloadUrl\' is provided.\n     */\n    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"\n            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";\n\n    /**\n     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to\n     * use instead of the default one.\n     */\n    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =\n            ".mvn/wrapper/maven-wrapper.properties";\n\n    /**\n     * Path where the maven-wrapper.jar will be saved to.\n     */\n    private static final String MAVEN_WRAPPER_JAR_PATH =\n            ".mvn/wrapper/maven-wrapper.jar";\n\n    /**\n     * Name of the property which should be used to override the default download url for the wrapper.\n     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";\n\n    public static void main(String args[]) {\n        System.out.println("- Downloader started");\n        File baseDirectory = new File(args[0]);\n        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());\n\n        // If the maven-wrapper.properties exists, read it and check if it contains a custom\n        // wrapperUrl parameter.\n        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);\n        String url = DEFAULT_DOWNLOAD_URL;\n        if (mavenWrapperPropertyFile.exists()) {\n            FileInputStream mavenWrapperPropertyFileInputStream = null;\n            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println("- ERROR loading \'" + MAVEN_WRAPPER_PROPERTIES_PATH + "\'");\n            } finally {\n                try {\n                    if (mavenWrapperPropertyFileInputStream != null) {\n                        mavenWrapperPropertyFileInputStream.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore ...\n                }\n            }\n        }\n        System.out.println("- Downloading from: " + url);\n\n        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);\n        if (!outputFile.getParentFile().exists()) {\n            if (!outputFile.getParentFile().mkdirs()) {\n                System.out.println(\n                        "- ERROR creating output directory \'" + outputFile.getParentFile().getAbsolutePath() + "\'");\n            }\n        }\n        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println("Done");\n            System.exit(0);\n        } catch (Throwable e) {\n            System.out.println("- Error downloading");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private static void downloadFileFromURL(String urlString, File destination) throws Exception {\n        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {\n            String username = System.getenv("MVNW_USERNAME");\n            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();\n            Authenticator.setDefault(new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(username, password);\n                }\n            });\n        }\n        URL website = new URL(urlString);\n        ReadableByteChannel rbc;\n        rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(destination);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    }\n\n}\n',
      "2cc7d4a55c0cd0092912bf49ae38b3a9e3fd0054":
        "PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000META-INF/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0014\u0000\u0000\u0000META-INF/MANIFEST.MF\u0095\u008fA\nÂ0\u0010E÷\u0081Ü!\u0017H¨\u0015Eº³®*\b\u0082Å\u00ad\u0084d\u008aCÛ$LcÅÛÛVT¨+wÃÿÃ{ü\u0083vXA\u0017å\u0019¨Cï2±P\tgE\u001b\u001ahÁE\u001d\u0087P\u0096\u0018\u001bÈD«{pòN:\u0004 \u009f§\u000f!Q+µælKæ\u008a=Ð·8\u0092ïq8Å»â,¿a\u0013eþ\u0018á®\"°\u009c\u009d\u0002\u0018¬Ðü¥vÖ\u0093,l&Ð«¨kMÈÙ\u008e@G°\u0013½\u009c2Q8£^R+÷¶\u001e×nTrI\u0097éÜ;_ÃÙ\u0013PK\u0007\bK¡Ý1¨\u0000\u0000\u0000+\u0001\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000META-INF/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000META-INF/maven/io.takari/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00005\u0000\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.properties+K-*ÎÌÏ³5Ð3Õ3ãJ/Ê/-ðL±ÍÌ×+IÌN,ÊäJ,*ÉLKL.\u0001\næ&\u0096¥æé\u0096\u0017%\u0016\u0014¤\u0016q\u0001\u0000PK\u0007\bL´@\u0005:\u0000\u0000\u00009\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000org/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000org/apache/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000org/apache/maven/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000org/apache/maven/wrapper/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.class\u0095VÉv\u0013G\u0014½\u0085\u0086\u0016¢\u0099\u0004\u0006ä`#bÀ\u0092\u0007up\b\u0001\u008b\u0098Á\u0081 \"\u001bc\u0083A\u0098\f-©lµ\u0091º\u0095î\u0092±3'\u0090y^åd\u0099U¶a#û\u0084\u0013²Ï\u008fä/\u0092¼jµlI\u0096sN´èªzUuß»¯î«Ò\u009f\u007fÿö\u0014ÀIü `\u001bÃ°e/hzEÏ\u0017¹VÖ\u0097¸©=°õJ\u0085ÛÚ%Ë\u0012\u008e Á\u0084n\u00983B·\u0005·\u0015ø\u0019ö,êKºVÒÍ\u0005ízn\u0091ç\u0005Cð\u009ca\u001ab\u008cÁ\u0017OÌ2øÇ\u00ad\u0002\u000fÃ\u0087í*\u0002\b2ìÎ\u0018&\u009f¬\u0096sÜ¾©çJ\u009c!\u0092±òziV·\r9ö\u008c~Q4\u001c\u0006-ó¿\u0082J1\u0004\u001cÙe8\u0016\u009fËlD7#lÃ\\HÕ-\u0086¥]1J<%ã\u000b_^Îó\u008a0,ÓQ\u0010aØ·±g}&\f\u0086ý*ºp\u0080Â\u009f7ÌBF¯\u009a\u0014\u0090}M·\u0019zãm¨\u00adC\u0005\u0087\u0018\u000eº&\u0093\u000bíÖtf¼¤;NÆÒ\u000b2\u0089Ý\fjód\u0018\u0087Ñ« §aö`T\u001cA\u008cÈ\tëÖt\u009aò\u001e÷¼Ôw¥Sa<\u008bc\núZÑÒ*\u008eã\u0084·-³i[\u0086¶Å1  ÁÐµÁ»)>\u0015\u0083\u0018\"ò\u000b\\Ì¬8\u0082\u0097\u009bæ\u0018¢\r¸öm.nR\u0085&7o§ÍSºÍM\u0011ÆA\u009c\u00942\u0018aH4\u008e§\u0011Ê\u0016H\u0089Ù0Ná´\u0082\u0017ZÔv³hs½ âE\u009caØ\u0099¯Ú\u0012¿n¤p[âª[S\u0012fTE\nç\u0088¬ÃÅ¸e\n¾,Z\buÇ·\u008c\"\u0004\u0092ôI\u0012c2O\u0082.êU'Y)ñejòrÝ\u0003Ë.\u0015\u009cdÉ\u0013F²¡\u0010Iù\u0082\u008a\u008b¸D\u0089(\u0011\u0098\u008bÊp<¾Y\u009c\u009b\u0092\u0099\náeR¨+ûdÑ*s)\u008e+*^ÁU\u0012\"¥õbÎ±JUÁ§tQl§í\u0081\u0086q\r\u0019\u0005¯¶d¯~\u0096*&0É°\u0083\u00921e[TRb\u0085áL\u0087Àþ;TÏ\u0014Â\u0014ùhNFÞ2çC\u0098&Ij9ÃÔÊ#®Er¸)Ep\u008b¡¯\u00adt:8¢Äß¦Û L5® K´Ûr¤`\u008e\u008a¶C©\u0087q\u0007¯©x\u001doÔ%8ÁEÑ\"q\\è@pnSæ\u009b\tÚ|¾DW\u009bVG `\u001dy\u00059\u0086C[\u00adQQ\u0000ÝaAÃ\\²îSçl³ÏúEÙâÓ3%6\u009b\u0088ºn/\u0090`¶»*¸J\"`ØÕ\u009a5\u0086\u0090;éÞF\u0091|\u0007]G3[Ü?)\u0017Ø0=UîÝ\u0094\u0007W~\u0086ÙH^÷Öia8Ðz\u008f¯T\u001awùþvØs\u0003c¤\u0017rèÏÑ%.\u0015QU±\u0084\u0007²F\fGHV2\u009axb®\u0095©\\¹¢âm©\u007f\u0085ÎtR/ó\u0010Þ¥¸êµ8Ü$¿áäÀ½ä¢N\u0015ø>>TðAk\u0001¸ç®â#|LHe]P\u00ad\u0092Ç®NUyWÁ#ò°11]5\u0085QæëÏC\b\u009f2\u008c\u008f[ÕR!fZ\"V¢4\b\u001e\u0013E\u001e\u009b\u0090ç\u0012kÜ\n±k\u0017§c\u0086éY\u000bÄÔ6rU\t\u0011ë?îô'e¨\u009f«ø\u0002_\u0092væ-\u009bâjÓN\u0007½vÐÎz\u0005<Ä×²Ò¾Ù\u0082\u0099|\u009eç\ryBá\u0019«jçù\u0015w\u0010íô²&åv\u001c¥\u0097Ð\u0007ùóQ\u008fÞsú*4Ò¨eÔ\u0006\u0006V\u0011zL\u009dm\bÓ7è\u001a»±\u0083¾j}\u0001µ;©%\u0011c7\u00adÚC}?\u008döJ\u0018v\u0084vH8g`h\u0015û&\u009fà`Öÿ;¢Yßp\rÏÔptf\rý5\f¯â¹Qÿ\u001a\u009e\u008fúk8\u001bõG^ªáüh 2>TÃå5¤oG®?ÁáìPäÆ*f<S4\u0010\u0099%¨;Y_ä.Ùî\u008d\u0006£AF\u0006_Ö7Hã7o?v9É G)4\u0090Ð\u0082è¡ðzq\u0088\u009eÞ^ê÷!F¯áQzFú0\u0086c¸\u0081\u0013È£\u001f%zëLjm\f¸D¯Ö)xDeo\u001es.y\u0007\u000b(\u0012é Ê0¨ç#¤),â>¥à\u0014Î\u0013R\u0099\u0012\u0094'¯&,ZUñÒV\u009f{\u008bæ¶É?!^Î\u007f¤o\u0090Ú´$;\u0018±]²\";\u001axzÚï\u001bû\u0005Ñh gd\u0082r²\u001cy§\u0086÷~B`è×G>ÖÓåÿù\u009f¿\u009eàa6òI#\u0001køl\u0015_ý±~n\u0007È\u00150L¤\u0093HÐá\u000eRÿ\u0014F\\z1W\u0000éuzi\u0097\u0014£µ»ð\u00adK\u008fá;\u0017éû\u007f\u0001PK\u0007\bÒØüÆB\u0005\u0000\u0000`\n\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00002\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.class\u0095SmO\u0013A\u0010~\u0096Ö\u001e\u009c\u0087Ôj\u008bø\u0006JÅ¶`\u008f\u001a¿aÐ¦ÅÄ¤\u0005B\u0015bø`\u0096viÏ\\w\u009b½-\u0084\u007f¥\u001f\u0014£\u0089?À\u001fe\u009c½T\u0083@\"\\rs³sÏ<Ïdföç¯o?\u0000TðÔÁ\u0018Ã\u0092Ò]\u009f\u000fx»'ü>?\u0010Ò?Ô|0\u0010Ú¯\u008b}>\fM]\u001dÊPñ\u008eÐù\u008a\u0083$Cî\u0003?à¾\u0014Æ¯\u000eMOH\u0013´¹Q\u009a!ezA\u0094_&ÎÆÅIW(ïy \u0003³Êà\u0017.\u0093XÜfHÖTGL\u0080áª\u0087+H¹H`Ò\u0083\u0083k\f\u0089\u0082\u0005L5\u0002)Ö\u0087ý=¡ßð½P0d\u001aªÍÃm®\u0003{\u001e\u0005\u0093¶t\u0086ò%ôó\u0015*}¦+Ì&\u008f¢C¥;'º\u0011(É0_(6þ¶ê|Ð\u008a\u0083\u001cÃì\u007fPã¸Å0ÙÜ^ßyÿ¶µ¶µ^m®¹¸\u008d»\u000eî0¤ãä\u0090Ë®ß:\u008a\u008cè{¸\u0087ûÔ\u0010[\u0099VTº9bX(4Nà\u008c\u000edw¥x64\u008e¹?J\u009bÕVkgc«îâ!ò\u000eæÿU\u008aá\u001e\u001ea\u0081\u0094\u008cªõ¸®jÍI)Y(îÖ\\dQ°s(2L\u009f#½[³³q[j¨ÛâU`'\u0090;Óà²M£\t®Év¨\"Jk\nÓS\u001d\u0007e\u0086ÒÅçäaÙ®Ãt[Éý ;Ôâô\u009c¼×R\n]\u000b©÷\"Â\u001c-S\u0082î\u0007K§íF\u00917F¯\u0083q\u008aO\u0090÷\u008cÎ6â\u0096\u0016?\u00939\u0086÷)ÆL\u0091M\u0011\u0006XE\u009a¬\u0017û.®#Cß$nàæ\u0088á\u0005\u009dì¿ìwdße¦¿b&3Kæ\u000b\u001e\u001cãñÇSd/O\u0090eGd\t\u0094bÔ\"\u0096bê'ðé:[1\u0016ãèù\rPK\u0007\b5ìC¢\u0012\u0002\u0000\u0000å\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000S\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.class\u00ad\u0094]o\u0012A\u0014\u0086ß\u0003´K·Ø\"*X¿Zûå.*«^\u0099`L\b\u008d\u0089\tÚÆ*\u0089éÕ\u0014FX³Ì\u0090Ù¡È\u008f2©7¶ÑÄ\u001fà\u008f2Î\u0000*µ$íE7Ù93sÎ¼ç\u00999³ûó×·\u001f\u0000\u001eã\u0089\u0083\u0004á\u0095T\u00ad\u0080uY£Í\u0083\u000e;à\"è+Öír\u0015lñ\u000f¬\u0017é-Ù\u0017\u0091dM®Öw\u0007±æ\u009d\u001d%\u008d[\u0087<6½O\u0083JO·¹Ða\u0083i©\u001c¤\bù\u008fì\u0080\u0005\u0082ëà\u0084\u008f0û,\u0014¡~NHz~\u009d\u0090ªÊ&w\u0091Ä\\\u00063\u0098%,ÖBÁ_÷:û\\½eû\u0011'äj²Á¢:S¡\u001d\u008f'Sº\u001dÆ\u0084íÚ\u0085¢\u0097\tK-®wX\u001c÷¥jNøB)\bk\u009e_û»¯éAe\u0007\u0097\tËgD¥q\u0085°ÐÖº[êZ\u0088w1W.®¡à OÈ\u000eWGL´\u0082\u0011r\u0006×±D\u0098·h#ú\u0001aÓ«MÄi\u0015\u008aVÙ?=\u0095ÆMs\u0084ÿRý\u0001Jã6\u00016é²\u0095_!<\u009d\"x®\u0014.V±î`í$ùÐ\u0097Á\u00066\r¹\u0096Õ6S\u0015¥\u0098!Oyþ^ÕE\u0016\u009e\u00ad¹O(LÉ¼Wµ×ã\u008dwÁ\u0005öë.\bs\u0004wWöT\u0083¿\bímÊ\u009fÒ*Y Bæ¥\u0010\\U#sh<vð\u0088P<?\u000faõl\"¬\u0018\u009e$ì\u0093DÂ~\u0003fì\u0098Q`¬©\u0010f\u008aGH\u007f1\u009d\u0084©\u0016\u0086nà3æM\u009b\u0019\u0005\u0018{ÉØ\u0014\u0016°8^\\1³ÖWø\u008eìû\\î\u0018Ws7r·\u008eqç+î\u001eáÞá\u007fr\u0087\u0013r\u0085\u0091\\Ö\n\u0017Çr\u001bÆ&Æ,÷§³$\u0086ï\u0083aû\u0010%Ø»e7\u0010\u0098¿\u008cû\u001bPK\u0007\bË\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00000\u0000\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.class\u0095X\u0007`\u001bÕ\u0019þ\u009e-ùÎâ0\u008e\u009c8QB\u0089\b\tñ\u0090\u00ad\u009a\u0091\u0010\u009b@ãÄ\u0001\u0083í\u0004Évª\u0004HÏòÙ>\u0090uæt²ã\u000eº \u0085\u0086ÒB\u0007e\u0094RZF[Ú\u0092\u0016d\u0093°ÚÒÐM÷Þ{ï½è÷\u009edY¶\u0015\n\tÑ½ñ¿\u007f~ÿÿÞÏ§þ{øQ\u0000mâ\u0005\u001a*\u0004\u009a\u001cw4jN\u0098É1+:nNZéè\u0094kNLXnt\u00875bfSÞ\u000eg*\u009drÌaËÕà\u0013¨½Ì\u009c4£)3=\u001aÝ5t\u0099\u0095ô4T\t\u009crl.Åã\u00025»c»Î\u008buÅãû·\u009f?Ðw¡\u0080è\u00168~»\u0093ÎxfÚ\u001b4SY«\u0012Ú;Ã\u0002Çu\u000eìÜÙ\u0015Û\u001fïÞÛU\tl¬\u00158\u0081üRvÒôl'Ýg\u008e[\u0002Á\u009ey]â\u009ek§G;¸XB6h¹\u0019~\u0004ªÎ¶Ó¶w\u008eÀÆ\u0086¥g\u0096®4\u000e\nø¶;ÃV\u0000\u0095Xn \u0016+\u0004*\u001b\u001a\u0007«!°ÒÀñ¨\u0091£\u0090\u0081\u0013P\u0013àh\u008d\u0081\u0013%Í\u0089I'=b\u008ff]k·ë\u001c\u0098Þ\u0096õÆ¬´WÐF\u0012\u009ed`\u00ad$\\Y$\\HC3{ì´Õ\u0097\u001d\u001f²Ü~s(¥Ìt\u0092fjÐtm9/,ú¼1;#\u0010éyöáëÐ±\u00811\u0018ó¼\u0089Ö\t©Þ@Ær\u0003Ø\u0088F\r\r\u000b\u0002\u001b\u009fÎxÖ¸\u0081&43\u0014£\u0096GkÈÒ\u009b\u00168µ\u008c\u0003\u001b\u0097.ih\u0011è}öº\u00adÏ\u008b,È±\u00adÌbÿ9Ô4\u0082¨\u008cÅó\u0005b\rÏÁîgÁ\u009b\u0011\u000fà4\u009c¡át\u0081zeMÚò¢\u000bh\f\u009c\u0089M\u0002\u0081\u008cå\u0015D0î\u0005o,!&C\u001dg\u0011Ü½\u0083}{ö\u000fÄ»b}Ûz»t´Ï-íÞ\u0016\u008fïÙ\u0015Û¡álFñ9\u0018Ó\u0016@\u0007Î\u0091~8W ú\\ü `\u00ad\u000f\u0017æ\u0002kK\u0094\u001f\u0088u\u0017òÀv¢;í\u0094¥\u0088\u0003]\u0007\u0092Ö\u0084ÄeFÃ\u000e\u0081ºù8\u0017w\u0002Ø\u0089ó5\u009c'`\u0094\u009e7Ð\u008d\u000b\u0098xÖ\u0001;ãeTöì\u0095¤=\u0006zÑG/HT\u0099.\u001d&©\u0089¾\u0086Æ\u0085ò%ñn\u0003\u0017).ã\u0097\u000fÛnF&PÜ@?¶\u0091~Î\u008eî´g¹i3% \u0099ÃÃ®\u0095¡°\u009a\u0085\u0086\u0011ÃÃVÆ³Ó\u0085\u0014«Y,i/.Ö°oÎ\u0082Â1\u0003\u0097àR\u0001¿ç\fÄzJ\u0014Ìo÷\u0010â/bÂÏqêÌ\u008e\u008cX®5¼+ëMd=f\u0081e\u008ek\u0018\u0012XU*«t7\u0000\u0013Ã2\u008e´~YÃbç\u0007°\u001f£rw\u008cuf~·\u0094\u0081¢º\f)\r\u0097/T\u009d>\u001e\u0087´\u0093\u0080O³º¦Y¥\u0095á«\u0017Ù0¿×!};aà\n°L×Ó\u0091\u009dfÆN.®M\u008de\u0011³\u0094\u0099TLÀ3\u0090Å$ë\u0017«W2\u009b2=K\u0016\u009cm£ä(°¼¡LÕÐq\u0080 \u0093T-\u008a,\u0080\u0017ã¥\u001a^R\u009a\u0093\u000b$\u0019x\u0019\u0096Q\u0002s2f]\u0091e\u0090ç*\u0095<úr\u0003¯À+é\u0007b\u00ad;]ô\u001b«o\tØJ6:ü\u0090\u007fx\u0001é¸\u009a\u0097Sk\u0000¯Åµ\u001a®a®\u001c3Íz\u009cÑQ\u008bÅáu8Èªl§G\u001c\u0081\u0015å\u008a$}òz¼AÃõ4¾\\8\r¼\u00117\u0010oS®í\u0011\u0012ZÃ¾ÎînyêMx\u008b\u00867ÏeßB\u0095\r¼\u00157Q.ÇÌh?Ï4vë¸Y\u0000òÜ\u00ad\u0006n\u0093·\u008d?\u0099r2\u0096\u0094\u007f+3ÑÉÒÿõå!EV¼\u0099\u0018êUÇ\u008a\u00ad@\u0085Íý\u0015e\u001dHîY7µ(\u0001{¸\\\u0093\u009d\u000b½ºå\u0099ÒC*aÈm_'\u008dMgÇcÊ\u0084\u0013x3\u008dÊ,Þîdef3\f\u0017hx\u007f©õ»Jj\u008fÀ\u0007\rÜ\u008fCL¡\u0005(ëVqX·\b¯e!÷aúGÞ\u0089\u0019Y\u0007\u001e4\u0090\u0093\u0098\u00ad&dâ\fö8½6\u008bÃ\u001a\u001eZxAªÃ\u0006\u008eàaYã®È\u009a©Ì¢°ç\u001fG\u001d\u008d{u<*pÕ\u009em±¾î¾óÂ\u0003\u0019\u001e\f\u009fßß¿;¬R,¼0ÇÂÎ¤å\u0086ÍtØNg¬$\u009f\u0007ádÑõaÏ\tÏU½0\u000f\u0085{%\u0010ÃÃ,°®=\u0094\u0095$\u00adáÝ)ËÌ¨S\u0019\u009b5?\u009c-Ê\u008b+8?nà#\n©S¦\u009bÖñ1Vb©\u0081ãÚ/V\nhø8óc±¥\u009dY;En:\u009e¤¹y½\u0003x\u0002\u009f\u0094\u0005ê \u008cÂ§\r|F>\u0016\u008c!JßtFW:©^OOàs\u0006\u009eÂçyJfK\u009a\u0001nyV\u000f\u0088\u0082À\u000eÉâ\u008b\u0006¾$c¢{N~\u00935\"YRÕôl!àòµö5\u0003_Ç7¸È\u0000nO\u0099ò6¨[PjÔ\"ù~\u000bßÑðm\u0002nÑ\u0096\u0081ïâ{ù\u009a¡æ=\u0085·kh)\u0097\u009e¹gÕ\u000f\nàhe\u0010R\u00ad\u009dÊ\u0005\u0001ü\b?ÑðcÂ¢ì1\u0003?ÅÏ\b4\u0019Í\u0082¢\u001bþ\u008fkòªëø\u0005\u001d@õòNv¥)¿2ðkü&\u000fÛ^\u008bá¤£_P\u0086Û¾%ÜJù»ÖH\u008aN\u008dæ9PÐï\n×W©]ë\u000bbuü\u0081^²Ô¤¿\u0010\u0018\r÷\u0006ðgüUÃ_æ.¾2\u008c\rü\r\u007f'\"ìô¤s9KÁ\u00962i³¯L&-]ÒñO&ï@ÿÎ\u0096³d\u009aþÛÀ\u007fðß|ì;§=\u008b.\u00ad/çÒ}\u009d:Ë\nÂrç@ë\u0081ñTë\u0090\u009d\u001enÝaz¦7=a±Ø1\tY{tÁþhÙ\u0004\u000fyyÛ;ù\u0084p§5Á6hõ<Û\u0018\u000b\u0095=n\u0015«\u0092.Ø\u0010]<÷î\u0092é·4Q3á)Û\u001b{\u0086:`gÂiÇ\u000bg²\u0013\u0013\u000eu\u0019\u000esmÚÉºá\u000b\u0006{[\u0003¢RèÌ=QÍþí\u0099;\u009aþ1×\u0099\u0092-\u0083zÐUÍub+\u008f\u0081e\u0002y\u001eYsHZ}l\u008c0ãó\u0010\u0098£ÕòSwawV\u0088\u0017\u0001#×ÎÜåv\u0099nÊ\u0096T+J¨\u008a\u001edzn\u0014Ë\r±B\u0096\u0094**d¥'\u0019`±Ò\u0010«D\u0088B&å%²kdQ;R\u0006(\u0005\u0087°\u008c\böhO\u0089\u0013ùdkØþLõf¯8É\u0010ke½\u0091\u008dÏü]Â\u008bÍ.Ô\u009a´ê>õ\tºmÊq\u0087u±\u009eÄ*O\u0018æa\u0087¸9µð ã\u0082ê@uÑP¨4\u00ad\u0093ãó\u008bM4ÅÉ´J~º\u00880«9)n¶æ7M79¦\u000bö<k6d¢\u001b2á\u0086\r\u0099\u000eõ_cÉP:ç4C\u009c.Î ¿F\u001cwÜô\u0016åU\u0099\u0002plwQ\u0013\u0096ëb÷\u001c\u0090\u0004\u0083Ê´\u0082¡Å\u00adeó[óÍ¶\u0093É÷çÕN¦tq\u001b-!³8Q\u009c´ò¯þú%MJ«dHïu³¾»\n\u00992\u008d×ýÿ\u0016\u000e'3¥+ùÏ\u000f\u001fVC\u0083Îq5\u009fs\u0015|\n\u00adÆq%s\u0003AÙÂs\u001c\u0094\r<¿²\u009b¯Å2þ\u00069³ISÉïÊ¦\u0019Ô55?\u0088ú¦È\u0083XÅÙjþ{Þ!Å$ÌßÕ¨âo\u0094\u0002\u009fO\u0016mdu\u001a\u0019\u009c\u008ez\u009cAu@\u001aÅ\u0006ëp\u008azY®Tb\u0085\u001aIÁ\u0015ü{\"V\u0014ÄîTê\u0003Ë\u0083ëgqêQÔ\u001cA$!fÐ:\u008b¶y\u00995\u008açf\u009as\u0016êÐ®ä\u0018ùs\u00059\u0015ò\u007f1\u0014x\u000e\u0016x®\u000fnV<O\nnQßz%ãI)£#A£¶\u0096\u0091±\u0015«p\u000e9î(\u0091±¾ \u0083×\u000b¶\u0091º\u0093c\u001fgÛ\u00954\u008bç\u0094Å\u0091\u001cºn\u0086ï\u0010¿\u0017æ°kOSsd\u0006±y\u0001õ\u0090Oíó\u0018¥óiÈ\u0005ô}\u000f×z\u008fá´\u0001\u009a\u0091wÚ\u001e¼P9\u00ad\u007f©pñSò<\u009e+\u0087E\u009fh÷7ç\u0090h¯:\u0082ý\u0089#0\u0013\u0094\u009e\u009cÁH_¨*\u0007»Ý×Ô\u001còÍÀ¡Ý\u0099v-ä\u000bN\u0085´\u001c¦C¾\u001c®l÷/ÛXû°Þ®Wo\u000eÜ\u0083H}`EõÕææ@}`9^5^ýæÛQ\u001b¼j\u0016¯Qsks %¤W®¨Îáº\u0090?¤çpcbSuÅ\u001dO\u007fæ\u001e¬m7\u0082o#aÈ\u007f\u0014zÈ\u009fÃ--G¡µäðö\u0090ñØ1v\u000e)ô¾\u0086\u007fçüt%C\tìæ,Æ\u009d~¢x\u0000kè\u008duôD#}\u0011E\u00820Ø\u008bs±\u008fð¹\u0084=÷¥ôä~R¾\u0088¿ì/1\u0084\u0014\u007f³\\\u007f5Fp\rFÙ\u0004\u008cáFbü&\\\u008e[¹û\u000e¤q'×ïáú}\\?Äõ\u0007¹þ\u0010\u001c\u0015\u008fëU\u0086\u001c.Æãp1\u001e\u0087\u008bñ\u0098ÅíäSI\u009aaÜ\u0081w2*w2ëò£\u0087H\u009b\u001fùÉ÷N¼\u008bßãp\u0000ïÆ]L\u009f(u½\u009b\u00124ê¿\u0095:ÜK<ôÐ¶÷ð[\u008d\u0097óT~ÔM¨¿\u0017ï#×\nÙ¤\u0096Dÿ>\u0005½\u009bTÞ31\u009a\u009agð\u0081¾\u0096'\u0089¾à\u0087\u0088\u0082\u0007r\u0098¹\u0005zð\u0091Y<\u0016\t~ô\b\u009eH\u0004\u008fÎà\u0013M-3øT\u000e\u009fÍá\u000b\u008cý<4O¢* \u0080*d(Ì£ª\u0093\u0004Þ\u0014ót\u001a\u009bØTJ\u00974åE\u0015]²¹è\u0092Íø2M\u00adàé6|EåQ\u0085|\u0018ç³QDÉ[V\u008c\u0083M9|5\u0087oöF\u0082ßÏá\u0087Á\u009fW>\u0082oåðË¾Hð·rþ{\u001fç\u0089Êà\u001fã\\l÷µ\bîWæð§v\u007fÈ\u0017òs³2QÙ\u001cüG\u000eÿ\"Á\u009f\u001eÇìý{\"Á§y²N\u0088Ò£}-¢\u001cqß\u0011Q\u0099¨\u0013þ\u0096\u0019¡=F\u0005u\"ì\"fQ\u008cÝô\u0095üæ\u001dÑDóAÄèlmWá Zq\u001d¶\u0010=\u0017\u0011\u00111öªc¸\u0081Ô72FoRN\u0089\u0091\u0092¦\u0015\u009drP9\u0080÷$^-\u0002â8r]\u0085-Â\u0010ÇÓ)\u00ad8EÔpä#ÇUâ\u0004QËè\u008d¡^\u00adU\u0092£!\u0096\u0089 r\u001e{»B)»\u0096séö6\u00962Q×ËB&êú\"G±\u0096é³F\u008652+ê\u0019ØÚö\u009cXÝ\u0092\u008fìýÍ9ñ¼û\u0017\u0095\u009d\u009b\u0019\u0083[XÏneÅ¼\r\u0011Bw>¦mEõÛDXÅ´\u008ao\u0090\u0093U\u00ad6°A¬+Ä4KTäÕú3yJÃÇ\u009a\u001e`Ó\\'Na]í\u00ad\u0013\u001bøé«\u0013\u001bùi÷Õ\u0089Fùõ×\u0089fù\u00adª\u0013-ò«Õ\u0089h\u00ad®\u0002ÄÃõñ\u0084¯9\u009eð\u0087üñDU¨*\u009eÐBZ<¡Gâ\u0089Úª\u0016þ°PÅgEÛ¼5ë\u0094Ü;)ÿÝÔí.Þ\u0006w³8ÜCýï%âÞÃ{è½%\u0081\u0019+XæGR\u009c©\u0002càb±IYV\u0087\u0001±YY¶\u0006½â,\u008e|¤í\u0012[8ò\u0093×VÑÎQ\u00159\u009e):T²V\u0088³¥\u001eb«8G]£\u0015è@þO\u0004B\u009c\u008bÀÿ\u0000PK\u0007\bC5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000)\u0000\u0000\u0000org/apache/maven/wrapper/Downloader.classE\u008eÁ\u000eÁ@\u0010\u0086ÿ¡\u0094\u0092\u0090x\u0000\u0007\u0017.6Î½\"\u0091H$\u0084ûj'´©ÝfUëÙ\u001c<\u0080\u0087\u0012[\u0084I&3\u007fþo&ÿãy»\u0003\u0098 í¢B\u0018hs\u00102\u0095Á\u0091ÅIæ¬Dad\u009a²\u0011S]¨DË\u0090\u008d\u000b\u0087Ð\u008de.E\"ÕA¬ö1\u0007\u0019¡\u0011~\u0011B\u007f¸|û\u008a3±]/ü\u008f\u008a´\u0098G\tû£\u001dÁ\u009b]\u0003N³H«³\u008b&¡÷ÿ÷s,µÑ\u0017\u0013pyEèü#\u008cKºN TQ\u0016ÙD5Ô\u00adv\u00adrìlØöì^Aë\u0005PK\u0007\b\u0084q÷\u0012°\u0000\u0000\u0000ã\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000org/apache/maven/wrapper/Installer.class\u009dXy`\u001cåuÿ=i¥Y\u00adÆ\u0097\u008cl\u008bÃ,\u0006ù\u0090u`\u001bd\u0090\u008dñ!\u0019D$YX\u0096ÄÚ`3Ö\u008eäÅ»;Ë\u001e\u0096d®\u0080m\u0012\bá\bIÁ\u0086p;Î\u0001\u0004Ó°²\u0011`Z\u0002iSÚ4éEÚ4mi\u009aÞ-½ï¸¿7{hW\u0092\u0013Ã\u001fZ}3ßûÞý~ï}óÝ\u009f½þ\u0016\u0080\u0015rÌ@\u0089`\u0091\u0013\u001fj²bÖÀ\u001e»)bí³£MÃq+\u0016³ãMíÑDÒ\n\u0087í¸\u0001\u008f`ö-Ö>«)lE\u0087\u009a¶ì¾Å\u001eH\njZÛ6oèíØ¶«µ½gÛÖö\u008d½ÛÚ·tíêÞ°íZAUÇ\u0004}O2\u001e\u008a\u000e\u00ad\u0011ÌØä(Ïh²Ï\n§l/*ø*'-\u0018J$\u0013\u0002oÐ\u0019\u008e\u0086\u001d+(¨í8£j\u00adY\";®\\cVrÏ\u0086DÂ\u008eì¦²\u0082¥g>×]HÉ£åkCÑPr\u009d ûç\u001c*\u0010v¶\u009c\u0097õ\t<\u009b\u009c íC)ªLÌÄ\\AéÒe}\u0015\u0010T\u009bð¡RWóM\u0098\u0098!\u0098Õ\u0011\u008aÚ]©Èn;¾Í\"\u0003u\u009f3`\u0085û¬xH\u009f³/=É=!ºè\u00923k\u0091\u000f\u0019mó\rÄm+i·Ò¯\u0082«\u007f\u008e}ý\u0099ÿ\u008cÍ`h(\u0015·\u0092!'ºfY&~!§is(l+»¶\u0091\u0001;¦{\t\u0003~ÁÜ\u0089øæw¼X$0;ûºúwmmëÞÒ»µÃ\u0087K°Ø@mQþô\u008c&\u0092vÄÄ\u0012,e\b\u0086ì¤\u001dÝ'X¼tjÊ,\u009búÊ\u0087:Ô\u001bX^ÌÑÝ3Ñ\u0080F\u0081\u0011J´EbÉQ×ãÛ\r\\J\u009d\\Ò¨\u009dlêÝÚn`%]?ùðÆT(Ì\u0010+ûËL\\\u008ef2Ú§iºep\u0092n\u0099ô\u009f^·\u0015¸B£}%£<\u009d9}^Ð\u0095Ò¤\u0084W\u0099X\u0087«é\u0000õ~\u0094ùÞpV\u000eÈê¹Æ\u008b\r\u0082uS\u0082\u009ayhÈ<¬jln\\UôªÁ}Õ°;\u0014mÜ\u001f\u008a©\u001a\u009bL´¢\u008d\u0085\u0097t2\u0002\u0004ç,\u009dÖ¶&\\á\u0005K{y+#6\u0090´\u0083þÂHû\u0019ÄPÜ\u0089FìhÒ¿/\u009b¸~\u001f®C\u0087\u0081O\t.<cþu8CCvÜD§ºÍ\u0013\u008a\u000e:>lÁõ\u0006ºé\u0093\u008f\u0095µ&¶¢\u0087åÄ\u0094Ò´\u008f\u0087v§ô5S%gQ6\u0005è½^ÁÂ\\eÓ>\u007f§r÷Ó1V|Ô?\u0018w\"~õN¿\u0006é\u0086I±9c\u0002äb£úo7±C³qv(±!<l\u008d&rÂtó&\u0013;usfn³7J\u001b÷úp3v\u001b°\u0098pg\u00074jð\u0080`ïÇ¯î³ã\u007f\u0089\u000bC\u0085¾¤m6\u0086\f°(®ø¤<LìA\u0088\u0088Â0m\u000fÅ\u0014_\n\"\u0094C\u001c\u001fö\"b \u009c+Þì{\u0013Qu\\¹=¢ýB\u0089b&nUv3È®Û\u008a3ý\u0094Nw\u0012&\u0092\u009aÚ\u0006wº¬\b\u001b\u000ea¦¬1fÅ\u0093º=¢\u0095J\u0094¸xi±äéêVéo3q»+;h\u0087Y\u0001^ÜIÝ\nS¨\u0012\u009fÆ=\u0006î&Ë³h&Ú\u0005\u000e°.\u0096\u0016gf±.\u0019É\u0087LÜ\u008bÏ°Fi\u001díØæ\bæLRzÙv\rÌ}&îW_TMª\u0080Ö\u0010\u0081Mð\u0080\u0089ÏãAò\ts\u008fïØLü\u0093ùd\u001ey*ÜÔAª5\u0095xXñö\u0011&kñ\u008en<jâ\u008bø\u0012\u0019\u0086\u00926SËa÷\u009d·´\u0090E{ö=Ù<\u0086Ã\u0006\u001e§nSwM\u001cÁ\u0013¬ý¨=\u0092\u009c\f?ÙbóâËì9\u00adêyuu0\u0014ç[\u0087¥ªþyÚÄ3\u001ah-ü\r»\u0013N8\u0095´5\u0007ÕæçL<¯¾«ÈD\u008dV«*GM|Åí\u0015{¬D\u0017¥zñU&do\u0094 \u0018Sþ^|\u009dúø\u0093\u008e_y¼hâ%¼ÌÜI)ÁDÌ\u008a3f\"f\u0006^\u0011\u009c;aÃÖT4\u0019\u008aØ\u0005}òUÁ®\fâ\u0004\u000bÂä_R\u009bXâ\u000f:vÂ\u001fu\u0092þ\u0001'\u009a´BQ¿\u0015\u001dÍ\u001b\u001c²\u0013\u008dþ¶\u0091X\u0006\u0080©ß`(\u001aôÛ#Ö@2<ê_1á\u0098Fídß2ñ\u001aÒLÙA'\u001e±èÛ+§é1;Î²·}\u0013WhÌO\u009ax\u001dãl®t¶¶¹öi¢¥N{ÓÄ[8%X\u0090°\u0093m#ö@*©\u001d¡Û\u008eGB\u0089\u0084\u008e\u0011Ó$q\u009f\nø\u0015\u0013¿\u008awèþDh¿í6ñv/Þ\u0015Üx&\u0087eý\u0094 ;\u001c\u007fä\u0093y\u008bø1P\b\u0091\u0082¦\u008f\u0089©L¿BÕzã\u0084®\u0099Åµ-¨\u008cì\u008b\u000eoµcNfÛ*ê\f\u009c\f¶\u0013R¬\u0082\u008e@\u001f\u0085'Ã§ å\u0093Ã7ù»\fóÀ;sÊ \u0097\u009bÀm*äKFbyR#\u0098\u0081\r\u0086&è\u0082ÇìÉ`Áh\u0005u\u007f^ñø:\u001aË\u008d°þI'Ö\u0016K_G\u000e\u0015=¡¡¨\u0095LÅI~é/@§)Ç\rüqn4u\u00896ÄãÖ¨Rúð#T)Vü©\u0089?Ã\u0087\u0014£\u0018¨§Ü<\\¶cj÷ù\u0089\u0089¿P\u008c¨\f%Zsy¢ùù\u0097&þ\n\u007fMS\u00ad`pÒ\u009c\u0097+\u001f\u0086Ñ3èv!Áß\u0099ø{eS\u0011Jô3û\u009cá\u0084\u0017ÿHgrÔhb6\u0018ø'ÖÈ\u0004\u008bî¸3`'\u0012ÙQÂ\u008b\u007f!ì\fì\u00898A/þ\u008d2W_~¹êö\u001f&þS\u0011o6\u008bp\u0093\u0015u¢!ú;\u0003y\u001fá¿µ±ý\u008fBñ\u008eé{ÙGø?\u0013?Ãi²æ}!î\u0096qa\u0015guXã\u0013\u0091RCxK\u009c3eÓ\u0014\u008f\u0016©1l\u0085\u0092\u009b\u009d¸WÊ\u0019Ý\u001e;ÉêÊÕº?6Qì~\"P\u008bß\u0010/ÕÊyzcjpÐ\u008eÛÁ\u00ad¶öCC|¼RæöÚ£±T\u0092*ÛV$³\u00adº\u0098¦Ì\u0090\u0099ÌYZ]@Ài¾`z(Ø \u0001\u00152\u009bÞ\u00909ôñÒiIè\u000f1d®\u0012\u009dÃÔ\u0099 Ê\u0088U4\u0097yE9µÙÅÒ¤ªT\u008d*¯Ô0Øµ\u0089Ú(\u001få<\u0002®\u009c/Xû±p¶\u0098í\u001aUh¡)\u0017ºc9\u0095\fêõP\u0085mòÉ\"¹Ä\u0090\u008bsú¨-[òmÅ\u0094Z=¢sU'#d\rñÐ\u0012¥ç5ká\u0084ìö(\u0085ÄS1BâDG\u0092:AÝ&'\u0015\u000eº\u00ad'ñ\u000b\u0002É¹^êMipGöa+N\u0006M\u0082\u0015ÝaÛJØì`~½ª*\u0016§x\u001d\u001dõ\u0087\u0006ý£NÊ?Ì«¿¢p\u008a4.liY¸\u008bk\u009d\bËÝt×\u009b\u009c\b\u000f²´LªéÄ³¦\bJb»ÙU§¦inê&|²7Ï\u009d&\u008fyV/Î\u000b:¦Ï<ý\u0010\u0090H\u0006\u009d\u0094\u0016Â´\u0011¡\u0091aÆ\u0080\u0012ì<I±ï×ä±í\u008c>^ã\u0095õ,\u0018'Ñ¨C\u001coÆ²Ñ\u0094Mz\u0007®ÔÑ5îÐËÉÑ\ni\u0093k\fÙ\u009c»ßf°NáÔ6åZi§-½=ùï+\u0005»z3\u0096O\u0099Ò!\u009dä\u0098t:\u009ca¶(\u0086câúZH=M\u008b÷Ê\u0016-è\fH)·ëMÙ*=z£\u008e\u0006í\u0011½\bO{«¥NåN¢Ë5j¯ô\u0099Ò/7¸\u001eKd\u0090e\u001a\u0014bb\u000fìaØ8Ð2dÓ\u0012\bçX5×H¤\u00064\u008a\u0086ì\"·\t;8\u00895e[\u0093Ov\u008a¥ wJW\u0003¦\u00045N\u0006¯\u0002:\u0001\u0010U\u008afÒ¶h*bg\u009bv¥\fIÈ\u0090=E\u009c\u000b\bL¹E'ÓJ\u009dLÛÂ¶^n\r\tç0¬P\u008f6\n\u001bõ\tÛ\u0086þèÍDb¦Üê^\u0018\"{µ_ªn\tE0z¥©0\"\u0085\u001cÖL\u000fd\u0086ðêrþäôÝ\u0092JæI\f\u0019Éõ\u0091l\u0013+ÜõÉ°X>IÉm\nt·«Kòr\néÜö r§)wÉ§9Ñ\f8±Ñ\"¤m\u009c\u001eEÏÄLý{\u008f)\u0007Ô\r³8kw:q;ëG×\u001f\u0087L¹W¿\u008d\u0095\r\u0084\u001dÍÔRw¾ö\u0004mM\u009dùg\b\u001aC»?7\u0093Ì\u009fêÇì\u001cS¦á\u001fÍWýTOûä!yÄ\u0090\u0087yã\u0098N{S¾ \u008f\u0092Íp\u009c\u0097\u001b\u008a\\ºcc{»v\u008b/Éc\u0086üR!\u0004G\u000b\u000e=.\u0087i\u0080¢6ÏòÌ²v=qH\u0085\u001dR\u001c\u008a\u0016\u0001H\u0081\u000bi¼\u008b@ó¦÷%Óh·\u001bv2Ù±\u0091Äa-\u001d_\u008f\u0093\u008a\u000fØÙQ.ÿù¯QY\u0010@Û£Qb@Øâ@¨cÎ\u0094q\u0010\u0017q@)\u0005øW\u00832\u0094óÉàS\t¼¨Ò\u008f\u0094\\Wé'Jþ÷ro&fñw6\u009f\u0002¤Ñs³êÆ0§nùk8§®þ5Ì;î\u001e^à\u001eóð·\u0091¿M¨À¥<º\u0082\"\u0000\u007fæ\u0018ÎÅy\u0080»R1â®TP\t×çã\u0002þ_Èw\u001e>]¨\u0002K\u0017P1ª!?¨ºè\u0004.îjx\u000fë\u001bÒXv\u0004W\u008e£)0\u008e\u0015\u0081\u0086\u0013X5\u0086ÕU-i¬\u00adZÏ\u009f46\u008eas§îU]Ã\u009d\u0086Ì»\u0013h?\u0006ïò4º2[Û¸U\u009fF_f\u008bï\u0003Í\u001eþÞØ\\V÷-ÌãjWKyMy\u001aÁ\u0016£´Ù[í9\u0082Ê\u001a#\u008d[\u008eà\u0086qì\rèÚQFº\u0088guHåÄ\u000f·TÔT¤±¿ß\u0015uG\u0091(²?§¾¦â$î¢÷+ôøÁ~O³We}¶¥¢®¦b\f\u009fkñU{\u008f ªºì\bfÔøNâ!Áa\u001cÕÕ\u0017x\r0\u008f¡¡Æ<\t&ãÛØÛRé\ny\u0092Bj*Óx*on]Må\u0018\u009eíWÊ\u0017\u0004GN\u007fÏ¥;¦tF\u0086®êküQE\u000b\u000f\u0019úâ\u001b9=òÒ\u0017\u008cã\u009b\u0081ªã\u009e7Q\u001a(\u00adï9\u0081_\u001eÃØ©º\u001a_éI\u009c(QEÆð\u0086R¿Í:x:KþíIä\u0005Ô¯¸é§9ó .æïåLÃfÌÁjý\u0098\u008aV\\\u0089kÐ\u0082\u000e¬Å.\\\u0005\u001bë8þ®G\n\u001bq;6á.R<\u00806\u001cÇf\u008c\u0091ò»¸\u0016¿\u008fvü\u0018×qÎïä¤ÞÅq·\u009bÃêõr>¶Ê*ôH\u000b×\u00adè\u0095=è\u0093\u0018úe\u00047È=\bÈcØ!_ÁMr\u001c;å=Üìæë\u0083Ì\\f]._¹z\u000fßaV®À<ü\u001a~\u009dyÚA\u0004Ë¬Êå}Ê/§5¶Dð\u001bx\u009fù»W\u0086ð\u009b\\\u0095!%7á·ð=îß.}øm|\u009f\u0019}\u0097ôà\u0007ÜõRÿKñ;|WA\u008dÿ\u0006¿ë®>Â\u0087ø=Zã£æ\u000bñ\u0007|W\u0089\u000f¨\u0084Iù\u0099½\u001f²zJô\u009b\u000e\u007fÿÐ\u00ad½?rËóU®´\u0090×\u008fãG\u00811ü¸\u0093i|Ëa¬ä¿?\t´\u0094¿Õ\\VÚì9\u0086ójÊ«=+»X\u0018\u007f~\u0018\u0095õ\r'ñÓ\u0012ô\u001fôHµ§ºìÙÓ?©\u009f\u0088ÍB\u0097_\u0090\u009aÚ¬ÔAÔb\bõØ\u0083Ë¸^\u0087°ë«:·æ×çk{½k\u0007[=ã¨v\u0094ðÔ,Z÷}òÌÙ\u0091Ùû!÷JôsA\u0006^ä\u0003z©\u0082\u0014\u001f\u0010^þö0<ÇµÒ\u0096Wý\u0003\u000bªSºÆñQ üMÔ\u0005J«þ¹'à©ú×\u009e@\u0019Ëêß{Æð_-\u009e\u001aO\u001aÿÛRVS\u0096f®ã\u0002Íõ¹R\u0096©¼§\n à¦q1\u0002ãR\u0011PÊÊ1\u00995&U-åãR\u001d\u0018\u0093ù-Æ1T×\u0018seA&qk¼=i9·\u009fµ)\u0017\u0004Z¼ß9ýS\u0096\u008eø»\u008ea\u009e+Q.â²2³\\¬èäÏÈ]V,W\u0096Ï\u0095Fþ\u001e§µÕx\u0006ÏË\"÷ÿË²$\u008b\u009b;1\u009f¿1zûVú&\u0081¹H\u0092b\u001fVa\u0098U0Â¬\u001f%øîÇ\u008d¸\u008d\u0014·su'î`\u0015<ÄÿGp7y\u001dÀQ\u001cÄË8\u0084Wp/\u0088%x\u001d÷Ñç÷3\u0083\u001epã´\u009f\u009e§oóqú@.uã4\u0017ïÊ\n®T·wd¥\u009bÉ«\u0010\u0091Ur\u0019#Û\u0082A¹\\\u009a\u0099É·¢IVË\u0015Üß\u008fÅr%ëÉ \u000eU²\u0086o¼x\f\u0015ÙÕQVÄZ¹\u008ag_qWë¸*ÑËp¶\u0089ÜèF\u001d8\u007f®\\}B6¼*\u00adi¹®\u0083.êJKwÉ\u000b(ó¼Xúâ¤\u008eò\u0010»ÀÃ|~\u0084Ú?êZ3/Ã#kÍ\fÌ\u0092mn#+Ñï~YIÔ\u0084z\u0003«\u0097»©Þ¸<-½\u009d¥ë\u008eaa\u009d\u009bYõ\u0017¬dj\u0011$\u009b=\nðe¥/\u001e,\u0095\u000bêßzöô\u0087<±\u007fB\u0089E4\u000b4ÑÀãtâaÂÔ\u0011¾{\u0002Kð$\u0096ñy%\u009es\u0095º,#.ïâÕnù²#Óa\u0001ÙNn39ÿï\u0090\u001béâE0\b\rï»Íî%\u0006.ßú\u0098\u001cZ\f\u0095,òr¾90.;\u0003ËÇäæL\u009aífÆ\u0005\u001bN\n§ò·eo&á#\u00871_\rª×\u0087(MJ\u008bÓ\u007f\fW\u0015¿\u0083£¯ëj<ú&>.)\u0096Áp \u0088fLFÇd\u007fZî \u0080»µg\u001cV\u0091\u0007'úûJ7\u0087¾FÕ¾A%_bî¼Lµ_Áb\"ÙjâO\u000b^#ò¦\u0099½/17Nà\u001e\u009ct\u001d³.cJÞ1\u0007ä3®ctõY7÷f#Áùý>:Æ\u0087Q¹_>GW,$R? \u009f§SE\u0007ÓÉ.¢ã=®Ãkçxð\u0086WK±¾¡´\u009a\u001a?¸¼!-_dG\u007fòôG\fú\u0091ú´<1aD\u0006ÔÞ J§\b7o3\u009a§\u0098HïpHù6.Á»\u0005\n×æ\u0015®\u0095'åË®Âµò\u0094<\u00ad°\u008f\u000bå\u0019y\u0096\nWÀ+Ï1¦\u001e\u009e4³«\u0012y^åÉ\u000br\u0094ÿõ\u0083\u0090\u008d\u009bÙfäÿ\u0001PK\u0007\bå¡[\u0007Ü\u000f\u0000\u0000\u0088\u001f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000%\u0000\u0000\u0000org/apache/maven/wrapper/Logger.class\u0085SmOÓP\u0018=w\u001bkWÊÀáP¦2\u0010Äm*õ%ñ\u000bÄ\u0018\t&&\u0005\u008c3%á\u008b¹«×RÒµó¶\u001dñ§ø3Ä\u0004\u008d\u001fü\u0001þ(ãs»\u0086\u0017\u0087±I{oÏs\u009eÓó\u009c¶¿~ÿø\tà\u0011\u009eh(04#éY|ÀÝ\u0003aõùP\u0084Ö\u0091ä\u0083\u0081\u0090\u0096\u001dy\u009e\u0090\u001aJ\f3\u0087|È\u00ad\u0080\u0087\u009eµÛ;\u0014nÂ 9[o^ìv·\u0018Ø>\u0083¾á\u0006~è'Ï\u0018\u008a\u00ad¶ÃPÚ\u008cÞ\u000b\u001d\u0093´KdJ»)\u0006sÛÙÙ{\u0097÷\u0019\u0098Æ\u0015\r3\u0017Ä»\u009fâDôMÔ0ËPöD\"Â!ÃjË>GI¤\u001fzëíqÈ@\u001d×4Ì]TÌj&®c\u009epñ1åAüÊ\u000b#)6y,\u0018ê\u0097iïWÀpÃÄ\u0004Ê\fÓ¶\u001f\u008a\u009d´ß\u0013ò-ï\u0005ÔS³#\u0097\u0007\u000e\u0097¾ºÏÁòF6¿\u0081\"\u0016M,@W\u0093\u001fø1Ã\u0092ý\u009f\u0088×\u0089ê\u0087\u001f¢\u007f¸q*\u0014Õª\u0089»hQºQJá×G4?²^\u0013'!¦à}\n \u0083û\u001aî1Ì^R6ñ\u0000+ôÞ\u0006\n\nB\u0092êÇ\u009e\u001afì\u0089dç\u0088Kb\u0018Ý(\u0095®xé«\u0001'Gf×\u0014\u001dK\u0014P\u0091¾\"\u0086\u0086J\u0089v%èÐèd¨ÐÝ\u001a\nPGµfÔÌï¨\u009eàêW4¾\u0010RÀMº\u0096\u0089\u0007ÌáV\u0086(\u009d\u0085Ó^\u008bVU\u009dè|Cóï\u0096zÖb\u008e\bdã6\u00ad\u0015,c%o~NlU«\u001e£ñ\u0019Æ1îtNÐ>S©f¶çI\u00ad\u0081)BÎÔªdÚÊÔ\u001e\u009eª=ÍÕô1\u001d#³Ý¤\u0091\u0017Ïiè¹\u0006£ßK1\u001fÿ\u0001PK\u0007\b\u0084'+ãü\u0001\u0000\u0000m\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000/\u0000\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.class\u0095X\u0007|\u001bW\u0019ÿ¿Ø±då²ä:\u00893\u001a%Í°e[ÊhÒ4I\u0087l+Äñ¬íØuÒÖ\\ä³\u00adTºSN§\u008c\u000e\n¥@Ye¯2\n¥P6i\u000b²¨iSV\u000beïQöÞ#@\u0081\u0002\u0085ÿ»\u0093µ,\u001bóû%º{ï¾÷Íÿ÷½ïóãO?ø0\u0080íb\u008f\u000b\u000b\u0004\u001a\fs<¨&ÔÈ\u0084\u0016\u008c«'5=xÊT\u0013\tÍ\fvÉÕ\u0090³èR£º\u000b\u0095\u0002Ë\u008e«'Õ`LÕÇ\u0083=Ç\u008ek\u0011K`e[ø@èpçÀHWh0Ü=r¸?Ü7r°§+,àíÌS÷[fT\u001fß'°¶\u0084l¤·¯§7Ü70<Ò\u0011\u001e\u0016XÜjèIKÕ\u00adA5\u0096ÒÜð\b,µõ\n¤\u0092\u009a\u0019\u00980â\u001aE\u0096ò\bw\u000fÊãn,&ù\f=\u0094®Áî¡\u0091Áp_KO\u007fØ\u008d%\u0094bïH\u0092îP\u0017·\u0096Moõ\u0086úû\u0087zúÚÜðN\u009fë\u000b÷ö\u001cîëtã\u0002\u0081EÜ\u0091\u008cúÛ{ºÝX%°pg`w`§\u0080[~è\r\r\u001ctc\u008dÀå3\u009cê,\u009a\u009d\u0085}¦h«ÙÞj>\u0016Õ\u00037D\u0013d·?\u0012\u008bêQër\u0081\u008aú\u0086A\u0081ÊVcTsÁGÛK}Ú\u0092\u008aÆF5Ó\u008d\u008d\u0002Õ9'y°\t[\\Ø\\\u0014²þ3IK\u008b+Ø\u008azÚ2®Y½¦ÁèZg\u0004¶ÔÏ\fVÃÌ-\u000führ¡±\u0098\u00adýMA3\u0002\u0002®\u00932p=c%,\u001d´\u0094g¹\u001eÛ\u0014lÇ\u000e\u0081ªýY«kË©3èÆÅtE0\u0010ß!\u000fíVp\töð\u0090\u0084¨>*Ð</\u001b²þ²åîU°\u000fûéoËp>\n\\P_FÇj0¨\n\u0016¢\u008aøê\u008cêZw*~L3\u0007Ôc1MâÜ\u0088¨±AÕ\u008cÊµ½éA\u0005Z¤Që¨°5\u0011M\n4vÎ;Õ\u0098&\u0095q>\u0005VÔ\u001f-ç\b\u0001OøtDKXQf\u008b\u000bí\u00025yªÜ\u0017\u000fµîPÐ\u0089.Òge\u001dRMÆnÚÆ¨\u0011<\u0010\u008diû$e\u008f\u0082^\\%°<K\u0099ÅFT£î\u0017Ö\u0017Ó\u00979Þ¯`@\u001ew\u0099\u0086aµEM¹7¨`HºwI\u0096å f&©\u0097\u001bLôÚ\u0001õzzÌgÛîË\u001aïóà(®uá\u001a\u0081õ³z«Ó\u0018\u001f×L\u0005×IÄTFõ1C\u0082ý\u0099\nT\u001cc\u001eçam«¾jÚÖ\u0094\u0015\u008d\u0005ó_l¥G\u0015h T×%T3©9é\u0091'9`\u001añ\u00909N&\u009bÊ\u0086¡\u0080o\u0097\u009a Ã\t\u001cw!J\f\u0095\u0013¨àzÄ\u0088ÖDÊ\nÅøâ\u00ad/9ß0(UÒ\u0015\u0018`\t¨QGGK\u0015bpJ\u00031XMÛé\u008c$X\u008a+\u008c\u0014\u007fks$½ÔÓ¢¶\u009a\u001a§v'qÚ\u0085S\u0002õ³z6\u001b\u0085ði-\u0092²\fr=\u0083\u001bèÁ1Ã\u001c*Å\u0084\u0094.Ð[¢N\u0081\u0093BvRÊ\\ £æ+q\u009f\u000b7\tl\u009c\u0095¼]Þ\r±\u0098fºð,\u0001ÿ¬tmÚ\u0098\u009a\u008aYmÆ)=f¨vu|¶Ì©\u0093ú)\u000fnÆ\u00ad23\u009f+°µLÁ(\u0097n.<\u008fålVi½ª5\u0011J&µ8\u008dµqÿ\u0002\u0005·Ë¤[lÓ\u001dfM>h\u0097äÛð\")9áÁ\u008dx\u0089|{©íÂÙÍÈé¿ov¢\"é¶²/c)\u009c\u0095¼\u0085é\u0099´¸\u0090\u0085¦ßRMKê|\u0007Z$@^©àUx5\u0093X³\u0003Â\bGË!\u007fver\u0001\u009a\u0083¦\u009c\u0006vM«Tíd«)#\u00915¤\u0018iÜH\u0094\u0080qYrFº¬(\u009fú,â§\u008a\u0081G0Í\u001f¤¼gû£ãºj¥L\u008a=4\u008fÚ°\u007f>8»\u009cè\u007f«@hV=Ø\u0013\u0004KKB«\u0011\u008f«ú¨¼\u0093Ø9\u009dÔ\u009cpÞ\u0085\u0016\u0017Þ.\u0010\u0098\u0093WÁÙ^Yÿxðn\u0089\u0083»ðN\u0005÷â]´3bècÑqÛÎ\u009ds\u0000µ,7» Ý\u008d÷(x/Þ'\u000bZ,f\u009c:¬_¯\u0013Õ=ÎÕ%°£~\u008eêP\u009e\u00addú\u0001\u0005\u001fÄYö_vá\u0016\b\u0097\u000fÂ\u009c\u009cmv£\u0005ü÷IÓïWð\u0000>Ä\u0014\u00888î\u0014hû\u001f\u0086ÏäÓ0³ñq!ÍzP\u0004\nÇ½NÈ\u0004Zç\u00162\u009f¸\u0013\u0098Ë#¥î\u0012Øöÿ:Ø\u0085\u008f²ù-L77\u001ef~9}x>í<\u0098Â#²\u008c}Là¢Ùo\u0082\\\u0019õà\u0013ø\u0094\u000b\u009f¤J³jTjçAª\u0016\u0093·ý£x\u008c\u0018âå>óR\\_¾;)¸\u0098§ð\u0019\u0005\u008fÛ%Y¶\u0007ª©é\u0096$\u0095_>§àó²I©Î}\u0091»_Tð%¹ëân·\u001a§\u0007¾Â»û\u009aÀqÕÜäÆ×Ø>\u00179Â\u008fo(ø&¾E¿\u0099Z\"¦F´\u0003Q3Iðì\u0099ß\u0015S®-\u009eÂ\u00ad\u001e<\u0081ï¹ð]\u0016¬<AkLM²\u009bø>~à8\u0084®°\b1æS\u009bát\u008d\u001b§{\u009e$+\u0096\u0019µÎ\u0004KiÈþGø\u0089\u000b?fo77¥\u0082\u009fâg\u008eßä\fÒo¤Ì\b\u0013ní\f\u0011ù¯dþ\u000büÊ\u0085_²w\u0098\u008dFÁ¯ñ\u001bg\b\u0091Ý³\u0094WÐ\u0097ê\u009a\u0015äÌEF¿Ã\u001f\\øý4\u001c³û\nþ\u0088?1ù-ãp_û\u008ccí\u0004ð\u009f\u0005Vç=Ö\u0097Ò\u00adh\\+h\u008cÏã¯\u0012¸OÊþ°À÷\u0003\u0013¦qÊéY\u0088Ö¿ã)\u0017þQ,»]Á?§ÑÒOøJdü\u009bW×\u0098\u008d&?þ£\b\bA¨h'Rj,Y2ÉLOAGÜ¢\u0082\u0013E«ªë\u0086å\u001bÕ\u0098¼qæ\u009f/\"C\u009bà\u0085îcÏåËæ\u0084\u008f=»o\u008c½¨/B÷\u001dS\u0093\u009aoëæäÖ\u0000Å\u0089\u0085\u008a¨\u0012.\u008a#}\\%Þ.-\u0083·£e4(\u0007¸óØF£\u0085G\u0011\u008b¦¡/\u009b\u000b\u0089Äm.Á±yM¡#úÏè\u0096z:çS\u000eQ±\\ \u0097\u0014Ç\u0083.!dÖuÎq|\u009f[p¾Þ\u001dì\n\u000f\u0084\u009aÛ»\u000fdËBÔ\bXö\u009cà¬\u009b§ËDÂ\u0088\u0017åß\u0013b\u0085\"V\u008aUNFôiI\u001bd¡¤Óü\n4Ì>\u001a²j´ëlÊ³}²[¬&vº\r\u009f-Ð\u0097\u0017Â\u0090¤ôÑ\u0080ìòyGN\u0088u\u008a¸P¬gèe\u0087\u0096ÇQ\t;\u000e\u00adb\u0083\u009c\u008a\u009dÑG\u009eÞâ\u0016\u009bh*Ed7}º=Mú\u0092\t-\u0012\u001d\u008bj£¾¨î;&ÇT\u009f©E´hÂâÓ±(à\u0011[D½Kl\u009d\u009eø\u008aÅ)¢AN\u009c\u000b#1#©¹\u0005ÇôM\u00adF\u008a|\u008aa6\r¬¬|Út^43\u001f\u0004çwÿÜ\u0005«0C\u0098yæ\fO×\u0096uÃô_q\nËvm\u0001Û<\u000e8Ë\u0089\u008b\u0015±Kþ\u0089¢\u008a±Ôô\u0093\u009c^\u009d¢áôyµ¥ãr@òÁ\u00066Þ\u0015\u0000ªQ'\u0007u¾ÕÁÅ'\u0081É÷\u0005öþ¢\u0082µÂõ\u0092\u0082õR®\u0097\u0015¬\u0097sí-X×p}AÁº\u0096ë\u0015\u0005ë\u0095\\×\u0015¬WÃÃ·µXÇ\u009d\u000b¹s\u0085\u00ad\u001d°f\në\u0087½\u001b2¸(\u0083\u0086I\u0004½;ÓØ\u0095Æ¥\u000fà²ûì\u0083Wð×Ã'à#\u0093f\\iï\u0082l¶ç\u0098\u0005ù\u0014|.ôO\"\u0094?Veo®·\u008f(\u000e\u0001ZÑf{%\u008c\u0003¤z\u0006ß+ùå Íæ)jèâ3\u0096Á¡ÎÆ\fº»øÓ×\u009dÁá½\u0095¶\u009aWSÁºJGÁ\f\u008ed0²waÝB\u007f\u0006\u00914Æ\u009b3\u00887Ý\u008f\u0013\u0019¤öVÕUù§pãð\u0014n\u001eöÞRW9\u0089çLá¶á\f\u009e?\u0089\u0017NâÅS¸cx\u0012/Oã\u0015ym\u0003\u008c\u0007°\u008dúl§~;\u0018\u008d\u008béå]Ø\u008aKÐ\u0084=|Û\u008bK±\u001f-¸\u008c³óå¶U\u0007\u001d}ñ\u001a¼Ö¶d\u0002\u009dx\u001dí©F\u0004¯çÛ\u0002r¹\u000e\u0003|« ¯a\fÑ'\u0095äv%Þ\u0080;é\u008d\u0016Öè7âMÜõÈÑ\u009fôo¶õy\u008bí\u008f\u0014OÉ(m\u009dÂ]T÷m\u009dS¸\u009bÏ{º\u001a\u009bÒx\u0007ÿ¿{¨±É\u009fÆûÓ¸ï\u0011|ølÎ\u0094\u0015d\r\u0084èÎ\u0016\u0082¨\u0095àhcìÂ¶Ê>\u0087eVe7Ã3\u0089\fU^FÈ|\u0004\u000f\u0092\u0083G\u008eüÙÈ\u001e%'\u0019¸\u0006úz\nSÒ\u0083Þ\u0087&q.\u0083\u008fÓåÙM\u007fÁVÞ\u009fKlAí\u0014~\bõè(@A\u0083í\u0011\t«\u0001\\\u0095\u0015´+\u000b¡E´çÓÎ¿¼=\u000e\u0090º\u000bX,²\u001d-YôæX\u0084²t+m\u009dÒø,ÿ\u007fÁûeïWÓøú$¾]Ê®¯\u0080ÝÊ\u001c»NteÙÝÃØJ \u001fò\u008a4¾\u0093Æ\u000fÓøy\u001a¿í¸\u0017\u008b\u0019\u0088óÃ\u008d\u0093øË9\u008aø\u009b÷_i<}'êäf\u008dXPù\u0010*\u0086+üý\u0019Q9)Üç\u001ceDõ¤PÎÚ²\u0096Â+\u0016g5YmW\u0086«¹7L|\u001ca~^C_]Kt\u008dä\u0082µ\u0014\u0015b©XÆÕZ\u0004²o5¨\u0016Ë\u0085×Îî!bÒÑøIbK\u0006þ\u0088WÔ\u0088\u009a´¨íð?\u0086%\u008eZu\u008e.\u0013Ã\u0093bMg#\u0015ZÛX#|i±±«)Gs\u0091¤iÚ[É¯\u009bë*ÏvËgó¹\u000eç£ß?)\u009aÎQ\u001f\u001f5?`×\u008eVúê ß»ì§c\u0091\u0004\u001c0Ê\fÐ°\u0098\u0088^Å\u009cðá863g\u009a\u0099)Û\u0011§¾\u0006iOð¼ÁÓ\tV\u0081\u0013Ä\u0087I.I\u0006Ù²-÷Ó\u0096j´\u0089 Øfû¡YlgÆ\bò¨\u0013\u001bèµ\u0005¤Tè\u0083\u001dvÔnÏEÍ \u0086ÒËÛ½Õ¬i\u001dþG¡Ø\u0011\u0090î÷*\u0019±s¸£pK¾Ü\u008fËìà ((gø{\u0003äßFjp\u0013+ÝÍØ\u0082[r\u0090©B#\u0085J:!vË\u0093â\u0092ÿ\u0002PK\u0007\b\u0011ps½]\u000b\u0000\u0000Ë\u0018\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000>\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.class\u008dR]O\u0013Q\u0010=³-»PWX¶õ\u0003?A\bi\u0017tåÍ(1!\u0010\u008dI£&\u009a>ø`rÛ^ÚÛlw\u009b»[ü[\u009aØ\u0098øà\u000fàG\u0011æ^\u001ab\u0081\u0087¾ìÌ\u0099\u00993gîÉ\u009e\u009eýý\u0007`\u000f\u009b\u001e\u001cÂ«L÷b1\u0012\u009d¾\u008c\u0087âD¦ñ\u000f-F#©ãÏ¢è\u001fä¹\u001c¶\u0013©·\u009aYG$G*/´j\u008f\u000b\u0095¥\u001eÊ\u0084` ND\u009c\u0088´\u0017\u007fj\u000fd§ x]\u001eú¦F\u0084å¦íª,~§\u0012ùfÚ:R\u009aà\u0016}\u0095o½$Ô\u009bóé3ÛÝW©*Þ\u0012ÞÏM\u009a=`\u00165Z\u0084òaÖ\u0095KàS},b©\u0082\u0012\u0002\u001f\u0015¬\u0012JõFËtª><¸&»ãc\u0001.a¥©Rùq<lKýU°\f!´æ´\u0084V\u0006O\u008beóDÂë9o½n0?9ìÉâÿ\u0092õ.¨7®\u001a[á9¶Ü \u0006_²±îÈ\u000b\u0010Î\u0088¼0<\u0082ÿ!M¥>L\u0004×s\u000f\u001b\u0084íù\u008e$¬^;\u0013\u001bìM\u0089ÿ¨\u0012Bc\u0010g¡±\f\b\u0002cªíðU¸Å_\u009fÑw8(s¬E;\u0013Ü\u008eþ`%Ú\u009d \u008c\u009eOPûÅu\u0007wí\u000e3Óe¾Ä2\u008eQE\u000f÷¸²nµj¸\u008f5ÀfFË±\u0099Q7Z\u000fðpª\u0015s$\u008e\u000bÑo\u0084?/\u0097»¶8´\u000bý\u008b\u0081éBÂ£\u001bÉµ«äâ\u0006²\u0083Çöû\u0004O9V,}\u001dÏ@çPK\u0007\b\u001coÏI»\u0001\u0000\u0000t\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,\u0000\u0000\u0000org/apache/maven/wrapper/PathAssembler.class\u009dVù\u007f\u0013÷\u0011}kK\u0096,\u0016\u0002\n\u0098Ú`*ÎÊ\u0092-\u0085&´\u0004\u0003\u0089/°RËv}\u0081q\u001b²\u0096\u0016yAÞUvW\u0006·i\u009b\u001e$mÒûNKzß§Ó&\u0092\u001b7¡÷\u000fý£Ú¾YÉ\u0092mD>¦?HûÝÝùÎ¼yóföûïÿ¼ù6\u0080\u0093øW\u0000M\nNXv.©\u0015´Ì\u0082\u009e\\Ô\u0096t3yÓÖ\n\u0005ÝN\u008ekîB\u009fãè\u008bóyÝ\u000eÀ§`÷umIKæ53\u0097\u001c\u009b¿®g\\\u0005mé¾\u0099¡Ñ«Ó\u0093C\u0013W\u0087ÇÒCW'§&R£\u0017\u0015\u0084GêÆ\u0093®m\u0098¹^\u0005;\u0007,Óq5Ó\u009dÑòE=\u0088V\u0005\u000fmq `×øÄØSC\u0003SUWA¨\n\u0002Õgtá\u0081\u009cvt{ØZÔi]\u0089cXÉ\u000bF^g\u008c\u0096³\u0086i¸ç\u00154G»f\u0014ø\u0006¬¬\u001eB3\u001eVñ\u0010v3à\u0088aê£ÅÅyÝ\u009eÒ\u0098\u009a@µ2Z~F³\r¹¯>ô¹\u000b\u0086£ :²=~\u0018xOt3\u0094®\u0099V(èP±\u0013»\u00186§»\u0083\u0086C&æ\u008b®a\u0099\nn¼\u0083ïK\u0095+éºfä\u008a¶&;z»¶\u0089å\u0098\u0097ÏÆ`½!\u001cB$\u0080w+èy \u0098*\u000eà0\u000b\u001fíªäfênrz\"E\u007f\n\u008eª8\u0086ã\nvT3\u001bÕ¤\u001eG¢\u009b-»îÕ\u0081l~\u008f\u008a(ºH\u008b\u00ad/ZKúÐ-W7\u001d\u008f\u0096\u0013Ñ{wÜÇI\\E7z\u0088À¶,B°+\b¦\u001b8x`¦ïñ\u0010@R\u0081º±ÀÂéI\u0015ïÅ£\n\u001eÞRÝ~Í!\u0092½Ñû\u0000?¥â}x¿\u0082\u0010·\u0089)±×\u0099k\u0090øº¤\u0002x\\Áþ\u00adVýE#\u009fÕmÁÓ«âl#<¢\u008f\u0010ÎãÉ\u0000\u009eØÔÇ\u0015\u000f*úÐÏ.[\u0092¶\u001c»¶¥\b\u0095^o\\\u0084Ó\u0018\u0094¾bÛîk\u0004\u007f&\bÎ\u0002%)\u0086)\u0015Oá\u0003lP!ÜÌR\u008aÛªt5;/VZÅ¨¤\u0017t\u00adÊË\u0010\u0012\u0018\u0017\u0000\u001f¤\u001e·ô_#8ÂÑ¤\u008a)q\"ä_1\nÂ¿<\u009eQqiÃca,\u0080Y\u0005§ÿß¦\u000bá2æ\u0004Û\u0087\u0014\\Üö\u001ci\u0094C}¢pþe6*UAò\u0001¥Mòæ\u0099q¥U\u0082ÙZß\u0006dééÐ[\u0091\u0081\u0010²H\u0007 ¯Ë¾ÚÑ¢_\nfAºW¸JgO\rkÎB\u0010×\u0015ø\u008f;Éã\u008e\b-¯b\u0011\u0084×rÍ²\u00175~(\u001eoPì¹m\u0089\u008c\u0088\u008av¾\u0012ãY\u008eõôà©\u0010\u001c\u0014\u0003 Û\u0003\u009e¹£g\u008a¶á.'Óºãh9öSNw\\\u0015K¸Y\u0099O)ï³\u0093a.'ï/ºÆ^z%\u009de\u0015\u001fÁGI\u00984ì²«óËà\u008bvÍõ\u000b\u0090\u008f©ø8>ÁT\u008b\u0085¬æ2\u0084?:×ß5\u0013À'9\u0001<Ç$`!ÙoäR¦«ç¤Q\u001d|ZÅgÄaKÖ\u000b\u0012ÂóxA´ò\"\u001fES²_\u001e}Nôþ\u0092ôVªáHú<¿/õÇ\u0013EÓ5\u00169K3zAj\u001dÄ\u0017\u0015\u001c\u001c°\u008aùlÄ´ÜÈ\u0002)\u008c\u0018f¡èF\u001cÏC\"\u0084\u0097ñe\tû\u0015\u0005±Fc³þdjÁ¶nÊ§±WRû\u001aGLý]-\"ÁW<Ëwz#\u0089\n:ß\u0091c\u00926_¡µi\u008e\u0083H!\u008bûF\u001a\u0004è\râ\u000e_'¤&ßSñ}ü\u0080õÍk\u000e\u000b\u009cÕoÉäj8\u0086Rbÿ#\u0015?ÆO\u0014´:Åùu\u0094mÑT#fY]Óë\n¥À_J:á\u0097*~%ã!@\u0005¬OÓß\u0088Ç\u0097ª\u001d3mçk§\u0091õ\u008f\u001fý\u0014ª¶¯©ø\u0003þH\u0082ôg\u008bZÞÙ\u0002t]ýW\u0082x\u0083*+òx\u0093È\u001aTJ\u0019\u007f\n`uóÈ^v\\}QÅ\u009bÒ\u0081\"îqÛb\u009b»Ë2\f\u0007\u0083x\u008bAd¨\u009d\u0089\u0004q\u0097\u0016\u0011Ã\u0089\u0014Í\u001b¦uÓ\u0094z\u000f\u0012Ô¼÷y\nMZE;£Ëhá!hÓ\u0018JH86~Ê49@H°#µÙsÏ\u008cÃaN\u0083f\u001e'\u009bÑ\u000e?Zx\u0017à]\u0013\u0082¼\u000fm¸ßÁ\u001fÏA\\\u0007ù\u008c\u00071þïáÝ£¼*¼úce\u0084_óL÷ò?Ä+èÜ\u0087#ØÇ\u0095Z1B\u001böó*\u000eÞUup\u0081\u0096b\u001b\u0012\u0007±ø\u001bh¯{ÙåA;F/ÇÑ\u008a\u0013\u009e§¶\u008auÕ\u0093¬\u0004\u0096\u00808\u0080\u0083U\u009fÿ%p\u0081};\u0016/¡³\u008c#éXw\u0019'Fc=ñ2bg|kHÌÊ«GÊxl\r§g¹<³\u008ase\f\u0084/\u00940Üîã_\t#e\u008c\u009dñ¯ÛNÔm§·Úz«îú¦\u00965\\\u009e\u008dµûÛ[Ê¸²RK§\u0083°À\u0013O+zH@\u0082\t$1\u0080Gp\u008b\u0087yIm¸\u0002º\u0096Úm|\u0018O3¥V<\u0087«ÜÛÄ]Kx\u0086«fZ\u0098ôÔBj\u0006Ð\u000f\u008d\u0014øég'æ¹\u0012K\u009e«ªd\\ç\u001b\u001f¯\u0087bDØYB¦\u008ck£aÃÿ\u0016\u009ag\u009bã\u0093³¾\u009eÉUÜXÙRºS\u0090#\u008e \u008aUv×P\u001dò\u0010(ÞJð5Ñ2\fËCÕ$\u009f\u0095jÜ;Ü';\u0013áÂ*ì4y»5ÚÝSÂskx~ÖG,\u009f*ãöîH\t\u009f]I¯áåÙð\u0017X£/Ýõ<\u001f¦l¾º\u0089µ^þ\u009f¥\nÏQyçùö\t\u001cÅ\u0093\u001e¾Ç\u0098\u001f£Ôð%ðu\u000f_\u000båð\r|ÓÓî~|\u000bß&¾£\\¿\u0082ïx\u0092\u008bÖ\u0090>Í7\"´½ñðwKxõÜÁ;ðÇWâÍ\u0007Køa\u009d\u0097°\u0097Í\u0010kt\u0081^.\u0092ë\u0094\u0017?RÙ[\u008b¿\u0017?\u00adöÍNü\f?÷bñ\u009c]\u008deÓZüt\u0090\u008f_¤»E9¯\u009eïdÀî\u0095îNß3%üº\u001e±ÍË,ÍÿQr<ÆÌÇ\u0089bbCU:jQ;ð[ü\u008e1ü|û{O\u0001*\u0095 ñ¥*<¬Vãß¦\u0085Ô·/\u001e\u000e\u0096°ò\n\u0082±×Ñ¾\u0012\u000fïðîv\u008bÜÃ¯¯¢TÆÚ\u008a\u0094E4\u001fþ3å\u001e\u0017¡¿½.ò¿ÜÝ\u0002s\u00862½Ä\u0090\u0097\th\u0096\tÏmèÖ¾\u001aÌ>üÕ#§\t\u007fóöÿ\u001dÿð$§p\u009f\u0082\u007fBù\u001fPK\u0007\b\u0087|+\u009f?\u0007\u0000\u0000Þ\u000e\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00006\u0000\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.class\u009dUY[\u0013W\u0018~\u008f\u0004\u0006Â¸¡¨AEÔ¢\u0010\bQ\u0011µ\u0004iÕb¥\r\u008b\u0086¢P»\fá\u0098\f&3ãd\"ÐÍî«íUoôÂËò<½¢½\b¥<O½ï\u008fjû\u009e$\u0090\u0004b·¹8gÎ·\u009dï{¿åüþÇ¯¿\u00018\u008dï4l\u00138e»\u0089°á\u0018ñ¤\f§\u008dûÒ\nÏ»\u0086ãH7\u001c[Ìx2=îÚ<x¦Ì\\3¬Ù\u0094t5ø\u0004vÍ\u0019÷\u008dpÊ°\u0012á±\u00999\u0019÷\u0004ê\u0006LËô\u0006\u0005j::'\u0005|WìYéG\r\u001atÔ¢N`gÔ´äh6=#Ý\tc&%\u0005\u009a¢vÜHM\u001a®©ÎE¢ÏK\u009a\u0019\u00813ÑÿêWD`OBz\u009b¹\u0002G:¢yoM;|ÕLÉHgá\u0098õÌTxÄp¨×\u00103\u0013\u0096áe]Þ?ô÷Ò\u0003ÑRä1Ï5\u00adDd+e0¢a\u008fÀî\u0092æ5#\u0093¤¶\u001fMhðc\u001f\u000ehØ/ \u0097ß¤#\u0080\u0016ÂhfÔ)\u000fã´\u0086C\u0002{KfJaùq\u0010\r\u001a\u008e\bì/72l9Y\u008f^H#íG+\u008e*ì\u008fÑ\u0093ÍAM*ýçt´ã\u0004!OÙÆ¬À\u0081\u0092P\u0099\u0099¼l+:ttª,ÖÆSvFjè\u0012h)Å}#kyfZ\u000e-Ä¥ã\u0099¶¥!´îX\u0019.\u0097³fjVºõ\b\u000b\u001c\u001fr]Ûm\u009bOJ«M]Ov\u009b³\u0011]Û\u001dzyÑ\u008fn\u009cV\u0011\u009c\u0011hîØ\n³ò¬\u001bguôá\u001c\u0081SÕa1\u008eP¹h¡:×³¸Õ\u0099\u00882qAÇóè\u0017¨÷ì\u0002\u0093 wlU¡l\u0010\u0003Ê¡\u008b\u0002Á*\u000e\u0095Q&\u0092®=¯*\u009a^Öã\u0005vLf£0o÷tô\u0004;ý¸\u0084+\u001a.¯\u0003\u0095O°+\u0013r!<nx\u009et-\u001d/aH@\u008bÛi'_\u0012¡j D\u009f¡\u001dQ)~YÇ5\f\u0013\u009c»r1&=U\tå\n$E\u001añ*F4D\u0005¶W0t\u008cb\u008c\u0098\u00984fx¶+°¯Bw¸H§\u0081ë\u0088i¸Á\u0086ÞÊÕ1\u0081×Xb\u0096\\ð6£ZÌ\u008d\u001a\u0012\u0017\u0014\u001a·tLa\u009a\u0001§\r\u008fmÏ\u001b{Ë\u0003¾\u00924Ü\u0098¼\u0097\u0095V\\V\t{¤ Ds·ñ¦\u00867ªàZ\u0014Ññ\u0096ê4ß\u001dÓ\u009aUÒ\u0086\u008e\u0019ÄYÛ\t×Î:ªÖ\u0086«&_\"¡áNÅð+ðt$a\u0012ä\u0094´\u0012^2ßºÃ\ný»:RHó\u009cPÐ\u009fø\u0087º,\u0092\u001aaã\u009e\u0006§\"\u001f\u009c\u001d:\\p\u009aÕ°3\u0005.T±õ/\u00ad_GVÇ}\u0005\u0080\u009642£Ì\u008b\u0086\u0005ÎÎ\u008dÞ\u001fÛhc\u0081\u001d¥\u009e,L¥\u001d\u0095\u0083D ±(±H\u0017Õ\u0090ß<[ýNÙ(ÞWÆ.Í²\u0088ª2«0n\u0004\u0002\u00157\u0094O\"\u0001A\u000f\u009a£U<%Os\nu¿a¡JKð\"ÃMdÓÒòÔó³\u0005\u009djºëuEèÙD\u0095jÅÒP\u0081U<e\u008bÎúsÖ÷¿\u009e\u000fÂ\u0016³³n\\\u0016@?ô\u008c'¯G©â(è\u001aÔ·\u008d\u007f|k¹j<\u0085¹\u000bîµÁ\u0015Ôÿ\u0094gû¹Öå\u0089\u00adhäª\u0017\u0004¸oçÞ\u0080\u001dØI©]yÙÝÊ\u0088xBn=Ï?¯¡ij\u0005{£Á\u001c\u009a\u001f£¶ky\r\u0007I8<²\u0086Ö)ÞÐ6Ú\u001dÊáø\u0012ô~\u001f\u007fN\u0006|OÕ¶\u0084Ã£k\bN\u00ad¡{ª©g\u0005§¨ß\u009bÃùÐ\n\"O\u009b\u0006\u007fÁ\u008b£Ý9\\]Å+\u0002ýµK¸\u0014¨]Å8ÿ}¡\u0080/\u0087É\u001cnö×\u0005êrxý\u0011Ú\u0003u$½Ý¯\u0005´\u001cf\u009f ¹+ u+©9\n®ÂªÁM¥ÍÔ>þs\u00adk\u00991\u001cãÀ\u000eÒû\u0000Î£\u001fó\u0084I!0\u0089f®G\u0019×1Æ{\u009c\u0091¶Sâ$O\u009d\\\u0083|\u0010ºp\u008ak/÷ó\b!\u0082\u001eN±Ó\u0098Æ\u0019Ü#õ=\u009cÅ§|t\u001eâ\u001c¾§Ä\u000f¤/SJ!z\u009b(\u0012-,â\u001dîõø\u0011ïR\u009eu\u0085Gx\u001f\u001fä}jÆ\u0003|H_\"¤~\u0084\u008fù7\u008d[ø\u00846kh¿\u000f\u009fásø¨\u0015ä8ü\u0082ùz\u0088\u0016|\u0089¯\u0098\u008f¯\u008b9+Øý&\u009fà\u0087ùl}û\u0017PK\u0007\b{\u0002`-è\u0004\u0000\u0000×\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00003\u0000\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.class\u0095\u0094ßS\u001bU\u0014Ç¿\u0017B\u0012Ò\u0085\u0084\u0004ª\u0088µÒjÙÄ\u0086-B´Z\u008a\rI*mC\u0012I\u0003Êè0\u0017XÃÖ°\u009bÙÝÀTÿ%\u001ftFÆ\u008e\u000fý\u0003ü£\u001cÏÝÝ@²Ü<ô!{~\u009fûÙ{Îæßÿþy\u000b`\u0005Í\u0018Æ\u0018ò\u0096ÝÖx\u0097\u001f\u009dèÚ)?ÓMíÜæÝ®nk{¾,YæÏF»gs×°Ì\u0018\"\f©Wü\u008ck\u001dn¶µúá+ýÈe\u0098)V÷\u008a?4\u000fZµF±ôâ RÛeHW¯ò\u009a®m\u0098íG\fSÔÎq¹éîòNO\u008fc\u0092aa»¸[©\u001dìí\u0014\u001b\u008dÊÎÁP'\u0086L`\u0097ë{µj½X\u0016½ãP\u0018nIËúi\f\nï\u009có×NË¤wû\u0085\u0081í3Lû®²unv,~L9Ç\u0086Cd\u0087=ñn\u0014÷\u0089MÝÕZ;Ï\u008865\u0018ßä\u008e\u001er5¸{Â\u0010ûÕèúA¡ù¾èºa\u001aî\u0006Ã¸\u009a¥»\u0088\u0094¬c=\u0081q| à&ÞKàC|\u0014Ã\u00ad¡»l¾v\\ýTÁm|LõmÝÕÍ3\u0086{êõkÌ^w%p\u0007\u009fÄp\u0097Fq\u0015Û´¬\u008eÎM\u0005\u009fâ\u001e½l\u0097Û\u008e\u001eø\u0018æd\u008d÷'Á *\u0098Â´Ðr\n\u0092\u0098\u008eã>CÒ¿îV\u0093îz«¾]\u0011áe\u0005iDãx@sío\u008d¸\u001eG\u0004?W\u0090AThk\nf}í\u000b\u0005s\u0088R³ªaêµÞé¡n¿ä\u0087\u001d],\u008buÄ;»Ü6\u0084\u001d8#î\u0089á0hÕwÚQ17Ã)\u0086FMs \r\u0098qt7\u001c\u0089¨ûbDÓý\u009aþÆ$/s/=4\u0094òÐÆ¤ÔìðÎ\u0088·,+HaÆo0\u009c>£\u000eg\u008bs3¡¦þ&Íª\u0092!S²#K\u0096\u008eRÒÚ_Íp\u000fß\u009b Üýþ\u001e'\u009cAÃ\u008f\u0004iÎ Ñ´zö\u0091þÔ\u0010Ã\u009a\u0097ÍbYpa\u0091.e\u009cþs&1\u008f\tDÉ\u008a\u00915\u00868Ù\u0089\u0001û\u0006ýhó<=\u0019HºIOÒ¢y2\u0013ÈÙ@Îy2I=è»¢çûdýF~F²\u0090û\u001bó¹tü\r\u0016Þ`ñ\u0002K¹ô\u008d¾\u009eÍ¥?»@>\u0097Ö.°âé«\u009e^øÓkû%=ï\u0010 è \ba¦°@ßìmò-BÅ],Ó7µF±\u0087\u0094¡ø\u0087á+|M\u0092á\u0011Ö\u0003\u0010\u008d¤\u0088MäþBö÷ËÆQÏ©\u000e\u0014O\\\u0016?ÆFP¼AÙc\";·@¸WX\tÏ{\u009fjò^\u0087\u009b~VÐAhâîÄÁßHA\u0096Â \u000f¤ Oä Ka\u00905ª)\u008c\u0000\u0099\n@\u008aØ\u0094\u0080\u0094þ\b\u0081<\u0094\u0082Tðô\u001a\b\u008d«\u0014\u0006Y§\u009aÇ#@Ä\u0016\u0089\u0083¿Å\u0096\u0004$\u001f\u0006y\"\u0005y\u0086ç2\u0090|\u0018¤L5\u0095\u0011 iï\u0004\u0086\u0017R\u0090\u00950È\u0096\u0014¤*\u0007Y\t\u0083T©f{\u0004H&\u0000Ù\u0096\u0082¬\u0086A\u001aR\u0090\u009a\u001cd5\fò\u0092jZ#@f\u0003\u0090º\u0014¤\u0010\u0006ù^\nÒ\u0090\u0083\u0014Â ?RÍO#@æ\u0002\u0090ï¼\u009a\u009dÿ\u0001PK\u0007\bº\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.\u0000\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.class\u0095W\t{\u0013×\u0015=\u0003r$\u008ba\u00136`\u0096Ta\t²¼¨¤$e§Þ\u00007ÆV,cb\b¥cil\u000f\u00915êh\u00841´IÚ¤m\u0092\u0096î[Ò&mhZº×´`Ñ¸\t]I\u009bî{\u007fM¿\u009e÷f$\u008dÄ\u0000áó÷iÞ{s×sÏ½óüÖÿ^{\u0003Àvü7\u0088E\nb¦5\u0099ÐòZzJOLkgô\\bÆÒòyÝJ\u001cs\u009e}gõtÑ6\u00ad \u0002\nV\u009cÖÎh\u0089¬\u0096\u009bL\f\u008d\u009fÖÓ¶\u0082\u0096ÞþÔÈp\u007f÷Ñ\u0091þ¡ÁSG\u0087\u0007N%\u0087\u0087\u0092}Ã#c\n\"\u0003Uù\u0094m\u0019¹É=\n\u0096ö\u0098¹\u0082\u00adåìQ-[ÔChT°<c\u0014øz¼h\u001bfî¨\u0095U°®ÆjwWª¯b6\u0004\u0095\u0081x5ºµ\u0082®`Íñþä©ÔÈÐp_½ür\u0005ê9#\u009fb\u0016º#[k>Ù5rØ#\u001e©3\u009fÔì©\u001aóuòÍ\u001eó\u008el8o\u0099\u0084Î6ô\u0082\u0082Õ\u000e\b4\u0095M$+ç\u0004bYUê \u0091eTË\u001cIÃL\u0088½\u0080jF³rDm¨hç\u008bvÅ\u0094Ä³\u008bÅÉe´q)xOÚÌM\u0018\u0093\n\u0012\u0003wªg\u008f\u0094,Z\u009aH\u008dª«&L\u008ba\u0089bö\u001a\u0016\u007fMkVA2V\u001b\u008b¿ãÖ;z+³\u0087\u008e\u0002=fF\u000fb\u0013Ñò\u009a\u000ea\u008b\u0082ûk\u0095å®ÃÝuVa\nã>Ü¯b\u001bbLy¯\u00913ìý\n6ß:T\u0097s\u00ad£AÄ\u00154ùÕ!\u008cV´\u000b\u0093\u001d\n\u0016ÇZGÃ \u0088bÿN\u0005û|-×\u0017ò\u0016Ð\u008c\u0092Ö\u0003FN\u001f,N\u008fëÖ\u00888\u0014\ra¦µì¨f\u0019bï\u001e\n¶¸ð+XËr¸Ø%kè!r\u007fHÅ»±\u0093¹ëgÉÏ\u0082\u008cøx\u0010»Ièj\u0010ÃÅ\u009cmLë}gÓz^Ô8\u0084½\nÚ]\u009bÑ*\u0098Ñ\tZ\u008dnÛZØ\u0016Í\u0098ÜæL;*ív\u0086±\u001fï\tâ@M¿;XªèB7\u0003`\u0094Ó\u001a\u0019¹+v3Ü'\u0006ê§\u0004\u0089r\u0093T\u0018»Ð+\u0080îSÐìcE\u0094b1Ú\u00838¬ ã®H\u001dÆ!´7²\u008e\u000f«Ø\u0080\u008dbuDÅj¬\u0011«!\u0015kÑ\"V\u008f¨X\u0087õ¢Þ)\u0015#8ÊþË\u009aZ&éiÝmo\u008b\u0000\u000ei\u008e©x\u0014\u009cy«ó\u0096\u009e×,½·f¤\u0019Ä2æ¢\u0090ÓíÄÑáþ=\"Î\u0013*\u001eÃIR¥ Û^\r\u0005+cµÒÂË!\u009cRñ~hìÚÉZyg¬5Å|\u0081V\u0090V\u0091\u0001\u0005\u0096PÍ\u008d\u009cM¾Ó\u0007v\u009fBø\u0099<\u0004RaJÔnUáæHÄûÓ*\u001e÷\u008bTLHñ~ZEÎO¿ü>¯â\u0003B?LýãF¾l¶ Â\u0016jáBÍñ\u0019\u00153\u001eé²\u0091Y\u0015ç<Òâ8\u0084\u000f²\u001dzÌb6#)/j\u001e\u009dñé\u000eË\u009c\u0096ÝÑ)\u0098ú\u0084`ê\u0093\nâ·\u0087ldÊ2gÜþ\u000fâÃÌ®ú®Ò\u0090\u001c\u0085ö\u0094AzÅïf|*,_ó\u0080\u008f9¾\u000bW6\u0085 \u009eU°ÞË\u009cÔlÎÖÎV$\u0004\u001d\u009eWñ\tÁÕ¥\u0096®e$ø&¿ºa\\À§\u0083øTy@»ú*>#\u0090m$²)\u0006:-'ÑçT|\u001e_ \u0005A(²=g;\u009f°\nÉË-#\u008c~IÅ\u0097\u0085\u0089æ\u008a\u0089T^O\u001b\u0013F\u009aª¶0÷\u0082\u008a\u0017E@\r¶I\u008f\u009c/\u0005³h¥«\u009fÄjË´âeÁå¯ó\u009bá74üéÿ²\u0088¢W¬¾©âU¡ÜÌ&5-û\u0088Q(P¨Ü\u0012A|»\\2Æß?T\u0001-\u0088ïð\u0006àM¬?Ç/2]èÚt\u0018\u0097ð=Á\u008fïW»¶\u009c¾èÚVüPÅ\u008fðcÖ]\u0090\u008d3¾*ä1#e/ã§AüÄ\u001bDU@Å\u0015ñ\u0095jHgMÑì!#ç\u009cWxQg\u008fS¥®÷DKüLEI@½\u0082ïjÆ¦\u0082í±;\u007fÐë¯\u000fA]R\u0094ñ\u0018±\u0013>½qK{ýâ\u0012\u0098ÍêÖmdºMÓfôZþ\u0088&\u0092%Y(.`º\u008e_\u0006ñ\u000b\u0005\u009bîl^Å¯ðk¶H\u009a\u0098Ør*+8\u0010»Ë<o\"õoñf\u00107n÷eò\u008b]Åïð{V° ¶\n¶ø\"VÇ\u001f²F³&9-Vù\b\u0013\u007fÃI\u0094ÖÞ\u000eÖüF\u008cû\u0004vÛ\u008b£o\u00158\u0010¤Ôas\u009aµWÝÁ9;¨ÉmF\u009fÐ\u008aYç\u0086Ï|Ï87ý\u007f)è\u001a4£r\u0017\u009d1ì©èãú¬s\u0003)8\u0003AÏD\u008d\u009cï4.ßU:YÊ\u0094\u001c\u000eÎÀiª\u009b\u0094\u009d\u0002#N\u0014Þ\u008dø_N#ZÐ\u0080{¸\u000br·\b!îÃ\u009eý\u0012î\u0097zöË¸_áÙ¯ä~\u0095gß\u0084\u0088¸Hp\u001d\u0011×\bùä%B>yÕàS¥Ï{ñ\u000ejD¹\u001b¤î\">×-@\u0019[À}cñÈæ\u0012¶. u¬\u0084¶¶\u0012:ç¤Ýíü\u0015^Äÿe\u000fðwµ£\u0085wI\u001fb%¼\u0010sì¨Ø6\u0018\u0093\u0090ê\u0088ÏãÁ\u0017±v\u0001»Æ\"{\u0002¯cñØâxê\u001aö\u0095Ðs]ø\u008dûº[&\u0001z\u0090F\u001ebè;=n;ÜÔÄÊq\u000bq\u001fvÜ*;¨ÑÀ\u0093\u008bñ\u0012\u000eÒô!\u009aî¿\u008a÷ÆÛ¯b Þv\u0015\u0083ñ\u008e«H¶1¨\u0017ðd[û5\fÇ¯ðu\t£ó8.\u0097\u0091%â1\u008f÷\u00950>\u008f\tçl¥sfÈ³¬s¶Ì93å\u0099å\u009c59gEyvö\u00126ì\u000eÈÌÏ;\u0099·\u0089Ì[\u0002%|èúeF¼\u0015\u001fÅ³xÊÍy?\u0096ów\u000f\u0002èäj/Ë¹\u008f\u0099îgÁ\u000eP²\u000bqt\u0013\u0091\u001eô£\u0017'ÑÇ\u000bÈAê\u001fÂó8\u008cWð°Äh\u0087\u0093=>\u0082§%F\u0017%Z\u008a\\\tj,\u0092+\u0081Ûbê\u00adÁ3´\u0010à)/\u0087üý\u0018ß\u0006(ýqYÂ\u008c|\u0003l!:Ï\r\u0010²O¾\u0089\u0016I\u0093+\u0018\u009cÇgyòEÒe\u001e_\u0099k«V.B-A\u00ad\u0006\f\u0091n\u008f`\u0013R\u009eêmq#k Q¾\u008a¯Ñ×\"ñ±¿É÷\u0098\\\u0003\u009bék \u0012\u009aÇK7°r\u0001\u0017HÑP\tß(á\u00959¹ºxL©wý(Ý\u008e1ÅÇØg'¥kÕ1åº\u000e\u008bë´Çá·¤Ãó\u0004Dho\\À¥1&üÝ#míóøÁ%\u0084\u0007ù\u009cë¸.~/K\u0092¯ä_Ùå½²õ4\u009e¦ÉÙ\fCÐ\u0099é\u0004Q×ÉÛIé>*¹¼±ÂÛ\u008d²\u0012ÂR\u0013®b\u009e\u0096\u0014ñÑs\u001bç\u0001>E¸!\u0087I×ê[0çI)ä¦¤à5,¸ú\tW¿Aè×+\u0017=Ê\r\u0015å\u009fãu\u000f\u001eOI3Y\u0006-¨\u0014iwâxcw £\u00ad%0\u008fß\\®kÒY\"z\u008e\u0090\u009c÷\u00100R!`\u0004oá\u000fÒ_\u0004\u007fÄ\u009f$\t\"ø3þBÝ0\u0013ø+A\u00114ã¥ÉM`\u000fß\b©`¼Ma\u001bÕ§ð\u0084\u0087MÁ\u008a\u009b þ&ß\u000bCºkh\u0086;QÒõ\u0082C$ëK\u0083\u001d7ÐÐ1×Îßö¹8\u0007ÎÅªñuT\u0007Í5ÒàR¶Årâ±\u008adlÆsÒaÜ1Uq¸Þu(V\u007f\u0097s´\u0091yý\u0083+\u0011ý«\u0095l\u0092î\u001cÜ ÇÀ?\u001bÜ10\u0016\u0010MT\u009e\u0083u)^ð¤¸¡âq\u0083ëQÁ¿¥ü\u007fþ\u000fPK\u0007\bøÇ£9\u0091\b\u0000\u0000,\u0013\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000org/apache/maven/wrapper/cli/\u0003\u0000PK\u0007\b\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.class\u009dUëN\u001aA\u0018=#\u008bèJ½\u0015\u0011më¥WXÁÕZÛ*ÔÔØ\u009a\u0098Pk\"!é¿\u000eë\u0014×ÀB\u0096EëKôYì\u001fLÚ¤\u000fÐ\u0087júÍ.E\u0094-¢?v.ß|sÎùÎ\fÃï??~\u0001XÆF\b}\fk\u0015»¨ó*7\u000e\u0085^æÇÂÒOl^\u00ad\n[7J¦¾Y¨967\u009c\u00adJ¹Ì\u00ad\u0083¬i\u0089\u00ad\u008au,lGØ!(\f£Gü\u0098ë%n\u0015õ\u008f\u0085#a8!ô3,w\u0005õ\u0003cèÏ\u0098\u0096él0\u0004â\u0089<\u0083²U9\u0010*\u0002\u0018\n#\u0084\u0001\u0086\u0011\u0099¿[/\u0017\u0084\u009dã\u0085\u0092`\u0018ÏV\f^ÊsÛ\u0094ófPq\u000eÍ\u001aC:{ëºÒ\fÑËÈ§Õ\u007fèoo\u000f\u009bÉåÒ\u001b\u0084\u001d2¼\bC<\u009e½po\u0087R$G:\u0091½j)mRß\u007f5DÕ1+V-\u0084èu§ÖF¿i\u0017ëea9\u00adý\f\u0083ûfÑâNÝ¦zR~\u00122m±}Ç6\u00ad\"\tO\u0090ü\u0010¦\u0019\u0016{¥ÞãvMØ*¦0¤\u0082áA\u00183\u0098%zªÿ\u008bYtéWâÝýì@K'ò\u0012p>\u008c\u0087xÄ\u0010¬Ê(Ãö\u007f\u009cì\nî\"\u001e´Q¤¥Ì'a\u008cã)Ã»k¤uîö=8\u0085ÛEº\u008e\u0011?}tç]ýtù\u0097nê\u0003Ý\u009e^O\u008eaõæµÐiK7\u0016ÃÐ±Ä0d\u0089\u0093\u001d«æpË »#q\u009fZeúsiÞ\nCþÆ\u0084\u009dx¾v^ãS'.ÃºïÝè\u0095¯g\u0097É0i\u001a\u009d©CG.\u001cù<ù\u0000\u0006Ü\u009c`ÜËU÷+uÛ\u0010Û¦|[æ»½\u001e\u008b\u0012\u008bás&·Þ\t»Ñ\u0019êù>]y\u009f\u0094y:Æ\u0000}Aú\u008f\bROo/µ\u00834Û¤\u009eÉ¨v\u000eõ;\r\u0002\bSÛï\u0006Çq\u0087Ú°\u0097\u0080a\u008cP?z)2F=\u0099\u0082»´/Bc\u0085f\u0013\u0098¤Q\u001fb.Á)\u00ad\u0004¨\u009fü\u0089©Oç¸÷AK6p_K.40×Àã³\u0016å°\u009b\u0016!e\u0013D\u001bu©ç¼\u00adMj9z\u00868Q\fÐ<\u0001\u008dH¤\u009c(õ^ÖX+kÁ\u00ad\u008b~ô>Â\u0092®°=Z\u0091ûTmAk ÕÀòÙ\u0095ò§]\r\u001eºÚÒ \u0012ú\u000bZ¿0Bm3bÕ\u0087ï¥Ë÷\u008dV\u0014êcM#vµ\u00944\"%\u008dH^b÷\u009c\u0098¡*gIÁ\u009c«Bóö¶TÄ\u009aNÈÑ+¼&\u0096\u0001R$=\t¸Ê<çb-ObMO¼ü5ô)\u008a|\u0004(âi\\§/í\u008e2ÍÈ\u009b¿PK\u0007\bðdQvý\u0002\u0000\u0000T\b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.class\u00adVk[\u001bE\u0014~\u0087lØ$lÛ\u0010\u0081\u008a\"\u0085Zjn\u0090\u0016è\u008dP\u0014\u0081ÚÔp±Ô -j\u0097e\tK\u0093ÝuwÃÅÛ\u000fñé÷~Õ/é\u0083>öég\u007f\u0083¿E=³\t\u0081d£@,y\u0098\u0099\u009d9çÌû\u009e9gÎüñ×¯¯\u0000\\Ç\u008f\"Ú\u0018f\f+\u009f\u0092MYÙRSEyGÕS»\u0096l\u009aª\u0095R\nZjzÝv,Yq\u0096,\u0083¦\u001cMµg\u008cbQÖ7²\u009a®Î\u0018ú\u000eMª\u0096\b\u0081áÎ©\f5Sgh\u009fÔtÍ\u0099bðEc9\u0006aÆØPCð!(Á\u008fv\u0086\u000b\\~¡T\\W\u00adGòzAe\u0088d\rE.ädKãßÕIÁÙÒl\u0086¹ì\u001bà\u0094fèÌ«\u0087Bû\u008b¦£\u0019:CW4\u0096Ý\u0096wäTAÖó©eÇÒô<\u0089özDgUGÖ\nê\u0006C_\u00935[±´ªÅ bè\u009bZ¾d\u0011\u0081±è\u007fC?\u0006tI¶lB\u0019Ë\u0089èf\b7b\n\u0081á¢\u0084ó¸ÀG½\u0012Â|ô.Þ\u0013ÑÇ0r¶]$ôã\u0012\u009d\u0092Q\u0085<\u0017}âuBìÔÐ+NH\u00870\u0088÷E\\>\u0003\u009c\u008a¦\u0084+\u0018b\u0090¶d{ÚÊ\u0097\u008aªîÐ©\u008fF[@Àð\u0081\u0084Nî\u009aAÄ$Ä\u0091`8OvëNh6ú\u0006Ø\u0092ûL×\u0099\f×ÎzÈgQ©m×¡«»\u0019Ývd]¡Èê<\u008cÛ\u0092£\u0015Ró²I\u0012Áe-¯Ë\u008e\u001by·\u001a×'½\u009c½3Si\u0011ãdüHó¾lo\u0091v\bc\b2\u0088J%\u009d\u0018\u0096N\u0088l\u0097éÆ1\u001eé\u0006¸^ø¡¹=EuÙÚ\"&Nº\u0080\u008e\u0099>\f\u009a\u009a>Ãóÿ\tï\u0094ÞjÍÇ!ÜÅ\u0087\"¦NJ\u0014\u000fH\u009e·\u001f1<8{üzLÕ2æcÌ\u008a\u0098a\u0018oE_Â\u001cîQàÑ\u008d\u0098\u0093\u000b%\u0095Ò6R\u0017xYÍvÒ\u001d¸\u008f\u0007\"2\u0094\u008aõ+\u0012>E\u0096! Ñý,;\u0006¥RO\u009dv¦:O\u0016\u0016°$b\u0091Ì{W%|\u0086\u0087T,tuÏi¼Ð\u0017×·UÅI\u0007ð\u0088\u0081Ý\r¡\u000b9\t+ø\u0082BYÓ7Ô½ÅM\u0086îfîÌ\u0004ð\u0098\u0001\u001dXÃW\"¾d8WwÒ\u0012¾ÆS*of\u0089¶¼\u001dõîè\u009di\u0002\u008bãY\u0097 \u0080ªJÐ.ñ:F\u009bs/d2MÊ\u0012\u0017ßäây\u000eº\u0099\u0004÷\u0093&a\u001bÏ\u0088 ]{\u000b®K¨\b\u0013\u0017±rÛÛ'^>ÞÜ Ü4kÅ\u0095WïÆÔ\u008d<S÷Ý\u0000\u0098Û3-Õ¶Ý\u001c\u008c4+¬>Ó \u000b\u008cb¡§¾âï\u009b\u0087UÿFKIÅ\u0090k1çO<$\u0086=\t7q\u008b\u008f¾\u0095\u0090Â5rÈ²Q²\u0014õ\u009eÆ\u0011'N÷\u0004\u0019á¶\u0019¬Ó=g\u009aY\u0098lÉ5Sia\u0090 ûÀÿ\u00824¢7\u0018µ\"}¥¨§0\u0087?þ\u0012\u0081_hÐ\u0086\u0010µíîd\u000f\u0085? U\u0004¨?\u0007\b\u0002\u007f\u0082¸}¸Úwò\u009ed\"x«jÔ$i¾ÙÕ\u0084ÿwt\u00adúâeô,¯\nÔ½½\\Æ;óÉ2\u0006æ\u0093ôyµ\u008cèÊÑ®\u0011\bÔöã\".¡\u000f\u0003\u0018¢\"Î\u0011\fT¬U\u0010¸£$\u0086ù{\u0088vîÇ\bi\u000büP¨¿îÚ\u001auQ\u008cÒ\u0088#\u000fü\u0086±Õ\u0097¸ñs\u0003»+ÇØ\u0005ª¶\u0019?fÚí6\u008d\u0005úºSµ\u0098v-þé:\u000eXKpFeL\u00961}\u0080O\u0018&\u0084\u0017\u0098ê\u0015\u000e0Ïð\u001a]\u000bÃ\u0011âùùM\u007f·ÿ9ÂÉáÈê\u0001\u009eø°ò\u0002½Éa_·¿\fy¸Û/<-C\u00ad,pÕ-\u0086\u009fþ~\u0095ä(}.ÊË\u0084\n\u0088\u0012û\u0018µqb\u009c lILÐh\u0089f\u001e\u0013cÎ`\u009cP\u0011¦\u009awÖP@Ñeµ\u0006\u001d\u0006¡\u001f I\u0013ß\u0090Ý(ý,Ø¤áÔ¸s©\u0012ÚÂÓÄ}\u0087¤\u008f¸sÎqÒâÞ\u000fÅ\u0013É×X+c·Ñ\u008fÌEÑ\u0006\u0084gé\u0014\u001eVc`¨\u0016Xeìÿ«\ný\u007fç¶ßW\u001dýÃ?PK\u0007\bjç F®\u0004\u0000\u0000Î\f\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000?\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.class\u009d\u0090AOÂ0\u0014ÇÿEØt¢ \nF\u0012\u008dÜ\u0004\u008c\u008bG\u0083!1D\u0013\u0093Å\u0083\u0010îe4£fë\u0096n\u0003¿\u0096'\u0012\u000f~\u0000?\u0094±\u001d\u0004\u008d\u0012\u000föÐ¾÷úïïý_ß?^ß\u0000\\âÐD\u008eà*\u0094\u009eM#êN\u0098\u001dÐ)\u0013öLÒ(bÒv}n÷Â  bìpÁn¤\u0097\u0006L$·Ï.\u008b\u0012\u001e\n\u0013y\u0082ú\u0013\u009dRÛ§Â³\u001fS\u0091ð\u0080\u00adî\t\u008ck.xÒ%¨\u009e9_º~\"¹ð:Í!A¾\u0017\u008e\u0099\u0085\rl\u0015Q\u0080APÒ\u009d\u001eÒ`Ää\u0080\u008e|FPqB\u0097úC*¹Î\u0097Å|2á1AÇù·ù\u000e\u0081\u0019°8¦^Öã\u0097;\u0082Ö\u001aÏß*\u0083\u0089\fgÚ\u008d\u001aDOPÑ\u0013\u0094\t\n.McÅ¬®Õ\u0012Xý0\u0095.»ãz\u008eÆ_\u0016/4\u0000\r\u0010E×+§\"õIj7UÖUyN\u009dF«=ÇæKvo©ÝÊªGJYÇ¶\u008aj\u000b\u0015\u008aØÉ(\u0006vQR\fÍ*/Y÷ª\u0083îa¶Úçsìý\u0084\u001d«G'\u0019ìt![ÁÌ%LGû8È,V³×µOPK\u0007\bûm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00007\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.class\u0095R]OÂ0\u0014½\u009dÀ\u0004¿ð;þ\u0003ö \u0095\u0010\u0013e\u0084Ä &&K4\u0081ð^Æu\u0096lÝRÆô·ùà\u000fðG\u0019K1H¤Ñ±\u0087¦½g÷\u009csÛóñùö\u000e\u0000u8¶Á\"P\u008fe@YÂüg¤\u0011ËPÐ\u0017É\u0092\u0004%õCN;q\u001411ô¸ÀN,2\u0094)J\u001b\n\u0004ª#\u00961\u001a2\u0011Ð\u0087Á\bý\u0094\u0080íÏþ P«y?ð½ja\u0083\u0010]ÇûÝã\u0012¨Ü¾ú\u0098¤<\u0016c\u001bÊ\u0004®òÚ¹\u0096Á$B\u0091Îû\t\u0094»<\u0010,\u009dH$pj²ÐZ¨uSÉEà¶]§×S>\u009aFËË\u008e\u008dC\u009cç\u0016SZ3½\u009b\u009a÷ç¤\u008fL\u008eq¸0¯Yùbu\u001a-ß_¹/çU\\®L<¿\u0092²ÊÏ\u0013\u000fôó5þ¡Y Ð\u008cÒuú*LÝx\"}¼ã¡¢81e÷ljY\u0005´Õk.»o/\u0097J\u0004\b¬Áô+ªÔ\u0017¡\u0004\u0016ØêTPõu¨¨\u009d\u0005\u001b\u001aÙ4 [\u001aÙ6 ;\u001a©\u001a\u0090]\u0085ìÁ¾Þ\u001fèõð\u001b9ú\u0002PK\u0007\b=8\u009f\u0094L\u0001\u0000\u0000»\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.class\u009dU[W\u0013W\u0014þ\u000e\u0017'\u0084IÀT¹X«XDC\"Ä»V@« \u0095\u0012À\u0016\u0004A¡\u000eÉi\u0018LfÒÉÄKûKÚ\u0087¾Y_|h»\n.ëZ]}ò¡kõgôo´ýÎdÈ\u009dµjWÖÌ\u0099sÎÞßÞßÞß9ùãï_\u007f\u0003p\u0006ßhh\u0011\u0018µ\u009dLÂÈ\u001b©M\u0099È\u0019\u008f¥\u0095xâ\u0018ù¼t\u0012©¬\u0099\u0098´s9ÃJ'MKÎç]Ó¶4´\tto\u0019\u008f\u008dDÖ°2\u0089ù\u008d-\u0099r\u00054ÛÛ.\bt%½Ý¢kf\u0013\u000bÒ\u001d\u0013èX03\u0096á\u0016\u001d)0X»;\u009e¬@-¸\u008eieÆ®ÒC7\u009cL1'-wñY\u009eNû«¬&³F¡@\u0093\u0003õkã1åÙ\u0099\u0096\u0085\u0094czÉ\bD\u001aá\u0005\u0082\u0085âFªÄ\u008b\u0016i\u0099wdÊPöË\u0086cÑ\u0084\u0016¦\u0095*npMMÄªÀ¾qÓ2Ý«\u0002½Ñ*ÄiW:ÆFV\u008e\r/\tÄ\u009bí4¥§¬Û&í´\f¢\u0015½:\"è\u0013h\u008d\u000e/i8D®\u0095úÜ6\n\u009b¬Q\u0010ýèí\u0080À\u0007:Ú±¯\u0003GqLÃ\u0080@¸\u0002¾d\u009bi\u001d\u001f\"HèÅ\u0095;7\u0095ùq\u001d\u001d\bvâ\u0004¢\u001aN\u0092jc~:\u0086\u0011\u0013\b\u0098jîÚ\u008e@Ot¸ªCÓþúX'NaTÃÈ.JÍ®\u008e\u0004N3°%\u009fR\t\u0007v\u0011ªô1¦ál\u008dlJÅèÄy\\ÔpA T£\n\u001d\u0097p\u009951ÒìÐÁh#ÜðªJè\u008a\u008e1\u008cS{\u009bFaÎ\u008bÍ*®*\u0005R®sÅÜ\u0086t\u0016\u0015K¥\u0003;ed\u0097\fÇTs\u007f±ÍÝ4©×ÓÉw;\u0001uÚ+\u008b\u0080*±}ÙõÔ\u0086£\u0086ý\u0090ÿY#Ô`Fºó»gj\u007fMWJ§j¨~m\u000f NVçº\u007f\u009c\u0004ÎÒë\u009dùêU\u0010\u0005\rÉ]éy\u0091\u0093f\u0081¸!¦»Pu®jUà§£TyGG\u0018!\u008a!gä\u000b\u008bvµÏT´Ñå\u007fd«\u0095\u0001ÃLjªr\u001fhàÉë\u00ad\u000fq£hfÓÒ\tâné\u0094\u00adèÐ\u0011RÓû:\u001e`\u008d}Uñ\u0014ÞHÓ\u0004÷\u0000ôØ~¡£«\u0004fèØ@\u008a`YieÜMO«ÓjCª(_\n\u001c\u008eNî\u008d\u0015\u0000=Â÷w/+\u0099\u001e\u0018\u0019\b`\u008b·Ó\u009a\n\u0093ÕÑ\u008dý\u0001P{úýÊåµ¦ðó:¾Â\u001c\u000f¹k\u00970\u0099\u0083#\u000bÅ,»Ö¿g@FcÓ§j.SVóz6k?©hAàPyq\u0096\u0088f>+«6\u0083\u0095|y\u008e½f4¹l\u0017ì¢\u0093\u0092·Lu@z\u001a\u001a:ª2Ä1\u0092lå¿Ö>Þ\u0096¼\u00039Ó8kA\u0080\u000f/¹ò¼\u0093\u000f»ç}\u0087ý±Ë\u001fY!\u008e!ÚFð\u001eç%\u008f\u00038Èñ\u0005ÑÛ8^\u008b½BOì\rúW^áým\u001c\u008eý\u008c#Û\u0018\u008c¿Æ\u0090ÀÜ\u000bô\u008d¼F\\àw\u009c\u0099\u008dý\u0082Ã§^ã\\\u000b\u0096¹ø\u0091Àwÿüõ\u0013!Z1Á÷\u0011\u000f~\u0090 ½L \u001f=8\u008e\u0018\u0086p\u0081ãU\u009cä\u0003\fx\u0094®ñ÷1à}µã:Ó\u008b\u0091Æ\r&Ú\u0082I®ê\\)íMñKà&n\u0095\u0093ÿÄK>á\u00ad\u0003í*¥\u001f½\u008d\t¯Vj1æ\u0085*\u0081´û¡\u0004nc\u009aoå|\u0091Öj/\u0010\u008b\u009c!ÓXÅ?È\u0011\u0018%N¢\n#PÆø´\u0019ÆL3\u008csÄ8ß\u0014c\u0016s>F5\u0089ùz\u0012\u0097\u009b\u0092ø\f\u009fûÎ×h\u00ad\u0002i±ø6æ\u001bâ\u008fÓiÂ\u0083è)\u0099\u0095K®aÁS\u0084Àb9\u0093?}0ù\u0006w)\u0083å$3º÷\u0016z\\\u008d;X]æ¸þ\u0016Ñø\u000e\u001e~\u008f`¼{`\u0007éåx$£ö\u0094Ñº÷\u00111}ÛGß¢¯Þ6ç\u0099ìÀ®¤z\u0085\u0082\u0005û\u001f`ï»Øù>vú({}\u0082]\u001ea©Ï³à\u0013\u0098¡\nfù\u009e#÷y¬°\u0006\u000fI¡BMúÔ\u0002X\u0083\u0083\u0082GÍm^§{\ruZf\u009dîíQ'Ý¯S\u0091Õ,\u0081]ö»\u001e&ÇA\u009e\u0093çho{Ùú²®u\u000fªZ\u0017.·îq\u0019å\u0092\u008f\u0012R(\u0091\u0099\u001f\u009a\u0082<¬\u0002\t\u0095A\u009e4çµÞÀ+M^r\u000f^]>¯î²\u009a/ø\u0019i±¶m<j\u00003\t¶U\u0095\u008fVÎçiS1¯×\u008bÙj*æg\u009eÕ×ÿ\u0002PK\u0007\b6W°K\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000I\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classÍV[O\u0013Q\u0010þ¦-,,ËU¹x¿U.-°à]\u008aH-÷«I\u0095\u0084ÇÃ²\u0096Åv·Ù.ðKü\u000f>b¢A%1¾\u0099ð£\u008csÚ\u0002Å\u0016a\u0011\u0013\u001fÚ9gæÌì|3sfÎÞÏ¯ß\u0000\fbFA\u0080\u0090pÜ\u0094.²ÂX3õ\u008cØ4m}Ë\u0015Ù¬éêFÚÒ\u0013N&#ìÕ9Ë6_\n7gºáø\u001bÏt',7ç%7V\u008ab\u0005!Â¸OC\u008bYÏrìø\u0096p\u008b\u009c¤'<\u0093Pí\u00adY¹ð\u0000a`Î\u009fÅ\u0018ë\u000e[¶å\u008d\u0010\u008cn¿Ê\u007f>\u009f?´Z¢\u0015ëY\"\u0084\u0012ÎªY\u000bB\u009d\u0086*T«\b¢^\u0083\u0082\u001aB£<´°\u0091Y1ÝWb%Í¸Zæ\u001cC¤\u0097\u0084kÉ}\u0091\u0019\u0092`9v>½\u00ad\u0098\u0005Æ_g\u001c\u009e<1\u0080å\u0098\bõ\u008eÍip½Br\bkÝsëbSèia§ô¤çZv*VÎéñë~Á|IÚc*ÚqIA\u0007¡ß\u009f-\r\u0097q\u0085P#\fÃÌåÂ\u0083\u0084¸ïÜ÷\u0014 mxVZ\u009f\u0017ÙX\u001d®á\u0086\u0082ë\u001c\u008f#\u0002\r7q\u008b\u0010L\u0099\u001e¡³44\u008b+ë¦áí\u001b*e)¸ã\u0003S!0\nî\u0012&}ÆôµýÖv¶ì²ÐÊúìÒÐ\u0082\u000b*Âè\u0091õ\u0019!ìUJ¬Ïrñ\u009bõÒ|ûÕ=\u000e\u001dßC\u0005½þ»ÏlEk\nú\t±3\u0015s!\u0086*ú0 CÌu¸zª»s¶«³\u007fñ\u0096TDq_~ð\u0001Qò\u009c\u009bÞ\t\u001f?µrAë¿.¯Êå\u0090oòAá¦d÷.Ë\u001c\u008f\u001b§Ø&\u009b\u008dßÑú\u0019_Åø\u0010Þÿó©u.sFV\u001d·F\u0082\u009at6\\Ã\u009c°ä(k+Óî\u0097!#hÓ¶mº\u0089´ÈåL\u009eu\u0017+ÙdõÊ)`Aå\u0087\u0082\u0082\u0004aôoç\u000e§®\u0002O+\u00ads\u0005\u0093\u0084¡³×\"Oå#»\u008eãZ\u0019\u000f\u0017®6~\u009aQS\u0093|Nð*\u0088\u0080|N0¿\u0096wS¼\u0097r-\u0012ý\u00045\u0012íÝ\u0081ö\u0081÷\u00014ð\u007f\u0083\u0094Q\u0002U4\u0086:\u001aG#óÚXÆçÑ\u0084f ¿â1À<Î\u0002Z\u008bVß±ý\u0010Óxä#ÔÏhëý\u0082«\u0001|Çí\u0085¾\u001fhÙEx9Ê\u0092Î\bí {{\u0017Ñeyn\u0017}ËÑ^fé}ûÂ{Û\u0007®´H\u00834\u008df\u009aA+Í\"Lóyw\"\u0085\u000f\u001d¸\u0013ÇC<b7äê1¯\u0002Ì\u001fÀ\u0013<E°\t\f|¨èb\u0017C\u0093\u009aJ\u001esì\u0010sµTfÌ\u008dy\u008eü\rçÿ\u009fa\u0084é\u0010\u009b ~W<gN\u0094é(Ó Óx(\u0080\u0017LÇB²]·c\u001c*&\u0098N\u0085ä\u0084lÇ4Ô_PK\u0007\bæ¿Ëk-\u0003\u0000\u0000%\u000b\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.class¥\u0095mO\u0013A\u0010Çÿs-\u00ad\\\u000b\u0005\u0015\u0004\u001f\u0011\u0011i+\u001c\u0088úB|&JL*\u0092\u0000Mä\u008dYÚµ\u009c¶{Íõ\u0000ýN¾\u0090D%ÑÄ\u000fÀ\u00872ÎÞ\u009d¥Ø\u0002¹4\u0097ÜîÎÎüvfvv÷àÏÏß\u0000æp/\t\u0083°à¸\u0015KÔEiKZ5±#\u0095µë\u008az]ºV©j[\u008bN\u00ad&T¹`+¹\"Ü\u0086t'\u009e½÷¤û¦îÙ\u008ej$\u0011'<\u0088\b\b\u009aUOx\u0092\u0090*\u001dÎ\u0013f\u000b'²|Ër\u000bq\u0081\u0090xh+Û{L\u0098\u009f\u008aj\u009c-\u0012â\u008bNY\u009a\u0088!\u0095F\u0012iÂ\u0093S0'ÆÃÈ^\u0010úÓèA\u0082\u0090ÑZËÛµMé®\u0089Í*\u0007x¶à\u0094Dµ(\\[\u008fCaÜÛ²\u001b\u0084GQ\u0017nÝ\tÎÄ@M|Þ\u0094ì\u0087ë\u0005BÂÐTá\u0083Ø\u0011VU¨\u008aµê¹¶ª,d7\b1áV´3m\u0093\u0084>G\u001dAlu@t\u0080Fõ=À·¦.\u0089\u008b\u0084¥\u0088\u0098uõQ9»ª\u008dfb\u0014\u0097õ\u008e^!\u001ct\u008a b©tS\u0013Qm\u008f\u008bÉ¯×\u0084\u0013îKÊQË\u008eú·K+\u009d6º\u001b§M\u008cc\"\u0089\u001b\u0084\u0099h©Jã&&¹\u008cD¹üâ\u0093ç\u008a¢¨nËc*\u0091ã©G>µ]\u009d\u0092lÑäó\u0099Õ\u0095q\u0086`®:ÛnI¾´õ)\u001cn3\u009dÑ\u001e\u0013Ò¯\u0094\u0092îbU4\u001a\u0092o¼\u0099ÓRÒÆaÄÑKs\u008eð´ÛóB\u0018ì K\u001d\u0019\u008d\u001cWJ\u0018ã,Äø\u0011àK@_UÜë\u0081¡\u0093Â\u0092^\u001e-ñÈà6\u0095£}\u0098¹üwôíñÐ@\u0086ÿýÚ\u0094ÖÐCë0©\u0088\u0001\u0096\r\u0007ê\u0018d ü\u009eÆ\u0012\u007fçp>\u0084ÞçVk\u0019±/M\u0096Ö\u0001m´0\u008c&ÃÀ\u0010Ë4ã\u0002FBÆk¶Ð\u008eg~aôm>÷\r}ÚÃK_ÿ\u0003¾ó\u0081c\u0081j\u0013\u0098\t\u0081ºwÕ_\u008epÍÏ\u0085F?\u000fc655ÿ\u0003×s\u0087TSÏP\u0099\u008bF¶¸j6Éf@æ©$n\u0085¼IÖÑë'rù}Líýçá\u009aÏ\t\u0002Îùÿ<ns;\u008e8ÏOÃbæ,·wâúu\u009aÆ|\\ßiÓ¸\u000bó/PK\u0007\b\u001b\u001b['\u0093\u0002\u0000\u0000Á\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classÍVíS\u0013g\u0010ÿmrpx9%ÒB¥E\u001b-\n$\u0084#\u008a/\u0010¥b\u0004k\u008d@\u001b¥\u008döe\u008eãi8\u009bÜ1\u0097\u008bô_é\u009fÐov¦\u001dl\u0099V¿uÆ/ý\u008f:Ý'9$\u0098S9´3ý\u0090ì=ûv»¿Ý{v\u009fýóû\u009f\u0000røVE\u008cpÝõ*\u0086¹aZëÂ¨\u0099\u000f\u0085clzæÆ\u0086ð\f«j\u001b\u0005·V3\u009dµ¢í\u0088eÓ«\u000boø\u009aøÎõÄ\u0082íÕýRc5\u0090«P\bó\u0011=-mø¶ëÌm\u009a^À)ù¦/\bÝþº]\u001f\u009e$L\u0016£yÌ³íeÛ±ýY\u00825\u001aÕøÕúM¥µ6«üØ\nA)¸kâ\u0010\b\t\u001d]èÖ\u0010Ça\u001d*z\b½Ri±Q[\u0015Þ\u001dsµÊyõ\u0015]Ë¬®\u0098\u009e-Ï\u0001S\u0091É\u0012\u0016\"F\u001b^\u0006\u0006 aíª¾\u0016ÁÎ¤\b\u0087]\u0087ëàù\u00adê\u0010ÖG\u008b\u000fÌ\u0087¦Q5\u009d\u008aQò=Û©ä;9cQão¹o«{^Å{\u0084ü\u0081Ü´\u0082Ð0\u0080A\u0089þû\u0084µ}E}° wR^Ñ0\u0084\u0013*\u008e\u0013&¢9Òñ!R\u0084\u001eÓ²D½>\u009c#ÌEn×±V:\rß®\u001a·Í\u008d|\u0002§0¬â#®à\u001e\u0081\u008eÓ8C\u0088W\u0084O8Ó\u000eËÒê\u0003aù;\u008eÚY*F#äÔBE\u0082\u0091Ö\u0091Áønbg\tç¢'vOÅ\u0004áFÄÚÜu¾wÜM§£¯ä×9©£\u000fïhÈâ¬ì\u008fs\u0084gaý\u0011ñ[\u0089Ú=íÍ\u001eÕöeÙq\u0017ª8O\u0098Þ¯¿9¯Ò¨\tÇ\u009fÿÁ\u0012Mg=¸H8\u0019øO\u0005·G¶Êª)·©\u0090\u001a9]\u001f\u0099P1MH¾Ø)\u001aò¸¢âò\u001eQ\u000bN\u001d³ø\u0098/d¾¦j&·Þt\bâ÷_Ý\u008d\u0081\u0096\u0086)ÌÉº]#ô\u0087x\u0091\u0010\\\u008f>~n\u0085\u0002ª¡\u0080\u0005ù²\u001bD¥·<C^s¡ìÛ¸eõ¿î×pp\u009b33nz\u00159\f;êÈÍâ\u0006CGwÛ\u0080!\\y#\\\tG\u00ad\u0017Á\u008b²\\\u0004p\u0013~úÏw\u008a·³\u0005ÈÉÄc\u0080 \u0095Ü\u0086g±\\n\u001a\u0003\u001dæ\u0013²\u0004\föMÇ\u0011^¡jÖë\u0082W\u0091þP§l\u001f^S\u0016\u0084/r*¾$\\}Óµ\u0080\u008b\u0017ÂÓÛ\u000b¬â+ÂÌÁ\u009b\u009b\u0097¦=§c/»l\u0091bXã¼;S2)×=~\u008a#&×=æ\u001fâÓ'|\u0096r=\u009dù\u0015Z:3¾\u0005ýg>Çp\u0084ÿ\u008fH\u0019\u0019è¢I$(\u0087^æ\r°\u008cõ\u0091ÄQ ùÄ\u0083\u008ay\u0084wÑ\u001fxý\u009býw1\u0015Û\u0018(gÆi\u000bÇ\u0016Ó¿@{\u008c\u000fÆ\u007fÃÉ\u0018\u009ebdF\u0019TþB®Å\u001eû\u0011}ÛÈ\u00963|4Ò¬\u009f{´\u008d©rß\u0005å\u000f\\*Ç³¥Ç\u0098ÙÂÕ'Û(\u0094¥EvPÙÑ\u009c\u007fô<Ü\u0013\u009c\u0018è<\u0087z\u0081W\u009c\u008b8E\u0097x¶O#Oy,Ól3ü©V`ÏÃ\u0017\fÁM\u000e[>}ÊO1$p\u000f·PäÔ\u008f³ì6\u0016¡$Á\u009e\u0097\u0082äFX¢0U\u009bh-ï¢Õ-Ý0Z½M\u008eü}Öüÿ\u001c%¦3ì\u0082xã¸Ã\u009c\u0002Ó»LãLW\u0094\u0018¾`ZVä68Ä/×p\u009fé×\u008a\u009cþCø\u0006Ú¿PK\u0007\bì\u0014úßÝ\u0003\u0000\u0000\u0000\r\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000T\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.class\u00adS[O\u0013A\u0014þf·t¥l¥¶\u0080\u008aVPQz\u0083\u0015_K\u009a\u0098&&M\u001a$)éûP\u00862d;ÛÌnëoñ?ôÅ\u0017L|0>û\u009f¼\u009cÙÝ@ \u0018cÂÃì¹Ì9ß9ß9³?~}ý\u0006`\u000f;\u000e,\u0086\u0083@\u000f=>æ\u00833á\u008døT(ï£æã±ÐÞÀ\u0097^;\u0018\u008d¸:éJ%\u000e¹\u000e\u0085ÞjóPtT(T(#9\u0015½HK5¤°1×<\n´\u0083\fCá\u009cO¹çs5ô>\u001c\u009f\u008bAä Ë°\u0012{'\u0091ô½«x\u0086ì¾T2j1Ø\u0095j\u009f!Ó\u000eND\u000e6\u0096\\8¸Ç°l\u008a\u001fLFÇB\u001fñc_0\u0014»Á\u0080û}®¥±Sg&:\u0093!Ãa÷nù4\u0019\u009cAlQ\u008díJ÷\u008aY\u0012Ù\u009c÷T;9\u0094°ê`åÚ$\u0092[\u0017kxÈPJ1\u008f\u0082ÎP\u0005Z\u0098.\u0018VoÁOÐ\u001e»X7y\u008b\u0097yÔW0\u008ed öÌ@æÒ.¯ßÒhNäé)\u0003ëÜ`\u0090ì¦9ï15\u0019^¸(à\u0001C¯r×3\u00adö\rþ\u0012C®\u0017Lô@¼\u0097f\u0083ks@»¦3\"Ý\u0093CÅ£\u0089YÁþßú¿ñ®öçGÒ¢¡¸\u001d¥\u0084nû<\fEè Î°û\u007fÜ\u00186þÁ\u000eo\u0088\u009bMg\u0081þ²\f,ó\u008aÉZ$Ë#ÉH.Ô¾ ÷\u0099\u0014\u000b.}³ÆÉ~\"Oº\u009b\u0004à>\u0096I2³\u00814ù\u0094¢3$\u008bõÆ\u0005\u008a\u00adò',\u0094gF\u007f4»D*\u009a\bö\u001bY\u000bÈÑÏíZv\u008cZK2ST£=ÁÓ¸R\u0011eÒ,êÁÅ3lÀ.¼£\u009a\u009biÍ\u001d\"b\u0093Ì×êßQjÐ¹ÀóÙõÆéäc\u000få\u0011×\u0097iê+\u0092VÊuëv®æÚ¦@£½Æv,+¨\u0092ÌÅ\u0083ª¡\u0081õ?PK\u0007\bà¤ûG*\u0002\u0000\u0000¯\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classíXéw\u0014U\u0016ÿ½¤C5Í\u0003c#Ñ\u0080K©\u0001\u0092ÎÒ \u0088b0C\u0004Äh\b`\u0098d\u00823h¥»L\n;UmUu\u0002¸\u008eÛ,*nq!âÎÈè8c`L\u0087\u0018qß\u008e\u009eã\u0007?û\u001føÅ¿@½·ªº³ts°\u0013?z8t½õwïýÝå½\u0097¯\u007fzï\u0003\u0000kñ¹\u00822\u0081\u00ad\u0096Ý\u0017×ÒZ¢_\u008f\u000fh\u0083º\u0019\u001f²µtZ·ã\u0089\u0094\u0011ßl\r\fhf²Ý0õ\u009d\u009aíèvÍ\u008d¦5dîH»\u0086eú#\u009d®æê\nB\u0002\u009bJ\u0084*@\u0011\u0090\u00967ÖéÚ\u0086Ù'pMû\u009c ýíÍ\u0002\u000b|8\u00815¿\u001aÈG ½\u008b\u0012S\u0083g\u0004ðÄ'§Á\u0010@\u0085ãÛ´±T#¦1Â6\fj©\u008cî\bT¶ïÓ\u0006µxÆ5RñvÃqina§ÑgjnÆ&15³¦7úý\u0094föÅ\u0003BZ\u0018Îí7\u009c\u009a5¥PâëÃ{7\u001a¦á¶\b!kKÝ</G\u0096ê¼R}5\u001f\u0007Õu\t\u00846[I}!\u0004Î\u00958\u001bÑ\bÊQ-±\u0014Ë)½Jeª0+H\u0084\u0082ó\u0005\u0096Nù·Õ¶µ\u0003ìä\bVàB\u0016u\u0091@ym]\u0017+q±Äb,áÖ¥\u0012\u0015XÀ\u00ad\u0095\u0012\nÂÜZ-±\u0010\u0011nÕI,\u0082\u00148\u008b\u0085wd\u0006zu{·Ö\u009b¢P\u008a¶[\t-Õ¥Ù\u0006÷\u0083Á\u0010\u0007\u008eÀ¶Rí)^0(\u009a\"\u0096Ùj÷e\u0006tÓ\u0015ØY[\u0018®uóñK\u0084,\\+q\u0019.\u0017XÒ§»×kÎ\u00944¢j\u008f\u0082+\u00046üZ\t¹½[÷'tÏ\u00960®\u0014¸<XÑ\u0098¢%ª_lÔÕ+\u009dÕjÒÒ\u001dÕ´\\ÕÕn×UÍTµ\u0000 IÁ\u0006Êå)cwôîÓ\u0013äÈf\\£`ã\u008c)\u009f\u0007\u0089\u0016ü\u0081\u0092ï6Ë\u001eÐHù\rE¨º¹}6 ±W°*\u0082uhåh¹V`Y1Â»X\u008d-\u0012[q\u001d\tLéf\u009fÛï±Õ\u0016ÆõTÉZMU\u001fH»\u0007òÖ¨C\u009a£¦mkÐHêI\u00954T\u0013§a¤i\u0011n@»\u0082\u001bÉ\u001d3\u000b\u0095Ävt\u0090\u0014-\u0099\u009c¥VÎ\u0092=ìÌ\u009d\u0012»p\u0093\u00176Äz:¥smm©\u009dW\u0090\b\u0084µ|PD\u000b\t!]¹\bi¶Û¡ïw)\u0006\"èF\u008f\u0082?\t4\u0095V\u0093$öp$F)\u0012[S)k(\u001f\u008c\u000eóòg\u0089¿ð´b8[\u0099_\u0005·\bl)Ñ°í\u0086ã\u0090Ò¾<\u0082÷L\u008c`/4vy¯À#¿A-*\u0015¡¨R\u0014ha\u0090³×wXs\u0089¤\bnC¿\u0002º\u001f4ÏãT\u00910°\u008f\u0003 \u0091Ð\u001d§f\u00adÀ®9ò\u0093/WE\u0012.\u0005SÁÀ\u0099Â¥àH\u0092°\u0090¦ó\u009drbGp\u00859X$aK=\u0018Ï\u0090,\u0005j\u0004Û8Dm\t\u0087«BÈ1\u000eRTe0¤`P`Ý\\\u0000%öã\u0000YGÉÐ\u0015\\n¢µu³¯7\u009ckwJÜÅ\u0089±<\u009f7Û3)× ìÏçO\u0018÷P\u001dÈ\rçãÉQ\u0087t[/¡6Ý'ñWÜO\u0001a¸º\u00ad¹\u0096-P5C©¶`\u009cèx\u0010\u000f+x\u0088´.\u009c\u0095ø\u001bþN4\u0099T0\u0004Î©\u00ad+¬gÌÞ?%\u001eá2¼\u0088<\u009c3\u0085q\u001f\u00938äU\u0082~Íá\u009aÃ$<!ñ$\u009e¢ÚH$lÑÓ¶\u009eÐXõnÍ6½[òL!ùÐ\u001bÆ³\n\u009e)¡RùA-ñ\u001c\u009e\u009fÊ\u000bÒe[É·½@\u001fÃ\u008aï$eÜn\u009b9mV0BW¤Ù\u009a^\u009b1RIÝ\u000eã\b±¶»_W#8\u008cVþyYâ\u0015¼J\u0007\u0011\u008b2©^4\u0016;\u001c\nL\u000f\u0000\u009bÃx]à¼\u009c\u009f\rGM\u0006ÜQ44zRþÅ\u0002Þ\u0098\u0085{ÚlÎáòÎ\u007fK¼É.\t»\u0096?\u0019Á\u007fð_\u0005oç®i3M\u0097ø\u001f;[IóPÊd§\u008eJ\u001cg\u0084ÅäÔÎLo\u0010\u009a\u0011ü\u001fc\nÞ\u0015¸zîÇ\u009aD\u0016q\n-Ëì°Ì\\ù\u0090i/\u0017sÝõs«\u0004ôªñ\u009e#Btþþ\u0004\u0098ë\u0099x\u009a\u001b1ß¾\u0004ÞçÃú\u001cºætZ\u0019;¡_gðÝ»ª\u0000¤\u0089£\u008c¼Úf\u009aº½9¥9\u000eWÑªâÐT:\u008a\u009eÃ\u0002g\u0017{\u0083O'\u009eÂhÚ$TÒ°\u001cÀ\u0002DùiA\u00ad(?,¼/=+¼/=*¼/=BhõYÔ.Cee%¿\u008c¼\u009del Í,£Þ³\u0084Æ(\r±ú1TÅÄ8Î\u008bMbEÏ8.\u0018\u0083\u001ak\u0018Ã%±Æ1ÔÄªCcX\u0015«®\u0018Cíq\u000f1F¿\u0017\u0092l\u0088\u0011DÄóX&^ ÷Ö\u0011z\b½\u0088\u0095â%Ô\u008b\u0097QOkÖ\u0091\u009e\u0084Oÿ\u001a\u0001¯UáéÀ-Ö¼Ük±î!¯ÅÚW\u0090vM\u0088çuT¼õ\u001d±,Ö\u008c`Å$ÖõD×\u0087Náª\u009eòØ»¸¤ó$®\u001eÇ¦\u000fë³Ø\u009c\u009bÞV8Mmµ~\u0002meè& \u001d£y+\u00963\u0003âu(â(iÿ\u0006V\u0089ch\u0011o¢M¼åYPåKÏ[Ð\u0081Nì&Ý\u0004þ\u0088\u009b\u0002\u001d»I{Aß\u0095$¥&\u008b®Ã¨fy\u0013¸YPµZ<\u0089½=Lî\u00ad£3E/aóÅ;¨\u0012£PÅ\tO\u009cô\u0081\u0002q\u0082_P\u0081\u0090Ë<¡@8\u0010òv\u001eg\u0001\u008f\u0013þÔþp~ÿ®\u009c\u0092b/\u0011É$ÿÈD\u001eÆêi\u001aú¬%\u008a²¶\u008aû'¡ûRoo÷·Ý!@\u0084»^ãÖÐÑ\u009cå\u0007s\u001e¸»¸\u0007&p¯@Ç1D\u001b'ð\u0080ÀGhÞ^ß\u0090Å?¨û¨ÀÈÏ?ø0\u008f\u007f\u00818µªNâéI\u001cî\u0089¾0\u008e\u0017\u0019*\u008b\u0097¢¯eq4XE\u00ad,\u008eeñ\u0096ß\u007fç\u000bD©U\u001bô²81ÊÝ)¾×SR@¼\u008f¥â\u0014\u0005èGäæ\u008fé¦ÿ\t\u0086Äg8$>ÇÓô=\"¾¤3é+|'¾Æ÷â\u001bü ¾õxU½Pý1àµ\u0005'0\u008e\u0093Äì!\n×\t\n\u0088²JPb½\u0017øª\u0081|¢°7bõ\r\u008dÕ¡ê\u008aqL\u001e\u009få¯\u0011\u000f·Ìû\u007fÊûý\u0000\u001fÒ7æ%À0\u0091SF¯\u0087a|\fþ\u008bÆ0>\tñÍ{\u0018\u009f\u0082\u008f©a|\u0016\u008aü\u0002PK\u0007\bF{)6N\u0007\u0000\u0000M\u0014\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000J\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.class\u00ad\u0095[O\u0013A\u0014ÇÿÓ\u0096\u0096.[.\n¨(\u008a\nØ\u000b²â5\u0001E\u0011Á\u0018+\u0090`jâÛ´LÊ\u009aÝÙfv\u0081\u0098ø¢¯~\u0015\u001f$QH|ð\u0003ø¡\u008cgv\u0097Z /MIÓ\u009d9\u0093s~óßsiÿüýõ\u001bÀ\u001c\u001ef\u0090`xá©ºÅ\u001b¼¶-,\u0097ï\nií)Þh\beÕ\u001cÛZö\\\u0097Ë\u00ad²-Å\u0006W¾P\u0093olß·e}½\u0011Ø\u009e\\RõÍ\u0080\u0007\"\u0083\u0014Ã|\u0087¤h\tã\u0019Ò^\bdx^î\u0010\u0013)i\u0081-\u0010í±-í`\u0091a%ß=®PaH-{[Â@\u0012}&20\u0019\u009ev\f>\u008eÌ\u0082¡ßD\u000fÒ\f\u0003ÚkmÇ\u00ad\nõ\u0096W\u001dÊÆ¹²WãN\u0085+[Ûña*Ø¶}\u0086ÕN/n[1JÒ Ë?V\u0005Y*X\u008f\u0093?\u0092/\u007fà»Ür¸¬[\u009b\u0081¢°\u0085Â{\u0083´\u008e\u009a¸\u0080a\u0086^Û?rNrU×ROE0ä<y\u008c»Ý\u0086Ûæ¦îke`\u001c×2¸Êð¬[\u0096\u0089\t\\g0<IÎ\rGè.]Ìw¬ñ¸º$n\u009a\u0018Ãe\u0086>O®yò(A\u001bí\u0012ßÝUã¸e\"\u008f©ð\u0015¨ì;®\u0090\u0001U=|\u009f£È\u0015¹E\u0085Ìë\u0016ÿz\u0006£r6\u00adY¨è\u008e»\u00ad'\u00ad\u0097Ôoz;ª&Vm=\u0003£§\u0018³:o\fæ+)\u0085Zv¸ï\u000b?\u0083»\f³\u009di¡æo«\u0086aèÔ{RõZ,ê\u0013Ê!ý¤Ò0è\u0081¦]\u001a\t-\u009eN²d½$+Ak_\u0091\u001dÂ(\u0096~\"·Of\u0002\u0003ôì×¡ÌA\u000fsa0\u0089A:\u001b\u008dÜ1D@\u0084;\u008deô9\u008fá\u0018:\u001fCÓÅÒ\u0001F¾5yÚ\u000fLµpÒMN\u001a\u0017q)äP\u000bÆ\u009c×t¿\u0016\u009f+þ@î\u0000WJ3\u0007¸ñý\u0004n/ÄMD\u008eM\\.Æé]\u000fí\u0012´\u009fÄT\f~\u0012\u000bÌj0i\u009c>\týÔ¢1Û\u0084f\u009b\u001a\u000b(Æ¨G¡\u001d£Hã»ÿé3t8ûL\u008dò%Ä\u0099\u0091c\u0084£\u0083\fJ1d\u009a<\u0093QÂ\u000e1³\u007fB\u008c\u0013F'Âïlø´p\u0087Ö1\u008aaôgy\u000fz¢æp?¥\u0087x\u000e\u000fRÆ?PK\u0007\b\n\u0081ªï\u009a\u0002\u0000\u0000I\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classµU]O\u0013A\u0014=ÓÖ\u0016\u0096\u0095\u0016\u0004Ä/@¬BKe¡øIQC\u001a0&\r\u0092Ô4\u0081·év,KÚÝfv\u000búSü\u0005úà\u0083&¢F\u0012\u007f\u0080?Êx§,µI«ÍúñÒÙ;÷\u009esï\u009c¹wúíû\u0097¯\u0000\u0096ñ \u0086\u0010Ã\u0086#«\u0006opsO\u0018u~ lãPòFCHÃ¬YFÞ©×¹])X¶ØæÒ\u00152ù´áY\u008e½~È¥¿Sô¸'b\u00880¬\u0006¤êÀ3\f\u0099?ý\fK\u0085ßrµ\u0090\u0095\u000eÆ\u001cCÔÛ³ÜäR_lW\u001d\n»fÙ\u0096÷\u0090Á\u009c\u000f\n\u000eZhªÄ\u0010É;\u00151\b\u0086³:b\u0018Ð\u0010F\\Ç \u0012\f\u008f\u0082\u0016Ð©\"\u0091+ÖQ\u001dg\u0010e\u0088«¨\u00adf½,ä3^®\u0091¬£\u0005Çäµ\u0012\u0097\u0096²ýÍ\u0088\u0012\u008eáqÐÄ½;\u0081ÔLÔùË² Kz'1\fãó\u0085}~À\u008d\u001a·«FÑ\u0093\u0096]Í¥v5*ö¢\u008eK\u0098d\u0018°ÜÓà0\u0097UUk\u0017\u0082ºÄ±·\u001cû4p»\u0017ëßè§á*®Å0Ë°\u0018ìZu$q\u009dî\u0093W*\u001b/<ÉK¼Ö\u0014¿8vIÃ\u001cR1Ì÷ËÒU«\u008e4\u0016H*n\u009aÂmõúJà~MíÆp\u0093!\u001fP¥õç\u009e\u0090\u009b\u0096t½b³ì»5d`¨¾¥BÞü÷Á\tz¯½*&ñcÈ2äþ\u0084ë¤ë\\\u008d\u009eÎ[êÔ·\u0019\u001a}Ný\u008fNágn½\u001dZÑiJSlZjt'º\u0000\u008bªß\u0018ô'¶-d¾Æ]WÐl\u008fõ\u0012\u0083¢:Ù\u0089\u00ad÷DÓÔuX\u0091\u0019\u001aÚ0ý\u0081\u00840¦\u009e\u0019 \u0091P\u008f\u0018í\u0084\u0011!YÔP\u000f\u0091U \b\u0015\u0097H/\u001cAO³O\u0018Ng\u008e0ò¾\u0085=G¿ÃÊÏ¦ ±iÄÙ\fñ\u0001\u0013ä#\fÆé\u000b\u00ad/\u0095#D\u009cç1é3¯\u0092\u00ad¢¢é\u0085\u008f¸ð¶Í\u0017%?X²\u0083'Úæ\u0089â2®\u0090\u009fa\nÓ>Ï>q«¨lú\u0003F\u0088j\u0086Vý3n¼ÂÄ12;ÊR\u001eª|ñ5âÇXÞñÍ\u0095wí\u009c\u009ab`)\f°tGÞl;oÖÏ\u001bÂ\u009d\u0016æ.îÑ:KJeè\u0015¸O;Ë´®¶T\u009bC.¢4\u009bÃZDû\u0001PK\u0007\b»Ð=\u0086ª\u0002\u0000\u0000§\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000E\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.class¥T[O\u0013Q\u0010þ¦-¬\u0094r- à\u0005\u0015j[.]\u008a\u0088J\u0091\u008bU\u0093\u009a\u0006LjHôíPNÊ\u0092v·ÙÝâßð\u0087ðâ\u000b\u0018I\fÏþ\u001f£¾\u0018çl7 -\nÅ\u0087³3gvfÎÌw¾9_\u007f}þ\u0002 \u008dg\u001a\u0002\u0084\u0015Ë.é¢*\u008a;R¯\u0088=iêïmQ\u00adJ[/\u0096\r=kU*ÂÜÎ\u001b¦|-lGÚ\u0013\u001bU×°L¶W\u0085-\\ËÖ\u0010\"ôî\u008a=¡\u0097\u0085YÒ7¶veÑÕÐN\u0018ð¬5×(ë§þ\u0084ö%Ã4ÜeB0\u0091Ü$\u0084²Ö¶\f#\u0088Î\b4\\#ô¨ÓÖk\u0095-i¿\u0011[eIèÏ[EQÞ\u0014¶¡ö¾1äî\u0018\u000ea-ÿ\u009f\rd\bZÑÛqÒbâÒéêy2\u00adú'saD1¨a\u0080\u0090j-6\u0082!\\'\u0084KÒ\u00ad\u001b¸ý¾D2\u007f\nsAº\u0019\r#\u0084\u0017W\u0002¥àÚ\u0086Y:\u0085&\u008caÜP·r\u0093ðêòÈü3g&¹\u0019ÆmÜÑ0F\u0018ü\u0093!å2\u0013Gu\u0015Á]ÜczT\f\u0093°\u009aÈ\u009fç\u0094É\u009fG®\u008c\u000fÆ\u001fLd<&Î\u0010´^\u0090\u0086û\u0084õ\u0016;Ê\nGæLG\u009a\u008eá\u001a{²\u0019®\u0018\u0012\n®$¡Ð2\\\u0017$÷p\u008ba*\u0082^L\u0013â\u0089|cK\u0099fK2Çä¶¼{H\u0013f[åêIð\u001c\u008f\u001bßFZ\u008dbÓ!õ\u007fs\r5ùè7[Ô\u0000\u0010\u001eª>ú\bÏ¯H«\u0006`\b\u009d<\u0018\u0005«f\u0017åKC=\u000fCM\u0091)U\n¡£`\u0094LáÖÔ¸¿û[Á\r¼Zj\u0015¹eF%\u00923MigËÂq¤£a¹\u0085y¯\u0017L\u0018»\u0080\u0014LìF8¸óó\u0007\u000f³\u008cR\u0090W\u001b¿þ!\u0004ÔcË»\u000eÞé,\u0089eÛä!Â\u001fY\t Âßve¤oèb=Rw@7zX\u0092º<?ø\u0003'S)\u0017¦\u000eÐ\u007f\u0084á·t\u0088ÑO¸u\u008cñõé&Óbè\b1µ\u008fÏ\u008c\u0084\u000e0¹\u007frZ7\u0017\u0007ú\u008e(ý@\u009c~z§Î×3û§*m\u0006)¯\u0092\u0005.:Å\u0091Q\u008csci\u008e\u008d³Ï\u001ck¡Þ5®î\u0081_Ý\fÿá¼è\u009a\u009c:Ft\u009a×\u0001æ÷Ï¶È«Ë³p\u001c£²à\u0087ÆX\u0006|T\u001e\u009d\u008f\u008aú\u001dÄcO{\u0082EOf°Är\u0094í1<Å\nkÄr\u0095å0Ë5\u008cþ\u0006PK\u0007\bK\u0002\u0096\u0017Í\u0002\u0000\u0000\u0081\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000F\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.class¥RMoÓ@\u0010}ã¸Ië\u00864M¡|Ó\u001e@Jz¨Å\u0095V\u0015\u0010\u0081@\u008aÚJA9pÛ¸#w+{m\u00ad7\u0085?À\u000fê\t\u0089\u0003?\u0080\u001fU1ëF*\u0088^JVÚ}óF³ow\u009eæ×å\u008f\u009f\u0000^b»\u0085\u0080ðº°i¬J\u0095\u009cr\u009c«s6ñ\u0017«Ê\u0092m\u009cd:\u001e\u0016y®ÌÉH\u001b>V¶bûü¨tº0Wdì\u0094ã\u0016BB÷L\u009d«8S&\u008d\u008f¦g\u009c8Bs_\u001bí\u000e\b\u008dþ`B\b\u0087Å\tGh`¥\u008d%4\tk^ôp\u0096OÙ~RÓ\u008c\t½Q\u0091¨l¢¬ö|\u009e\fÝ©®\boG\u008bþs\u008fÐ)\u008c\u0084Ö\u001dòW÷Æ¦\u0084\u0083þà¶º\u007f+F\u0085\u0011¡YÎF:>î\u008f®m\u0018;«Mº· ~'e÷AU×o\u0088\u0099\u009fëgåf\u0099±\u0013\u0087Þõ\u0017÷f0\u0089@X\u0011åq1³\t¿×ÞûÍ\u007f®îú\u0006\tí\u008fÆ°\u001dfªª¸já1a÷v_ ¬ß0HÏ\b¯þß.Âê\u001f,Ü\u0096\u0086\u001að«\u0089À\u008f\u009cð\u0096°X\u0090\u0004\u0097v¾cùB\u0082\u0000Q]$Iú\u0086U\u0089ÛW\u0005\u0082wà§»\u0083µ\u001a»X¯±\u0087\u008d\u001aïú|×WÞ\u009b\u008b¿\u0010\fæâ\u009b7\u008b\u0007õ¾_\u009f\u000fðP°'\u0011á\u0011\u009e\u0084\u0011\u009e\nn\u0085ÑoPK\u0007\b\n \u0095Ò\u0094\u0001\u0000\u0000¥\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000A\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.class¥S]O\u0013Q\u0010=SZ¶¬k©\u0005\nø\u0089\nÒ.´+~àGÕ\u00071&&\u00044\u0098\u001a|ò²½)K¶»Íî\u0082ñ§ø\u000b|\u0095DJ¢\u0089?À¿dDçnW\u0004\u008a\u0089\u0086\u0087Þ\u009d{fÎÌ\u0099¹Óo{\u009f¿\u0002\u0098CMC\u008aPó\u0083¦%ÚÂ^\u0097VKlIÏz\u001b\u0088v[\u0006\u0096í:Ö\u0082ßj\t¯±èxò¹\bB\u0019L.·#Ç÷V¢Àñ\u009a\u001aÒ\u0084ü\u0086Ø\u0012\u0096+¼¦µ¼¶!í\u0088Ð'\u0082&¡°øÇÓ\u008d¯\u0011úý\u0098ÏÆ\u0003Çs¢G\u0084éRo\\/R®\u0013Ò\u000b~Cêè\u0083a \u008bÓ\\§T®\u000f\u00800h \u0083~e\u009d1 ¡\u009f\u0011¥xi³µ&\u0083\u0097bÍ\u0095J\u008do\u000b·.\u0002GÝ\u00130\u001d\u00ad;!ááâ\t\u0086ÀMå\u009a2zâ\u0084mW¼[\u0012-Î;\\*÷¶\u0090Å8!U©è8\u0087\u000b\u001aÎ\u001f\u001a]7ÆÀE\\\"èa$\u0082(|åDë\u0084\u0091cæS~\u00adá2aô¨ãñ¦ã6d c\u0002WÕ\u008c&ÿB¯«\u0088k\u0006¦Qâ\u0097P\u009dz\rBå¸Ð\u001e(©QS)L\u00033\u0018%d#¿ëÌ¢B n\u0091`\u0019(*_ã\u009fÞ÷D/ ú!ÜP\u001d\u000f°\u0018aÛ2\f'ç\b/J'Ë{Ü\u0006ë+þf`Ë§\u008eZ bO\u0086ª¢\u0010\u008cg\u009e'\u0083\u0005W\u0084¡\f5Ü#TÿO\t§8¨\u0085\u0087ÍûÎÿÛ\u0014\njÙÙ*¨Uço\u00861n\u009cý:ßVù¦â\u0006Í]\u009c2gv\u00903gw\u0090ßN¨\u008a\u0096æó\u0007\u009f{Lú\u0089\u001c\u0001C\u008cLti\u0018Æ\b\u0010[ª\fÅ\u0096*\u0094b\u009b\u001f4)ó\u0086£\u0095oÞü\u0084\\a¬\u0083³ï1þ\u0005\u0013«\u0085±]\\a0ßÁT\u0007å\u000f(Æèì!ôã¾\u009a¸\u0002õÅ\n\u008cnÆD\u0001©ÕJªYüU¾\u008cÙAõ(9{\u0080\u009cé\u0092óà\u0089\\OÈÓ,Uµ¬\u00993¬bnû0\u009d'1\u0014#Ègq\u0013·\u0012ÒÔ~E\u0016}¤\"¾ÿ¦ðïv|Îã\u000e\u007fõ\u0098t\u0017÷¡ÿ\u0002PK\u0007\b\u0016¤\u0018Óv\u0002\u0000\u0000f\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.class\u00adTMO\u0013A\u0018~fºeeY(ß\"ZPAh)v\u0005\u008c\u0097\u0012\u0012Ò¨©iÀ¤\u0086DoC\u0099´K¶³Íî\u0016\u007f\u000b\u009c¼y°\u0017/\u0090hb<û£\u008cïl+\b\u0085\u0090&f3;ï×¼ó<ÏÌî¯ßß~\u0000XÃº\tÎðÒ\u000fj\u008eh\u008aj]:\rq$\u0095ó1\u0010Í¦\f\u009cªç:E¿Ñ\u0010ê ì*ùV\u0004¡\f\u0016w\u009b\u0091ë«J\u0014¸ªFÙ¦\bDä\u0007&\f\u0086ÑCq$\u001cO¨\u009a³»\u007f(«\u0091\u0089\u0001\u0086É8Ú\u008a\\Ï¹¨g\u0018Øt\u0095\u001bm1$2Ù=\u0006£è\u001fH\u000b\t\fÙ0q\u0087!¥÷Üi5öeðNì{\u0092a¼ìW\u0085·'\u0002WûÝ \u0011ÕÝ\u0090áuù¿Ð(0\u0098ÕØ£ÖË\u0099ò\u0005¡Ne¡7\u0092-Y\u0098À\u0094\u0089ÉK\u0002t²6¦q\u0097¸zRÕ¢zÌµdâ\u001eÃN\u009fp\u008b\"\u0094%\u0015J\u0015º\u0091{$¯â¶0\u0083ûZ¸\u0007\f\u0095L¿ZÜÒ¼\u0090ÝÓýçl\u008cb\u008c\u0004òcéÖô\u0081ô¨q\u009e^'ÖaÝ\u000f\"ªc\u001fþ:ëWTí\\\u0093BoD«Ê0Çð¦o67\u009c¬&Á0Ä`UüVP\u0095¯\\}}¦{Öç5\u0016\u0086Á\u008a[S\"jé\u008b°y\u0013â+\u0097z³W\u008f-RÄ.)%\u0083¢'ÂP\u0086&\u001c\u0086|\u007f\u0094\u0018æo9\"\"r=m<#Ò\t\u001aIúä\rpým\u00917H\u009eC3£9¹r\u0006ë+\u0019\u001c6½\u0007t\u0090\u009b\u0018&Ûî\u0014`\u0004)\u009a\u0099>ÿîâ/ÔT·ÜÎ\u009dbÜø\u0004Óø\f#±µú¯÷ÂH\u001fÃ\u009a2N\u0090äíô\u00896\u008f\u00914Úß1ó\u009e\u009da6GÕéöùÆs\u0084\r|\u0010#ÜB\u009a\u000fa\u0089ÛÈð\u0011¬ñ\u00146øX\fèygÓ. mÍãa\fr\u001b\u008fÈâ\u0094ÙÀc,\u0010¼4\u0016éY\u00801ºMÀ\u009ft\u0081?¥L\u0082æá\u0095ÜOL¬Ò8ÅRû2{\u001aÃq\u0084Ö\u0011¨åîRÝ\u0082w\u0005Ë\\/\u0098N'\u0090\u008d\u00ad\u0015äây\u0095ö\u0004ÆÉ\u009aA\u009eÎc\u0096êóôû\u009dý\u0003PK\u0007\b7¤çy\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000@\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.class¥\u0093ÍnÓ@\u0014\u0085ÏMÜ:uS\u0092\u0006\u001aÊ\u007f¡\u007fI#b±%\u0015 E !Em¥TY°\u009b8£Ä\u0095=\u008eÆn\u0011ïÄ\u0086\rH,x\u0000\u001e\nqÇ\u000e\u00904Ù\u0094X\u009a¹sí{?\u009f3\u009aùùëû\u000f\u0000/pd#Gx\u0019é¡+ÆÂ\u001bI7\u0014WR¹\u001fµ\u0018\u008f¥v½ÀwÛQ\u0018\n5èøJ\u009e\t\u001dK½\u0097\u0085n\"\u0012iÃ\"\u0094/Ä\u0095p\u0003¡\u0086îiÿBz\taõØW~ò\u008a\u0090¯Õ{\u0004«\u001d\r¤\u0083<Ö\u008aXÁ*¡dp'\u0097a_êsÑ\u000f$¡Ò\u0089<\u0011ô\u0084öM>yi%#?&\u001cwþ_a\u008bõ\u0085âS_r¦\u0093ÓqâG\u008a°Uëü\u0013ÝM´¯\u0086\u00adú\u0007BÁ\u008f³\u0092\u0002*,þy³áà\u000eª6¶flf\u001dEÜE\u0089`\u0087\"aa¬3/ôÐ8\u0099C\u00136\"5#`´@À\u0002I75\u009eágí¯Gê$R\u007f~|¶Èù\u0092û\u001b©©\u0092·j@x][\u0006Yï9 ¬\u0011\u009cnt©=ùÎ7\u0087¡:×Ô4N\bÅ÷JIÝ\u000eD\u001cËØÆ>áÍ²Ûfã\u0090Ð¼\u0019\u0085°9ÇáÝ\u009fÊ¬\u001d¶\u0095\u0087yøâ\u0099\u009bÀ¹Í\u0099Ë\u00918®\u001c}Cá\u000b/rpx6\u009fAE¬óº\u0098\u0015pÜ\u0080¹t·PJAe\u008e\u0019¤Å]9\u0083nT6¿âöçk\u0098r\u008a©f%\u0019&]mã\u001e\u0088\u0081÷ñ \u0005?Ä#~OxüW]#Íy\\W¶=¥\u008c2dÙh|2iÜç\u0098\u009bØÚYl+\u0097\u008e§éü\f»\u001c+¼ÚÃ\u0001j\u00969\u0004\u0007¨[ÎoPK\u0007\bûtS\u0083ì\u0001\u0000\u0000°\u0004\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000M\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classÅU[O\u0013Q\u0010þ¦WX\u0016(H+â\r\u0015µ]\n\u000bÞ/\u0084H\b*\tA\u0012´\u000f¾\u001dÚ\u0093²Úî6Û-ðêÿñA\u0012.\u0089\u000fþ\u0000þ\u0001^\u001e|ñÅ\u0017ý\u0003Æ9Û\rT\n\u009a\u008a\u0089\u000fÝ\u0099sÎÌ73ßÌ9Ýùñö\u001d\u0080qÜ\u0089#Dxä¸ESTD~Y\u009ae±\"msÕ\u0015\u0095\u008atÍ|É2§\u009drYØ\u00859Ë\u0096\u000bÂ\u00adJwè\u0099ýÒvVí'\u0015ÏrìúÞ¢'<\u0019G\u0084ð E°&\u0014B´Z\u0097\u0013s-b5 Ü'\u0084\u0085[$ôÎ½\u0010+Â,\t»h.z®e\u0017ù¨#¿ïK\u0018û}\u001c\u001fµÐ\u0010\u008d\u0001b\u0013\u0096my\u0093\u0084WéfüVá\u008eSf&G\u0088L;\u0005©!\u008cn\u001d\u001dH\u0010fÒ\u00adB6u\u0081\u0081ÛÁìé\u0088£Mi}:Ú¡)-¥#\u008a\u0018¡[ùÏ×ÊKÒ}*\u0096JRqíäE)'\\K\u00ad\u0083Í\u0088·lU\t³\u00ad¦tÔ\u00941û]Eé=\u0016Õ)·X+KÛãV§3ÏyÛ±ÙÂõæå\u009a7¥z?\u0099Î\u001c\u0087[\u008d\u008b\u001dÔq\u0001ç\b\u009ac³q¥$Õ`òb?öÂ!\u0013p¬°\u00846\u0011 k¸\u0082t\u001cW\t£\u00adÍ\u0094\u008e\f\fB§(\u0014fÖ<WäD©Æ\u0089'\u000fË\u0095'hç?Oñ?\u009b\u008dLN5mDÝ\u0003\u009dû´èÔÜ¼|h©9L5Á\u008cª\u009a\tú¬mKwº$ªUY\u008dãÚ\u009fÈnÂ!ô\u001cò\u0016Þ$Üû{Jø\u008dúeÕ\u007fTÉ\u0018ä\u0082Ãü\u009a\u0087Ñ«î%k½êÎú\u0092o,Ë\u0018B\u008a\u000f¶ëäU\u0099W\u0011\u0096I\u0083¶Ñe\fo¢ÇÈnâ\u00841²\u0089ä:\u001f\u0084p\u0092¿)\u0006\u0003í\"Jï¡Ñ\u0007tÓGôÑ'ôó\u0099Q\u0007À)\f\u0000¾¦\u0002\u0092¯©\u0090!_SÉ\u0084y÷4Î\u0004¡³,\u0095U(òz/NLíÐg\u001fW¯\u009f\u0006¸\u0084³8\u0017x\u009a\u0081gÔØÂù7\u0007\u009c¿48G÷\u009c/âRà|\u0097eè(ç¯¾sªn°WQ\u0014C~E¤n\u007f\u00003É6*DÂØ`¶6Ð³\u0085Ë,\u0092û\u0088~åô\r\u001dô½!¥D\u001d5\u0001nÂp\u0080\u0095f\u0006\u0099_´\u0019ÃÙ\u0091md×\u000fdµëû\u0087üß¨ÿ51Ær\u0080\u0019\ró\u001f÷õ\u0088\u0086\u001b,oEÔ¼\u008fã6´\u009fPK\u0007\bO<êÑÇ\u0002\u0000\u0000Õ\u0007\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.class¥Z\u000b|TÕ\u0099ÿ\u007fÉdîÌä\n!\u0098È H\u0004\"!ä¡(¨I\u0000C\u0000\u008d\u0090\u0080\u008dB\u0003\u0082Ü$7ÉÀd&ÎL\u0080ø~ Ò*P\u00ad\u0015\u0082ÖÊ¶6µZ\u0015\u0095\u0084\u0098\n\u0096Z+îv·»Ýn]ÝG©înÕ\u00ad}¸îÚÕ\u0085ý\u009f;w^É \føû\u0099sï9ßû|ßÿ|ç\u000eo\u001e{ù \u0080\u008bd¯\u0086,AE0ÔQit\u001b\u00ad\u009dfe\u0097±É\fTn\u000e\u0019ÝÝf¨²Õï«¬\u000bvu\u0019\u0081¶e¾\u0080¹Â\b\u0085Í\u0090\u0006\u0087 o\u0083±É¨ô\u001b\u0081\u008eÊå-\u001bÌÖ\u0088`l°;â\u000b\u0006Â\u000b{\u009b\"!_ \u00833Ë,ª\u009e\u0088Ï_Ù`tW\u000bÜM¾\u008e\u0080\u0011é\t\u0099\u0082¦ÔÕ\u009ae\t\u0091Q\u0001ÕËNÕ°å\u0096æêùÔ0Îðû\u0083\u009b\u001b|[Ì¶èlX «\u0005ã\u00adùë\u0002\u001b\u0003ÁÍ\u0081øJ~\u009bÙ\u001d2[\rõº\u0082:#fHP\u0010µÄ\u0017¬´¦V\u0085|\u009c¦èñÓ\u008d0ý·X\u0017ùÂF\u008bßl\u0013¸jhLÀ\u0017\u0099/È.\u0099¹Rà¨\u000b¶\u0099\u001e\u008cG\u0081\u0086³\u0019\u0084\u0084[u~\nÐQ\u0088s\u0004\u0085mfØ\u00172Ûjc\"\u009b\"\u008cKØ\u0012²Ú\r\u0081WÇ\u0018xT\u0010é`cOW\u008b\u0019ºV©¤ÑË\u0082\u00ad\u0086\u007f¥\u0011ò©w{ÒYc\u0019¡á<ÁÄ\u0098ýË{\"Ý=\u0011FÓ4º¢n¸Q\u0084©\u001aÎOÙÁ¦ÞpÄìÒ1\rÓ©?Ø\u0013\u0019\u0015\u0083¨\u0088j\u000f&ã\u0002\u001d\u00930\u0083ö\u0095,K§¦zæJ\u000f\u00ad\u009f©¨J\u0019³\u0004\u0095\u001dG+D\u0091N\u001f]½ð\u009478\u009ayÔ\u009f\u008d\n%9OÃ\u0085ÜëD\u0002]e\u0084;\u0099D\u001eT¢BEïb\u001d9pj\u0098C\u0013Òì¦\u0007\u0097`¦¢»L\u0087\u008e³\u0018\u008d\u0091f\nrº\u0095RÁâ\u00925£Ssæ\u0017\u009bnÙÛ\u0096ä\u0000åy\u0016oi5£\u0089§\u0081Ùrù©:_\u001bêèé2\u0003\u00918¿\u0007W`¡\u0086ÚØ&Z\u0011¨\r\u0085\u008c^fW\u001d\u00161\u001b\u008cð2_\u0098ûX\u009cb|´Ti|\u0082M\u0091U«\u001d[¢£\nWr,Ib¨g(T~\u009d\u008e¿¹\u00ad\u0089WîB\u009a \nV§S\u0096\u0006\tægn\u0080\u0086e'\u0083¶QL\u001a\u001aGeU\u0093\u0019ÉÅ\n|IÃ5\u0082³R KG\u0013®e°7\u0019þ\u001e\u0093ù<¡$9²uA¿\u009fÑVÀäA\u0003Vª¼]\u0095¨\u009b\u00914ªn\u0096¢YQ\u0011®ÎI¿\u000b+5\\/X\u0094YÙL_h¶\u0007Cæ\u0012_(\u001ciêi±×=X\u0083uJÛ\r\u0082§J2\u00adÄLw#CùéM¦ÿ¹0Ðª¡\u0085(8:>:ÚÀTs©\u00026\"AByaÊ\u008eÔÛóÕ¹è\u0080OCgLJÊª\u008e\rØH\u008c\n\u0098[X@gÇ$$\u0017\u0090\u0086®T\u0000µ²Ô\u0083 nÔÐ-¨ÊÐÛè N\u0000ú\u0010\u0002S)¯Ëèm19\u0013\u008aD\u000f+BrI\u001a\u0018ZíB\u008f «¼Ü\u0003?6ëØ\u0082^&¤yc\u008fá\u000f\u008f`\u0089\u0015ÿj\r7\u000bª34±¶\u009dá±ÏM\u000fnÂ\u00ad*un\u0013t\u009f$uÎ<\u0015\u009253\u0003\\¸C \u0095\u0097¯Y7oí,åõ]:îV!Óº\u008c\be\u0086ÕÜ=:îÅ}ì7Â=-a»\u001b)(©\u009f9:\u0082jÓ¾¢ã«¸\u009fÕm\u009dÂ\u0089\u0088w¦\u0089xÆGÁh\u0087¢â\u0093ö\u009cFlÇN\r;\u0004W\u009c©,\u001d_Ã\u0083\u00821¶+\u008dLb\u009e\u001f\u0082ù%\u0019Û\u0099l¡\u000b_ç\tfG}^E©\nò7t<\u0082]\f¼/ÐfnYÞÎ\u009aa\u0088ëÕR\u009f\u008aÿ\u001eU\u007fõé\u0083¾\u001d\u008féø&\u001e§Ð` vÀ\tV¤Ëñ3³û\t\u0002\u0082e6\u00advá/Tî¬YW¾¶¢TÃw\bÙ\tuñNlq(\u0014d\u0087ðmT(àï×ñ=UT<Î\u0002\u0011Ã\u0017\b/5{5|\u009f\u0010=ÒÒ\u0085=>\u007f\u009b\u0019rá\u0019¶\u009c,È§ð¬*\u0092çNPº+\u0015Å>\u001d/àEu`Ó¡\u0000ÛÉò´\u00118\u0081ªj%b¿\u008e\u0001\fÒËH0Öx§\u0082VRÐ\u0087t¼¬ºÏ1\u001df\u0084\u0087[,ðjé\u0087:^Q\u0099Ãý`H»ýfÄT;yHÇ«ø\u0011\rô\u009b\u0081\u008eH§Õ\u009fÖ«ÎéÇ:ráQåó\u0013\u001d¯«\u009dÌ\r\u0006\u001a\u0083vo\u00ad\u0010ö\r\u001dG\u00942\u00adÓ\b«<T´\u007f©ã¯\u0090G|³´Ä6n±òüìt'\u001e\u008fãî\u0091\brÒÆ1m÷e\u0089±\u0092BPs&)Å\u0010\u0018ª¢òÓ54zÔÚ\u0018\u0082,<slPp\u001eh³jXêù\u0012´EkÑ\u0087\u008b8í#ÐEßh\u0007\u008b.õ~ÐÛ\u001d»#\u009cr³%\u0098\u0092¸Fñüµ;¹pm q©\u009a\u009d1 T«´9ªÃ\u00ad®5\u009enÕ\u008d_\u00176:ÌDO\u0014\u00adC«\u0012âýÎ¿Å:xë\u0090^\u0012\f\u0011æ\u00ad\u000eþ=ü\u0087*¯w5¼\u009fÒ´]\u001b2M6m\u001a>\u0014,8\u00adð«ü7¬^À\u0083\u000fð;¥å#v]\u00996I£¤Y5ÿ[üA\tüã¨N0\u0089*\u0017\u001fã\u0013\rÿ\u0095ÒpÒ'\u001dÿ\u008dÿQ`ÑÖVë÷\u007fA/É3þÏ1\u0084²ÛüÀF³-~KúTaÛÇª\u0093ú¿\fîÿQ\u007f4\u001cç¥è´B\u0011M°äð\u001e\u0013a4$Kpõi\u0086w¤L+È\u009f\u008bC\u0097\u001cq2Ï\u0088tñ\u009c\u001d\u0097Ò\u000e2 Õ\u009a¸RòËºE©;\u0091G4ÆHrå,Mt\u0002fê\u008dI\u00971êLÈæF¸\u0084p\u0096UVÄ;\u0094äë2^xçwl\búX¢5'Ø\u009eSAøjåD¡.ç(hWp½È\f·\u0086|\u0096'.ñ\n\u0088¾+ä\\]&Éd\u001aÒ\u00ad.í\u0097¥i÷NxûK\u009eR¢¦èR¤\u0002æÜhö22\u001e\u0099*Ó5\u0099\u0016sÝ\"o0\"\u009dº\u0014Ë\u0005ÔØelá\u001dY\u009dïõ\u008a½D\u0097\u0099\u008aÝÅã$¤\u0004h2+%²Ì»é\u008bÕZ®\u0094J¹.\u0015ªÉvÑ±\u0095êöä\u0012Þç\u001dÅáâ\u0080Z\u009e\u00adËÅjÙÉe\u001e·¬u\u0099£Ë\\¹\u0094Sí\u0016\u0002$\u0082\u009b\u001c³\u0093ÜuãàQí\u0092Ë¹iÅê\u0090\u0096j\u001eÁR#\u0098\u0094®?\u008c\u001d´.á\u008d]\u000b\u0017\u0015)\u0013\u0095=WèR«\u000e²\u009cv\u007fO¸S\u0081nZ\u0004#2·Ç´Æ¿ª\u008c0Fuk!*Iúb5vD\u009aR\u008f\u009f\u0089\u009fÑ7\u0013û£\u0018\u000fÖ\u0014éQ¿\u0094\u008eî\u0090Ùn\u0001|l&oäw\u0001\u009egÁ$&î:\u0093\u0083¶X\u0017^\u008eÖ^§º\u0015ßf2×¦zqê§nÒ÷¼9'ÿJ\u0098ö\u0000\u009b6RwZªé#<>\u0001Yu:\u0007OÙ\u0094\u0005éa ¦tþ©!\u0081&_f~\u008dÎÌöv\u001e\u0083²JÁÔ\u001aB¹\\Ï\u00adN§\u00884²N%9oúe§Ø^*ÙÖç¶ýJÃ~Ö]¤3\u009a$\u0085é1MÝµL\u001b\u0082IÝbI`\u007f}\"ÙªrÔí\u009e£%9µ\u009f²\u008b\u0097'Ü\tCwz\u001fæF'\u0099&¼ËOMj\u008c¨¤Ãð\u008fúèæ\u0092 Û¢(SÑ\u008câð\u008c\"_¸Èð\u0087L£\u00ad·¨\u008d\u0095\u00140Û*Ø1Ë\u008d\n©èúå\u0019\u0001T\nô\u008b\u001fÏ*Q=ºlRW[OXÝåÂ«|\u0091N\u0097\u0010v«ê\u008c@ \u0018)âñS\u0014L²È E\u0081ØLk\u0094Æb-ÚLÖ¢\u0019å3háçh\u008ew\u008f\u0094í2Z[Ípx:ñ÷â\u008c?\u0003Í\\\u009d\u0010ÀN´6s\u0001£~\"\u0088\u0089\u009b\u009dx¼XpåéJ\u001eõ\u0015ßÓ\u0014ì\tµ\u009aK|ª#.\u001cÅW¡¸\u0088{õ\u0081\u0080\u0019²>Ø+ÔÍ±*^\u0093û\u0004u§óùbÄ\u0087,\u0016júi=ùc\u0007\u00815íg0M\u001e\u00104fhF\u009d\u00116ë\u0003a3\u0010öE|\u009bÌ\u0091]\u0013Sû$\u0014\u009aìÌ¼í[\u009aøµ%éNÃ¸§_Ðä¡Ì¿n6øÂaZ\u001a\u0015Æ²µU\u0014¤\u009d×ä\u001b§Û¼Ön6Bfª\u0017'ZÈ\u001bÙù³õLãì\u009eÌ?Ã-O9\u008eõÔ×Âô\u001d1oæ)j¿ÅrÊPmÊïf)®N8Ñ\u0012Îçm/\u001b@\u000e²Ôo1|Óø\u0096\u0005\u0017ÿç\u0015ÐzÎµÆ|õ\u001b\f\u00907AýâÅ÷1¤\u0019\u008b<r\u008cS?SrTÿ\u008dË\u0097\u0001äï\u0081æè\u0087#ûELØg\u0089\u0098È¿N\u008b¤\nçZ3àÛ¤8û<8¬Õ±¥Ã\u0098Üü\u0002¦\f¢x\u0010%\tf\u008fÅ²\u0088Z\u0017[\u0002ô(9f¡Ì\u0016Uj\u008bº\u009e¢\u0014í¤ÒA\u0094S\\eó .Ú\u008fÙ|¼¤yÖ æîÇ¥\t¹ù¤\u0006®äßjJ»\u008a²ë-ù\u0085Q\u0019¶|õ¤ãrj¸\u0093\u000eTs\u00ad\u0086sÊäy¶ùY\u0016½»tÖ\u0001,\u0018ÀâçGxÝ\u0094$Ô\u001d\u0017ê¦Âz®\u008búQ\u0087Û\u0090\u0010\u001aÝ\u0084«\u0095ðì\u009dÜ\u0098\\úøÙ0\u00966\u000f£¡¹ô%Ì\u001eÂrÁ ®\u001bÄ\u0097\u001b\u0086±¦¹´L\u0006±¶qÖ\u0010ÖSZN¿¼êÍ\u0019B»àUø«\u001cå^Ç\u0000\u0002}ò\u001d¯#?2\u0080M}È\u001bÆMÍ\u008aç\u0096Æ~y\u0098Ó·\u000fàÎ>L$¥×\u00913\u0080\u00ad\u0003ØVåô:\u0007ð\u0000\tÂ$xÈ\"¨ð:òæ\ràá¹Î(e\u0001)v+ZÍ«y\u001d\u0005NÇz\u008b÷Q2Í'Ó·,¦ó-Z%v·-ÖëpÆé\n_À\u0084=( õ^RïAî0¾Í={ò\u0010YHTåTþz\u009dCøn\u0016úP¨d9m\u008d\u0096uø¥-»J³(5\u009bòæòa<Õ\u009cÿô ~ (\u009f\u001fÀKjÜVåòº\u0006p \u000fù^WÌWÚ\u0081\u001djz¸1g®»\u009fR\u001c\u0005î\u0002·òfw\u0095'I\u0090Ç\u0016ä\u0089\u000b\u001anÜê\u0096\u0002·\u008aðÁ½ÇßìÇ\u0012Zq8ÙP\u009b¬\u001fe_h\u0091¢ðX;õZ£Ú¼\u009f\nö\u001c«)\u001fÀ\u009be*\u009d²\u00adt:\u0088Jþ]\u0087\t¸\u0001Ó°\u009e\u0089c \u000e-h@+V¡Mý¶\u0082\u0010Ú±\u0005\u001d¸\u0007\u009dØ\u0001\u001f\u001eÇ\u0006ü\u0000\u001bñ2ü8\u0082.ü\u0012\u0001¼\u0085 þ\u0080n|\u008a\u001bÅ\u0089\u0090ä±\u0083)DD¼è\u0091©Ø,\u0017b\u008bÔóö|\rn\u0092µ¸YÖã\u0016iÇ\u00adìyn\u0093^Ü.\u000fá\u000eÙÍ÷'q·|\u000f[å9Ü+C¸O\u000ea\u009b\u001cÆýò\u000e\u001e\u0090£xPÞÃCò!sò\u0013<\"\u007fÆ.«\f\u009eQi-\u009fÅÊ\u0080OWágLû\tò.þ\u001a\u007fÃÄ\u009f&oáçø[ú\\%ûðwø\u0005Ë\"ÄRú{Úî¤OSð\u000fø\u0015\u009f\u001egÍª9\u008d~éöê§x\u009fÞý\u0002Nú\u0014åÐèÑ!ü#ç4út\u00835ç¢µnûé\u001d\u009bÎ%>\u0096àÛ\u0094ì¦\u008fSð\u000e9<ø§\u0018ÚXvþ³U®ÿ\u0082\u007fµÑf\u000e\u00adU\u0005®\u0095:öã×¥\u0089º\u008f\u0002Ö£¬ÝÇ\u0092\u0000K\u008b\u0003Vnz\u0011\u0087G\u0089x\u0082\"ö¦\u0015ñ\u001b¼\u001b\u0015\u0091=\u008b\u001e(\u008882\u008c÷\u0014Æý;1á·Ä\u008a\u000f\u009aYáÿ9\u0088ß7\u0096ÇAc\b\u007fÊÂªa|Ê\u001aû_BÃ\u0010>#b8ûñ\u0013Uc\u0016b|^\u0095\u0013å?F~\u00053¿·Ê;g@²mnÑ\u009a\u0007ÅÍ¼Õ¢ì\u009e~4x=qÀq{Ý¬\u0006Ç\u0013\u0098âu%RÞ\u001dMù!ñPD?&Ùk\u0091QkJ\u0092ÊþãÏy]ãeì\u0001\u0019G\u0089Ô^Påñz^G®ª¾\u0083{Àµ\t\u009cqxÝd\u0090\u0089ÙdtÚ\u008c\u0097fÏÍñ:\u0086ä<å¯2PëÇ¹ÊXÛ@gA\u008eªÍ\u0083\u0007ä|\u0012j6×QÅ2#\u0089¥+Æ\"¥\nµ\u0086¤Ìb·´O*\u001b/\u0095\u008eW\u0090Ý\u009c\u00adVØX7\rÈ%ôë²2åÖx¹\u008c~\u0015Ðêªñ2/ê]N\nu³Ã\u0096hñÅ\u008dØY6 \u000böÅ\u000bþ.\u0014ñï÷\u0099¬OÃËÒ\u0099ÉR\u009e\u008dgyn<\u0087Õx\u009ee¾\u008feü\u0002¶áE<\u0088\u0097H¹\u009f\u0014\u0003x\u009ds?gÉ¿\u008da\u001cÅ\u000fñ\u0011^ÁÇ4þ8\u009e\u00157\u000e\u008b\u008e\u001fËL¼&s8.Àër=µûñ\u0086Ü\u0085#r\u000fÞ\u0094\u00979÷\u001a~&o°$UòíàÑË\u0004\u008b\u0017í\u0011\u0016éB¦\u009f[^\u0095:YÄTõÊó²X\u0096ÐîÙ²K®dJ:hå\u0000Þ\u0092«\u0098Â«ñ¤ÔsU£µ;åjYÊöa\u001bæË2\u0016\u0099\u009bV\u0016K\u0083õt\u0014çI£*<Zø\u008a\u0014³\u0018sh§n\u0015£\u0093V®\u0093å²\u0082²UY^B¹Q\u00ad×Ä´Ê\u0097¨5ª«)®ëZ\u0096v\u0094ó:rzÔç?Úk\u009d±²ÒªÁ_ñÝÉqé°¬bf778æÏú)4&Ø²Ò!õ/\u0093x¤bª}¤V9&ï\u0081»lÖ\u0080¬]UF¼\u0096õê){~\f´\u008f¿Í-4\u0012\u0098]¡j\u0093hæ\"\u0092y\u00884c\u00885ùÄ¨\u000b\u0088I¥týB:SEd©áÜ\u0012ÂÂ¹¶k4GZ¤Õj\u0015\u0096J\u001b\u0003ÀÛ\u0016êÄ$\u0012gQR\u00adt@Ýþ/@¡t\u0012»\u001c\t¬²87p¼\u0093áß\u0018E\t\u0019O\u0097\u0095\u0093}³\u009a«r\u000eÎudÏWU\u009b3yv\u0083\u0002\u00872ûØô\u000e\u008b\u009fÙ\u001b\u0088¦vYÓ\u0001é\u001e\u0094ð¡²ü§\u0007$\u0012_Þ<byk¶L.pì=þâ0>oVMÐ ô6\u0094Y\u0080¡j\u0089ÝàD\u0016\u0097]~\u008dJ_y\u0099]³\u000e;j¿)K@_4dïÓì\u000fp\u001e>d8~Ç®è#öQï³Áû#\u000f¶?Ñµ\u008f±\u009dã.|\u0092\u0014²¾xwÕ'7YÝÕ8,´\u000e\u0084,r]dec\u0016y£\u0019\u0095\u009dç\u0092\u009bå\u0016\u001b\u0089\u008b-pg3Lû~ýÌ\u0088\u0016n^¬q%Ë\u00adr[\u001a\u0096Ù#»¾ê$\u0096ÛÓj9<RË\u0082$\u0096;äÎ4,\u0097\u008eÔR\u001bï¨³X½êïÝ²\u0095c\bc¤\u0014+ä\u001e§[î\u0085È6ÒÜÄñ+PÿªDä«¤¼\u009fãvL\u0094\u001d\u001c¿Æ÷\u00079~\u009d\u0015ò0ÇG\u001cY\u008c¾È.êÚÎq·Ã#}\u001c\u001f%ÿ1\u008e\u008fq>Èñ\u009b\u009c\u007f\u009cã\u0013ðü?PK\u0007\b5Øûü²\u0010\u0000\u0000´(\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00004\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.class\u00adVi{\u0013×\u0015~¯\u0016ËÈ\u0083Á\u008e1(\tF`À²\u0090-¶\u0090`\u001b·¶\u0083\u0083©\u0017\u008a©]\u0013Òd\u0090\u0006y\u0088¬\u0011£\u0091\u0083³µMÛìk\u0097,t_é\u0007>$ÏS \u0094§Ë·>Oû\u001f\u009aoù\u0019iß{g$KÖ8\t4_4w9÷Ü÷¼ç=G÷_\u009fþåo\u0000\u000eà\u008f\u0011\u0004\u0004ú-;\u0097Ö\u008bzfÑH/éËF!ý\u0094\u00ad\u0017\u008b\u0086\u009dÎäÍô)Ý.\u0019Ù1kiI/d'Í\u0082\u0011AH`óE}YOçõB.=sþ¢\u0091q\u00046YEÇ´\n¥Ñ\u0095YÇ6\u000b9®L*«²cæÓSzqP`Ã¬\u0099+èNÙ6\u0004\u0016êw\u0087&W]º\u000e\u0006'ï\fØ\u008cº\u007fp\u0098÷´\u0016m£d\u0014\u001cw©T\u000feÖphÒ]¿âs½rd\\vl}ÄÎ\u0095\u0097è\u008e\u008e6×\u001c\u009b4KÒÓî5Kë¸j\u001a2\u000b¦3,°5Qc0á\u0018¶~>o\föÎ\tLøí\f}6\r~\u0004H_¡1+kD\u0011D\u0087\u0086MØ\"\u0010LôÎE°U m\u0015î\t½´Hî£èDÇ\u0006\bÜ«!\u008c¦\bîo°\"EQÜçZíÐ°\u0001Ñ\bv\nÜ³j5bÛú\u008a\u008c?\u008a¸k·[\u0083\u0086\u008d-Ø\u008bD\u0004=\u0002í\u008dÁièER Ù\u0094sÇ²\u0005:\u0013½5|Nxë\u0083-H¡?\u0082¾\u008a\u0097º]\riìgÈ\u0005fK £â¡F\u009e\u0083\u0011\u001cü<¥70\u0019Áa\u0081Ãw#Â(\u000e¡#Ê\n{PÃC8*\u0010Í\u0019«bl«\u000bQÊ±\u0005\u0083\u0092£!\u0081\u008du\u001b\u0011\f×Õ\u009a+§\u0016|\u0015£\u0011\u008cÔY3\u008d\u001aÆð0\u0013],\u0093\u0085\u0087\u0012\u008d$4®ø0%\u0099\u001e×ð\bN\bD\u0016õÒ´\"\u0095ê9+Ë\u0088!N\u0097\u0097Î\u001bö\u0019\u0099>fcÒÊèù9Ý6åÜ[\f9\u008b&ãÜ\u007f\u0087\u0005Ì\"\u0089X\u0015\u0092:ü\u008a\u0084Uä\u001a|®óÆ²\u0010Ð\u008aêÆ\u0019ÏÃ\u0091»ë/ìb.\u0006&CÆßPìÔp=)+Å\n1ã_N}³`\u001c«Òeëåîah\u0006³µÃ#s ¾§\u0094\u008a×w2¹\u0016e\u008d\u009eÓð\u0018¾En.\u0095-Ç\u0018)dOZ&¹Iø÷¨Æ\u008b¢8\u0086'4è8ÏÜ\\°ì%\u009db9\u009ah4|ô³ÅWånÈ¿\u0007ú´T\u009fã\u0011\u0090ä\u00adk\u0097GËf>kØQdÑÑ\u008cE\u0081@*.'\u00175<\u0089<qK¶\u000bY\u0081>\u001fÜ\u008d·xîÈ1\u0089\u0012=Ò\u0013Ko\u001eß¤|KÊ¢$uZvT\u001dÆÖ=Os³4nÚ%Z\t¦«©äeô\u000b3@)²@+zÞâ\u0087þ¬Lò3\u001afð¬ÀIßøîª\ndÇz^Ã·ñ\u001d\u008a1c\u0015\u001cÝ\u0094U»Å§ëÈÆ¡\u0011çHa¥\u00025\u0096¨i\u0080cV>O;éU\u009aöùïùKàl\u000b~ ;ç\u008b¬\u0003¿S2ú\u00975\\Æ\n\u009bWÞÊM\u001aËF¾Ú\u0088;ýQ\b$¿8\u0004Ù\u008cßÐð&Þb\u0093d\u0097\u0017ØëÇ\u0081ß?Ò;\u0002»j2Íkrz¾R¡Ç/g\f\u0085³\u0019?\u0012Øæb\u008e÷ì)õÄ\u000b\u0096\u0013Ï\u001a\u0017\u0098\u008cl\u007f\u0014oã'ò\u001fþÝu\u0004À§@\u001ba\u001d_ó\u008ei¯û\u000fò^2{\u001b\u0016×\u0091ÝF=\u009bU\u001eçô|ÙhÁÏð\u008b\b~ÎçRýi\r¿\u0094ú\bÒZ ¼,m)YÎ*:xÚ\u0007ñ\u009d¶ÃÿCÀ¿Óð{¼ \u001b@6;\u0092g'\u0088ÎZe;c\u008c\u009b²Yw6\u001cí\u0097`±\u0093\u009a\nòý\u001cD»|-q\u0016á,\u0080fÎù.ªÎ[8çû§:oå.\u0098©Í\u001c»+m´\u0080\u0090\u008f49\u007f>y\u0013÷$o£sá&¶]G\u008cÃû8Ü~\u001d]\u001cÆ9Üu\u001dÝûna\u008fÀôU\u009cè»\u0085}\u0002ÿÀ\u0081©Û8ÄÝ\u0007\u0006B©\u001b8r\u000b\u0003\u0002\u0003MW±=ÖäY\u001c\u001b\b'ÿ\u0084X,\u001c\u000bÝÂW\u0082\u0098\u0097;Ç\u0005®ü÷ã>opý#\u0015Ñ\u0004\u007fû\u0089\u001c\u008c2Ä÷Þ&lÇ½Ø\u0081=Ø\u0085£èÆ(vã\u001cg\u0017ùu¸ö\u001c\u00128IëÃd\u0082\u0011àk\u0098\u0004Ôh\nÓ\u008cü(Y\u009eÁ)Æ:\u008a\u0083ø:NÓë921\u008b3<ñ\rZj´ríç8\u0012²\u008fò\u0097¼Ðo\u0093Ú\u008b·/\u0084ÿ\u008aàB0É ºnâÑÙ\u0085\u0090\u001cvËá\u009fñø\u0087\u008aK\u0089ÜµO)D®ß¸\u0087( ÿåª¼g\u0094ÿÿpÔÄïéÛÈ\u0092¾\u000bS¡a\u0097Ü\u0081ðU\u001c\u0088\u0085«ä\u0085¶_A4Õ\u009e»\u0001s>Õ¾¤>±PÍ,8,\u00ad\u0015\u008fÿf\n¬\u000f×p¹\u009fÚ8@e\u001c$«\u0087ÈÞab<ÂÑ\u0083\u0018àóp\u0084,\u008dqo\u008a\\\u00adryºÊåi\\R\\6s×F\u0089¨£8AöË¼c's°L.C5\\Jû§\u0014\u0097l{\u001e\u0097\u0013<\u0015à·-¹ï\u0006\u009e\u009e\u0097D2Öç\u0002¸V%/ª\f\u008e\u0093\u0092q\u0005£Ó=P\u0085ÑÆD\u009eQn¿\u008b\u0017ªT~O¹\u007f\u0085£\u0010¿½tú}¥Î\u00ad\u0015u\u001e\u009bJ\u0092\u0092\u0097>@8t\u00ad\"¶O\u0082×ª\fuªhO¡\u0083ê¸\u009fØ»8îa4'Uöd\u009dõV!ôò¢W\t \u0083`%\u0098@MÔrï5\u0005\u008f\u007fu^Ô%\u0082T\u001e¤ú\tíõ\u0000\u0001\u001d\u009aJý\u0013Ûnãí\u0085ö\u001f\u0086\u0094®öI\u0015ÝÄ\u008fÿ\u009eZ\u0095R»\u008açqJõ\t\u008euBÊ¬\u0003Ée¥\u0095Å\"å\u001dàø=¼_åç\u0003\u0005$\u00ad\u0080\u0001²\f»×ê5W£×pÕñ\u0015¼ëEñ°\u0097;M\u001ef\u0014?\r`þ£5i{\u0092:Ë×¤M«úÑð+\u0005\u0010ø5~ãy,xéêªãeZªÂí ¿å\u0015}«8[UÐ\u0016¿Eæè\u0092º'éz¨ÞÓ¥jZ¨\u0091[ñ\u00adìt\u0092\u0092 Wÿ |]ý\u001fPK\u0007\b\u0088!ç@ë\u0006\u0000\u0000z\u0010\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000:\u0000\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.class\u009dS]O\u0013A\u0014=Ó\u0096n)K\u0081\u0002U¾¤\bB[´+\u008aõ£\u0015EÄ\u0084¤\u0011\u0093\u009a\u001ax\u001bÚI»d»m¶[\u0014ÿ\u0089>\u009bøâ\u0083&*A\u0012õÙ\u001fe¼³»´\u0085\u0086\u0017_vvîÜ{î¹gÎüùûã'\u0080\u0015¬+ð1¬Ö\u00ad\u008aÆ\u001b¼T\u0015Z\u008d\u001f\bS{mñFCXZÉÐµ\u0017Üj\u008aòF½Vãf9¯\u009bb»aëuSA\u0080ax\u009f\u001fpÍàfEÛÞÛ\u0017%\u009b!xÀ\u008d\u0096hÒYÞ9lÙº¡åõ¦\u009deè/è\u0015\u0093Û-K0,\u009c;Îå;X\u0005ÛÒÍJv\u008dJ\u00829ÝÔí5\u0006\u007f\"Yd\blÔË\"\f?\u0006Uô#¬`\u0088a´\u0003´nYüP¢\u0085\u0011Á`?\u0018¢*ú\u0010d\u0018\u0092Ì\u009f·j{ÂzÉ÷\f\"\u0010Í×KÜ(rK\u0097{/\u0018°«:qÏäÿG\u0012¢\u001bª\b»(\u0005`\u0018K${G\n\u0013¥I\u0015S\u0098¦Ü*oz¹4Ü®\u0082+\f³\u009d\u008a-Ã\u0010\u0015n\u0014ln\u008bÍ7%á´\b!NIn»x¹.\u009aq³nÇ«Ä0ÎÍÃ¸£}:\u008c\u0019\\\u0095úÌ3\u008c'zI$\u008b\u0003¸\u0086%\u0005\u008b\f\u0091³· \"\u0081$ÉÐÔßº´¶BXf\u0098ò:\u0012ãx\u00adeØzÃ\u0010n³fZbÝP\u0091\u0086F\u00054¾ì¹Õ=ºë\u008c¬\u0082\u00953\u0086qÉ\u0090)N%#Ý£§\u009au»f±'x\u0081W\u0006x¹¼nUZ5aÚ\u0092Õ]\u0015÷p\u009fXQü\u009c\u0012\u001e§ä.]\u0003÷J¤%zp%ÎC\u0015kòÂ\u0014½¹YkØ\u0087\fáB½e\u0095Ä3]zfú\u0002;¤%\u0018æèÆýôØ\b]:\u0091V\u0085v>\u0084hÇ¤\u0087é;@\u0091'\u0094Åh\u001dN\u001dAM\u009d ²s\u0084áo\u0018ùâd\u008fÒ7âà\u008c#\u0080\u0018\u0086h\u001d£\u009dêÖÐ.æô¸\u0084Ë\u001e^ÃÃË¤¾câ=\u0006O0³\u0013\u009d=ÂÜ¯ÔW\u008c\u001cc\u0081nù\u0083\u0017N\u009d\u0086ýÇ¸îÃoÜüÜî\u001a#\u009eÀ\u0004±\u009eÄ\b¦q\u0085Ì\u0095ÀlW÷L»û-Ü¦*w¾U\u0087\u0085FQ\u0099Ó'Ñ; A'8ß\u0005Ò×\u0006¹Cqw\u0084§\u0094í\u0093\u0019²xù\u0018\u0019\u001f^uä\b;gK\u0094\u0099ppbn®\u0087#ÿ\u001e ë´§×æ!æ<:QW\u0083\u001cÃ;(þ\u008f\b\u0004>\u009dã¶ÜÅ-ÚæöÈÉzü\u000fPK\u0007\bà=!C×\u0002\u0000\u0000@\u0005\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000H\u0000\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.class¥\u0091MO\"A\u0010\u0086ß\u0012\u0004DüB]uãa¼\u0081\tL<û\u0091(fOd%Áxo\u0086rh33=i\u001a\fÿJO&\u001eü\u0001þ(cÏ\u0080Æ°\u0093]\u0093íC½Õ\u0095÷©Nu½¾=¿\u00008ÂÏ\"\u0016\b\u0017Jû®\u0088\u00857`7\u0014c\u008eÜ{-â\u0098µë\u0005ÒíhuÇ\u009e±b+Fò°¥ÂPDý¶\u008c¸¥¢±-².\"OhýµÏyoh´øW#BáDFÒ\u009c\u0011rµú\r!ßR}.#\u0087¥\n\u0016Q ¬%þß£°ÇúZô\u0002&TÛÊ\u0013Á\u008dÐ2¹Ï\u008ay3\u0090CÂeûÿ\u0087;&løüa\u009a\\ÅFª\u0088°U«·ïÄX¸\u0081\u0088|·k´\u008cüã\u00126\bÔ!ìýA\\²\u00112à~\t[\u0084J<}¹a5&ìg¸\u0087\u009e\u0096iZÂ\u008e]R\u0097\u008d3\u0083\u0012M\u00adÎ\u00adÒ\u008e\u0019°Ó\u001bÉ ïL\t§ÆM¿é4:á$ñ\u009d\u0086\u0093±\bF\\o\u0012Ê]5Ò\u001eÿ\u0092É\u000f\u001d~køf2\"\u000e`÷\u0081äämf÷`cÑÞ\\«duñð\t¥G\u009b, lc!-nbÙÆÊÔ`u%ÅW±6\u0083\u001b38W]\u007f\u0098Cw¾ ¹O´\u009a\u0081nÎ£û\u0099èv\u0006úc\u001e=È@\t»©kï\u001dPK\u0007\bïBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000PK\u0003\u0004\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000G\u0000\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.class¥\u0091ËN\u001b1\u0014\u0086ÿCB\u0012\u0002-\u0090r§\u008bé.©\u0094\u008cºbÁEB\u0089X p\u0091ReïLN'®fÆ#\u008f\u0013\u0094·*+$\u0016<@\u001f\ná\u0019\u0002Bé\b!Õ\u008bsóÿ\u001dûØ\u007f\u001fï\u001f\u0000üÀ^\u0019\u000b\u0084S¥}WÄÂ\u001b±\u001b\u008a\tGî\u008d\u0016qÌÚõ\u0002éö¦\u0089áðZ+[0\u0092\u0093¶\nC\u0011\r»2â¶\u008a&¶Èº\u008c\"¡ýn\u009bÓAb´ðÌû\u008d\b¥#\u0019IsB(Ô\u001b}B±\u00ad\u0086\\E\u0001K+XD\u0089°\u009aê/Çá\u0080õO1\b\u0098Pë*O\u0004}¡e\u009aÏ\u008aE3\u0092\u0089½S÷¿g;$¬ûürïéUl¤\u008a\b\u001bõF÷·\u0098\b7\u0010\u0091ïö\u008c\u0096\u0091\u007fXÁ:\u0081:\u0084Ý\u007f\u0088\u000e\u001b!\u0003\u001eV°AXN²\u0083\u009b±\u0095\u0010¾æ\u0088\u0013OË,¬`\u009bpÐcã<3N<S:ê\u0097cFì\u009c÷/\u009c:·ü\u0096Óì\u0084Ót÷8\u009cND0æF\u008bPí©±öøL¦\u008fÒøÈ¼\u00adt*|\u0083ý\u0001¤«h#ûòÖ\u0096mæZOÖ/~¿CåÖ\u0006\u000b¨Z[Ê\u008a5,[»ò,°þS\u0086\u007fÆê\fnÎàBmíÏ\u001cºõ\u0006-¼¢µ\u001côË<º\u009f\u008bnæ [ó¨\u0093\u0083\u0012v2Õî\u0013PK\u0007\b¯vê²\u0089\u0001\u0000\u0000&\u0003\u0000\u0000PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000META-INF/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000K¡Ý1¨\u0000\u0000\u0000+\u0001\u0000\u0000\u0014\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009\u0000\u0000\u0000META-INF/MANIFEST.MFPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000#\u0001\u0000\u0000META-INF/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000b\u0001\u0000\u0000META-INF/maven/io.takari/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000'\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000«\u0001\u0000\u0000META-INF/maven/io.takari/maven-wrapper/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000L´@\u0005:\u0000\u0000\u00009\u0000\u0000\u00005\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0002\u0000\u0000META-INF/maven/io.takari/maven-wrapper/pom.propertiesPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u009f\u0002\u0000\u0000org/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000Ó\u0002\u0000\u0000org/apache/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000e\u0003\u0000\u0000org/apache/maven/PK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0019\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000O\u0003\u0000\u0000org/apache/maven/wrapper/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ÒØüÆB\u0005\u0000\u0000`\n\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0098\u0003\u0000\u0000org/apache/maven/wrapper/BootstrapMainStarter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005ìC¢\u0012\u0002\u0000\u0000å\u0003\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001;\t\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$1.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000Ë\u001b_\n\t\u0002\u0000\u0000p\u0004\u0000\u0000S\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u00ad\u000b\u0000\u0000org/apache/maven/wrapper/DefaultDownloader$SystemPropertiesProxyAuthenticator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000C5\u0084\u008fp\f\u0000\u0000f\u0018\u0000\u00000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u00017\u000e\u0000\u0000org/apache/maven/wrapper/DefaultDownloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084q÷\u0012°\u0000\u0000\u0000ã\u0000\u0000\u0000)\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0005\u001b\u0000\u0000org/apache/maven/wrapper/Downloader.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000å¡[\u0007Ü\u000f\u0000\u0000\u0088\u001f\u0000\u0000(\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\f\u001c\u0000\u0000org/apache/maven/wrapper/Installer.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0084'+ãü\u0001\u0000\u0000m\u0003\u0000\u0000%\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001>,\u0000\u0000org/apache/maven/wrapper/Logger.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0011ps½]\u000b\u0000\u0000Ë\u0018\u0000\u0000/\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u008d.\u0000\u0000org/apache/maven/wrapper/MavenWrapperMain.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001coÏI»\u0001\u0000\u0000t\u0003\u0000\u0000>\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001G:\u0000\u0000org/apache/maven/wrapper/PathAssembler$LocalDistribution.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0087|+\u009f?\u0007\u0000\u0000Þ\u000e\u0000\u0000,\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001n<\u0000\u0000org/apache/maven/wrapper/PathAssembler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000{\u0002`-è\u0004\u0000\u0000×\t\u0000\u00006\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0007D\u0000\u0000org/apache/maven/wrapper/SystemPropertiesHandler.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000º\u0001?a\u0098\u0003\u0000\u0000(\t\u0000\u00003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001SI\u0000\u0000org/apache/maven/wrapper/WrapperConfiguration.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000øÇ£9\u0091\b\u0000\u0000,\u0013\u0000\u0000.\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001LM\u0000\u0000org/apache/maven/wrapper/WrapperExecutor.classPK\u0001\u0002\u0014\u0000\u0014\u0000\b\b\b\u0000\u0000\u0000!\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00009V\u0000\u0000org/apache/maven/wrapper/cli/PK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ðdQvý\u0002\u0000\u0000T\b\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0086V\u0000\u0000org/apache/maven/wrapper/cli/AbstractCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000jç F®\u0004\u0000\u0000Î\f\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001ðY\u0000\u0000org/apache/maven/wrapper/cli/AbstractPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ûm6\u0094T\u0001\u0000\u0000g\u0002\u0000\u0000?\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0015_\u0000\u0000org/apache/maven/wrapper/cli/CommandLineArgumentException.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000=8\u009f\u0094L\u0001\u0000\u0000»\u0003\u0000\u00007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ö`\u0000\u0000org/apache/maven/wrapper/cli/CommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00006W°K\u0011\u0005\u0000\u0000\u009e\u000b\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u0087b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000æ¿Ëk-\u0003\u0000\u0000%\u000b\u0000\u0000I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001úg\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u001b\u001b['\u0093\u0002\u0000\u0000Á\u0007\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u009ek\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$AfterOptions.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ì\u0014úßÝ\u0003\u0000\u0000\u0000\r\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001 n\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$BeforeFirstSubCommand.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000à¤ûG*\u0002\u0000\u0000¯\u0004\u0000\u0000T\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001õr\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000F{)6N\u0007\u0000\u0000M\u0014\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001¡u\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$KnownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n\u0081ªï\u009a\u0002\u0000\u0000I\u0007\u0000\u0000J\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001h}\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$MissingOptionArgState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000»Ð=\u0086ª\u0002\u0000\u0000§\u0007\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001z\u0080\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionAwareParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000K\u0002\u0096\u0017Í\u0002\u0000\u0000\u0081\u0007\u0000\u0000E\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u009d\u0083\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\n \u0095Ò\u0094\u0001\u0000\u0000¥\u0003\u0000\u0000F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ý\u0086\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0016¤\u0018Óv\u0002\u0000\u0000f\u0005\u0000\u0000A\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001å\u0088\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionString.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00007¤çy\u007f\u0002\u0000\u0000\u0089\u0005\u0000\u0000K\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Ê\u008b\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$OptionStringComparator.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ûtS\u0083ì\u0001\u0000\u0000°\u0004\u0000\u0000@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001Â\u008e\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$ParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000O<êÑÇ\u0002\u0000\u0000Õ\u0007\u0000\u0000M\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001\u001c\u0091\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser$UnknownOptionParserState.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u00005Øûü²\u0010\u0000\u0000´(\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001^\u0094\u0000\u0000org/apache/maven/wrapper/cli/CommandLineParser.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000\u0088!ç@ë\u0006\u0000\u0000z\u0010\u0000\u00004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001r¥\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLine.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000à=!C×\u0002\u0000\u0000@\u0005\u0000\u0000:\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001¿¬\u0000\u0000org/apache/maven/wrapper/cli/ParsedCommandLineOption.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000ïBm\u0087\u0088\u0001\u0000\u00005\u0003\u0000\u0000H\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001þ¯\u0000\u0000org/apache/maven/wrapper/cli/ProjectPropertiesCommandLineConverter.classPK\u0001\u0002\u0014\u0003\u0014\u0000\b\b\b\u0000\u0001\u0000!\u0000¯vê²\u0089\u0001\u0000\u0000&\u0003\u0000\u0000G\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000´\u0001ü±\u0000\u0000org/apache/maven/wrapper/cli/SystemPropertiesCommandLineConverter.classPK\u0005\u0006\u0000\u0000\u0000\u0000/\u0000/\u0000\u0006\u0012\u0000\u0000ú³\u0000\u0000\u0000\u0000",
      "642d572ce90e5085986bdd9c9204b9404f028084":
        "distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.3/apache-maven-3.6.3-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n",
      dfe0770424b2a19faf507a501ebfc23be8f54e7b:
        "# Auto detect text files and perform LF normalization\n* text=auto\n",
      a2a3040aa86debfd8826d9c2b5c816314c17d9fe:
        "HELP.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**\n!**/src/test/**\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n\n### VS Code ###\n.vscode/\n",
      "3c8a5537314954d53ec2fb774b34fe5d5a5f253a":
        '#!/bin/sh\n# ----------------------------------------------------------------------------\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# "License"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#    https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# Maven Start Up Batch script\n#\n# Required ENV vars:\n# ------------------\n#   JAVA_HOME - location of a JDK home dir\n#\n# Optional ENV vars\n# -----------------\n#   M2_HOME - location of maven2\'s installed home dir\n#   MAVEN_OPTS - parameters passed to the Java VM when running Maven\n#     e.g. to debug Maven itself, use\n#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n# ----------------------------------------------------------------------------\n\nif [ -z "$MAVEN_SKIP_RC" ]; then\n\n  if [ -f /etc/mavenrc ]; then\n    . /etc/mavenrc\n  fi\n\n  if [ -f "$HOME/.mavenrc" ]; then\n    . "$HOME/.mavenrc"\n  fi\n\nfi\n\n# OS specific support.  $var _must_ be set to either true or false.\ncygwin=false\ndarwin=false\nmingw=false\ncase "$(uname)" in\nCYGWIN*) cygwin=true ;;\nMINGW*) mingw=true ;;\nDarwin*)\n  darwin=true\n  # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home\n  # See https://developer.apple.com/library/mac/qa/qa1170/_index.html\n  if [ -z "$JAVA_HOME" ]; then\n    if [ -x "/usr/libexec/java_home" ]; then\n      export JAVA_HOME="$(/usr/libexec/java_home)"\n    else\n      export JAVA_HOME="/Library/Java/Home"\n    fi\n  fi\n  ;;\nesac\n\nif [ -z "$JAVA_HOME" ]; then\n  if [ -r /etc/gentoo-release ]; then\n    JAVA_HOME=$(java-config --jre-home)\n  fi\nfi\n\nif [ -z "$M2_HOME" ]; then\n  ## resolve links - $0 may be a link to maven\'s home\n  PRG="$0"\n\n  # need this for relative symlinks\n  while [ -h "$PRG" ]; do\n    ls=$(ls -ld "$PRG")\n    link=$(expr "$ls" : \'.*-> \\(.*\\)$\')\n    if expr "$link" : \'/.*\' >/dev/null; then\n      PRG="$link"\n    else\n      PRG="$(dirname "$PRG")/$link"\n    fi\n  done\n\n  saveddir=$(pwd)\n\n  M2_HOME=$(dirname "$PRG")/..\n\n  # make it fully qualified\n  M2_HOME=$(cd "$M2_HOME" && pwd)\n\n  cd "$saveddir"\n  # echo Using m2 at $M2_HOME\nfi\n\n# For Cygwin, ensure paths are in UNIX format before anything is touched\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --unix "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --unix "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --unix "$CLASSPATH")\nfi\n\n# For Mingw, ensure paths are in UNIX format before anything is touched\nif $mingw; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME="$( (\n      cd "$M2_HOME"\n      pwd\n    ))"\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME="$( (\n      cd "$JAVA_HOME"\n      pwd\n    ))"\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  javaExecutable="$(which javac)"\n  if [ -n "$javaExecutable" ] && ! [ "$(expr \\"$javaExecutable\\" : \'\\([^ ]*\\)\')" = "no" ]; then\n    # readlink(1) is not available as standard on Solaris 10.\n    readLink=$(which readlink)\n    if [ ! $(expr "$readLink" : \'\\([^ ]*\\)\') = "no" ]; then\n      if $darwin; then\n        javaHome="$(dirname \\"$javaExecutable\\")"\n        javaExecutable="$(cd \\"$javaHome\\" && pwd -P)/javac"\n      else\n        javaExecutable="$(readlink -f \\"$javaExecutable\\")"\n      fi\n      javaHome="$(dirname \\"$javaExecutable\\")"\n      javaHome=$(expr "$javaHome" : \'\\(.*\\)/bin\')\n      JAVA_HOME="$javaHome"\n      export JAVA_HOME\n    fi\n  fi\nfi\n\nif [ -z "$JAVACMD" ]; then\n  if [ -n "$JAVA_HOME" ]; then\n    if [ -x "$JAVA_HOME/jre/sh/java" ]; then\n      # IBM\'s JDK on AIX uses strange locations for the executables\n      JAVACMD="$JAVA_HOME/jre/sh/java"\n    else\n      JAVACMD="$JAVA_HOME/bin/java"\n    fi\n  else\n    JAVACMD="$(which java)"\n  fi\nfi\n\nif [ ! -x "$JAVACMD" ]; then\n  echo "Error: JAVA_HOME is not defined correctly." >&2\n  echo "  We cannot execute $JAVACMD" >&2\n  exit 1\nfi\n\nif [ -z "$JAVA_HOME" ]; then\n  echo "Warning: JAVA_HOME environment variable is not set."\nfi\n\nCLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher\n\n# traverses directory structure from process work directory to filesystem root\n# first directory with .mvn subdirectory is considered project base directory\nfind_maven_basedir() {\n\n  if [ -z "$1" ]; then\n    echo "Path not specified to find_maven_basedir"\n    return 1\n  fi\n\n  basedir="$1"\n  wdir="$1"\n  while [ "$wdir" != \'/\' ]; do\n    if [ -d "$wdir"/.mvn ]; then\n      basedir=$wdir\n      break\n    fi\n    # workaround for JBEAP-8937 (on Solaris 10/Sparc)\n    if [ -d "${wdir}" ]; then\n      wdir=$(\n        cd "$wdir/.."\n        pwd\n      )\n    fi\n    # end of workaround\n  done\n  echo "${basedir}"\n}\n\n# concatenates all lines of a file\nconcat_lines() {\n  if [ -f "$1" ]; then\n    echo "$(tr -s \'\\n\' \' \' <"$1")"\n  fi\n}\n\nBASE_DIR=$(find_maven_basedir "$(pwd)")\nif [ -z "$BASE_DIR" ]; then\n  exit 1\nfi\n\n##########################################################################################\n# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n# This allows using the maven wrapper in projects that prohibit checking in binary data.\n##########################################################################################\nif [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Found .mvn/wrapper/maven-wrapper.jar"\n  fi\nelse\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Couldn\'t find .mvn/wrapper/maven-wrapper.jar, downloading it ..."\n  fi\n  if [ -n "$MVNW_REPOURL" ]; then\n    jarUrl="$MVNW_REPOURL/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  else\n    jarUrl="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n  fi\n  while IFS="=" read key value; do\n    case "$key" in wrapperUrl)\n      jarUrl="$value"\n      break\n      ;;\n    esac\n  done <"$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"\n  if [ "$MVNW_VERBOSE" = true ]; then\n    echo "Downloading from: $jarUrl"\n  fi\n  wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"\n  if $cygwin; then\n    wrapperJarPath=$(cygpath --path --windows "$wrapperJarPath")\n  fi\n\n  if command -v wget >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found wget ... using wget"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      wget "$jarUrl" -O "$wrapperJarPath"\n    else\n      wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath"\n    fi\n  elif command -v curl >/dev/null; then\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Found curl ... using curl"\n    fi\n    if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then\n      curl -o "$wrapperJarPath" "$jarUrl" -f\n    else\n      curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f\n    fi\n\n  else\n    if [ "$MVNW_VERBOSE" = true ]; then\n      echo "Falling back to using Java to download"\n    fi\n    javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"\n    # For Cygwin, switch paths to Windows format before running javac\n    if $cygwin; then\n      javaClass=$(cygpath --path --windows "$javaClass")\n    fi\n    if [ -e "$javaClass" ]; then\n      if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Compiling MavenWrapperDownloader.java ..."\n        fi\n        # Compiling the Java class\n        ("$JAVA_HOME/bin/javac" "$javaClass")\n      fi\n      if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then\n        # Running the downloader\n        if [ "$MVNW_VERBOSE" = true ]; then\n          echo " - Running MavenWrapperDownloader.java ..."\n        fi\n        ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")\n      fi\n    fi\n  fi\nfi\n##########################################################################################\n# End of extension\n##########################################################################################\n\nexport MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}\nif [ "$MVNW_VERBOSE" = true ]; then\n  echo $MAVEN_PROJECTBASEDIR\nfi\nMAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"\n\n# For Cygwin, switch paths to Windows format before running java\nif $cygwin; then\n  [ -n "$M2_HOME" ] &&\n    M2_HOME=$(cygpath --path --windows "$M2_HOME")\n  [ -n "$JAVA_HOME" ] &&\n    JAVA_HOME=$(cygpath --path --windows "$JAVA_HOME")\n  [ -n "$CLASSPATH" ] &&\n    CLASSPATH=$(cygpath --path --windows "$CLASSPATH")\n  [ -n "$MAVEN_PROJECTBASEDIR" ] &&\n    MAVEN_PROJECTBASEDIR=$(cygpath --path --windows "$MAVEN_PROJECTBASEDIR")\nfi\n\n# Provide a "standardized" way to retrieve the CLI args that will\n# work with both Windows and non-Windows executions.\nMAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"\nexport MAVEN_CMD_LINE_ARGS\n\nWRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nexec "$JAVACMD" \\\n  $MAVEN_OPTS \\\n  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \\\n  "-Dmaven.home=${M2_HOME}" "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \\\n  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"\n',
      c8d43372c986d97911cdc21bd87e0cbe3d83bdda:
        '@REM ----------------------------------------------------------------------------\n@REM Licensed to the Apache Software Foundation (ASF) under one\n@REM or more contributor license agreements.  See the NOTICE file\n@REM distributed with this work for additional information\n@REM regarding copyright ownership.  The ASF licenses this file\n@REM to you under the Apache License, Version 2.0 (the\n@REM "License"); you may not use this file except in compliance\n@REM with the License.  You may obtain a copy of the License at\n@REM\n@REM    https://www.apache.org/licenses/LICENSE-2.0\n@REM\n@REM Unless required by applicable law or agreed to in writing,\n@REM software distributed under the License is distributed on an\n@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@REM KIND, either express or implied.  See the License for the\n@REM specific language governing permissions and limitations\n@REM under the License.\n@REM ----------------------------------------------------------------------------\n\n@REM ----------------------------------------------------------------------------\n@REM Maven Start Up Batch script\n@REM\n@REM Required ENV vars:\n@REM JAVA_HOME - location of a JDK home dir\n@REM\n@REM Optional ENV vars\n@REM M2_HOME - location of maven2\'s installed home dir\n@REM MAVEN_BATCH_ECHO - set to \'on\' to enable the echoing of the batch commands\n@REM MAVEN_BATCH_PAUSE - set to \'on\' to wait for a keystroke before ending\n@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven\n@REM     e.g. to debug Maven itself, use\n@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000\n@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files\n@REM ----------------------------------------------------------------------------\n\n@REM Begin all REM lines with \'@\' in case MAVEN_BATCH_ECHO is \'on\'\n@echo off\n@REM set title of command window\ntitle %0\n@REM enable echoing by setting MAVEN_BATCH_ECHO to \'on\'\n@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%\n\n@REM set %HOME% to equivalent of $HOME\nif "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")\n\n@REM Execute a user defined script before this one\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPre\n@REM check for pre script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_pre.bat" call "%HOME%\\mavenrc_pre.bat"\nif exist "%HOME%\\mavenrc_pre.cmd" call "%HOME%\\mavenrc_pre.cmd"\n:skipRcPre\n\n@setlocal\n\nset ERROR_CODE=0\n\n@REM To isolate internal variables from possible post scripts, we use another setlocal\n@setlocal\n\n@REM ==== START VALIDATION ====\nif not "%JAVA_HOME%" == "" goto OkJHome\n\necho.\necho Error: JAVA_HOME not found in your environment. >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n:OkJHome\nif exist "%JAVA_HOME%\\bin\\java.exe" goto init\n\necho.\necho Error: JAVA_HOME is set to an invalid directory. >&2\necho JAVA_HOME = "%JAVA_HOME%" >&2\necho Please set the JAVA_HOME variable in your environment to match the >&2\necho location of your Java installation. >&2\necho.\ngoto error\n\n@REM ==== END VALIDATION ====\n\n:init\n\n@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".\n@REM Fallback to current working directory if not found.\n\nset MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%\nIF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir\n\nset EXEC_DIR=%CD%\nset WDIR=%EXEC_DIR%\n:findBaseDir\nIF EXIST "%WDIR%"\\.mvn goto baseDirFound\ncd ..\nIF "%WDIR%"=="%CD%" goto baseDirNotFound\nset WDIR=%CD%\ngoto findBaseDir\n\n:baseDirFound\nset MAVEN_PROJECTBASEDIR=%WDIR%\ncd "%EXEC_DIR%"\ngoto endDetectBaseDir\n\n:baseDirNotFound\nset MAVEN_PROJECTBASEDIR=%EXEC_DIR%\ncd "%EXEC_DIR%"\n\n:endDetectBaseDir\n\nIF NOT EXIST "%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config" goto endReadAdditionalConfig\n\n@setlocal EnableExtensions EnableDelayedExpansion\nfor /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\\.mvn\\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a\n@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%\n\n:endReadAdditionalConfig\n\nSET MAVEN_JAVA_EXE="%JAVA_HOME%\\bin\\java.exe"\nset WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.jar"\nset WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain\n\nset DOWNLOAD_URL="https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n\nFOR /F "tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\\.mvn\\wrapper\\maven-wrapper.properties") DO (\n    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B\n)\n\n@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central\n@REM This allows using the maven wrapper in projects that prohibit checking in binary data.\nif exist %WRAPPER_JAR% (\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Found %WRAPPER_JAR%\n    )\n) else (\n    if not "%MVNW_REPOURL%" == "" (\n        SET DOWNLOAD_URL="%MVNW_REPOURL%/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar"\n    )\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Couldn\'t find %WRAPPER_JAR%, downloading it ...\n        echo Downloading from: %DOWNLOAD_URL%\n    )\n\n    powershell -Command "&{"^\n\t\t"$webclient = new-object System.Net.WebClient;"^\n\t\t"if (-not ([string]::IsNullOrEmpty(\'%MVNW_USERNAME%\') -and [string]::IsNullOrEmpty(\'%MVNW_PASSWORD%\'))) {"^\n\t\t"$webclient.Credentials = new-object System.Net.NetworkCredential(\'%MVNW_USERNAME%\', \'%MVNW_PASSWORD%\');"^\n\t\t"}"^\n\t\t"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile(\'%DOWNLOAD_URL%\', \'%WRAPPER_JAR%\')"^\n\t\t"}"\n    if "%MVNW_VERBOSE%" == "true" (\n        echo Finished downloading %WRAPPER_JAR%\n    )\n)\n@REM End of extension\n\n@REM Provide a "standardized" way to retrieve the CLI args that will\n@REM work with both Windows and non-Windows executions.\nset MAVEN_CMD_LINE_ARGS=%*\n\n%MAVEN_JAVA_EXE% %JVM_CONFIG_MAVEN_PROPS% %MAVEN_OPTS% %MAVEN_DEBUG_OPTS% -classpath %WRAPPER_JAR% "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*\nif ERRORLEVEL 1 goto error\ngoto end\n\n:error\nset ERROR_CODE=1\n\n:end\n@endlocal & set ERROR_CODE=%ERROR_CODE%\n\nif not "%MAVEN_SKIP_RC%" == "" goto skipRcPost\n@REM check for post script, once with legacy .bat ending and once with .cmd ending\nif exist "%HOME%\\mavenrc_post.bat" call "%HOME%\\mavenrc_post.bat"\nif exist "%HOME%\\mavenrc_post.cmd" call "%HOME%\\mavenrc_post.cmd"\n:skipRcPost\n\n@REM pause the script if MAVEN_BATCH_PAUSE is set to \'on\'\nif "%MAVEN_BATCH_PAUSE%" == "on" pause\n\nif "%MAVEN_TERMINATE_CMD%" == "on" exit %ERROR_CODE%\n\nexit /B %ERROR_CODE%\n',
      e168b2799d20267ac52cf4acbd15701d9ce1aab4:
        '<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.5.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web-services</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n'
    }
  }
];
